<!-- Based off of https://github.com/austinEng/webgpu-samples/blob/master/compute_boids.html -->
<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=1200">
  <title>WebGPU Compute Shader Flocking</title>
  <script src="scripts/gl-matrix-min.js"></script>
  <link rel="stylesheet" href="css/style.css"/>
  <style>
  body {
      font-family: system-ui;
      color: #f7f7ff;
      background-color: rgb(38, 38, 127);
      text-align: center;
  }
  canvas {
      margin: 0 auto;
  }
  </style>
</head>
<body>
  <div id="contents">
    <h1>Compute Shader Flocking</h1>
    <p>
        This demo uses a compute shader to update the positions of objects in parallel.
    </p>
    <canvas></canvas>
  </div>
  <div id="error">
      <h2>WebGPU not available</h2>
      <p>
          Make sure you are on a system with WebGPU enabled. In
          Safari, first make sure the Developer Menu is visible (Preferences >
          Advanced), then Develop > Experimental Features > WebGPU.
      </p>
      <p>
        In addition, you must be using Safari Technology Preview 92 or above.
        You can get the latest STP <a href="https://developer.apple.com/safari/download/">here</a>.
      </p>
  </div>
  <script>
    if (!navigator.gpu || GPUBufferUsage.COPY_SRC === undefined)
      document.body.className = 'error';

    const numParticles = 1500;

    const renderShaders = `
@vertex
fn vertex_main(@location(0) particlePos: vec2<f32>, @location(1) particleVel: vec2<f32>, @location(2) position: vec2<f32>) -> @builtin(position) vec4<f32>
{
    let angle = -atan(particleVel.x / particleVel.y);
    let result = vec2(position.x * cos(angle) - position.y * sin(angle),
        position.x * sin(angle) + position.y * cos(angle));
    return vec4(result + particlePos, 0, 1);
}

@fragment
fn fragment_main() -> @location(0) vec4<f32>
{
    return vec4(1.0, 1.0, 1.0, 1.0);
}
`;

    const computeShader = `
struct Particle {
    pos: vec2<f32>,
    vel: vec2<f32>,
}

struct SimParams {
    deltaT: f32,
    rule1Distance: f32,
    rule2Distance: f32,
    rule3Distance: f32,
    rule1Scale: f32,
    rule2Scale: f32,
    rule3Scale: f32,
}

@group(0) @binding(0) var<uniform> params: SimParams;
@group(0) @binding(1) var<storage, read> particlesA: array<Particle>;
@group(0) @binding(2) var<storage, read_write> particlesB: array<Particle>;

@compute
@workgroup_size(1, 1, 1)
fn compute_main(@builtin(global_invocation_id) threadID: vec3<u32>)
{
    let index = threadID.x;

    if index >= ${numParticles} {
        return;
    }

    var vPos = particlesA[index].pos;
    var vVel = particlesA[index].vel;

    var cMass = vec2(0.0, 0.0);
    var cVel = vec2(0.0, 0.0);
    var colVel = vec2(0.0, 0.0);
    var cMassCount = 0u;
    var cVelCount = 0u;

    var pos: vec2<f32>;
    var vel: vec2<f32>;
    var i: u32 = 0;
    loop {
        if i >= ${numParticles} { break; }

        if (i == index) { continue; }

        pos = particlesA[i].pos.xy;
        vel = particlesA[i].vel.xy;

        if (distance(pos, vPos) < params.rule1Distance) {
            cMass += pos;
            cMassCount++;
        }
        if (distance(pos, vPos) < params.rule2Distance) {
            colVel -= (pos - vPos);
        }
        if (distance(pos, vPos) < params.rule3Distance) {
            cVel += vel;
            cVelCount++;
        }

        i++;
    }
    if (cMassCount > 0) {
        cMass = cMass / f32(cMassCount) - vPos;
    }
    if (cVelCount > 0) {
        cVel = cVel / f32(cVelCount);
    }

    vVel += cMass * params.rule1Scale + colVel * params.rule2Scale + cVel * params.rule3Scale;

    // clamp velocity for a more pleasing simulation.
    vVel = normalize(vVel) * clamp(length(vVel), 0.0, 0.1);

    // kinematic update
    vPos += vVel * params.deltaT;

    // Wrap around boundary
    if (vPos.x < -1.0) { vPos.x = 1.0; }
    if (vPos.x > 1.0) { vPos.x = -1.0; }
    if (vPos.y < -1.0) { vPos.y = 1.0; }
    if (vPos.y > 1.0) { vPos.y = -1.0; }

    particlesB[index].pos = vPos;
    particlesB[index].vel = vVel;
}
`;

    async function init() {
      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();

      const canvas = document.querySelector('canvas');
      let size = window.innerWidth < window.innerHeight ? window.innerWidth : window.innerHeight;
      size *= 0.75;
      canvas.width = size;
      canvas.height = size;
      const context = canvas.getContext('webgpu');

      context.configure({
        device,
        format: "bgra8unorm",
      });

      device.pushErrorScope('validation');

      const renderModule = device.createShaderModule({ code: renderShaders });

      const renderPipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({ bindGroupLayouts: [] }),

        vertex: {
          module: renderModule,
          entryPoint: "vertex_main",
          buffers: [{
            // instanced particles buffer
            arrayStride: 4 * 4,
            stepMode: "instance",
            attributes: [{
              // instance position
              shaderLocation: 0,
              offset: 0,
              format: "float32x2"
            }, {
              // instance velocity
              shaderLocation: 1,
              offset: 2 * 4,
              format: "float32x2"
            }],
          }, {
            // vertex buffer
            arrayStride: 2 * 4,
            stepMode: "vertex",
            attributes: [{
              // vertex positions
              shaderLocation: 2,
              offset: 0,
              format: "float32x2"
            }],
          }],
        },
        fragment: {
          module: renderModule,
          entryPoint: "fragment_main",
          targets: [{
            format: "bgra8unorm",
            alpha: {},
            color: {},
          }],
        },

        primitive: { topology: "triangle-list" },

        // depthStencilState: {
        //   depthWriteEnabled: true,
        //   depthCompare: "less",
        //   format: "depth32float-stencil8",
        //   stencilFront: {},
        //   stencilBack: {},
        // },

        // rasterizationState: {
        //   frontFace: 'ccw',
        //   cullMode: 'none',
        // },

      });

      device.popErrorScope().then(error => {
        if (error)
          console.error("Render shaders: " + error.message);
      });

      device.pushErrorScope('validation');

      const computePipeline = device.createComputePipeline({
        layout: 'auto',
        compute: {
          module: device.createShaderModule({ code: computeShader }),
          entryPoint: "compute_main",
        }
      });

      device.popErrorScope().then(error => {
        if (error)
          console.error("Compute shader: " + error.message);
      });

      const depthTexture = device.createTexture({
        size: { width: canvas.width, height: canvas.height, depthOrArrayLayers: 1 },
        arrayLayerCount: 1,
        mipLevelCount: 1,
        sampleCount: 1,
        dimension: "2d",
        format: "depth24plus",
        usage: GPUTextureUsage.RENDER_ATTACHMENT
      });

      const renderPassDescriptor = {
        colorAttachments: [{
          clearColor: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
          loadOp: "clear",
          storeOp: "store",
        }],
        //depthStencilAttachment: {
        //  view: depthTexture.createView(),
        //  depthLoadOp: "clear",
        //  depthStoreOp: "store",
        //  clearDepth: 1.0,
        //  stencilLoadValue: 0,
        //  stencilStoreOp: "store",
        //}
      };

      const vertexBufferData = new Float32Array([-0.01, -0.02, 0.01, -0.02, 0.00, 0.02]);
      const verticesBuffer = device.createBuffer({
        size: vertexBufferData.byteLength,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true,
      });
      new Float32Array(verticesBuffer.getMappedRange()).set(vertexBufferData);
      verticesBuffer.unmap();

      const simParamData = new Float32Array([0.04, 0.1, 0.025, 0.025, 0.02, 0.05, 0.005]);
      const simParamBuffer = device.createBuffer({
        size: simParamData.byteLength,
        usage: GPUBufferUsage.UNIFORM,
        mappedAtCreation: true,
      });
      new Float32Array(simParamBuffer.getMappedRange()).set(simParamData);
      simParamBuffer.unmap();

      const initialParticleData = new Float32Array(numParticles * 4);
      for (let i = 0; i < numParticles; ++i) {
        initialParticleData[4 * i + 0] = 2 * (Math.random() - 0.5);
        initialParticleData[4 * i + 1] = 2 * (Math.random() - 0.5);
        initialParticleData[4 * i + 2] = 2 * (Math.random() - 0.5) * 0.1;
        initialParticleData[4 * i + 3] = 2 * (Math.random() - 0.5) * 0.1;
      }

      const particleBuffers = new Array(2);
      const particleBindGroups = new Array(2);
      for (let i = 0; i < 2; ++i) {
        let particleArrayBuffer;
        particleBuffers[i] = device.createBuffer({
          size: initialParticleData.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE,
          mappedAtCreation: true,
        });
        new Float32Array(particleBuffers[i].getMappedRange()).set(initialParticleData);
        particleBuffers[i].unmap();
      }
      for (let i = 0; i < 2; ++i) {
        particleBindGroups[i] = device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(0),
          entries: [{
            binding: 0,
            resource: {
              buffer: simParamBuffer,
              offset: 0,
              size: simParamData.byteLength
            },
          }, {
            binding: 1,
            resource: {
              buffer: particleBuffers[i],
              offset: 0,
              size: initialParticleData.byteLength,
            },
          }, {
            binding: 2,
            resource: {
              buffer: particleBuffers[(i + 1) % 2],
              offset: 0,
              size: initialParticleData.byteLength,
            },
          }],
        });
      }

      let t = 0;
      function frame() {
        renderPassDescriptor.colorAttachments[0].view = context.getCurrentTexture().createView();

        const commandEncoder = device.createCommandEncoder({});
        {
          const passEncoder = commandEncoder.beginComputePass();
          passEncoder.setPipeline(computePipeline);
          passEncoder.setBindGroup(0, particleBindGroups[t % 2]);
          passEncoder.dispatchWorkgroups(numParticles, 1, 1);
          passEncoder.end();
        }
        {
          const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
          passEncoder.setPipeline(renderPipeline);
          passEncoder.setVertexBuffer(0, particleBuffers[(t + 1) % 2]);
          passEncoder.setVertexBuffer(1, verticesBuffer);
          passEncoder.draw(3, numParticles, 0, 0);
          passEncoder.end();
        }
        device.queue.submit([commandEncoder.finish()]);

        ++t;
        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);
    }

    init();

  </script>
</body>

</html>
