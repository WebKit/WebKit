2014-02-20  Geoffrey Garen  <ggaren@apple.com>

        Math.imul gives wrong results
        https://bugs.webkit.org/show_bug.cgi?id=126345

        Reviewed by Mark Hahnenberg.

        Don't truncate non-int doubles to 0 -- that's just not how ToInt32 works.
        Instead, take a slow path that will do the right thing.

        * jit/ThunkGenerators.cpp:
        (JSC::imulThunkGenerator):

2014-02-20  Filip Pizlo  <fpizlo@apple.com>

        DFG should do its own static estimates of execution frequency before it starts creating OSR entrypoints
        https://bugs.webkit.org/show_bug.cgi?id=129129

        Reviewed by Geoffrey Garen.
        
        We estimate execution counts based on loop depth, and then use those to estimate branch
        weights. These weights then get carried all the way down to LLVM prof branch_weights
        meta-data.
        
        This is better than letting LLVM do its own static estimates, since by the time we
        generate LLVM IR, we may have messed up the CFG due to OSR entrypoint creation. Of
        course, it would be even better if we just slurped in some kind of execution counts
        from profiling, but we don't do that, yet.

        * CMakeLists.txt:
        * GNUmakefile.list.am:
        * JavaScriptCore.vcxproj/JavaScriptCore.vcxproj:
        * JavaScriptCore.xcodeproj/project.pbxproj:
        * dfg/DFGBasicBlock.cpp:
        (JSC::DFG::BasicBlock::BasicBlock):
        * dfg/DFGBasicBlock.h:
        * dfg/DFGBlockInsertionSet.cpp:
        (JSC::DFG::BlockInsertionSet::insert):
        (JSC::DFG::BlockInsertionSet::insertBefore):
        * dfg/DFGBlockInsertionSet.h:
        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::handleInlining):
        (JSC::DFG::ByteCodeParser::parseCodeBlock):
        * dfg/DFGCriticalEdgeBreakingPhase.cpp:
        (JSC::DFG::CriticalEdgeBreakingPhase::breakCriticalEdge):
        * dfg/DFGLoopPreHeaderCreationPhase.cpp:
        (JSC::DFG::createPreHeader):
        * dfg/DFGNaturalLoops.h:
        (JSC::DFG::NaturalLoops::loopDepth):
        * dfg/DFGOSREntrypointCreationPhase.cpp:
        (JSC::DFG::OSREntrypointCreationPhase::run):
        * dfg/DFGPlan.cpp:
        (JSC::DFG::Plan::compileInThreadImpl):
        * dfg/DFGStaticExecutionCountEstimationPhase.cpp: Added.
        (JSC::DFG::StaticExecutionCountEstimationPhase::StaticExecutionCountEstimationPhase):
        (JSC::DFG::StaticExecutionCountEstimationPhase::run):
        (JSC::DFG::StaticExecutionCountEstimationPhase::applyCounts):
        (JSC::DFG::performStaticExecutionCountEstimation):
        * dfg/DFGStaticExecutionCountEstimationPhase.h: Added.

2014-02-20  Filip Pizlo  <fpizlo@apple.com>

        FTL may not see a compact_unwind section if there weren't any stackmaps
        https://bugs.webkit.org/show_bug.cgi?id=129125

        Reviewed by Geoffrey Garen.
        
        It's OK to not have an unwind section, so long as the function also doesn't have any
        OSR exits.

        * ftl/FTLCompile.cpp:
        (JSC::FTL::fixFunctionBasedOnStackMaps):
        (JSC::FTL::compile):
        * ftl/FTLUnwindInfo.cpp:
        (JSC::FTL::UnwindInfo::parse):
        * ftl/FTLUnwindInfo.h:

== Rolled over to ChangeLog-2014-02-20 ==
