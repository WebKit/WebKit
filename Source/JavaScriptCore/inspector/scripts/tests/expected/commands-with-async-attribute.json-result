### Begin File: InspectorBackendCommands.js.in
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

// Database
InspectorBackend.registerDomain("Database", null);
InspectorBackend.registerEnum("Database.PrimaryColors", {Red: "red", Green: "green", Blue: "blue"});
InspectorBackend.registerCommand("Database.executeSQLSyncOptionalReturnValues", null, [{"name": "databaseId", "type": "number"}, {"name": "query", "type": "string"}], ["columnNames", "notes", "timestamp", "values", "payload", "databaseId", "sqlError", "screenColor", "alternateColors", "printColor"]);
InspectorBackend.registerCommand("Database.executeSQLAsyncOptionalReturnValues", null, [{"name": "databaseId", "type": "number"}, {"name": "query", "type": "string"}], ["columnNames", "notes", "timestamp", "values", "payload", "databaseId", "sqlError", "screenColor", "alternateColors", "printColor"]);
InspectorBackend.registerCommand("Database.executeSQLSync", null, [{"name": "databaseId", "type": "number"}, {"name": "query", "type": "string"}], ["columnNames", "notes", "timestamp", "values", "payload", "databaseId", "sqlError", "alternateColors", "screenColor", "printColor"]);
InspectorBackend.registerCommand("Database.executeSQLAsync", null, [{"name": "databaseId", "type": "number"}, {"name": "query", "type": "string"}], ["columnNames", "notes", "timestamp", "values", "payload", "databaseId", "sqlError", "screenColor", "alternateColors", "printColor"]);
InspectorBackend.registerDatabaseDispatcher = InspectorBackend.registerDispatcher.bind(InspectorBackend, "Database");
InspectorBackend.activateDomain("Database", null);
### End File: InspectorBackendCommands.js.in

### Begin File: TestAlternateBackendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#pragma once

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

#include "TestProtocolObjects.h"
#include <JavaScriptCore/InspectorBackendDispatcher.h>
#include <JavaScriptCore/InspectorFrontendRouter.h>

namespace Inspector {

class AlternateBackendDispatcher {
public:
    void setBackendDispatcher(RefPtr<BackendDispatcher>&& dispatcher) { m_backendDispatcher = WTFMove(dispatcher); }
    BackendDispatcher* backendDispatcher() const { return m_backendDispatcher.get(); }
private:
    RefPtr<BackendDispatcher> m_backendDispatcher;
};


class AlternateDatabaseBackendDispatcher : public AlternateBackendDispatcher {
public:
    virtual ~AlternateDatabaseBackendDispatcher() { }
    virtual void executeSQLSyncOptionalReturnValues(long protocol_requestId, int databaseId, const String& query) = 0;
    virtual void executeSQLAsyncOptionalReturnValues(long protocol_requestId, int databaseId, const String& query) = 0;
    virtual void executeSQLSync(long protocol_requestId, int databaseId, const String& query) = 0;
    virtual void executeSQLAsync(long protocol_requestId, int databaseId, const String& query) = 0;
};

} // namespace Inspector

#endif // ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
### End File: TestAlternateBackendDispatchers.h

### Begin File: TestBackendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#pragma once

#include "TestProtocolObjects.h"
#include <JavaScriptCore/InspectorBackendDispatcher.h>
#include <tuple>
#include <wtf/Expected.h>
#include <wtf/text/WTFString.h>

namespace Inspector {



#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
class AlternateDatabaseBackendDispatcher;
#endif // ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

class DatabaseBackendDispatcherHandler {
public:
    virtual Protocol::ErrorStringOr<std::tuple<RefPtr<JSON::ArrayOf<String>> /* opt_columnNames */, String /* opt_notes */, std::optional<double> /* opt_timestamp */, RefPtr<JSON::Object> /* opt_values */, RefPtr<JSON::Value> /* opt_payload */, std::optional<int> /* opt_databaseId */, RefPtr<Protocol::Database::Error> /* opt_sqlError */, std::optional<Protocol::Database::PrimaryColors> /* opt_screenColor */, RefPtr<Protocol::Database::ColorList> /* opt_alternateColors */, String /* opt_printColor */>> executeSQLSyncOptionalReturnValues(int databaseId, const String& query) = 0;
    class ExecuteSQLAsyncOptionalReturnValuesCallback : public BackendDispatcher::CallbackBase {
    public:
        ExecuteSQLAsyncOptionalReturnValuesCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess(RefPtr<JSON::ArrayOf<String>>&& opt_columnNames, const String& opt_notes, std::optional<double>&& opt_timestamp, RefPtr<JSON::Object>&& opt_values, RefPtr<JSON::Value>&& opt_payload, std::optional<int>&& opt_databaseId, RefPtr<Protocol::Database::Error>&& opt_sqlError, std::optional<Protocol::Database::PrimaryColors>&& opt_screenColor, RefPtr<Protocol::Database::ColorList>&& opt_alternateColors, const String& opt_printColor);
    };
    virtual void executeSQLAsyncOptionalReturnValues(int databaseId, const String& query, Ref<ExecuteSQLAsyncOptionalReturnValuesCallback>&&) = 0;
    virtual Protocol::ErrorStringOr<std::tuple<Ref<JSON::ArrayOf<String>> /* columnNames */, String /* notes */, double /* timestamp */, Ref<JSON::Object> /* values */, Ref<JSON::Value> /* payload */, int /* databaseId */, Ref<Protocol::Database::Error> /* sqlError */, Ref<Protocol::Database::ColorList> /* alternateColors */, Protocol::Database::PrimaryColors /* screenColor */, String /* printColor */>> executeSQLSync(int databaseId, const String& query) = 0;
    class ExecuteSQLAsyncCallback : public BackendDispatcher::CallbackBase {
    public:
        ExecuteSQLAsyncCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess(Ref<JSON::ArrayOf<String>>&& columnNames, const String& notes, double timestamp, Ref<JSON::Object>&& values, Ref<JSON::Value>&& payload, int databaseId, Ref<Protocol::Database::Error>&& sqlError, Protocol::Database::PrimaryColors screenColor, Ref<Protocol::Database::ColorList>&& alternateColors, const String& printColor);
    };
    virtual void executeSQLAsync(int databaseId, const String& query, Ref<ExecuteSQLAsyncCallback>&&) = 0;
protected:
    virtual ~DatabaseBackendDispatcherHandler();
};

class DatabaseBackendDispatcher final : public SupplementalBackendDispatcher {
public:
    static Ref<DatabaseBackendDispatcher> create(BackendDispatcher&, DatabaseBackendDispatcherHandler*);
    void dispatch(long protocol_requestId, const String& protocol_method, Ref<JSON::Object>&& protocol_message) final;
private:
    void executeSQLSyncOptionalReturnValues(long protocol_requestId, RefPtr<JSON::Object>&& protocol_parameters);
    void executeSQLAsyncOptionalReturnValues(long protocol_requestId, RefPtr<JSON::Object>&& protocol_parameters);
    void executeSQLSync(long protocol_requestId, RefPtr<JSON::Object>&& protocol_parameters);
    void executeSQLAsync(long protocol_requestId, RefPtr<JSON::Object>&& protocol_parameters);
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
public:
    void setAlternateDispatcher(AlternateDatabaseBackendDispatcher* alternateDispatcher) { m_alternateDispatcher = alternateDispatcher; }
private:
    AlternateDatabaseBackendDispatcher* m_alternateDispatcher { nullptr };
#endif // ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
private:
    DatabaseBackendDispatcher(BackendDispatcher&, DatabaseBackendDispatcherHandler*);
    DatabaseBackendDispatcherHandler* m_agent { nullptr };
};

} // namespace Inspector
### End File: TestBackendDispatchers.h

### Begin File: TestBackendDispatchers.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "TestBackendDispatchers.h"

#include <JavaScriptCore/InspectorFrontendRouter.h>
#include <wtf/NeverDestroyed.h>

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
#include "TestAlternateBackendDispatchers.h"
#endif // ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

namespace Inspector {

DatabaseBackendDispatcherHandler::~DatabaseBackendDispatcherHandler() { }

Ref<DatabaseBackendDispatcher> DatabaseBackendDispatcher::create(BackendDispatcher& backendDispatcher, DatabaseBackendDispatcherHandler* agent)
{
    return adoptRef(*new DatabaseBackendDispatcher(backendDispatcher, agent));
}

DatabaseBackendDispatcher::DatabaseBackendDispatcher(BackendDispatcher& backendDispatcher, DatabaseBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain("Database"_s, this);
}

void DatabaseBackendDispatcher::dispatch(long protocol_requestId, const String& protocol_method, Ref<JSON::Object>&& protocol_message)
{
    Ref<DatabaseBackendDispatcher> protect(*this);

    auto protocol_parameters = protocol_message->getObject("params"_s);

    if (protocol_method == "executeSQLSyncOptionalReturnValues"_s) {
        executeSQLSyncOptionalReturnValues(protocol_requestId, WTFMove(protocol_parameters));
        return;
    }
    if (protocol_method == "executeSQLAsyncOptionalReturnValues"_s) {
        executeSQLAsyncOptionalReturnValues(protocol_requestId, WTFMove(protocol_parameters));
        return;
    }
    if (protocol_method == "executeSQLSync"_s) {
        executeSQLSync(protocol_requestId, WTFMove(protocol_parameters));
        return;
    }
    if (protocol_method == "executeSQLAsync"_s) {
        executeSQLAsync(protocol_requestId, WTFMove(protocol_parameters));
        return;
    }

    m_backendDispatcher->reportProtocolError(BackendDispatcher::MethodNotFound, makeString("'Database."_s, protocol_method, "' was not found"_s));
}

void DatabaseBackendDispatcher::executeSQLSyncOptionalReturnValues(long protocol_requestId, RefPtr<JSON::Object>&& protocol_parameters)
{
    auto in_databaseId = m_backendDispatcher->getInteger(protocol_parameters.get(), "databaseId"_s, true);
    auto in_query = m_backendDispatcher->getString(protocol_parameters.get(), "query"_s, true);
    if (m_backendDispatcher->hasProtocolErrors()) {
        m_backendDispatcher->reportProtocolError(BackendDispatcher::InvalidParams, "Some arguments of method 'Database.executeSQLSyncOptionalReturnValues' can't be processed"_s);
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->executeSQLSyncOptionalReturnValues(protocol_requestId, *in_databaseId, in_query);
        return;
    }
#endif // ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

    auto result = m_agent->executeSQLSyncOptionalReturnValues(*in_databaseId, in_query);
    if (!result) {
        ASSERT(!result.error().isEmpty());
        m_backendDispatcher->reportProtocolError(BackendDispatcher::ServerError, result.error());
        return;
    }

    auto [out_opt_columnNames, out_opt_notes, out_opt_timestamp, out_opt_values, out_opt_payload, out_opt_databaseId, out_opt_sqlError, out_opt_screenColor, out_opt_alternateColors, out_opt_printColor] = WTFMove(result.value());

    auto protocol_jsonMessage = JSON::Object::create();
    if (!!out_opt_columnNames)
        protocol_jsonMessage->setArray("columnNames"_s, out_opt_columnNames.releaseNonNull());
    if (!!out_opt_notes)
        protocol_jsonMessage->setString("notes"_s, out_opt_notes);
    if (!!out_opt_timestamp)
        protocol_jsonMessage->setDouble("timestamp"_s, *out_opt_timestamp);
    if (!!out_opt_values)
        protocol_jsonMessage->setObject("values"_s, out_opt_values.releaseNonNull());
    if (!!out_opt_payload)
        protocol_jsonMessage->setValue("payload"_s, out_opt_payload.releaseNonNull());
    if (!!out_opt_databaseId)
        protocol_jsonMessage->setInteger("databaseId"_s, *out_opt_databaseId);
    if (!!out_opt_sqlError)
        protocol_jsonMessage->setObject("sqlError"_s, out_opt_sqlError.releaseNonNull());
    if (!!out_opt_screenColor)
        protocol_jsonMessage->setString("screenColor"_s, Protocol::TestHelpers::getEnumConstantValue(*out_opt_screenColor));
    if (!!out_opt_alternateColors)
        protocol_jsonMessage->setArray("alternateColors"_s, out_opt_alternateColors.releaseNonNull());
    if (!!out_opt_printColor)
        protocol_jsonMessage->setString("printColor"_s, out_opt_printColor);
    m_backendDispatcher->sendResponse(protocol_requestId, WTFMove(protocol_jsonMessage), false);
}

DatabaseBackendDispatcherHandler::ExecuteSQLAsyncOptionalReturnValuesCallback::ExecuteSQLAsyncOptionalReturnValuesCallback(Ref<BackendDispatcher>&& backendDispatcher, int id) : BackendDispatcher::CallbackBase(WTFMove(backendDispatcher), id) { }

void DatabaseBackendDispatcherHandler::ExecuteSQLAsyncOptionalReturnValuesCallback::sendSuccess(RefPtr<JSON::ArrayOf<String>>&& opt_columnNames, const String& opt_notes, std::optional<double>&& opt_timestamp, RefPtr<JSON::Object>&& opt_values, RefPtr<JSON::Value>&& opt_payload, std::optional<int>&& opt_databaseId, RefPtr<Protocol::Database::Error>&& opt_sqlError, std::optional<Protocol::Database::PrimaryColors>&& opt_screenColor, RefPtr<Protocol::Database::ColorList>&& opt_alternateColors, const String& opt_printColor)
{
    auto protocol_jsonMessage = JSON::Object::create();
    if (!!opt_columnNames)
        protocol_jsonMessage->setArray("columnNames"_s, opt_columnNames.releaseNonNull());
    if (!!opt_notes)
        protocol_jsonMessage->setString("notes"_s, opt_notes);
    if (!!opt_timestamp)
        protocol_jsonMessage->setDouble("timestamp"_s, *opt_timestamp);
    if (!!opt_values)
        protocol_jsonMessage->setObject("values"_s, opt_values.releaseNonNull());
    if (!!opt_payload)
        protocol_jsonMessage->setValue("payload"_s, opt_payload.releaseNonNull());
    if (!!opt_databaseId)
        protocol_jsonMessage->setInteger("databaseId"_s, *opt_databaseId);
    if (!!opt_sqlError)
        protocol_jsonMessage->setObject("sqlError"_s, opt_sqlError.releaseNonNull());
    if (!!opt_screenColor)
        protocol_jsonMessage->setString("screenColor"_s, Protocol::TestHelpers::getEnumConstantValue(*opt_screenColor));
    if (!!opt_alternateColors)
        protocol_jsonMessage->setArray("alternateColors"_s, opt_alternateColors.releaseNonNull());
    if (!!opt_printColor)
        protocol_jsonMessage->setString("printColor"_s, opt_printColor);
    CallbackBase::sendSuccess(WTFMove(protocol_jsonMessage));
}

void DatabaseBackendDispatcher::executeSQLAsyncOptionalReturnValues(long protocol_requestId, RefPtr<JSON::Object>&& protocol_parameters)
{
    auto in_databaseId = m_backendDispatcher->getInteger(protocol_parameters.get(), "databaseId"_s, true);
    auto in_query = m_backendDispatcher->getString(protocol_parameters.get(), "query"_s, true);
    if (m_backendDispatcher->hasProtocolErrors()) {
        m_backendDispatcher->reportProtocolError(BackendDispatcher::InvalidParams, "Some arguments of method 'Database.executeSQLAsyncOptionalReturnValues' can't be processed"_s);
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->executeSQLAsyncOptionalReturnValues(protocol_requestId, *in_databaseId, in_query);
        return;
    }
#endif // ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

    m_agent->executeSQLAsyncOptionalReturnValues(*in_databaseId, in_query, adoptRef(*new DatabaseBackendDispatcherHandler::ExecuteSQLAsyncOptionalReturnValuesCallback(m_backendDispatcher.copyRef(), protocol_requestId)));
}

void DatabaseBackendDispatcher::executeSQLSync(long protocol_requestId, RefPtr<JSON::Object>&& protocol_parameters)
{
    auto in_databaseId = m_backendDispatcher->getInteger(protocol_parameters.get(), "databaseId"_s, true);
    auto in_query = m_backendDispatcher->getString(protocol_parameters.get(), "query"_s, true);
    if (m_backendDispatcher->hasProtocolErrors()) {
        m_backendDispatcher->reportProtocolError(BackendDispatcher::InvalidParams, "Some arguments of method 'Database.executeSQLSync' can't be processed"_s);
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->executeSQLSync(protocol_requestId, *in_databaseId, in_query);
        return;
    }
#endif // ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

    auto result = m_agent->executeSQLSync(*in_databaseId, in_query);
    if (!result) {
        ASSERT(!result.error().isEmpty());
        m_backendDispatcher->reportProtocolError(BackendDispatcher::ServerError, result.error());
        return;
    }

    auto [out_columnNames, out_notes, out_timestamp, out_values, out_payload, out_databaseId, out_sqlError, out_alternateColors, out_screenColor, out_printColor] = WTFMove(result.value());

    auto protocol_jsonMessage = JSON::Object::create();
    protocol_jsonMessage->setArray("columnNames"_s, WTFMove(out_columnNames));
    protocol_jsonMessage->setString("notes"_s, out_notes);
    protocol_jsonMessage->setDouble("timestamp"_s, out_timestamp);
    protocol_jsonMessage->setObject("values"_s, WTFMove(out_values));
    protocol_jsonMessage->setValue("payload"_s, WTFMove(out_payload));
    protocol_jsonMessage->setInteger("databaseId"_s, out_databaseId);
    protocol_jsonMessage->setObject("sqlError"_s, WTFMove(out_sqlError));
    protocol_jsonMessage->setArray("alternateColors"_s, WTFMove(out_alternateColors));
    protocol_jsonMessage->setString("screenColor"_s, Protocol::TestHelpers::getEnumConstantValue(out_screenColor));
    protocol_jsonMessage->setString("printColor"_s, out_printColor);
    m_backendDispatcher->sendResponse(protocol_requestId, WTFMove(protocol_jsonMessage), false);
}

DatabaseBackendDispatcherHandler::ExecuteSQLAsyncCallback::ExecuteSQLAsyncCallback(Ref<BackendDispatcher>&& backendDispatcher, int id) : BackendDispatcher::CallbackBase(WTFMove(backendDispatcher), id) { }

void DatabaseBackendDispatcherHandler::ExecuteSQLAsyncCallback::sendSuccess(Ref<JSON::ArrayOf<String>>&& columnNames, const String& notes, double timestamp, Ref<JSON::Object>&& values, Ref<JSON::Value>&& payload, int databaseId, Ref<Protocol::Database::Error>&& sqlError, Protocol::Database::PrimaryColors screenColor, Ref<Protocol::Database::ColorList>&& alternateColors, const String& printColor)
{
    auto protocol_jsonMessage = JSON::Object::create();
    protocol_jsonMessage->setArray("columnNames"_s, WTFMove(columnNames));
    protocol_jsonMessage->setString("notes"_s, notes);
    protocol_jsonMessage->setDouble("timestamp"_s, timestamp);
    protocol_jsonMessage->setObject("values"_s, WTFMove(values));
    protocol_jsonMessage->setValue("payload"_s, WTFMove(payload));
    protocol_jsonMessage->setInteger("databaseId"_s, databaseId);
    protocol_jsonMessage->setObject("sqlError"_s, WTFMove(sqlError));
    protocol_jsonMessage->setString("screenColor"_s, Protocol::TestHelpers::getEnumConstantValue(screenColor));
    protocol_jsonMessage->setArray("alternateColors"_s, WTFMove(alternateColors));
    protocol_jsonMessage->setString("printColor"_s, printColor);
    CallbackBase::sendSuccess(WTFMove(protocol_jsonMessage));
}

void DatabaseBackendDispatcher::executeSQLAsync(long protocol_requestId, RefPtr<JSON::Object>&& protocol_parameters)
{
    auto in_databaseId = m_backendDispatcher->getInteger(protocol_parameters.get(), "databaseId"_s, true);
    auto in_query = m_backendDispatcher->getString(protocol_parameters.get(), "query"_s, true);
    if (m_backendDispatcher->hasProtocolErrors()) {
        m_backendDispatcher->reportProtocolError(BackendDispatcher::InvalidParams, "Some arguments of method 'Database.executeSQLAsync' can't be processed"_s);
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->executeSQLAsync(protocol_requestId, *in_databaseId, in_query);
        return;
    }
#endif // ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

    m_agent->executeSQLAsync(*in_databaseId, in_query, adoptRef(*new DatabaseBackendDispatcherHandler::ExecuteSQLAsyncCallback(m_backendDispatcher.copyRef(), protocol_requestId)));
}

} // namespace Inspector

### End File: TestBackendDispatchers.cpp

### Begin File: TestFrontendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#pragma once

#include "TestProtocolObjects.h"
#include <wtf/JSONValues.h>
#include <wtf/text/WTFString.h>

namespace Inspector {

class FrontendRouter;

} // namespace Inspector
### End File: TestFrontendDispatchers.h

### Begin File: TestFrontendDispatchers.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "TestFrontendDispatchers.h"

#include <JavaScriptCore/InspectorFrontendRouter.h>

namespace Inspector {

} // namespace Inspector

### End File: TestFrontendDispatchers.cpp

### Begin File: TestProtocolObjects.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#pragma once

#include <JavaScriptCore/InspectorProtocolTypes.h>
#include <wtf/JSONValues.h>
#include <wtf/text/WTFString.h>

namespace Inspector {



namespace Protocol {



// Forward declarations.
namespace Database {
class Error;
enum class PrimaryColors;
} // Database
// End of forward declarations.


// Typedefs.
namespace Database {
/* Unique identifier of Database object. */
using DatabaseId = int;
using ColorList = JSON::ArrayOf<Protocol::Database::PrimaryColors>;
} // Database
// End of typedefs.

namespace TestHelpers {

String getEnumConstantValue(int code);

template<typename T> String getEnumConstantValue(T enumValue)
{
    return getEnumConstantValue(static_cast<int>(enumValue));
}

} // namespace TestHelpers

namespace Database {

enum class PrimaryColors {
    Red = 0,
    Green = 1,
    Blue = 2,
}; // enum class PrimaryColors

/* Database error. */
class Error final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        MessageSet = 1 << 0,
        CodeSet = 1 << 1,
        AllFieldsSet = (MessageSet | CodeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Error*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Error;
    public:

        Builder<STATE | MessageSet>& setMessage(const String& in_message)
        {
            COMPILE_ASSERT(!(STATE & MessageSet), property_message_already_set);
            m_result->setString("message"_s, in_message);
            return castState<MessageSet>();
        }

        Builder<STATE | CodeSet>& setCode(int in_code)
        {
            COMPILE_ASSERT(!(STATE & CodeSet), property_code_already_set);
            m_result->setInteger("code"_s, in_code);
            return castState<CodeSet>();
        }

        Ref<Error> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Error) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Error>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Error> result = Error::create()
     *     .setMessage(...)
     *     .setCode(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // Database



namespace TestHelpers {

template<typename ProtocolEnumType>
std::optional<ProtocolEnumType> parseEnumValueFromString(const String&);

// Enums in the 'Database' Domain
template<>
std::optional<Protocol::Database::PrimaryColors> parseEnumValueFromString<Protocol::Database::PrimaryColors>(const String&);

} // namespace TestHelpers

} // namespace Protocol

} // namespace Inspector

namespace WTF {

template<typename T> struct DefaultHash;

// Hash declarations in the 'Database' Domain
template<>
struct DefaultHash<Inspector::Protocol::Database::PrimaryColors> : IntHash<Inspector::Protocol::Database::PrimaryColors> { };

} // namespace WTF
### End File: TestProtocolObjects.h

### Begin File: TestProtocolObjects.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "TestProtocolObjects.h"

#include <wtf/Assertions.h>

namespace Inspector {

namespace Protocol {

namespace TestHelpers {

static const ASCIILiteral enum_constant_values[] = {
    "red"_s,
    "green"_s,
    "blue"_s,
    "cyan"_s,
    "magenta"_s,
    "yellow"_s,
    "black"_s,
};

String getEnumConstantValue(int code) {
    return enum_constant_values[code];
}

// Enums in the 'Database' Domain

template<> std::optional<Protocol::Database::PrimaryColors> parseEnumValueFromString<Protocol::Database::PrimaryColors>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Protocol::Database::PrimaryColors::Red,
        (size_t)Protocol::Database::PrimaryColors::Green,
        (size_t)Protocol::Database::PrimaryColors::Blue,
    };
    for (size_t i = 0; i < 3; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Protocol::Database::PrimaryColors)constantValues[i];

    return std::nullopt;
}

} // namespace TestHelpers



} // namespace Protocol

} // namespace Inspector

### End File: TestProtocolObjects.cpp

### Begin File: TestProtocolBackendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include <JavaScriptCore/InspectorAlternateBackendDispatchers.h>
#include <wtf/RetainPtr.h>

@protocol TestProtocolDatabaseDomainHandler;

namespace Inspector {


class ObjCInspectorDatabaseBackendDispatcher final : public AlternateDatabaseBackendDispatcher {
    WTF_MAKE_FAST_ALLOCATED;
public:
    ObjCInspectorDatabaseBackendDispatcher(id<TestProtocolDatabaseDomainHandler> handler) { m_delegate = handler; }
    void executeSQLSyncOptionalReturnValues(long protocol_requestId, int databaseId, const String& query) final;
    void executeSQLAsyncOptionalReturnValues(long protocol_requestId, int databaseId, const String& query) final;
    void executeSQLSync(long protocol_requestId, int databaseId, const String& query) final;
    void executeSQLAsync(long protocol_requestId, int databaseId, const String& query) final;
private:
    RetainPtr<id<TestProtocolDatabaseDomainHandler>> m_delegate;
};

} // namespace Inspector

### End File: TestProtocolBackendDispatchers.h

### Begin File: TestProtocolBackendDispatchers.mm
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "config.h"
#import "TestProtocolBackendDispatchers.h"

#include "TestProtocolInternal.h"
#include "TestProtocolTypeConversions.h"
#include <wtf/JSONValues.h>

namespace Inspector {

void ObjCInspectorDatabaseBackendDispatcher::executeSQLSyncOptionalReturnValues(long protocol_requestId, int in_databaseId, const String& in_query)
{
    if (![m_delegate respondsToSelector:@selector(executeSQLSyncOptionalReturnValuesWithErrorCallback:successCallback:databaseId:query:)]) {
        backendDispatcher()->reportProtocolError(protocol_requestId, BackendDispatcher::MethodNotFound, "'Database.executeSQLSyncOptionalReturnValues' was not found"_s);
        backendDispatcher()->sendPendingErrors();
        return;
    }

    id errorCallback = ^(NSString *error) {
        backendDispatcher()->reportProtocolError(protocol_requestId, BackendDispatcher::ServerError, error);
        backendDispatcher()->sendPendingErrors();
    };

    id successCallback = ^(NSArray/*<NSString>*/ **out_opt_columnNames, NSString **out_opt_notes, double *out_opt_timestamp, RWIProtocolJSONObject **out_opt_values, RWIProtocolJSONObject **out_opt_payload, int *out_opt_databaseId, TestProtocolDatabaseError **out_opt_sqlError, TestProtocolDatabasePrimaryColors *out_opt_screenColor, NSArray/*<NSString>*/ **out_opt_alternateColors, TestProtocolDatabase(anonymous) *out_opt_printColor) {
        auto protocol_jsonMessage = JSON::Object::create();
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(out_opt_columnNames, @"columnNames");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(out_opt_notes, @"notes");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(out_opt_values, @"values");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(out_opt_payload, @"payload");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(out_opt_sqlError, @"sqlError");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(out_opt_alternateColors, @"alternateColors");
        if (!!out_opt_columnNames)
            protocol_jsonMessage->setArray("columnNames"_s, toJSONStringArray(*out_opt_columnNames));
        if (!!out_opt_notes)
            protocol_jsonMessage->setString("notes"_s, *out_opt_notes);
        if (!!out_opt_timestamp)
            protocol_jsonMessage->setDouble("timestamp"_s, *out_opt_timestamp);
        if (!!out_opt_values)
            protocol_jsonMessage->setObject("values"_s, [*out_opt_values toJSONObject]);
        if (!!out_opt_payload)
            protocol_jsonMessage->setValue("payload"_s, [*out_opt_payload toJSONObject]);
        if (!!out_opt_databaseId)
            protocol_jsonMessage->setInteger("databaseId"_s, *out_opt_databaseId);
        if (!!out_opt_sqlError)
            protocol_jsonMessage->setObject("sqlError"_s, [*out_opt_sqlError toJSONObject]);
        if (!!out_opt_screenColor)
            protocol_jsonMessage->setString("screenColor"_s, toProtocolString(*out_opt_screenColor));
        if (!!out_opt_alternateColors)
            protocol_jsonMessage->setArray("alternateColors"_s, toJSONStringArray(*out_opt_alternateColors));
        if (!!out_opt_printColor)
            protocol_jsonMessage->setString("printColor"_s, toProtocolString(*out_opt_printColor));
        backendDispatcher()->sendResponse(protocol_requestId, WTFMove(protocol_jsonMessage), false);
    };

    int o_in_databaseId = in_databaseId;
    NSString *o_in_query = in_query;
    [m_delegate executeSQLSyncOptionalReturnValuesWithErrorCallback:errorCallback successCallback:successCallback databaseId:o_in_databaseId query:o_in_query];
}

void ObjCInspectorDatabaseBackendDispatcher::executeSQLAsyncOptionalReturnValues(long protocol_requestId, int in_databaseId, const String& in_query)
{
    if (![m_delegate respondsToSelector:@selector(executeSQLAsyncOptionalReturnValuesWithErrorCallback:successCallback:databaseId:query:)]) {
        backendDispatcher()->reportProtocolError(protocol_requestId, BackendDispatcher::MethodNotFound, "'Database.executeSQLAsyncOptionalReturnValues' was not found"_s);
        backendDispatcher()->sendPendingErrors();
        return;
    }

    id errorCallback = ^(NSString *error) {
        backendDispatcher()->reportProtocolError(protocol_requestId, BackendDispatcher::ServerError, error);
        backendDispatcher()->sendPendingErrors();
    };

    id successCallback = ^(NSArray/*<NSString>*/ **out_opt_columnNames, NSString **out_opt_notes, double *out_opt_timestamp, RWIProtocolJSONObject **out_opt_values, RWIProtocolJSONObject **out_opt_payload, int *out_opt_databaseId, TestProtocolDatabaseError **out_opt_sqlError, TestProtocolDatabasePrimaryColors *out_opt_screenColor, NSArray/*<NSString>*/ **out_opt_alternateColors, TestProtocolDatabase(anonymous) *out_opt_printColor) {
        auto protocol_jsonMessage = JSON::Object::create();
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(out_opt_columnNames, @"columnNames");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(out_opt_notes, @"notes");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(out_opt_values, @"values");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(out_opt_payload, @"payload");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(out_opt_sqlError, @"sqlError");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(out_opt_alternateColors, @"alternateColors");
        if (!!out_opt_columnNames)
            protocol_jsonMessage->setArray("columnNames"_s, toJSONStringArray(*out_opt_columnNames));
        if (!!out_opt_notes)
            protocol_jsonMessage->setString("notes"_s, *out_opt_notes);
        if (!!out_opt_timestamp)
            protocol_jsonMessage->setDouble("timestamp"_s, *out_opt_timestamp);
        if (!!out_opt_values)
            protocol_jsonMessage->setObject("values"_s, [*out_opt_values toJSONObject]);
        if (!!out_opt_payload)
            protocol_jsonMessage->setValue("payload"_s, [*out_opt_payload toJSONObject]);
        if (!!out_opt_databaseId)
            protocol_jsonMessage->setInteger("databaseId"_s, *out_opt_databaseId);
        if (!!out_opt_sqlError)
            protocol_jsonMessage->setObject("sqlError"_s, [*out_opt_sqlError toJSONObject]);
        if (!!out_opt_screenColor)
            protocol_jsonMessage->setString("screenColor"_s, toProtocolString(*out_opt_screenColor));
        if (!!out_opt_alternateColors)
            protocol_jsonMessage->setArray("alternateColors"_s, toJSONStringArray(*out_opt_alternateColors));
        if (!!out_opt_printColor)
            protocol_jsonMessage->setString("printColor"_s, toProtocolString(*out_opt_printColor));
        backendDispatcher()->sendResponse(protocol_requestId, WTFMove(protocol_jsonMessage), false);
    };

    int o_in_databaseId = in_databaseId;
    NSString *o_in_query = in_query;
    [m_delegate executeSQLAsyncOptionalReturnValuesWithErrorCallback:errorCallback successCallback:successCallback databaseId:o_in_databaseId query:o_in_query];
}

void ObjCInspectorDatabaseBackendDispatcher::executeSQLSync(long protocol_requestId, int in_databaseId, const String& in_query)
{
    if (![m_delegate respondsToSelector:@selector(executeSQLSyncWithErrorCallback:successCallback:databaseId:query:)]) {
        backendDispatcher()->reportProtocolError(protocol_requestId, BackendDispatcher::MethodNotFound, "'Database.executeSQLSync' was not found"_s);
        backendDispatcher()->sendPendingErrors();
        return;
    }

    id errorCallback = ^(NSString *error) {
        backendDispatcher()->reportProtocolError(protocol_requestId, BackendDispatcher::ServerError, error);
        backendDispatcher()->sendPendingErrors();
    };

    id successCallback = ^(NSArray/*<NSString>*/ *out_columnNames, NSString *out_notes, double out_timestamp, RWIProtocolJSONObject *out_values, RWIProtocolJSONObject *out_payload, int out_databaseId, TestProtocolDatabaseError *out_sqlError, NSArray/*<NSString>*/ *out_alternateColors, TestProtocolDatabasePrimaryColors out_screenColor, TestProtocolDatabase(anonymous) out_printColor) {
        auto protocol_jsonMessage = JSON::Object::create();
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(out_columnNames, @"columnNames");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(out_notes, @"notes");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(out_values, @"values");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(out_payload, @"payload");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(out_sqlError, @"sqlError");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(out_alternateColors, @"alternateColors");
        protocol_jsonMessage->setArray("columnNames"_s, toJSONStringArray(out_columnNames));
        protocol_jsonMessage->setString("notes"_s, out_notes);
        protocol_jsonMessage->setDouble("timestamp"_s, out_timestamp);
        protocol_jsonMessage->setObject("values"_s, [out_values toJSONObject]);
        protocol_jsonMessage->setValue("payload"_s, [out_payload toJSONObject]);
        protocol_jsonMessage->setInteger("databaseId"_s, out_databaseId);
        protocol_jsonMessage->setObject("sqlError"_s, [out_sqlError toJSONObject]);
        protocol_jsonMessage->setArray("alternateColors"_s, toJSONStringArray(out_alternateColors));
        protocol_jsonMessage->setString("screenColor"_s, toProtocolString(out_screenColor));
        protocol_jsonMessage->setString("printColor"_s, toProtocolString(out_printColor));
        backendDispatcher()->sendResponse(protocol_requestId, WTFMove(protocol_jsonMessage), false);
    };

    int o_in_databaseId = in_databaseId;
    NSString *o_in_query = in_query;
    [m_delegate executeSQLSyncWithErrorCallback:errorCallback successCallback:successCallback databaseId:o_in_databaseId query:o_in_query];
}

void ObjCInspectorDatabaseBackendDispatcher::executeSQLAsync(long protocol_requestId, int in_databaseId, const String& in_query)
{
    if (![m_delegate respondsToSelector:@selector(executeSQLAsyncWithErrorCallback:successCallback:databaseId:query:)]) {
        backendDispatcher()->reportProtocolError(protocol_requestId, BackendDispatcher::MethodNotFound, "'Database.executeSQLAsync' was not found"_s);
        backendDispatcher()->sendPendingErrors();
        return;
    }

    id errorCallback = ^(NSString *error) {
        backendDispatcher()->reportProtocolError(protocol_requestId, BackendDispatcher::ServerError, error);
        backendDispatcher()->sendPendingErrors();
    };

    id successCallback = ^(NSArray/*<NSString>*/ *out_columnNames, NSString *out_notes, double out_timestamp, RWIProtocolJSONObject *out_values, RWIProtocolJSONObject *out_payload, int out_databaseId, TestProtocolDatabaseError *out_sqlError, TestProtocolDatabasePrimaryColors out_screenColor, NSArray/*<NSString>*/ *out_alternateColors, TestProtocolDatabase(anonymous) out_printColor) {
        auto protocol_jsonMessage = JSON::Object::create();
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(out_columnNames, @"columnNames");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(out_notes, @"notes");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(out_values, @"values");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(out_payload, @"payload");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(out_sqlError, @"sqlError");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(out_alternateColors, @"alternateColors");
        protocol_jsonMessage->setArray("columnNames"_s, toJSONStringArray(out_columnNames));
        protocol_jsonMessage->setString("notes"_s, out_notes);
        protocol_jsonMessage->setDouble("timestamp"_s, out_timestamp);
        protocol_jsonMessage->setObject("values"_s, [out_values toJSONObject]);
        protocol_jsonMessage->setValue("payload"_s, [out_payload toJSONObject]);
        protocol_jsonMessage->setInteger("databaseId"_s, out_databaseId);
        protocol_jsonMessage->setObject("sqlError"_s, [out_sqlError toJSONObject]);
        protocol_jsonMessage->setString("screenColor"_s, toProtocolString(out_screenColor));
        protocol_jsonMessage->setArray("alternateColors"_s, toJSONStringArray(out_alternateColors));
        protocol_jsonMessage->setString("printColor"_s, toProtocolString(out_printColor));
        backendDispatcher()->sendResponse(protocol_requestId, WTFMove(protocol_jsonMessage), false);
    };

    int o_in_databaseId = in_databaseId;
    NSString *o_in_query = in_query;
    [m_delegate executeSQLAsyncWithErrorCallback:errorCallback successCallback:successCallback databaseId:o_in_databaseId query:o_in_query];
}

} // namespace Inspector

### End File: TestProtocolBackendDispatchers.mm

### Begin File: TestProtocolConfiguration.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import <WebInspector/TestProtocol.h>

__attribute__((visibility ("default")))
@interface TestProtocolConfiguration : NSObject
@property (nonatomic, retain, setter=setDatabaseHandler:) id<TestProtocolDatabaseDomainHandler> databaseHandler;
@end


### End File: TestProtocolConfiguration.h

### Begin File: TestProtocolConfiguration.mm
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "TestProtocolConfiguration.h"

#import "TestProtocolInternal.h"
#import "TestProtocolBackendDispatchers.h"
#import <JavaScriptCore/AlternateDispatchableAgent.h>
#import <JavaScriptCore/AugmentableInspectorController.h>
#import <JavaScriptCore/InspectorAlternateBackendDispatchers.h>
#import <JavaScriptCore/InspectorBackendDispatchers.h>

using namespace Inspector;

@implementation TestProtocolConfiguration
{
    AugmentableInspectorController* _controller;
    RetainPtr<id<TestProtocolDatabaseDomainHandler>> _databaseHandler;
}

- (instancetype)initWithController:(AugmentableInspectorController*)controller
{
    self = [super init];
    if (!self)
        return nil;
    ASSERT(controller);
    _controller = controller;
    return self;
}

- (void)setDatabaseHandler:(id<TestProtocolDatabaseDomainHandler>)handler
{
    if (handler == _databaseHandler)
        return;

    _databaseHandler = handler;

    auto alternateDispatcher = makeUnique<ObjCInspectorDatabaseBackendDispatcher>(handler);
    auto alternateAgent = makeUnique<AlternateDispatchableAgent<DatabaseBackendDispatcher, AlternateDatabaseBackendDispatcher>>("Database"_s, *_controller, WTFMove(alternateDispatcher));
    _controller->registerAlternateAgent(WTFMove(alternateAgent));
}

- (id<TestProtocolDatabaseDomainHandler>)databaseHandler
{
    return _databaseHandler.get();
}

@end


### End File: TestProtocolConfiguration.mm

### Begin File: TestProtocolEventDispatchers.mm
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "TestProtocolInternal.h"

#import "TestProtocolTypeConversions.h"
#import <wtf/JSONValues.h>

using namespace Inspector;


### End File: TestProtocolEventDispatchers.mm

### Begin File: TestProtocol.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import <Foundation/Foundation.h>

#import <WebInspector/RWIProtocolJSONObject.h>


@class TestProtocolDatabaseError;

typedef NS_ENUM(NSInteger, TestProtocolDatabasePrimaryColors) {
    TestProtocolDatabasePrimaryColorsRed,
    TestProtocolDatabasePrimaryColorsGreen,
    TestProtocolDatabasePrimaryColorsBlue,
};

typedef NS_ENUM(NSInteger, TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColor) {
    TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorCyan,
    TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorMagenta,
    TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorYellow,
    TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorBlack,
};

typedef NS_ENUM(NSInteger, TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColor) {
    TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorCyan,
    TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorMagenta,
    TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorYellow,
    TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorBlack,
};

typedef NS_ENUM(NSInteger, TestProtocolDatabaseExecuteSQLSyncPrintColor) {
    TestProtocolDatabaseExecuteSQLSyncPrintColorCyan,
    TestProtocolDatabaseExecuteSQLSyncPrintColorMagenta,
    TestProtocolDatabaseExecuteSQLSyncPrintColorYellow,
    TestProtocolDatabaseExecuteSQLSyncPrintColorBlack,
};

typedef NS_ENUM(NSInteger, TestProtocolDatabaseExecuteSQLAsyncPrintColor) {
    TestProtocolDatabaseExecuteSQLAsyncPrintColorCyan,
    TestProtocolDatabaseExecuteSQLAsyncPrintColorMagenta,
    TestProtocolDatabaseExecuteSQLAsyncPrintColorYellow,
    TestProtocolDatabaseExecuteSQLAsyncPrintColorBlack,
};

__attribute__((visibility ("default")))
@interface TestProtocolDatabaseError : RWIProtocolJSONObject
- (instancetype)initWithPayload:(NSDictionary<NSString *, id> *)payload;
- (instancetype)initWithProtocolObject:(RWIProtocolJSONObject *)jsonObject;
- (instancetype)initWithMessage:(NSString *)message code:(int)code;
/* required */ @property (nonatomic, copy) NSString *message;
/* required */ @property (nonatomic, assign) int code;
@end

@protocol TestProtocolDatabaseDomainHandler <NSObject>
@optional
- (void)executeSQLSyncOptionalReturnValuesWithErrorCallback:(void(^)(NSString *error))errorCallback successCallback:(void(^)(NSArray/*<NSString>*/ **columnNames, NSString **notes, double *timestamp, RWIProtocolJSONObject **values, RWIProtocolJSONObject **payload, int *databaseId, TestProtocolDatabaseError **sqlError, TestProtocolDatabasePrimaryColors *screenColor, NSArray/*<NSString>*/ **alternateColors, TestProtocolDatabase(anonymous) *printColor))successCallback databaseId:(int)databaseId query:(NSString *)query;
- (void)executeSQLAsyncOptionalReturnValuesWithErrorCallback:(void(^)(NSString *error))errorCallback successCallback:(void(^)(NSArray/*<NSString>*/ **columnNames, NSString **notes, double *timestamp, RWIProtocolJSONObject **values, RWIProtocolJSONObject **payload, int *databaseId, TestProtocolDatabaseError **sqlError, TestProtocolDatabasePrimaryColors *screenColor, NSArray/*<NSString>*/ **alternateColors, TestProtocolDatabase(anonymous) *printColor))successCallback databaseId:(int)databaseId query:(NSString *)query;
- (void)executeSQLSyncWithErrorCallback:(void(^)(NSString *error))errorCallback successCallback:(void(^)(NSArray/*<NSString>*/ *columnNames, NSString *notes, double timestamp, RWIProtocolJSONObject *values, RWIProtocolJSONObject *payload, int databaseId, TestProtocolDatabaseError *sqlError, NSArray/*<NSString>*/ *alternateColors, TestProtocolDatabasePrimaryColors screenColor, TestProtocolDatabase(anonymous) printColor))successCallback databaseId:(int)databaseId query:(NSString *)query;
- (void)executeSQLAsyncWithErrorCallback:(void(^)(NSString *error))errorCallback successCallback:(void(^)(NSArray/*<NSString>*/ *columnNames, NSString *notes, double timestamp, RWIProtocolJSONObject *values, RWIProtocolJSONObject *payload, int databaseId, TestProtocolDatabaseError *sqlError, TestProtocolDatabasePrimaryColors screenColor, NSArray/*<NSString>*/ *alternateColors, TestProtocolDatabase(anonymous) printColor))successCallback databaseId:(int)databaseId query:(NSString *)query;
@end




#import <WebInspector/RWIProtocolBuildCompatibilityObjects.h>

### End File: TestProtocol.h

### Begin File: TestProtocolInternal.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "TestProtocol.h"
#import "TestProtocolJSONObjectPrivate.h"
#import <JavaScriptCore/AugmentableInspectorController.h>
#import <wtf/JSONValues.h>




### End File: TestProtocolInternal.h

### Begin File: TestProtocolTypeConversions.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "TestProtocol.h"
#import <WebInspector/RWIProtocolArrayConversions.h>

namespace Inspector {

template<typename ObjCEnumType>
std::optional<ObjCEnumType> fromProtocolString(const String& value);

inline String toProtocolString(TestProtocolDatabasePrimaryColors value)
{
    switch(value) {
    case TestProtocolDatabasePrimaryColorsRed:
        return "red"_s;
    case TestProtocolDatabasePrimaryColorsGreen:
        return "green"_s;
    case TestProtocolDatabasePrimaryColorsBlue:
        return "blue"_s;
    }
}

template<>
inline std::optional<TestProtocolDatabasePrimaryColors> fromProtocolString(const String& value)
{
    if (value == "red")
        return TestProtocolDatabasePrimaryColorsRed;
    if (value == "green")
        return TestProtocolDatabasePrimaryColorsGreen;
    if (value == "blue")
        return TestProtocolDatabasePrimaryColorsBlue;
    return std::nullopt;
}

inline String toProtocolString(TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColor value)
{
    switch(value) {
    case TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorCyan:
        return "cyan"_s;
    case TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorMagenta:
        return "magenta"_s;
    case TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorYellow:
        return "yellow"_s;
    case TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorBlack:
        return "black"_s;
    }
}

template<>
inline std::optional<TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColor> fromProtocolString(const String& value)
{
    if (value == "cyan")
        return TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorCyan;
    if (value == "magenta")
        return TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorMagenta;
    if (value == "yellow")
        return TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorYellow;
    if (value == "black")
        return TestProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorBlack;
    return std::nullopt;
}

inline String toProtocolString(TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColor value)
{
    switch(value) {
    case TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorCyan:
        return "cyan"_s;
    case TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorMagenta:
        return "magenta"_s;
    case TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorYellow:
        return "yellow"_s;
    case TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorBlack:
        return "black"_s;
    }
}

template<>
inline std::optional<TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColor> fromProtocolString(const String& value)
{
    if (value == "cyan")
        return TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorCyan;
    if (value == "magenta")
        return TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorMagenta;
    if (value == "yellow")
        return TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorYellow;
    if (value == "black")
        return TestProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorBlack;
    return std::nullopt;
}

inline String toProtocolString(TestProtocolDatabaseExecuteSQLSyncPrintColor value)
{
    switch(value) {
    case TestProtocolDatabaseExecuteSQLSyncPrintColorCyan:
        return "cyan"_s;
    case TestProtocolDatabaseExecuteSQLSyncPrintColorMagenta:
        return "magenta"_s;
    case TestProtocolDatabaseExecuteSQLSyncPrintColorYellow:
        return "yellow"_s;
    case TestProtocolDatabaseExecuteSQLSyncPrintColorBlack:
        return "black"_s;
    }
}

template<>
inline std::optional<TestProtocolDatabaseExecuteSQLSyncPrintColor> fromProtocolString(const String& value)
{
    if (value == "cyan")
        return TestProtocolDatabaseExecuteSQLSyncPrintColorCyan;
    if (value == "magenta")
        return TestProtocolDatabaseExecuteSQLSyncPrintColorMagenta;
    if (value == "yellow")
        return TestProtocolDatabaseExecuteSQLSyncPrintColorYellow;
    if (value == "black")
        return TestProtocolDatabaseExecuteSQLSyncPrintColorBlack;
    return std::nullopt;
}

inline String toProtocolString(TestProtocolDatabaseExecuteSQLAsyncPrintColor value)
{
    switch(value) {
    case TestProtocolDatabaseExecuteSQLAsyncPrintColorCyan:
        return "cyan"_s;
    case TestProtocolDatabaseExecuteSQLAsyncPrintColorMagenta:
        return "magenta"_s;
    case TestProtocolDatabaseExecuteSQLAsyncPrintColorYellow:
        return "yellow"_s;
    case TestProtocolDatabaseExecuteSQLAsyncPrintColorBlack:
        return "black"_s;
    }
}

template<>
inline std::optional<TestProtocolDatabaseExecuteSQLAsyncPrintColor> fromProtocolString(const String& value)
{
    if (value == "cyan")
        return TestProtocolDatabaseExecuteSQLAsyncPrintColorCyan;
    if (value == "magenta")
        return TestProtocolDatabaseExecuteSQLAsyncPrintColorMagenta;
    if (value == "yellow")
        return TestProtocolDatabaseExecuteSQLAsyncPrintColorYellow;
    if (value == "black")
        return TestProtocolDatabaseExecuteSQLAsyncPrintColorBlack;
    return std::nullopt;
}

} // namespace Inspector

### End File: TestProtocolTypeConversions.h

### Begin File: TestProtocolTypeConversions.mm
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "TestProtocolTypeConversions.h"

#import "TestProtocol.h"
#import "TestProtocolTypeParser.h"
#import <WebInspector/RWIProtocolJSONObjectPrivate.h>

using namespace Inspector;

@interface TestProtocolTypeConversions (DatabaseDomain)

+ (void)_parseDatabaseId:(NSNumber **)outValue fromPayload:(id)payload;
+ (void)_parsePrimaryColors:(NSNumber **)outValue fromPayload:(id)payload;
+ (void)_parseColorList:(NSArray/*<NSString>*/ **)outValue fromPayload:(id)payload;
+ (void)_parseError:(TestProtocolDatabaseError **)outValue fromPayload:(id)payload;

@end

@implementation TestProtocolTypeConversions (DatabaseDomain)

+ (void)_parseDatabaseId:(NSNumber **)outValue fromPayload:(id)payload
{
    THROW_EXCEPTION_FOR_BAD_TYPE(payload, [NSNumber class]);
    *outValue = (NSNumber *)payload;
}

+ (void)_parsePrimaryColors:(NSNumber **)outValue fromPayload:(id)payload
{
    THROW_EXCEPTION_FOR_BAD_TYPE(payload, [NSString class]);
    auto result = Inspector::fromProtocolString<TestProtocolDatabasePrimaryColors>((__bridge CFStringRef)payload);
    THROW_EXCEPTION_FOR_BAD_ENUM_VALUE(result, @"PrimaryColors");
    *outValue = @(result.value());
}

+ (void)_parseColorList:(NSArray/*<NSString>*/ **)outValue fromPayload:(id)payload
{
    THROW_EXCEPTION_FOR_BAD_TYPE(payload, [NSArray/*<NSString>*/ class]);
    *outValue = (NSArray/*<NSString>*/ *)payload;
}

+ (void)_parseError:(TestProtocolDatabaseError **)outValue fromPayload:(id)payload
{
    THROW_EXCEPTION_FOR_BAD_TYPE(payload, [NSDictionary class]);
    *outValue = [[TestProtocolDatabaseError alloc] initWithPayload:payload];
}

@end


### End File: TestProtocolTypeConversions.mm

### Begin File: TestProtocolTypes.mm
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "TestProtocolInternal.h"

#import "TestProtocolTypeConversions.h"
#import <WebInspector/RWIProtocolJSONObjectPrivate.h>
#import <wtf/Assertions.h>
#import <wtf/JSONValues.h>

using namespace Inspector;

@implementation TestProtocolDatabaseError

- (instancetype)initWithPayload:(nonnull NSDictionary<NSString *, id> *)payload
{
    if (!(self = [super init]))
        return nil;

    THROW_EXCEPTION_FOR_REQUIRED_PROPERTY(payload[@"message"], @"message");
    self.message = payload[@"message"];

    THROW_EXCEPTION_FOR_REQUIRED_PROPERTY(payload[@"code"], @"code");
    self.code = [payload[@"code"] integerValue];

    return self;
}
- (instancetype)initWithProtocolObject:(RWIProtocolJSONObject *)object
{
    if (!(self = [super initWithJSONObject:[object toJSONObject].get()]))
        return nil;

    return self;
}

- (instancetype)initWithMessage:(NSString *)message code:(int)code
{
    if (!(self = [super init]))
        return nil;

    THROW_EXCEPTION_FOR_REQUIRED_PROPERTY(message, @"message");

    self.message = message;
    self.code = code;

    return self;
}

- (void)setMessage:(NSString *)message
{
    [super setString:message forKey:@"message"];
}

- (NSString *)message
{
    return [super stringForKey:@"message"];
}

- (void)setCode:(int)code
{
    [super setInteger:code forKey:@"code"];
}

- (int)code
{
    return [super integerForKey:@"code"];
}

@end


### End File: TestProtocolTypes.mm
