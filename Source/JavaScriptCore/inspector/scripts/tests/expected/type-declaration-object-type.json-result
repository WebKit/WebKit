### Begin File: InspectorTestBackendCommands.js
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from type-declaration-object-type.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py
### End File: InspectorTestBackendCommands.js

### Begin File: InspectorTestBackendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from type-declaration-object-type.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#ifndef InspectorTestBackendDispatchers_h
#define InspectorTestBackendDispatchers_h

#if ENABLE(INSPECTOR)

#include "InspectorTestProtocolTypes.h"
#include <inspector/InspectorBackendDispatcher.h>
#include <wtf/PassRefPtr.h>
#include <wtf/text/WTFString.h>

namespace Inspector {

typedef String ErrorString;

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

#endif // !defined(InspectorTestBackendDispatchers_h)
### End File: InspectorTestBackendDispatchers.h

### Begin File: InspectorTestBackendDispatchers.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from type-declaration-object-type.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "InspectorTestBackendDispatchers.h"

#if ENABLE(INSPECTOR)

#include <inspector/InspectorFrontendChannel.h>
#include <inspector/InspectorValues.h>
#include <wtf/text/CString.h>

namespace Inspector {



} // namespace Inspector

#endif // ENABLE(INSPECTOR)

### End File: InspectorTestBackendDispatchers.cpp

### Begin File: InspectorTestFrontendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from type-declaration-object-type.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#ifndef InspectorTestFrontendDispatchers_h
#define InspectorTestFrontendDispatchers_h

#if ENABLE(INSPECTOR)

#include "InspectorTestProtocolTypes.h"
#include <inspector/InspectorFrontendChannel.h>
#include <inspector/InspectorValues.h>
#include <wtf/PassRefPtr.h>
#include <wtf/text/WTFString.h>

namespace Inspector {



} // namespace Inspector

#endif // ENABLE(INSPECTOR)

#endif // !defined(InspectorTestFrontendDispatchers_h)
### End File: InspectorTestFrontendDispatchers.h

### Begin File: InspectorTestFrontendDispatchers.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from type-declaration-object-type.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "InspectorTestFrontendDispatchers.h"

#if ENABLE(INSPECTOR)

#include <wtf/text/CString.h>

namespace Inspector {

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

### End File: InspectorTestFrontendDispatchers.cpp

### Begin File: InspectorTestProtocolTypes.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from type-declaration-object-type.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#ifndef InspectorTestProtocolTypes_h
#define InspectorTestProtocolTypes_h

#if ENABLE(INSPECTOR)

#include <inspector/InspectorJSProtocolTypes.h>
#include <inspector/InspectorProtocolTypes.h>
#include <wtf/Assertions.h>
#include <wtf/PassRefPtr.h>

namespace Inspector {



namespace Protocol {

// Forward declarations.
namespace Database {
class DummyObject;
class Error;
class ObjectWithPropertyNameConflicts;
class OptionalParameterBundle;
class ParameterBundle;
} // Database

namespace Test {
class ParameterBundle;
} // Test
// End of forward declarations.




String getTestEnumConstantValue(int code);

template<typename T> String getTestEnumConstantValue(T enumValue)
{
    return getTestEnumConstantValue(static_cast<int>(enumValue));
}

namespace Database {
/* Database error. */
class Error : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        MessageSet = 1 << 0,
        CodeSet = 1 << 1,
        AllFieldsSet = (MessageSet | CodeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Error*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Error;
    public:

        Builder<STATE | MessageSet>& setMessage(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MessageSet), property_message_already_set);
            m_result->setString(ASCIILiteral("message"), value);
            return castState<MessageSet>();
        }

        Builder<STATE | CodeSet>& setCode(int value)
        {
            COMPILE_ASSERT(!(STATE & CodeSet), property_code_already_set);
            m_result->setInteger(ASCIILiteral("code"), value);
            return castState<CodeSet>();
        }

        operator RefPtr<Error>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Error) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Error>*>(&m_result);
        }

        PassRefPtr<Error> release()
        {
            return RefPtr<Error>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Error> result = Error::create()
     *     .setMessage(...)
     *     .setCode(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::Protocol::StructItemTraits ItemTraits;
};

class OptionalParameterBundle : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*OptionalParameterBundle*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class OptionalParameterBundle;
    public:

        operator RefPtr<OptionalParameterBundle>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(OptionalParameterBundle) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<OptionalParameterBundle>*>(&m_result);
        }

        PassRefPtr<OptionalParameterBundle> release()
        {
            return RefPtr<OptionalParameterBundle>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<OptionalParameterBundle> result = OptionalParameterBundle::create();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::Protocol::StructItemTraits ItemTraits;

    void setColumnNames(PassRefPtr<Inspector::Protocol::Array<String>> value)
    {
        InspectorObjectBase::setArray(ASCIILiteral("columnNames"), value);
    }

    void setNotes(const String& value)
    {
        InspectorObjectBase::setString(ASCIILiteral("notes"), value);
    }

    void setTimestamp(double value)
    {
        InspectorObjectBase::setDouble(ASCIILiteral("timestamp"), value);
    }

    void setValues(PassRefPtr<Inspector::InspectorObject> value)
    {
        InspectorObjectBase::setObject(ASCIILiteral("values"), value);
    }

    void setPayload(PassRefPtr<Inspector::InspectorValue> value)
    {
        InspectorObjectBase::setValue(ASCIILiteral("payload"), value);
    }

    void setError(PassRefPtr<Inspector::Protocol::Database::Error> value)
    {
        InspectorObjectBase::setObject(ASCIILiteral("error"), value);
    }
};

class ParameterBundle : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ColumnNamesSet = 1 << 0,
        NotesSet = 1 << 1,
        TimestampSet = 1 << 2,
        ValuesSet = 1 << 3,
        PayloadSet = 1 << 4,
        ErrorSet = 1 << 5,
        AllFieldsSet = (ColumnNamesSet | NotesSet | TimestampSet | ValuesSet | PayloadSet | ErrorSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ParameterBundle*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ParameterBundle;
    public:

        Builder<STATE | ColumnNamesSet>& setColumnNames(PassRefPtr<Inspector::Protocol::Array<String>> value)
        {
            COMPILE_ASSERT(!(STATE & ColumnNamesSet), property_columnNames_already_set);
            m_result->setArray(ASCIILiteral("columnNames"), value);
            return castState<ColumnNamesSet>();
        }

        Builder<STATE | NotesSet>& setNotes(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NotesSet), property_notes_already_set);
            m_result->setString(ASCIILiteral("notes"), value);
            return castState<NotesSet>();
        }

        Builder<STATE | TimestampSet>& setTimestamp(double value)
        {
            COMPILE_ASSERT(!(STATE & TimestampSet), property_timestamp_already_set);
            m_result->setDouble(ASCIILiteral("timestamp"), value);
            return castState<TimestampSet>();
        }

        Builder<STATE | ValuesSet>& setValues(PassRefPtr<Inspector::InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & ValuesSet), property_values_already_set);
            m_result->setObject(ASCIILiteral("values"), value);
            return castState<ValuesSet>();
        }

        Builder<STATE | PayloadSet>& setPayload(PassRefPtr<Inspector::InspectorValue> value)
        {
            COMPILE_ASSERT(!(STATE & PayloadSet), property_payload_already_set);
            m_result->setValue(ASCIILiteral("payload"), value);
            return castState<PayloadSet>();
        }

        Builder<STATE | ErrorSet>& setError(PassRefPtr<Inspector::Protocol::Database::Error> value)
        {
            COMPILE_ASSERT(!(STATE & ErrorSet), property_error_already_set);
            m_result->setObject(ASCIILiteral("error"), value);
            return castState<ErrorSet>();
        }

        operator RefPtr<ParameterBundle>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ParameterBundle) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<ParameterBundle>*>(&m_result);
        }

        PassRefPtr<ParameterBundle> release()
        {
            return RefPtr<ParameterBundle>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ParameterBundle> result = ParameterBundle::create()
     *     .setColumnNames(...)
     *     .setNotes(...)
     *     .setTimestamp(...)
     *     .setValues(...)
     *     .setPayload(...)
     *     .setError(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::Protocol::StructItemTraits ItemTraits;
};

/* Conflicted names may cause generated getters/setters to clash with built-in InspectorObject methods. */
class ObjectWithPropertyNameConflicts : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IntegerSet = 1 << 0,
        ArraySet = 1 << 1,
        StringSet = 1 << 2,
        ValueSet = 1 << 3,
        ObjectSet = 1 << 4,
        AllFieldsSet = (IntegerSet | ArraySet | StringSet | ValueSet | ObjectSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ObjectWithPropertyNameConflicts*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ObjectWithPropertyNameConflicts;
    public:

        Builder<STATE | IntegerSet>& setInteger(const String& value)
        {
            COMPILE_ASSERT(!(STATE & IntegerSet), property_integer_already_set);
            m_result->setString(ASCIILiteral("integer"), value);
            return castState<IntegerSet>();
        }

        Builder<STATE | ArraySet>& setArray(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ArraySet), property_array_already_set);
            m_result->setString(ASCIILiteral("array"), value);
            return castState<ArraySet>();
        }

        Builder<STATE | StringSet>& setString(const String& value)
        {
            COMPILE_ASSERT(!(STATE & StringSet), property_string_already_set);
            m_result->setString(ASCIILiteral("string"), value);
            return castState<StringSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString(ASCIILiteral("value"), value);
            return castState<ValueSet>();
        }

        Builder<STATE | ObjectSet>& setObject(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ObjectSet), property_object_already_set);
            m_result->setString(ASCIILiteral("object"), value);
            return castState<ObjectSet>();
        }

        operator RefPtr<ObjectWithPropertyNameConflicts>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ObjectWithPropertyNameConflicts) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<ObjectWithPropertyNameConflicts>*>(&m_result);
        }

        PassRefPtr<ObjectWithPropertyNameConflicts> release()
        {
            return RefPtr<ObjectWithPropertyNameConflicts>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ObjectWithPropertyNameConflicts> result = ObjectWithPropertyNameConflicts::create()
     *     .setInteger(...)
     *     .setArray(...)
     *     .setString(...)
     *     .setValue(...)
     *     .setObject(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::Protocol::StructItemTraits ItemTraits;
};

} // Database

namespace Test {
class ParameterBundle : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ColumnNamesSet = 1 << 0,
        NotesSet = 1 << 1,
        TimestampSet = 1 << 2,
        ValuesSet = 1 << 3,
        PayloadSet = 1 << 4,
        ErrorSet = 1 << 5,
        AllFieldsSet = (ColumnNamesSet | NotesSet | TimestampSet | ValuesSet | PayloadSet | ErrorSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*ParameterBundle*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ParameterBundle;
    public:

        Builder<STATE | ColumnNamesSet>& setColumnNames(PassRefPtr<Inspector::Protocol::Array<String>> value)
        {
            COMPILE_ASSERT(!(STATE & ColumnNamesSet), property_columnNames_already_set);
            m_result->setArray(ASCIILiteral("columnNames"), value);
            return castState<ColumnNamesSet>();
        }

        Builder<STATE | NotesSet>& setNotes(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NotesSet), property_notes_already_set);
            m_result->setString(ASCIILiteral("notes"), value);
            return castState<NotesSet>();
        }

        Builder<STATE | TimestampSet>& setTimestamp(double value)
        {
            COMPILE_ASSERT(!(STATE & TimestampSet), property_timestamp_already_set);
            m_result->setDouble(ASCIILiteral("timestamp"), value);
            return castState<TimestampSet>();
        }

        Builder<STATE | ValuesSet>& setValues(PassRefPtr<Inspector::InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & ValuesSet), property_values_already_set);
            m_result->setObject(ASCIILiteral("values"), value);
            return castState<ValuesSet>();
        }

        Builder<STATE | PayloadSet>& setPayload(PassRefPtr<Inspector::InspectorValue> value)
        {
            COMPILE_ASSERT(!(STATE & PayloadSet), property_payload_already_set);
            m_result->setValue(ASCIILiteral("payload"), value);
            return castState<PayloadSet>();
        }

        Builder<STATE | ErrorSet>& setError(PassRefPtr<Inspector::Protocol::Database::Error> value)
        {
            COMPILE_ASSERT(!(STATE & ErrorSet), property_error_already_set);
            m_result->setObject(ASCIILiteral("error"), value);
            return castState<ErrorSet>();
        }

        operator RefPtr<ParameterBundle>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ParameterBundle) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<ParameterBundle>*>(&m_result);
        }

        PassRefPtr<ParameterBundle> release()
        {
            return RefPtr<ParameterBundle>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ParameterBundle> result = ParameterBundle::create()
     *     .setColumnNames(...)
     *     .setNotes(...)
     *     .setTimestamp(...)
     *     .setValues(...)
     *     .setPayload(...)
     *     .setError(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::Protocol::StructItemTraits ItemTraits;
};

} // Test



} // namespace Protocol

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

#endif // !defined(InspectorTestProtocolTypes_h)
### End File: InspectorTestProtocolTypes.h

### Begin File: InspectorTestProtocolTypes.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from type-declaration-object-type.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "InspectorTestProtocolTypes.h"

#if ENABLE(INSPECTOR)

#include <wtf/text/CString.h>

namespace Inspector {

namespace Protocol {

static const char* const enum_constant_values[] = {
};

String getTestEnumConstantValue(int code) {
    return enum_constant_values[code];
}



} // namespace Protocol

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

### End File: InspectorTestProtocolTypes.cpp
