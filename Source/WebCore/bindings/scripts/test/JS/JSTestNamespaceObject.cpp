/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"
#include "JSTestNamespaceObject.h"

#include "ActiveDOMObject.h"
#include "DOMIsoSubspaces.h"
#include "JSDOMAttribute.h"
#include "JSDOMBinding.h"
#include "JSDOMConstructorNotCallable.h"
#include "JSDOMConvertAny.h"
#include "JSDOMConvertBoolean.h"
#include "JSDOMConvertInterface.h"
#include "JSDOMConvertNullable.h"
#include "JSDOMConvertNumbers.h"
#include "JSDOMConvertStrings.h"
#include "JSDOMExceptionHandling.h"
#include "JSDOMGlobalObjectInlines.h"
#include "JSDOMOperation.h"
#include "JSDOMWrapperCache.h"
#include "JSTestObj.h"
#include "ScriptExecutionContext.h"
#include "TestNamespaceObject.h"
#include "WebCoreJSClientData.h"
#include <JavaScriptCore/JSCInlines.h>
#include <JavaScriptCore/JSDestructibleObjectHeapCellType.h>
#include <JavaScriptCore/ObjectPrototype.h>
#include <JavaScriptCore/SlotVisitorMacros.h>
#include <JavaScriptCore/SubspaceInlines.h>
#include <wtf/GetPtr.h>
#include <wtf/PointerPreparations.h>

#if ENABLE(Condition1)
#include "IDLTypes.h"
#include "JSDOMConvertBase.h"
#include "TestNamespaceObjectImpl.h"
#endif


namespace WebCore {
using namespace JSC;

// Functions

static JSC_DECLARE_HOST_FUNCTION(jsTestNamespaceObjectConstructorFunction_overloadedNamespaceOperation);
static JSC_DECLARE_HOST_FUNCTION(jsTestNamespaceObjectConstructorFunction_enabledBySettingNamespaceOperation);
#if ENABLE(Condition1)
static JSC_DECLARE_HOST_FUNCTION(jsTestNamespaceObjectConstructorFunction_namespaceOperationFromPartial);
#endif

// Attributes

static JSC_DECLARE_CUSTOM_GETTER(jsTestNamespaceObjectConstructor_namespaceAttribute);
#if ENABLE(Condition1)
static JSC_DECLARE_CUSTOM_GETTER(jsTestNamespaceObjectConstructor_namespaceAttributeFromPartial);
#endif

using JSTestNamespaceObjectDOMConstructor = JSDOMConstructorNotCallable<JSTestNamespaceObject>;

#if ENABLE(Condition1)
static JSValue createJSTestNamespaceObjectConstructor_namespaceAttributeFromPartial(VM& vm, JSObject*)
{
    return CustomGetterSetter::create(vm, jsTestNamespaceObjectConstructor_namespaceAttributeFromPartial, nullptr);
}

static bool isEnabledJSTestNamespaceObjectConstructor_namespaceAttributeFromPartial(JSGlobalObject* globalObject)
{
    UNUSED_PARAM(globalObject);
    return jsCast<JSDOMGlobalObject*>(globalObject)->scriptExecutionContext()->settingsValues().testSetting1Enabled;
}
#endif

static JSValue createJSTestNamespaceObjectConstructor_enabledBySettingNamespaceOperation(VM& vm, JSObject* thisObject)
{
    return JSFunction::create(vm, thisObject->globalObject(), 0, "enabledBySettingNamespaceOperation"_s, jsTestNamespaceObjectConstructorFunction_enabledBySettingNamespaceOperation);
}

static bool isEnabledJSTestNamespaceObjectConstructor_enabledBySettingNamespaceOperation(JSGlobalObject* globalObject)
{
    UNUSED_PARAM(globalObject);
    return jsCast<JSDOMGlobalObject*>(globalObject)->scriptExecutionContext()->settingsValues().testSetting2Enabled;
}

#if ENABLE(Condition1)
static JSValue createJSTestNamespaceObjectConstructor_namespaceOperationFromPartial(VM& vm, JSObject* thisObject)
{
    return JSFunction::create(vm, thisObject->globalObject(), 0, "namespaceOperationFromPartial"_s, jsTestNamespaceObjectConstructorFunction_namespaceOperationFromPartial);
}

static bool isEnabledJSTestNamespaceObjectConstructor_namespaceOperationFromPartial(JSGlobalObject* globalObject)
{
    UNUSED_PARAM(globalObject);
    return jsCast<JSDOMGlobalObject*>(globalObject)->scriptExecutionContext()->settingsValues().testSetting1Enabled;
}
#endif

/* Hash table for Constructor */

static const struct CompactHashIndex JSTestNamespaceObjectConstructorTableIndex[17] = {
    { -1, -1 },
    { -1, -1 },
    { 1, -1 },
    { -1, -1 },
    { 3, 16 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 2, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 0, -1 },
    { 4, -1 },
};


static const HashTableValue JSTestNamespaceObjectConstructorTableValues[] =
{
    { "namespaceAttribute", JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsTestNamespaceObjectConstructor_namespaceAttribute), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(nullptr) } },
#if ENABLE(Condition1)
    { "namespaceAttributeFromPartial", JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::PropertyCallback, NoIntrinsic, { (intptr_t)static_cast<LazyPropertyCallback>(createJSTestNamespaceObjectConstructor_namespaceAttributeFromPartial), (intptr_t) static_cast<IsLazyPropertyEnabledCallback>(isEnabledJSTestNamespaceObjectConstructor_namespaceAttributeFromPartial) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "overloadedNamespaceOperation", static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t)static_cast<RawNativeFunction>(jsTestNamespaceObjectConstructorFunction_overloadedNamespaceOperation), (intptr_t) (1) } },
    { "enabledBySettingNamespaceOperation", static_cast<unsigned>(JSC::PropertyAttribute::PropertyCallback), NoIntrinsic, { (intptr_t)static_cast<LazyPropertyCallback>(createJSTestNamespaceObjectConstructor_enabledBySettingNamespaceOperation), (intptr_t) static_cast<IsLazyPropertyEnabledCallback>(isEnabledJSTestNamespaceObjectConstructor_enabledBySettingNamespaceOperation) } },
#if ENABLE(Condition1)
    { "namespaceOperationFromPartial", static_cast<unsigned>(JSC::PropertyAttribute::PropertyCallback), NoIntrinsic, { (intptr_t)static_cast<LazyPropertyCallback>(createJSTestNamespaceObjectConstructor_namespaceOperationFromPartial), (intptr_t) static_cast<IsLazyPropertyEnabledCallback>(isEnabledJSTestNamespaceObjectConstructor_namespaceOperationFromPartial) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
};

static const HashTable JSTestNamespaceObjectConstructorTable = { 5, 15, true, nullptr, JSTestNamespaceObjectConstructorTableValues, JSTestNamespaceObjectConstructorTableIndex };
template<> const unsigned JSTestNamespaceObjectDOMConstructor::StructureFlags = Base::StructureFlags | JSC::HasStaticPropertyTable;
template<> const ClassInfo JSTestNamespaceObjectDOMConstructor::s_info = { "TestInterfaceName", &Base::s_info, &JSTestNamespaceObjectConstructorTable, nullptr, CREATE_METHOD_TABLE(JSTestNamespaceObjectDOMConstructor) };

template<> JSValue JSTestNamespaceObjectDOMConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
{
    UNUSED_PARAM(vm);
    return globalObject.objectPrototype();
}

template<> void JSTestNamespaceObjectDOMConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
{
    UNUSED_PARAM(globalObject);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
    reifyStaticProperties(vm, nullptr, JSTestNamespaceObjectConstructorTableValues, *this);
}

const ClassInfo JSTestNamespaceObject::s_info = { "TestInterfaceName", &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTestNamespaceObject) };

JSTestNamespaceObject::JSTestNamespaceObject(Structure* structure, JSDOMGlobalObject& globalObject)
    : JSDOMObject(structure, globalObject) { }

void JSTestNamespaceObject::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(vm, info()));

    static_assert(!std::is_base_of<ActiveDOMObject, TestNamespaceObject>::value, "Interface is not marked as [ActiveDOMObject] even though implementation class subclasses ActiveDOMObject.");

}

JSValue JSTestNamespaceObject::getConstructor(VM& vm, const JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSTestNamespaceObjectDOMConstructor, DOMConstructorID::TestNamespaceObject>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
}

void JSTestNamespaceObject::destroy(JSC::JSCell* cell)
{
    JSTestNamespaceObject* thisObject = static_cast<JSTestNamespaceObject*>(cell);
    thisObject->JSTestNamespaceObject::~JSTestNamespaceObject();
}

static inline JSValue jsTestNamespaceObjectConstructor_namespaceAttributeGetter(JSGlobalObject& lexicalGlobalObject)
{
    auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    RELEASE_AND_RETURN(throwScope, (toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, TestNamespaceObject::namespaceAttribute())));
}

JSC_DEFINE_CUSTOM_GETTER(jsTestNamespaceObjectConstructor_namespaceAttribute, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSTestNamespaceObject>::getStatic<jsTestNamespaceObjectConstructor_namespaceAttributeGetter>(*lexicalGlobalObject, thisValue, attributeName);
}

#if ENABLE(Condition1)
static inline JSValue jsTestNamespaceObjectConstructor_namespaceAttributeFromPartialGetter(JSGlobalObject& lexicalGlobalObject)
{
    auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    RELEASE_AND_RETURN(throwScope, (toJS<IDLDouble>(lexicalGlobalObject, throwScope, WebCore::TestNamespaceObjectImpl::namespaceAttributeFromPartial())));
}

JSC_DEFINE_CUSTOM_GETTER(jsTestNamespaceObjectConstructor_namespaceAttributeFromPartial, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSTestNamespaceObject>::getStatic<jsTestNamespaceObjectConstructor_namespaceAttributeFromPartialGetter>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

static inline JSC::EncodedJSValue jsTestNamespaceObjectConstructorFunction_overloadedNamespaceOperation1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto objArg = convert<IDLNullable<IDLInterface<TestObj>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "objArg", "TestInterfaceName", "overloadedNamespaceOperation", "TestObj"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto strArg = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, TestNamespaceObject::overloadedNamespaceOperation(WTFMove(objArg), WTFMove(strArg)))));
}

static inline JSC::EncodedJSValue jsTestNamespaceObjectConstructorFunction_overloadedNamespaceOperation2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto objArg = convert<IDLNullable<IDLInterface<TestObj>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "objArg", "TestInterfaceName", "overloadedNamespaceOperation", "TestObj"); });
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    EnsureStillAliveScope argument1 = callFrame->argument(1);
    auto longArg = argument1.value().isUndefined() ? std::optional<Converter<IDLLong>::ReturnType>() : std::optional<Converter<IDLLong>::ReturnType>(convert<IDLLong>(*lexicalGlobalObject, argument1.value()));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, TestNamespaceObject::overloadedNamespaceOperation(WTFMove(objArg), WTFMove(longArg)))));
}

static inline JSC::EncodedJSValue jsTestNamespaceObjectConstructorFunction_overloadedNamespaceOperationOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(2, callFrame->argumentCount());
    if (argsCount == 1) {
        RELEASE_AND_RETURN(throwScope, (jsTestNamespaceObjectConstructorFunction_overloadedNamespaceOperation2Body(lexicalGlobalObject, callFrame)));
    }
    if (argsCount == 2) {
        JSValue distinguishingArg = callFrame->uncheckedArgument(1);
        if (distinguishingArg.isUndefined())
            RELEASE_AND_RETURN(throwScope, (jsTestNamespaceObjectConstructorFunction_overloadedNamespaceOperation2Body(lexicalGlobalObject, callFrame)));
        if (distinguishingArg.isNumber())
            RELEASE_AND_RETURN(throwScope, (jsTestNamespaceObjectConstructorFunction_overloadedNamespaceOperation2Body(lexicalGlobalObject, callFrame)));
        RELEASE_AND_RETURN(throwScope, (jsTestNamespaceObjectConstructorFunction_overloadedNamespaceOperation1Body(lexicalGlobalObject, callFrame)));
    }
    return argsCount < 1 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsTestNamespaceObjectConstructorFunction_overloadedNamespaceOperation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSTestNamespaceObject>::callStatic<jsTestNamespaceObjectConstructorFunction_overloadedNamespaceOperationOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "overloadedNamespaceOperation");
}

static inline JSC::EncodedJSValue jsTestNamespaceObjectConstructorFunction_enabledBySettingNamespaceOperationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto arg = convert<IDLAny>(*lexicalGlobalObject, argument0.value());
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, TestNamespaceObject::enabledBySettingNamespaceOperation(WTFMove(arg)))));
}

JSC_DEFINE_HOST_FUNCTION(jsTestNamespaceObjectConstructorFunction_enabledBySettingNamespaceOperation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSTestNamespaceObject>::callStatic<jsTestNamespaceObjectConstructorFunction_enabledBySettingNamespaceOperationBody>(*lexicalGlobalObject, *callFrame, "enabledBySettingNamespaceOperation");
}

#if ENABLE(Condition1)
static inline JSC::EncodedJSValue jsTestNamespaceObjectConstructorFunction_namespaceOperationFromPartialBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return WebCore::TestNamespaceObjectImpl::operationFromPartialImpl(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsTestNamespaceObjectConstructorFunction_namespaceOperationFromPartial, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSTestNamespaceObject>::callStatic<jsTestNamespaceObjectConstructorFunction_namespaceOperationFromPartialBody>(*lexicalGlobalObject, *callFrame, "namespaceOperationFromPartial");
}

#endif

JSC::IsoSubspace* JSTestNamespaceObject::subspaceForImpl(JSC::VM& vm)
{
    auto& clientData = *static_cast<JSVMClientData*>(vm.clientData);
    auto& spaces = clientData.subspaces();
    if (auto* space = spaces.m_subspaceForTestNamespaceObject.get())
        return space;
    static_assert(std::is_base_of_v<JSC::JSDestructibleObject, JSTestNamespaceObject> || !JSTestNamespaceObject::needsDestruction);
    if constexpr (std::is_base_of_v<JSC::JSDestructibleObject, JSTestNamespaceObject>)
        spaces.m_subspaceForTestNamespaceObject = makeUnique<IsoSubspace> ISO_SUBSPACE_INIT(vm.heap, vm.destructibleObjectHeapCellType.get(), JSTestNamespaceObject);
    else
        spaces.m_subspaceForTestNamespaceObject = makeUnique<IsoSubspace> ISO_SUBSPACE_INIT(vm.heap, vm.cellHeapCellType.get(), JSTestNamespaceObject);
    auto* space = spaces.m_subspaceForTestNamespaceObject.get();
IGNORE_WARNINGS_BEGIN("unreachable-code")
IGNORE_WARNINGS_BEGIN("tautological-compare")
    void (*myVisitOutputConstraint)(JSC::JSCell*, JSC::SlotVisitor&) = JSTestNamespaceObject::visitOutputConstraints;
    void (*jsCellVisitOutputConstraint)(JSC::JSCell*, JSC::SlotVisitor&) = JSC::JSCell::visitOutputConstraints;
    if (myVisitOutputConstraint != jsCellVisitOutputConstraint)
        clientData.outputConstraintSpaces().append(space);
IGNORE_WARNINGS_END
IGNORE_WARNINGS_END
    return space;
}


}
