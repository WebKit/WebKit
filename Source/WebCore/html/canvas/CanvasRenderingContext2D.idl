/*
 * Copyright (C) 2006 Apple Computer, Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

enum CanvasWindingRule { "nonzero", "evenodd" };

interface CanvasRenderingContext2D : CanvasRenderingContext {

    void save();
    void restore();

    void scale([Default=Undefined] optional float sx,
               [Default=Undefined] optional float sy);
    void rotate([Default=Undefined] optional float angle);
    void translate([Default=Undefined] optional float tx,
                   [Default=Undefined] optional float ty);
    void transform([Default=Undefined] optional float m11,
                   [Default=Undefined] optional float m12,
                   [Default=Undefined] optional float m21,
                   [Default=Undefined] optional float m22,
                   [Default=Undefined] optional float dx,
                   [Default=Undefined] optional float dy);
    void setTransform([Default=Undefined] optional float m11,
                      [Default=Undefined] optional float m12,
                      [Default=Undefined] optional float m21,
                      [Default=Undefined] optional float m22,
                      [Default=Undefined] optional float dx,
                      [Default=Undefined] optional float dy);

    attribute float globalAlpha;
    [TreatNullAs=NullString] attribute DOMString globalCompositeOperation;

    CanvasGradient createLinearGradient([Default=Undefined] optional float x0,
                                        [Default=Undefined] optional float y0,
                                        [Default=Undefined] optional float x1,
                                        [Default=Undefined] optional float y1)
        raises (DOMException);
    CanvasGradient createRadialGradient([Default=Undefined] optional float x0,
                                        [Default=Undefined] optional float y0,
                                        [Default=Undefined] optional float r0,
                                        [Default=Undefined] optional float x1,
                                        [Default=Undefined] optional float y1,
                                        [Default=Undefined] optional float r1)
        raises (DOMException);

    attribute float lineWidth;
    [TreatNullAs=NullString] attribute DOMString lineCap;
    [TreatNullAs=NullString] attribute DOMString lineJoin;
    attribute float miterLimit;

    attribute float shadowOffsetX;
    attribute float shadowOffsetY;
    attribute float shadowBlur;
    [TreatNullAs=NullString] attribute DOMString shadowColor;

    void setLineDash(sequence<float> dash);
    sequence<float> getLineDash();
    attribute float lineDashOffset;

    [Custom] attribute Array webkitLineDash;
    attribute float webkitLineDashOffset;

    void clearRect([Default=Undefined] optional float x,
                   [Default=Undefined] optional float y,
                   [Default=Undefined] optional float width,
                   [Default=Undefined] optional float height);
    void fillRect([Default=Undefined] optional float x,
                  [Default=Undefined] optional float y,
                  [Default=Undefined] optional float width,
                  [Default=Undefined] optional float height);

    void beginPath();

#if defined(ENABLE_CANVAS_PATH) && ENABLE_CANVAS_PATH
    attribute DOMPath currentPath;
#endif

    // FIXME: These methods should be shared with CanvasRenderingContext2D in the CanvasPathMethods interface.
    void closePath();
    void moveTo([Default=Undefined] optional float x,
                [Default=Undefined] optional float y);
    void lineTo([Default=Undefined] optional float x,
                [Default=Undefined] optional float y);
    void quadraticCurveTo([Default=Undefined] optional float cpx,
                          [Default=Undefined] optional float cpy,
                          [Default=Undefined] optional float x,
                          [Default=Undefined] optional float y);
    void bezierCurveTo([Default=Undefined] optional float cp1x,
                       [Default=Undefined] optional float cp1y,
                       [Default=Undefined] optional float cp2x,
                       [Default=Undefined] optional float cp2y,
                       [Default=Undefined] optional float x,
                       [Default=Undefined] optional float y);
    void arcTo([Default=Undefined] optional float x1,
               [Default=Undefined] optional float y1,
               [Default=Undefined] optional float x2,
               [Default=Undefined] optional float y2,
               [Default=Undefined] optional float radius)
        raises (DOMException);
    void rect([Default=Undefined] optional float x,
              [Default=Undefined] optional float y,
              [Default=Undefined] optional float width,
              [Default=Undefined] optional float height);
    void arc([Default=Undefined] optional float x,
             [Default=Undefined] optional float y,
             [Default=Undefined] optional float radius,
             [Default=Undefined] optional float startAngle,
             [Default=Undefined] optional float endAngle,
             [Default=Undefined] optional boolean anticlockwise)
        raises (DOMException);

    void fill(optional CanvasWindingRule winding);
    void stroke();
    void clip(optional CanvasWindingRule winding);
    boolean isPointInPath([Default=Undefined] optional float x,
                          [Default=Undefined] optional float y,
                          optional CanvasWindingRule winding);
    boolean isPointInStroke([Default=Undefined] optional float x,
                            [Default=Undefined] optional float y);

    // text
    attribute DOMString font;
    attribute DOMString textAlign;
    attribute DOMString textBaseline;

    TextMetrics measureText([Default=Undefined] optional DOMString text);

    // other

    void setAlpha([Default=Undefined] optional float alpha);
    void setCompositeOperation([Default=Undefined] optional DOMString compositeOperation);

#if !defined(LANGUAGE_CPP) || !LANGUAGE_CPP
    void setLineWidth([Default=Undefined] optional float width);
    void setLineCap([Default=Undefined] optional DOMString cap);
    void setLineJoin([Default=Undefined] optional DOMString join);
    void setMiterLimit([Default=Undefined] optional float limit);
#endif

    void clearShadow();

    void fillText(DOMString text, float x, float y, optional float maxWidth);
    void strokeText(DOMString text, float x, float y, optional float maxWidth);

    void setStrokeColor([StrictTypeChecking] DOMString color, optional float alpha);
    void setStrokeColor(float grayLevel, optional float alpha);
    void setStrokeColor(float r, float g, float b, float a);
    void setStrokeColor(float c, float m, float y, float k, float a);

    void setFillColor([StrictTypeChecking] DOMString color, optional float alpha);
    void setFillColor(float grayLevel, optional float alpha);
    void setFillColor(float r, float g, float b, float a);
    void setFillColor(float c, float m, float y, float k, float a);

    void strokeRect([Default=Undefined] optional float x,
                    [Default=Undefined] optional float y,
                    [Default=Undefined] optional float width,
                    [Default=Undefined] optional float height,
                    optional float lineWidth);

    void drawImage(HTMLImageElement? image, float x, float y)
        raises (DOMException);
    void drawImage(HTMLImageElement? image, float x, float y, float width, float height)
        raises (DOMException);
    void drawImage(HTMLImageElement? image, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh)
        raises (DOMException);
    void drawImage(HTMLCanvasElement? canvas, float x, float y)
        raises (DOMException);
    void drawImage(HTMLCanvasElement? canvas, float x, float y, float width, float height)
        raises (DOMException);
    void drawImage(HTMLCanvasElement? canvas, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh)
        raises (DOMException);
#if defined(ENABLE_VIDEO) && ENABLE_VIDEO
    void drawImage(HTMLVideoElement? video, float x, float y)
        raises (DOMException);
    void drawImage(HTMLVideoElement? video, float x, float y, float width, float height)
        raises (DOMException);
    void drawImage(HTMLVideoElement? video, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh)
        raises (DOMException);
#endif

    void drawImageFromRect(HTMLImageElement image,
                           optional float sx, optional float sy, optional float sw, optional float sh,
                           optional float dx, optional float dy, optional float dw, optional float dh,
                           optional DOMString compositeOperation);

    void setShadow(float width, float height, float blur, [StrictTypeChecking] optional DOMString color, optional float alpha);
    void setShadow(float width, float height, float blur, float grayLevel, optional float alpha);
    void setShadow(float width, float height, float blur, float r, float g, float b, float a);
    void setShadow(float width, float height, float blur, float c, float m, float y, float k, float a);

    void putImageData(ImageData? imagedata, float dx, float dy)
        raises(DOMException);
    void putImageData(ImageData? imagedata, float dx, float dy, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight)
        raises(DOMException);

    void webkitPutImageDataHD(ImageData? imagedata, float dx, float dy)
        raises(DOMException);
    void webkitPutImageDataHD(ImageData? imagedata, float dx, float dy, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight)
        raises(DOMException);

    CanvasPattern createPattern(HTMLCanvasElement? canvas, [TreatNullAs=NullString] DOMString repetitionType)
        raises (DOMException);
    CanvasPattern createPattern(HTMLImageElement? image, [TreatNullAs=NullString] DOMString repetitionType)
        raises (DOMException);
    ImageData createImageData(ImageData? imagedata)
        raises (DOMException);
    ImageData createImageData(float sw, float sh)
        raises (DOMException);

    [Custom] attribute custom strokeStyle;
    [Custom] attribute custom fillStyle;

    // pixel manipulation
    ImageData getImageData([Default=Undefined] optional float sx, [Default=Undefined] optional float sy,
                           [Default=Undefined] optional float sw, [Default=Undefined] optional float sh)
        raises(DOMException);

    ImageData webkitGetImageDataHD([Default=Undefined] optional float sx, [Default=Undefined] optional float sy,
                                   [Default=Undefined] optional float sw, [Default=Undefined] optional float sh)
        raises(DOMException);

    readonly attribute float webkitBackingStorePixelRatio;

    attribute boolean webkitImageSmoothingEnabled;
};

