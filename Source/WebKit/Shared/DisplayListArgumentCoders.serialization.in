# Copyright (C) 2023 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

headers: <WebCore/DisplayListItems.h>

[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::SetState {
    WebCore::GraphicsContextState state();
};

[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::SetLineDash {
    WebCore::DashArray dashArray();
    float dashOffset();
};

[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::ClipOutToPath {
    WebCore::Path path();
};

[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::ClipPath {
    WebCore::Path path();
    WebCore::WindRule windRule();
};

[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::DrawGlyphs {
    WebCore::RenderingResourceIdentifier fontIdentifier();
    WebCore::PositionedGlyphs positionedGlyphs();
};

[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::DrawSystemImage {
    Ref<WebCore::SystemImage> systemImage();
    WebCore::FloatRect destinationRect();
};

[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::DrawLinesForText {
    WebCore::FloatPoint blockLocation();
    WebCore::FloatSize localAnchor();
    WebCore::DashArray widths();
    float thickness();
    bool isPrinting();
    bool doubleLines();
    WebCore::StrokeStyle style();
};

[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::DrawPath {
    WebCore::Path path();
};

[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::DrawFocusRingPath {
    WebCore::Path path();
    float outlineWidth();
    WebCore::Color color();
};

[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::DrawFocusRingRects {
    Vector<WebCore::FloatRect> rects();
    float outlineOffset();
    float outlineWidth();
    WebCore::Color color();
};

[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::FillRectWithColor {
    WebCore::FloatRect rect();
    WebCore::Color color();
};

[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::FillRectWithGradient {
    WebCore::FloatRect rect();
    Ref<WebCore::Gradient> gradient();
};

[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::FillCompositedRect {
    WebCore::FloatRect rect();
    WebCore::Color color();
    WebCore::CompositeOperator compositeOperator();
    WebCore::BlendMode blendMode();
};

[CustomHeader] class WebCore::DisplayList::FillRoundedRect {
    WebCore::FloatRoundedRect roundedRect();
    WebCore::Color color();
    WebCore::BlendMode blendMode();
};

[CustomHeader] class WebCore::DisplayList::FillRectWithRoundedHole {
    WebCore::FloatRect rect();
    WebCore::FloatRoundedRect roundedHoleRect();
    WebCore::Color color();
};

[CustomHeader] class WebCore::DisplayList::FillPath {
    WebCore::Path path();
};

[CustomHeader] class WebCore::DisplayList::StrokePath {
    WebCore::Path path();
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::LineCap : uint8_t {
    Butt,
    Round,
    Square
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::LineJoin : uint8_t {
    Miter,
    Round,
    Bevel
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::StrokeStyle : uint8_t {
    NoStroke,
    SolidStroke,
    DottedStroke,
    DashedStroke,
    DoubleStroke,
    WavyStroke,
};

[OptionSet, AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::TextDrawingMode : uint8_t {
    Fill,
    Stroke,
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::DecodingMode : uint8_t {
    Auto,
    Synchronous,
    Asynchronous
};

header: <WebCore/GraphicsTypes.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::CompositeMode {
    WebCore::CompositeOperator operation;
    WebCore::BlendMode blendMode;
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::DocumentMarkerLineStyleMode : uint8_t {
    TextCheckingDictationPhraseWithAlternatives,
    Spelling,
    Grammar,
    AutocorrectionReplacement,
    DictationAlternatives
};

header: <WebCore/GraphicsTypes.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::DocumentMarkerLineStyle {
    WebCore::DocumentMarkerLineStyleMode mode;
    WebCore::Color color;
};

[Nested, AdditionalEncoder=StreamConnectionEncoder]  enum class WebCore::ShadowRadiusMode : bool;

header: <WebCore/GraphicsTypes.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::DropShadow {
    WebCore::FloatSize offset;
    float blurRadius;
    WebCore::Color color;
    WebCore::ShadowRadiusMode radiusMode;
};

header: <WebCore/DisplayListItems.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::DrawDotsForDocumentMarker {
    WebCore::FloatRect rect();
    WebCore::DocumentMarkerLineStyle style();
};

[Nested] enum class WebCore::ImageOrientation::Orientation : int {
    FromImage,
    OriginTopLeft,
    OriginTopRight,
    OriginBottomRight,
    OriginBottomLeft,
    OriginLeftTop,
    OriginRightTop,
    OriginRightBottom,
    OriginLeftBottom,
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ImageOrientation {
    WebCore::ImageOrientation::Orientation orientation()
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ImagePaintingOptions {
     WebCore::CompositeOperator m_compositeOperator;
     WebCore::BlendMode m_blendMode;
     WebCore::DecodingMode m_decodingMode;
     WebCore::ImageOrientation m_orientation;
     WebCore::InterpolationQuality m_interpolationQuality;
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::CompositeOperator : uint8_t {
    Clear,
    Copy,
    SourceOver,
    SourceIn,
    SourceOut,
    SourceAtop,
    DestinationOver,
    DestinationIn,
    DestinationOut,
    DestinationAtop,
    XOR,
    PlusDarker,
    PlusLighter,
    Difference
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::BlendMode : uint8_t {
    Normal,
    Multiply,
    Screen,
    Darken,
    Lighten,
    Overlay,
    ColorDodge,
    ColorBurn,
    HardLight,
    SoftLight,
    Difference,
    Exclusion,
    Hue,
    Saturation,
    Color,
    Luminosity,
    PlusDarker,
    PlusLighter
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::GradientSpreadMethod : uint8_t {
    Pad,
    Reflect,
    Repeat
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::InterpolationQuality : uint8_t {
    Default,
    DoNotInterpolate,
    Low,
    Medium,
    High
};

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::Gradient::LinearData {
    WebCore::FloatPoint point0;
    WebCore::FloatPoint point1;
};

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::Gradient::RadialData {
    WebCore::FloatPoint point0;
    WebCore::FloatPoint point1;
    float startRadius;
    float endRadius;
    float aspectRatio;
};

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::Gradient::ConicData {
    WebCore::FloatPoint point0;
    float angleRadians;
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::Gradient {
    std::variant<WebCore::Gradient::LinearData, WebCore::Gradient::RadialData, WebCore::Gradient::ConicData> data();
    WebCore::ColorInterpolationMethod colorInterpolationMethod();
    WebCore::GradientSpreadMethod spreadMethod();
    WebCore::GradientColorStops stops();
}

[Nested, AdditionalEncoder=StreamConnectionEncoder] class WebCore::SourceBrush::Brush::LogicalGradient {
    Ref<WebCore::Gradient> gradient;
    WebCore::AffineTransform spaceTransform;
}

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::Pattern::Parameters {
    bool repeatX;
    bool repeatY;
    WebCore::AffineTransform patternSpaceTransform;
}

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::Pattern {
    WebCore::SourceImage tileImage();
    WebCore::Pattern::Parameters parameters();
}

[Nested, AdditionalEncoder=StreamConnectionEncoder] class WebCore::SourceBrush::Brush {
    std::variant<WebCore::SourceBrush::Brush::LogicalGradient, Ref<WebCore::Pattern>> brush;
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::SourceBrush {
    WebCore::Color color();
    std::optional<WebCore::SourceBrush::Brush> brush();
}

[AdditionalEncoder=StreamConnectionEncoder, CustomHeader] class WebCore::DisplayList::SetInlineFillColor {
    uint8_t colorData().resolved().red
    uint8_t colorData().resolved().green
    uint8_t colorData().resolved().blue
    uint8_t colorData().resolved().alpha
}

[AdditionalEncoder=StreamConnectionEncoder, CustomHeader] class WebCore::DisplayList::SetInlineStrokeColor {
    uint8_t colorData().resolved().red
    uint8_t colorData().resolved().green
    uint8_t colorData().resolved().blue
    uint8_t colorData().resolved().alpha
}
