# Copyright (C) 2022 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

header: <WebCore/DOMCacheEngine.h>
[CustomHeader] struct WebCore::DOMCacheEngine::CacheInfo {
    WebCore::DOMCacheIdentifier identifier
    String name
}

[CustomHeader] struct WebCore::DOMCacheEngine::CacheInfos {
    Vector<WebCore::DOMCacheEngine::CacheInfo> infos;
    uint64_t updateCounter;
};

[CustomHeader] struct WebCore::DOMCacheEngine::CacheIdentifierOperationResult {
    WebCore::DOMCacheIdentifier identifier;
    bool hadStorageError;
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::TransformationMatrix {
    double m11()
    double m12()
    double m13()
    double m14()
    double m21()
    double m22()
    double m23()
    double m24()
    double m31()
    double m32()
    double m33()
    double m34()
    double m41()
    double m42()
    double m43()
    double m44()
}

struct WebCore::CacheQueryOptions {
    bool ignoreSearch;
    bool ignoreMethod;
    bool ignoreVary;
    String cacheName;
}

struct WebCore::CharacterRange {
    uint64_t location
    uint64_t length
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::AffineTransform {
    double a()
    double b()
    double c()
    double d()
    double e()
    double f()
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatPoint {
    float x()
    float y()
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatPoint3D {
    float x()
    float y()
    float z()
}

struct WebCore::IDBCursorRecord {
    WebCore::IDBKeyData key;
    WebCore::IDBKeyData primaryKey;
    WebCore::IDBValue value;
}

class WebCore::IDBCursorInfo {
    WebCore::IDBResourceIdentifier identifier();
    WebCore::IDBResourceIdentifier transactionIdentifier();
    uint64_t objectStoreIdentifier();
    uint64_t sourceIdentifier();

    WebCore::IDBKeyRangeData range();

    WebCore::IndexedDB::CursorSource cursorSource();
    WebCore::IndexedDB::CursorDirection cursorDirection();
    WebCore::IndexedDB::CursorType cursorType();
};

class WebCore::IDBError {
    std::optional<WebCore::ExceptionCode> code()
    String messageForSerialization()
}

struct WebCore::IDBGetAllRecordsData {
    WebCore::IDBKeyRangeData keyRangeData;
    WebCore::IndexedDB::GetAllType getAllType;
    std::optional<uint32_t> count;
    uint64_t objectStoreIdentifier;
    uint64_t indexIdentifier;
}

class WebCore::IDBGetResult {
    WebCore::IDBKeyData keyData()
    WebCore::IDBKeyData primaryKeyData()
    WebCore::IDBValue value()
    std::optional<WebCore::IDBKeyPath> keyPath()
    Vector<WebCore::IDBCursorRecord> prefetchedRecords()
    bool isDefined()
}

class WebCore::IDBGetAllResult {
    WebCore::IndexedDB::GetAllType type()
    Vector<WebCore::IDBKeyData> keys()
    Vector<WebCore::IDBValue> values()
    std::optional<WebCore::IDBKeyPath> keyPath()
}

class WebCore::IDBDatabaseInfo {
    String m_name
    uint64_t m_version
    uint64_t m_maxIndexID
    uint64_t m_maxObjectStoreID
    HashMap<uint64_t, WebCore::IDBObjectStoreInfo> m_objectStoreMap
}

struct WebCore::IDBKeyRangeData {
    [ReturnEarlyIfTrue] bool isNull;

    WebCore::IDBKeyData lowerKey;
    WebCore::IDBKeyData upperKey;

    bool lowerOpen;
    bool upperOpen;
};

class WebCore::IDBTransactionInfo {
    WebCore::IDBResourceIdentifier identifier();
    WebCore::IDBTransactionMode mode();
    WebCore::IDBTransactionDurability durability();
    uint64_t newVersion();
    Vector<String> objectStores();
    std::unique_ptr<WebCore::IDBDatabaseInfo> originalDatabaseInfo();
};

struct WebCore::IDBGetRecordData {
    WebCore::IDBKeyRangeData keyRangeData;
    WebCore::IDBGetRecordDataType type;
}

class WebCore::IDBIndexInfo {
    uint64_t identifier()
    uint64_t objectStoreIdentifier()
    String name()
    WebCore::IDBKeyPath keyPath()
    bool unique()
    bool multiEntry()
}

class WebCore::IDBObjectStoreInfo {
    uint64_t identifier()
    String name()
    std::optional<WebCore::IDBKeyPath> keyPath()
    bool autoIncrement()
    HashMap<uint64_t, WebCore::IDBIndexInfo> indexMap()
}

struct WebCore::IDBIterateCursorData {
    WebCore::IDBKeyData keyData;
    WebCore::IDBKeyData primaryKeyData;
    unsigned count;
    WebCore::IndexedDB::CursorIterateOption option;
}

class WebCore::IDBResourceIdentifier {
    WebCore::IDBConnectionIdentifier m_idbConnectionIdentifier
    uint64_t m_resourceNumber
}

class WebCore::IDBValue {
    WebCore::ThreadSafeDataBuffer data()
    Vector<String> blobURLs()
    Vector<String> blobFilePaths()
};

class WebCore::IDBRequestData {
    WebCore::IDBConnectionIdentifier m_serverConnectionIdentifier;
    WebCore::IDBResourceIdentifier m_requestIdentifier;
    std::optional<WebCore::IDBResourceIdentifier> m_transactionIdentifier;
    std::optional<WebCore::IDBResourceIdentifier> m_cursorIdentifier;
    uint64_t m_objectStoreIdentifier;
    uint64_t m_indexIdentifier;
    WebCore::IndexedDB::IndexRecordType m_indexRecordType;
    std::optional<WebCore::IDBDatabaseIdentifier> m_databaseIdentifier;
    uint64_t m_requestedVersion;
    WebCore::IndexedDB::RequestType m_requestType;
}

# FIXME: When decoding from IPC, databaseName can be null, and the non-empty constructor asserts that this is not the case.
[LegacyPopulateFrom=EmptyConstructor] class WebCore::IDBDatabaseIdentifier {
    String m_databaseName
    WebCore::ClientOrigin m_origin
    bool m_isTransient
}

struct WebCore::IDBDatabaseNameAndVersion {
    String name;
    uint64_t version;
}

[LegacyPopulateFrom=EmptyConstructor] class WebCore::IDBResultData {
    WebCore::IDBResultType m_type;
    WebCore::IDBResourceIdentifier m_requestIdentifier;
    WebCore::IDBError m_error;
    uint64_t m_databaseConnectionIdentifier;
    std::unique_ptr<WebCore::IDBDatabaseInfo> m_databaseInfo;
    std::unique_ptr<WebCore::IDBTransactionInfo> m_transactionInfo;
    std::unique_ptr<WebCore::IDBKeyData> m_resultKey;
    std::unique_ptr<WebCore::IDBGetResult> m_getResult;
    std::unique_ptr<WebCore::IDBGetAllResult> m_getAllResult;
    uint64_t m_resultInteger;
}

[LegacyPopulateFrom=EmptyConstructor] class WebCore::IDBKeyData {
    [ReturnEarlyIfTrue] bool m_isNull;
    WebCore::IndexedDB::KeyType m_type;
    std::variant<Vector<WebCore::IDBKeyData>, String, double, WebCore::ThreadSafeDataBuffer> m_value;
}

#if USE(CG)
headers: <CoreGraphics/CGGeometry.h> <CoreGraphics/CGAffineTransform.h>
[AdditionalEncoder=StreamConnectionEncoder] struct CGSize {
    CGFloat width
    CGFloat height
};

struct CGPoint {
    CGFloat x
    CGFloat y
};

struct CGRect {
    CGPoint origin
    CGSize size
};

struct CGAffineTransform {
  CGFloat a
  CGFloat b
  CGFloat c
  CGFloat d
  CGFloat tx
  CGFloat ty
};
#endif

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatRect {
    WebCore::FloatPoint location()
    WebCore::FloatSize size()
}

[Return=Ref, CustomHeader=True] class WebCore::LinearTimingFunction {
};

[Return=Ref, CustomHeader=True] class WebCore::CubicBezierTimingFunction {
    WebCore::CubicBezierTimingFunction::TimingFunctionPreset timingFunctionPreset()
    double x1()
    double y1()
    double x2()
    double y2()
};

[Return=Ref, CustomHeader=True] class WebCore::StepsTimingFunction {
    int numberOfSteps()
    std::optional<WebCore::StepsTimingFunction::StepPosition> stepPosition()
};

[Return=Ref, CustomHeader=True] class WebCore::SpringTimingFunction {
    double mass()
    double stiffness()
    double damping()
    double initialVelocity()
};

[LegacyPopulateFrom=EmptyConstructor] struct WebCore::ResourceLoadStatistics {
    WebCore::RegistrableDomain registrableDomain;
    WallTime lastSeen;
    bool hadUserInteraction;
    WallTime mostRecentUserInteractionTime;
    bool grandfathered;
    HashSet<WebCore::RegistrableDomain> storageAccessUnderTopFrameDomains;
    HashSet<WebCore::RegistrableDomain> topFrameUniqueRedirectsTo;
    HashSet<WebCore::RegistrableDomain> topFrameUniqueRedirectsToSinceSameSiteStrictEnforcement;
    HashSet<WebCore::RegistrableDomain> topFrameUniqueRedirectsFrom;
    HashSet<WebCore::RegistrableDomain> topFrameLinkDecorationsFrom;
    bool gotLinkDecorationFromPrevalentResource;
    HashSet<WebCore::RegistrableDomain> topFrameLoadedThirdPartyScripts;
    HashSet<WebCore::RegistrableDomain> subframeUnderTopFrameDomains;
    HashSet<WebCore::RegistrableDomain> subresourceUnderTopFrameDomains;
    HashSet<WebCore::RegistrableDomain> subresourceUniqueRedirectsTo;
    HashSet<WebCore::RegistrableDomain> subresourceUniqueRedirectsFrom;
    bool isPrevalentResource;
    bool isVeryPrevalentResource;
    unsigned dataRecordsRemoved;
    unsigned timesAccessedAsFirstPartyDueToUserInteraction;
    unsigned timesAccessedAsFirstPartyDueToStorageAccessAPI;
#if ENABLE(WEB_API_STATISTICS)
    HashSet<WebCore::RegistrableDomain> topFrameRegistrableDomainsWhichAccessedWebAPIs;
    HashSet<String> fontsFailedToLoad;
    HashSet<String> fontsSuccessfullyLoaded;
    WebCore::CanvasActivityRecord canvasActivityRecord;
    OptionSet<WebCore::NavigatorAPIsAccessed> navigatorFunctionsAccessed;
    OptionSet<WebCore::ScreenAPIsAccessed> screenFunctionsAccessed;
#endif
};

[OptionSet] enum class WebCore::NavigatorAPIsAccessed : uint64_t {
    AppVersion,
    UserAgent,
    Plugins,
    MimeTypes,
    CookieEnabled
};

[OptionSet] enum class WebCore::ScreenAPIsAccessed : uint64_t {
    Height,
    Width,
    ColorDepth,
    PixelDepth,
    AvailLeft,
    AvailTop,
    AvailHeight,
    AvailWidth
};

#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
[AdditionalEncoder=StreamConnectionEncoder, CustomHeader=True] struct WebCore::GraphicsContextGLActiveInfo {
    String name;
    GCGLenum type;
    GCGLint size;
};
#endif

enum class WebCore::ViewportFit : uint8_t {
    Auto,
    Contain,
    Cover,
};

header: <WebCore/ViewportArguments.h>
[CustomHeader=True] struct WebCore::ViewportAttributes {
    WebCore::FloatSize layoutSize;

    float initialScale;
    float minimumScale;
    float maximumScale;

    float userScalable;
    float orientation;
    float shrinkToFit;

    WebCore::ViewportFit viewportFit;
};

header: <WebCore/ShareData.h>
[CustomHeader=True] struct WebCore::ShareDataWithParsedURL {
    WebCore::ShareData shareData;
    std::optional<URL> url;
    Vector<WebCore::RawFile> files;
    WebCore::ShareDataOriginator originator;
};

struct WebCore::ShareData {
    String title;
    String text;
    String url;
};

enum class WebCore::ShareDataOriginator : bool

[CustomHeader=True] struct WebCore::RawFile {
    String fileName;
    RefPtr<WebCore::SharedBuffer> fileData;
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatRoundedRect {
    WebCore::FloatRect rect();
    WebCore::FloatSize radii().topLeft();
    WebCore::FloatSize radii().topRight();
    WebCore::FloatSize radii().bottomLeft();
    WebCore::FloatSize radii().bottomRight();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::IntRect {
    WebCore::IntPoint location();
    WebCore::IntSize size();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::IntPoint {
    int x();
    int y();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::IntSize {
    int width();
    int height();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatSize {
    float width();
    float height();
}

[AdditionalEncoder=StreamConnectionEncoder, CreateUsing=fromRawValue] class WebCore::LayoutUnit {
    int rawValue()
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::LayoutPoint {
    WebCore::LayoutUnit x();
    WebCore::LayoutUnit y();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::LayoutSize {
    WebCore::LayoutUnit width();
    WebCore::LayoutUnit height();
}

struct WebCore::DictionaryPopupInfo {
    WebCore::FloatPoint origin;
    WebCore::TextIndicatorData textIndicator;
#if PLATFORM(COCOA)
    WebCore::DictionaryPopupInfoCocoa platformData;
#endif
};

enum class WebCore::PCM::AttributionEphemeral : bool
enum class WebCore::PCM::WasSent : bool

class WebCore::PrivateClickMeasurement {
    uint8_t sourceID()
    WebCore::PCM::SourceSite sourceSite()
    WebCore::PCM::AttributionDestinationSite destinationSite()
    WallTime timeOfAdClick()
    WebCore::PCM::AttributionEphemeral isEphemeral()
    std::optional<uint64_t> adamID()
    std::optional<WebCore::PCM::AttributionTriggerData> attributionTriggerData()
    WebCore::PCM::AttributionTimeToSendData timesToSend()
    std::optional<WebCore::PCM::EphemeralNonce> ephemeralSourceNonce()
    String sourceApplicationBundleID()
}

[CustomHeader=True] struct WebCore::PCM::SourceSite {
    WebCore::RegistrableDomain registrableDomain
}

[CustomHeader=True] struct WebCore::PCM::AttributionDestinationSite {
    WebCore::RegistrableDomain registrableDomain
}

[CustomHeader=True] struct WebCore::PCM::EphemeralNonce {
    String nonce
}

[CustomHeader=True] struct WebCore::PCM::AttributionTriggerData {
    uint8_t data
    uint8_t priority;
    WebCore::PCM::WasSent wasSent;
    std::optional<WebCore::RegistrableDomain> sourceRegistrableDomain;
    std::optional<WebCore::PCM::EphemeralNonce> ephemeralDestinationNonce;
    std::optional<WebCore::RegistrableDomain> destinationSite;
# destinationUnlinkableToken and destinationSecretToken are not serialized.
}

[CustomHeader=True] struct WebCore::PCM::AttributionTimeToSendData {
    std::optional<WallTime> sourceEarliestTimeToSend;
    std::optional<WallTime> destinationEarliestTimeToSend;
}

#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
struct WebCore::ApplePayRecurringPaymentRequest {
    String paymentDescription
    WebCore::ApplePayLineItem regularBilling
    std::optional<WebCore::ApplePayLineItem> trialBilling
    String billingAgreement
    String managementURL
    String tokenNotificationURL
};
#endif

#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
struct WebCore::ApplePayPaymentTokenContext {
    String merchantIdentifier
    String externalIdentifier
    String merchantName
    String merchantDomain
    String amount
}
#endif

#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
struct WebCore::ApplePayPaymentOrderDetails {
    String orderTypeIdentifier
    String orderIdentifier
    String webServiceURL
    String authenticationToken
}
#endif

#if ENABLE(APPLE_PAY_AMS_UI) && ENABLE(PAYMENT_REQUEST)
struct WebCore::ApplePayAMSUIRequest {
    String engagementRequest
}
#endif

#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
struct WebCore::ApplePayAutomaticReloadPaymentRequest {
    String paymentDescription
    WebCore::ApplePayLineItem automaticReloadBilling
    String billingAgreement
    String managementURL
    String tokenNotificationURL
}
#endif

#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
struct WebCore::ApplePayDateComponents {
    std::optional<unsigned> years;
    std::optional<unsigned> months;
    std::optional<unsigned> days;
    std::optional<unsigned> hours;
}

struct WebCore::ApplePayDateComponentsRange {
    WebCore::ApplePayDateComponents startDateComponents;
    WebCore::ApplePayDateComponents endDateComponents;
}
#endif // ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)

#if ENABLE(APPLE_PAY)
struct WebCore::ApplePayLineItem {
    WebCore::ApplePayLineItem::Type type
    String label
    String amount
    WebCore::ApplePayPaymentTiming paymentTiming
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    WallTime recurringPaymentStartDate
    WebCore::ApplePayRecurringPaymentDateUnit recurringPaymentIntervalUnit
    unsigned recurringPaymentIntervalCount
    WallTime recurringPaymentEndDate
#endif
#if ENABLE(APPLE_PAY_DEFERRED_LINE_ITEM)
    WallTime deferredPaymentDate
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_LINE_ITEM)
    String automaticReloadPaymentThresholdAmount
#endif
}

struct WebCore::ApplePayShippingMethod {
    String label
    String detail
    String amount
    String identifier
#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
    std::optional<WebCore::ApplePayDateComponentsRange> dateComponentsRange
#endif
#if ENABLE(APPLE_PAY_SELECTED_SHIPPING_METHOD)
    bool selected
#endif
}

[Return=Ref] class WebCore::ApplePayError {
    WebCore::ApplePayErrorCode code()
    std::optional<WebCore::ApplePayErrorContactField> contactField()
    String message()
}

[Return=Ref, AdditionalEncoder=StreamConnectionEncoder] class WebCore::ApplePayButtonSystemImage {
    WebCore::ApplePayButtonType m_applePayButtonType
    WebCore::ApplePayButtonStyle m_applePayButtonStyle
    String m_locale
    float m_largestCornerRadius
}

enum class WebCore::ApplePayLogoStyle : bool
[Return=Ref, AdditionalEncoder=StreamConnectionEncoder] class WebCore::ApplePayLogoSystemImage {
    WebCore::ApplePayLogoStyle applePayLogoStyle()
}

header: <WebCore/ApplePayButtonSystemImage.h>
enum class WebCore::ApplePayButtonType : uint8_t {
    Plain,
    Buy,
    SetUp,
    Donate,
    CheckOut,
    Book,
    Subscribe,
#if ENABLE(APPLE_PAY_NEW_BUTTON_TYPES)
    Reload,
    AddMoney,
    TopUp,
    Order,
    Rent,
    Support,
    Contribute,
    Tip,
#endif
}

enum class WebCore::ApplePayButtonStyle : uint8_t {
    White,
    WhiteOutline,
    Black,
}

struct WebCore::ApplePayDetailsUpdateBase {
    WebCore::ApplePayLineItem newTotal;
    Vector<WebCore::ApplePayLineItem> newLineItems;
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    std::optional<WebCore::ApplePayRecurringPaymentRequest> newRecurringPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest> newAutomaticReloadPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    std::optional<Vector<WebCore::ApplePayPaymentTokenContext>> newMultiTokenContexts;
#endif
}

struct WebCore::ApplePayPaymentMethodUpdate : WebCore::ApplePayDetailsUpdateBase {
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    Vector<RefPtr<WebCore::ApplePayError>> errors;
    Vector<WebCore::ApplePayShippingMethod> newShippingMethods;
#endif
#if ENABLE(APPLE_PAY_INSTALLMENTS)
    String installmentGroupIdentifier;
#endif
};

struct WebCore::ApplePayShippingContactUpdate : WebCore::ApplePayDetailsUpdateBase {
    Vector<RefPtr<WebCore::ApplePayError>> errors;
    Vector<WebCore::ApplePayShippingMethod> newShippingMethods;
};

struct WebCore::ApplePayShippingMethodUpdate : WebCore::ApplePayDetailsUpdateBase {
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    Vector<WebCore::ApplePayShippingMethod> newShippingMethods;
#endif
};

struct WebCore::ApplePayPaymentAuthorizationResult {
    unsigned short status;
    Vector<RefPtr<WebCore::ApplePayError>> errors;
#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
    std::optional<WebCore::ApplePayPaymentOrderDetails> orderDetails;
#endif
}
#endif // ENABLE(APPLE_PAY)

#if ENABLE(APPLE_PAY_COUPON_CODE)
struct WebCore::ApplePayCouponCodeUpdate : WebCore::ApplePayDetailsUpdateBase {
    Vector<RefPtr<WebCore::ApplePayError>> errors;
    Vector<WebCore::ApplePayShippingMethod> newShippingMethods;
};
#endif

#if ENABLE(APPLICATION_MANIFEST)
[Nested] enum class WebCore::ApplicationManifest::Display : uint8_t {
    Browser
    MinimalUI
    Standalone
    Fullscreen
};

[Nested, OptionSet] enum class WebCore::ApplicationManifest::Icon::Purpose : uint8_t {
    Any
    Monochrome
    Maskable
}

[Nested] struct WebCore::ApplicationManifest::Icon {
    URL src
    Vector<String> sizes
    String type
    OptionSet<WebCore::ApplicationManifest::Icon::Purpose> purposes
}

struct WebCore::ApplicationManifest {
    String name
    String shortName
    String description
    URL scope
    WebCore::ApplicationManifest::Display display
    URL startURL
    WebCore::Color themeColor
    Vector<WebCore::ApplicationManifest::Icon> icons
}
#endif // ENABLE(APPLICATION_MANIFEST)

enum class WebCore::DOMCacheEngine::Error : uint8_t {
    NotImplemented,
    ReadDisk,
    WriteDisk,
    QuotaExceeded,
    Internal,
    Stopped,
    CORP
};

struct WebCore::RetrieveRecordsOptions {
    WebCore::ResourceRequest request;
    WebCore::CrossOriginEmbedderPolicy crossOriginEmbedderPolicy;
    Ref<WebCore::SecurityOrigin> sourceOrigin;
    bool ignoreSearch;
    bool ignoreMethod;
    bool ignoreVary;
    bool shouldProvideResponse;
};

struct WebCore::ContactInfo {
    Vector<String> name;
    Vector<String> email;
    Vector<String> tel;
};

struct WebCore::ContactsRequestData {
    Vector<WebCore::ContactProperty> properties;
    bool multiple;
    String url;
};

#if ENABLE(MEDIA_SESSION)
struct WebCore::MediaPositionState {
    double duration;
    double playbackRate;
    double position;
};
#endif // ENABLE(MEDIA_SESSION)

#if ENABLE(WEB_RTC)
struct WebCore::DetachedRTCDataChannel {
    WebCore::RTCDataChannelIdentifier identifier;
    String label;
    WebCore::RTCDataChannelInit options;
    WebCore::RTCDataChannelState state;
};
#endif

header: <WebCore/WebCodecsEncodedVideoChunk.h>
#if ENABLE(WEB_CODECS)
struct WebCore::WebCodecsEncodedVideoChunkData {
    WebCore::WebCodecsEncodedVideoChunkType type;
    int64_t timestamp;
    std::optional<uint64_t> duration;
    Vector<uint8_t> buffer;
};
#endif

struct WebCore::HTMLModelElementCamera {
    double pitch;
    double yaw;
    double scale;
};

struct WebCore::NotificationData {
    String title;
    String body;
    String iconURL;
    String tag;
    String language;
    WebCore::NotificationDirection direction;
    String originString;
    URL serviceWorkerRegistrationURL;
    UUID notificationID;
    WebCore::ScriptExecutionContextIdentifier contextIdentifier;
    PAL::SessionID sourceSession;
    MonotonicTime creationTime;
    Vector<uint8_t> data;
};

struct WebCore::PermissionDescriptor {
    WebCore::PermissionName name;
}

#if ENABLE(SERVICE_WORKER)
struct WebCore::PushSubscriptionData {
    WebCore::PushSubscriptionIdentifier identifier;
    String endpoint;
    std::optional<WebCore::EpochTimeStamp> expirationTime;
    Vector<uint8_t> serverVAPIDPublicKey;
    Vector<uint8_t> clientECDHPublicKey;
    Vector<uint8_t> sharedAuthenticationSecret;
};
#endif

[Return=Ref] class WebCore::DeprecationReportBody {
    String id()
    WallTime anticipatedRemoval()
    String message()
    String sourceFile()
    std::optional<unsigned> lineNumber()
    std::optional<unsigned> columnNumber()
};

[Return=Ref] class WebCore::Report {
    String type()
    String url()
    RefPtr<WebCore::ReportBody> body()
};

[Return=Ref] class WebCore::TestReportBody {
    String message()
}

enum class WebCore::SpeechRecognitionErrorType : uint8_t {
    NoSpeech,
    Aborted,
    AudioCapture,
    Network,
    NotAllowed,
    ServiceNotAllowed,
    BadGrammar,
    LanguageNotSupported
};

struct WebCore::SpeechRecognitionError {
    WebCore::SpeechRecognitionErrorType type;
    String message;
};

struct WebCore::SpeechRecognitionRequestInfo {
    WebCore::SpeechRecognitionConnectionClientIdentifier clientIdentifier;
    String lang;
    bool continuous;
    bool interimResults;
    uint64_t maxAlternatives;
    WebCore::ClientOrigin clientOrigin;
    WebCore::FrameIdentifier frameIdentifier;
};

[CustomHeader] struct WebCore::SpeechRecognitionAlternativeData {
    String transcript;
    double confidence;
};

struct WebCore::SpeechRecognitionResultData {
    Vector<WebCore::SpeechRecognitionAlternativeData> alternatives;
    bool isFinal;
};

struct WebCore::WebLockManagerSnapshot {
    Vector<WebCore::WebLockManagerSnapshot::Info> held;
    Vector<WebCore::WebLockManagerSnapshot::Info> pending;
};

[Nested] struct WebCore::WebLockManagerSnapshot::Info {
    String name;
    WebCore::WebLockMode mode;
    String clientId;
};

#if ENABLE(WEB_AUTHN)
[LegacyPopulateFrom=EmptyConstructor] struct WebCore::AuthenticationExtensionsClientInputs {
    String appid;
    bool googleLegacyAppidSupport;
}

[Nested] struct WebCore::AuthenticationExtensionsClientOutputs::CredentialPropertiesOutput {
    bool rk;
};

struct WebCore::AuthenticationExtensionsClientOutputs {
    std::optional<bool> appid;
    std::optional<WebCore::AuthenticationExtensionsClientOutputs::CredentialPropertiesOutput> credProps;
}

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::Parameters {
    WebCore::PublicKeyCredentialType type;
    int64_t alg;
};

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::AuthenticatorSelectionCriteria {
    std::optional<WebCore::AuthenticatorAttachment> authenticatorAttachment;
    std::optional<WebCore::ResidentKeyRequirement> residentKey;
    bool requireResidentKey;
    WebCore::UserVerificationRequirement userVerification;
};

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::Entity {
    String name;
    String icon;
};

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::RpEntity : WebCore::PublicKeyCredentialCreationOptions::Entity {
    std::optional<String> id;
};

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::UserEntity : WebCore::PublicKeyCredentialCreationOptions::Entity {
    WebCore::BufferSource id;
    String displayName;
};

struct WebCore::PublicKeyCredentialDescriptor {
    WebCore::PublicKeyCredentialType type;
    WebCore::BufferSource id;
    Vector<WebCore::AuthenticatorTransport> transports;
};
#endif // ENABLE(WEB_AUTHN)

struct WebCore::PublicKeyCredentialCreationOptions {
#if ENABLE(WEB_AUTHN)
    WebCore::PublicKeyCredentialCreationOptions::RpEntity rp;
    WebCore::PublicKeyCredentialCreationOptions::UserEntity user;

    WebCore::BufferSource challenge;
    Vector<WebCore::PublicKeyCredentialCreationOptions::Parameters> pubKeyCredParams;

    std::optional<unsigned> timeout;
    Vector<WebCore::PublicKeyCredentialDescriptor> excludeCredentials;
    std::optional<WebCore::PublicKeyCredentialCreationOptions::AuthenticatorSelectionCriteria> authenticatorSelection;
    WebCore::AttestationConveyancePreference attestation;
    std::optional<WebCore::AuthenticationExtensionsClientInputs> extensions;
#endif // ENABLE(WEB_AUTHN)
};

struct WebCore::PublicKeyCredentialRequestOptions {
#if ENABLE(WEB_AUTHN)
    WebCore::BufferSource challenge;
    std::optional<unsigned> timeout;
    String rpId;
    Vector<WebCore::PublicKeyCredentialDescriptor> allowCredentials;
    WebCore::UserVerificationRequirement userVerification;
    std::optional<WebCore::AuthenticationExtensionsClientInputs> extensions;
#endif // ENABLE(WEB_AUTHN)
};

[CreateUsing=fromRawString] class WebCore::RegistrableDomain {
    String string()
}

struct WebCore::AudioConfiguration {
    String contentType;
    String channels;
    std::optional<uint64_t> bitrate;
    std::optional<uint32_t> samplerate;
    std::optional<bool> spatialRendering;
};

[Nested] enum class WebCore::Cookie::SameSitePolicy : uint8_t {
    None
    Lax
    Strict
};

struct WebCore::Cookie {
    String name;
    String value;
    String domain;
    String path;
    double created;
    std::optional<double> expires;
    bool httpOnly;
    bool secure;
    bool session;
    String comment;
    URL commentURL;
    Vector<uint16_t> ports;
    WebCore::Cookie::SameSitePolicy sameSite;
};

#if ENABLE(VIDEO)
struct WebCore::VideoFrameMetadata {
    double presentationTime;
    double expectedDisplayTime;

    unsigned width;
    unsigned height;
    double mediaTime;

    unsigned presentedFrames;
    std::optional<double> processingDuration;

    std::optional<double> captureTime;
    std::optional<double> receiveTime;
    std::optional<unsigned> rtpTimestamp;
};
#endif // ENABLE(VIDEO)

#if ENABLE(SERVICE_WORKER)
struct WebCore::NavigationPreloadState {
    bool enabled;
    String headerValue;
};
#endif // ENABLE(SERVICE_WORKER)
