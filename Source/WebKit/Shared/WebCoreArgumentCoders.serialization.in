# Copyright (C) 2022-2023 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

webkit_platform_headers: <WebCore/Color.h> <WebCore/ColorTypes.h>

header: <WebCore/DOMCacheEngine.h>
[CustomHeader] struct WebCore::DOMCacheEngine::CacheInfo {
    WebCore::DOMCacheIdentifier identifier
    String name
}

[CustomHeader] struct WebCore::DOMCacheEngine::CacheInfos {
    Vector<WebCore::DOMCacheEngine::CacheInfo> infos;
    uint64_t updateCounter;
};

[CustomHeader] struct WebCore::DOMCacheEngine::CacheIdentifierOperationResult {
    WebCore::DOMCacheIdentifier identifier;
    bool hadStorageError;
};

#if ENABLE(APPLE_PAY)
header: <WebCore/ApplePayFeature.h>
enum class WebCore::ApplePayFeature : uint8_t {
#if ENABLE(APPLE_PAY_LATER)
    ApplePayLater,
#endif
#if ENABLE(APPLE_PAY_LATER_AVAILABILITY)
    ApplePayLaterAvailability,
#endif
#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
    AuthorizationResultOrderDetails,
#endif
    LineItemPaymentTiming,
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    PaymentRequestAutomaticReload,
#endif
#if ENABLE(APPLE_PAY_COUPON_CODE)
    PaymentRequestCouponCode,
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    PaymentRequestMultiTokenContexts,
#endif
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    PaymentRequestRecurring,
#endif
#if ENABLE(APPLE_PAY_SHIPPING_CONTACT_EDITING_MODE)
    PaymentRequestShippingContactEditingMode,
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_LINE_ITEM)
    PaymentTimingAutomaticReload,
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    PaymentRequestDeferred,
#endif
#if ENABLE(APPLE_PAY_DEFERRED_LINE_ITEM)
    PaymentTimingDeferred,
#endif
    PaymentTimingImmediate,
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    PaymentTimingRecurring,
#endif
#if ENABLE(APPLE_PAY_SHIPPING_CONTACT_EDITING_MODE)
    ShippingContactEditingModeEnabled,
    ShippingContactEditingModeStorePickup,
#endif
#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
    ShippingMethodDateComponentsRange,
#endif
};

enum class WebCore::ApplePayPaymentTiming : uint8_t {
    Immediate,
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    Recurring,
#endif
#if ENABLE(APPLE_PAY_DEFERRED_LINE_ITEM)
    Deferred,
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_LINE_ITEM)
    AutomaticReload,
#endif
};

#endif // ENABLE(APPLE_PAY)

#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
enum class WebCore::ApplePayRecurringPaymentDateUnit : uint8_t {
    Year,
    Month,
    Day,
    Hour,
    Minute,
};
#endif // ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)

enum class WebCore::ContactProperty : uint8_t {
    Email,
    Name,
    Tel
};

header: <WebCore/CookieConsentDecisionResult.h>
enum class WebCore::CookieConsentDecisionResult : uint8_t {
    NotSupported,
    Consent,
    Dissent,
};

header: <WebCore/IDBResultData.h>
enum class WebCore::IDBResultType : uint8_t {
    Error,
    OpenDatabaseSuccess,
    OpenDatabaseUpgradeNeeded,
    DeleteDatabaseSuccess,
    CreateObjectStoreSuccess,
    DeleteObjectStoreSuccess,
    ClearObjectStoreSuccess,
    PutOrAddSuccess,
    GetRecordSuccess,
    GetAllRecordsSuccess,
    GetCountSuccess,
    DeleteRecordSuccess,
    CreateIndexSuccess,
    DeleteIndexSuccess,
    OpenCursorSuccess,
    IterateCursorSuccess,
    RenameObjectStoreSuccess,
    RenameIndexSuccess,
};

enum class WebCore::IDBTransactionDurability : uint8_t {
    Strict,
    Relaxed,
    Default
};

enum class WebCore::IDBTransactionMode : uint8_t {
    Readonly,
    Readwrite,
    Versionchange
};

#if ENABLE(MEDIA_SESSION)
header: <WebCore/MediaSessionAction.h>
enum class WebCore::MediaSessionAction : uint8_t {
    Play,
    Pause,
    Seekbackward,
    Seekforward,
    Previoustrack,
    Nexttrack,
    Skipad,
    Stop,
    Seekto,
    Settrack,
};

header: <WebCore/MediaSessionPlaybackState.h>
enum class WebCore::MediaSessionPlaybackState : uint8_t {
    None,
    Paused,
    Playing,
};
#endif // ENABLE(MEDIA_SESSION)

#if ENABLE(MEDIA_SESSION_COORDINATOR)
header: <WebCore/MediaSessionCoordinatorState.h>
enum class WebCore::MediaSessionCoordinatorState : uint8_t {
    Waiting,
    Joined,
    Closed,
};

header: <WebCore/MediaSessionReadyState.h>
enum class WebCore::MediaSessionReadyState : uint8_t {
    Havenothing,
    Havemetadata,
    Havecurrentdata,
    Havefuturedata,
    Haveenoughdata,
};
#endif // ENABLE(MEDIA_SESSION_COORDINATOR)

header: <WebCore/RTCErrorDetailType.h>
enum class WebCore::RTCErrorDetailType : uint8_t {
    DataChannelFailure,
    DtlsFailure,
    FingerprintFailure,
    SctpFailure,
    SdpSyntaxError
};

enum class WebCore::NotificationEventType : bool;

enum class WebCore::PermissionName : uint8_t {
    Accelerometer,
    BackgroundFetch,
    Bluetooth,
    Camera,
    DisplayCapture,
    Geolocation,
    Gyroscope,
    Magnetometer,
    Microphone,
    Midi,
    Nfc,
    Notifications,
    Push,
    ScreenWakeLock,
    SpeakerSelection
};

header: <WebCore/PermissionQuerySource.h>
enum class WebCore::PermissionQuerySource : uint8_t {
    Window,
    DedicatedWorker,
    SharedWorker,
    ServiceWorker
};

header: <WebCore/PermissionState.h>
enum class WebCore::PermissionState : uint8_t {
    Granted,
    Denied,
    Prompt
};

header: <WebCore/PushPermissionState.h>
enum class WebCore::PushPermissionState : uint8_t {
    Denied,
    Granted,
    Prompt
};

header: <WebCore/Autofill.h>
enum class WebCore::AutofillFieldName : uint8_t {
    None,
    Name,
    HonorificPrefix,
    GivenName,
    AdditionalName,
    FamilyName,
    HonorificSuffix,
    Nickname,
    Username,
    NewPassword,
    CurrentPassword,
    OrganizationTitle,
    Organization,
    StreetAddress,
    AddressLine1,
    AddressLine2,
    AddressLine3,
    AddressLevel4,
    AddressLevel3,
    AddressLevel2,
    AddressLevel1,
    Country,
    CountryName,
    PostalCode,
    CcName,
    CcGivenName,
    CcAdditionalName,
    CcFamilyName,
    CcNumber,
    CcExp,
    CcExpMonth,
    CcExpYear,
    CcCsc,
    CcType,
    TransactionCurrency,
    TransactionAmount,
    Language,
    Bday,
    BdayDay,
    BdayMonth,
    BdayYear,
    Sex,
    URL,
    Photo,
    Tel,
    TelCountryCode,
    TelNational,
    TelAreaCode,
    TelLocal,
    TelLocalPrefix,
    TelLocalSuffix,
    TelExtension,
    Email,
    Impp,
    WebAuthn,
    OneTimeCode,
    DeviceEID,
    DeviceIMEI,
};

enum class WebCore::NonAutofillCredentialType : bool;

enum class WebCore::EnterKeyHint : uint8_t {
    Unspecified,
    Enter,
    Done,
    Go,
    Next,
    Previous,
    Search,
    Send
};

enum class WebCore::DownloadableBinaryFontAllowedTypes : uint8_t {
    Any,
    Restricted,
    None
};

header: <WebCore/LoadSchedulingMode.h>
enum class WebCore::LoadSchedulingMode : uint8_t {
    Direct,
    Prioritized
};

header: <WebCore/ResourceLoaderOptions.h>
enum class WebCore::ServiceWorkersMode : uint8_t {
    All,
    None,
    Only
};

header: <WebCore/ShouldTreatAsContinuingLoad.h>
enum class WebCore::ShouldTreatAsContinuingLoad : uint8_t {
    No,
    YesAfterNavigationPolicyDecision,
    YesAfterProvisionalLoadStarted
};

header: <WebCore/ContentSecurityPolicy.h>
enum class WebCore::ContentSecurityPolicyModeForExtension : uint8_t {
    None,
    ManifestV2,
    ManifestV3
};

header: <WebCore/MediaProducer.h>
enum class WebCore::MediaProducerMediaCaptureKind : uint8_t {
    Microphone,
    Camera,
    Display,
    SystemAudio,
    EveryKind,
};

header: <WebCore/ScreenOrientationType.h>
enum class WebCore::ScreenOrientationType : uint8_t {
    PortraitPrimary,
    PortraitSecondary,
    LandscapePrimary,
    LandscapeSecondary
};

enum class WebCore::StorageBlockingPolicy : uint8_t {
    AllowAll,
    BlockThirdParty,
    BlockAll
};

#if HAVE(TRANSLATION_UI_SERVICES) && ENABLE(CONTEXT_MENUS)
struct WebCore::TranslationContextMenuInfo {
    String text;
    WebCore::IntRect selectionBoundsInRootView;
    WebCore::IntPoint locationInRootView;
    WebCore::TranslationContextMenuMode mode;
    WebCore::TranslationContextMenuSource source;
};

header: <WebCore/TranslationContextMenuInfo.h>
enum class WebCore::TranslationContextMenuMode : bool;
enum class WebCore::TranslationContextMenuSource : bool;
#endif // HAVE(TRANSLATION_UI_SERVICES) && ENABLE(CONTEXT_MENUS)

#if USE(APPKIT)
header: <WebCore/AppKitControlSystemImage.h>
enum class WebCore::AppKitControlSystemImageType : uint8_t {
    ScrollbarTrackCorner,
};
#endif // USE(APPKIT)

header: <WebCore/ListStyleType.h>
[Nested] enum class WebCore::ListStyleType::Type : uint8_t {
    CounterStyle,
    String,
    None
}

header: <WebCore/ScrollTypes.h>
enum class WebCore::ScrollIsAnimated : bool;

enum class WebCore::ScrollGranularity : uint8_t {
    Line,
    Page,
    Document,
    Pixel
};

[CustomHeader] struct WebCore::DOMCacheEngine::CrossThreadRecord {
    uint64_t identifier;
    uint64_t updateResponseCounter;
    WebCore::FetchHeadersGuard requestHeadersGuard;
    WebCore::ResourceRequest request;
    WebCore::FetchOptions options;
    String referrer;
    WebCore::FetchHeadersGuard responseHeadersGuard;
    WebCore::ResourceResponseData response;
    std::variant<std::nullptr_t, Ref<WebCore::FormData>, Ref<WebCore::SharedBuffer>> responseBody;
    uint64_t responseBodySize;
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::TransformationMatrix {
    double m11()
    double m12()
    double m13()
    double m14()
    double m21()
    double m22()
    double m23()
    double m24()
    double m31()
    double m32()
    double m33()
    double m34()
    double m41()
    double m42()
    double m43()
    double m44()
}

struct WebCore::CacheQueryOptions {
    bool ignoreSearch;
    bool ignoreMethod;
    bool ignoreVary;
}

struct WebCore::CharacterRange {
    uint64_t location
    uint64_t length
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::AffineTransform {
    double a()
    double b()
    double c()
    double d()
    double e()
    double f()
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatPoint {
    float x()
    float y()
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatPoint3D {
    float x()
    float y()
    float z()
}

class WebCore::FloatQuad {
    WebCore::FloatPoint p1();
    WebCore::FloatPoint p2();
    WebCore::FloatPoint p3();
    WebCore::FloatPoint p4();
}

struct WebCore::IDBCursorRecord {
    WebCore::IDBKeyData key;
    WebCore::IDBKeyData primaryKey;
    WebCore::IDBValue value;
}

class WebCore::IDBCursorInfo {
    WebCore::IDBResourceIdentifier identifier();
    WebCore::IDBResourceIdentifier transactionIdentifier();
    uint64_t objectStoreIdentifier();
    uint64_t sourceIdentifier();

    WebCore::IDBKeyRangeData range();

    WebCore::IndexedDB::CursorSource cursorSource();
    WebCore::IndexedDB::CursorDirection cursorDirection();
    WebCore::IndexedDB::CursorType cursorType();
};

class WebCore::IDBError {
    std::optional<WebCore::ExceptionCode> code()
    String messageForSerialization()
}

struct WebCore::IDBGetAllRecordsData {
    WebCore::IDBKeyRangeData keyRangeData;
    WebCore::IndexedDB::GetAllType getAllType;
    std::optional<uint32_t> count;
    uint64_t objectStoreIdentifier;
    uint64_t indexIdentifier;
}

class WebCore::IDBGetResult {
    WebCore::IDBKeyData keyData()
    WebCore::IDBKeyData primaryKeyData()
    WebCore::IDBValue value()
    std::optional<WebCore::IDBKeyPath> keyPath()
    Vector<WebCore::IDBCursorRecord> prefetchedRecords()
    bool isDefined()
}

class WebCore::IDBGetAllResult {
    WebCore::IndexedDB::GetAllType type()
    Vector<WebCore::IDBKeyData> keys()
    Vector<WebCore::IDBValue> values()
    std::optional<WebCore::IDBKeyPath> keyPath()
}

class WebCore::IDBDatabaseInfo {
    String m_name
    uint64_t m_version
    uint64_t m_maxIndexID
    uint64_t m_maxObjectStoreID
    HashMap<uint64_t, WebCore::IDBObjectStoreInfo> m_objectStoreMap
}

struct WebCore::IDBKeyRangeData {
    WebCore::IDBKeyData lowerKey;
    WebCore::IDBKeyData upperKey;

    bool lowerOpen;
    bool upperOpen;
};

class WebCore::IDBTransactionInfo {
    WebCore::IDBResourceIdentifier identifier();
    WebCore::IDBTransactionMode mode();
    WebCore::IDBTransactionDurability durability();
    uint64_t newVersion();
    Vector<String> objectStores();
    std::unique_ptr<WebCore::IDBDatabaseInfo> originalDatabaseInfo();
};

struct WebCore::IDBGetRecordData {
    WebCore::IDBKeyRangeData keyRangeData;
    WebCore::IDBGetRecordDataType type;
}

class WebCore::IDBIndexInfo {
    uint64_t identifier()
    uint64_t objectStoreIdentifier()
    String name()
    WebCore::IDBKeyPath keyPath()
    bool unique()
    bool multiEntry()
}

class WebCore::IDBObjectStoreInfo {
    uint64_t identifier()
    String name()
    std::optional<WebCore::IDBKeyPath> keyPath()
    bool autoIncrement()
    HashMap<uint64_t, WebCore::IDBIndexInfo> indexMap()
}

struct WebCore::IDBIterateCursorData {
    WebCore::IDBKeyData keyData;
    WebCore::IDBKeyData primaryKeyData;
    unsigned count;
    WebCore::IndexedDB::CursorIterateOption option;
}

class WebCore::IDBResourceIdentifier {
    WebCore::IDBConnectionIdentifier m_idbConnectionIdentifier
    uint64_t m_resourceNumber
}

class WebCore::IDBValue {
    WebCore::ThreadSafeDataBuffer data()
    Vector<String> blobURLs()
    Vector<String> blobFilePaths()
};

class WebCore::IDBRequestData {
    WebCore::IDBConnectionIdentifier m_serverConnectionIdentifier;
    WebCore::IDBResourceIdentifier m_requestIdentifier;
    std::optional<WebCore::IDBResourceIdentifier> m_transactionIdentifier;
    std::optional<WebCore::IDBResourceIdentifier> m_cursorIdentifier;
    uint64_t m_objectStoreIdentifier;
    uint64_t m_indexIdentifier;
    WebCore::IndexedDB::IndexRecordType m_indexRecordType;
    std::optional<WebCore::IDBDatabaseIdentifier> m_databaseIdentifier;
    uint64_t m_requestedVersion;
    WebCore::IndexedDB::RequestType m_requestType;
}

# FIXME: When decoding from IPC, databaseName can be null, and the non-empty constructor asserts that this is not the case.
[LegacyPopulateFromEmptyConstructor] class WebCore::IDBDatabaseIdentifier {
    String m_databaseName
    WebCore::ClientOrigin m_origin
    bool m_isTransient
}

struct WebCore::IDBDatabaseNameAndVersion {
    String name;
    uint64_t version;
}

[LegacyPopulateFromEmptyConstructor] class WebCore::IDBResultData {
    WebCore::IDBResultType m_type;
    WebCore::IDBResourceIdentifier m_requestIdentifier;
    WebCore::IDBError m_error;
    uint64_t m_databaseConnectionIdentifier;
    std::unique_ptr<WebCore::IDBDatabaseInfo> m_databaseInfo;
    std::unique_ptr<WebCore::IDBTransactionInfo> m_transactionInfo;
    std::unique_ptr<WebCore::IDBKeyData> m_resultKey;
    std::unique_ptr<WebCore::IDBGetResult> m_getResult;
    std::unique_ptr<WebCore::IDBGetAllResult> m_getAllResult;
    uint64_t m_resultInteger;
}

class WebCore::IDBKeyData {
    std::variant<std::nullptr_t, WebCore::IDBKeyData::Invalid, Vector<WebCore::IDBKeyData>, String, double, WebCore::IDBKeyData::Date, WebCore::ThreadSafeDataBuffer, WebCore::IDBKeyData::Min, WebCore::IDBKeyData::Max> value()
}

[Nested] struct WebCore::IDBKeyData::Invalid {
}

[Nested] struct WebCore::IDBKeyData::Min {
}

[Nested] struct WebCore::IDBKeyData::Max {
}

[Nested] struct WebCore::IDBKeyData::Date {
    double value
}

enum class WebCore::IndexedDB::KeyType : int8_t {
    Max,
    Invalid,
    Array,
    Binary,
    String,
    Date,
    Number,
    Min,
};

enum class WebCore::IndexedDB::CursorDirection : uint8_t {
    Next,
    Nextunique,
    Prev,
    Prevunique,
};

enum class WebCore::IndexedDB::ObjectStoreOverwriteMode : uint8_t {
    Overwrite,
    OverwriteForCursor,
    NoOverwrite,
};

enum class WebCore::IndexedDB::RequestType : uint8_t {
    Open,
    Delete,
    Other,
};

#if USE(CG)
headers: <CoreGraphics/CGGeometry.h> <CoreGraphics/CGAffineTransform.h>
[WebKitPlatform, AdditionalEncoder=StreamConnectionEncoder] struct CGSize {
    CGFloat width
    CGFloat height
};

[WebKitPlatform] struct CGPoint {
    CGFloat x
    CGFloat y
};

[WebKitPlatform] struct CGRect {
    CGPoint origin
    CGSize size
};

struct CGAffineTransform {
  CGFloat a
  CGFloat b
  CGFloat c
  CGFloat d
  CGFloat tx
  CGFloat ty
};
#endif

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatRect {
    WebCore::FloatPoint location()
    WebCore::FloatSize size()
}

[Nested] struct WebCore::LinearTimingFunction::Point {
    double value
    double progress
}

[RefCounted, CustomHeader] class WebCore::LinearTimingFunction {
    Vector<WebCore::LinearTimingFunction::Point> points()
};

[Nested] enum class WebCore::CubicBezierTimingFunction::TimingFunctionPreset : uint8_t {
    Ease,
    EaseIn,
    EaseOut,
    EaseInOut,
    Custom
};

[RefCounted, CustomHeader] class WebCore::CubicBezierTimingFunction {
    WebCore::CubicBezierTimingFunction::TimingFunctionPreset timingFunctionPreset()
    double x1()
    double y1()
    double x2()
    double y2()
};

[Nested] enum class WebCore::StepsTimingFunction::StepPosition : uint8_t {
    JumpStart,
    JumpEnd,
    JumpNone,
    JumpBoth,
    Start,
    End,
};

[RefCounted, CustomHeader] class WebCore::StepsTimingFunction {
    int numberOfSteps()
    std::optional<WebCore::StepsTimingFunction::StepPosition> stepPosition()
};

[RefCounted, CustomHeader] class WebCore::SpringTimingFunction {
    double mass()
    double stiffness()
    double damping()
    double initialVelocity()
};

[LegacyPopulateFromEmptyConstructor] struct WebCore::ResourceLoadStatistics {
    WebCore::RegistrableDomain registrableDomain;
    WallTime lastSeen;
    bool hadUserInteraction;
    WallTime mostRecentUserInteractionTime;
    bool grandfathered;
    HashSet<WebCore::RegistrableDomain> storageAccessUnderTopFrameDomains;
    HashSet<WebCore::RegistrableDomain> topFrameUniqueRedirectsTo;
    HashSet<WebCore::RegistrableDomain> topFrameUniqueRedirectsToSinceSameSiteStrictEnforcement;
    HashSet<WebCore::RegistrableDomain> topFrameUniqueRedirectsFrom;
    HashSet<WebCore::RegistrableDomain> topFrameLinkDecorationsFrom;
    bool gotLinkDecorationFromPrevalentResource;
    HashSet<WebCore::RegistrableDomain> topFrameLoadedThirdPartyScripts;
    HashSet<WebCore::RegistrableDomain> subframeUnderTopFrameDomains;
    HashSet<WebCore::RegistrableDomain> subresourceUnderTopFrameDomains;
    HashSet<WebCore::RegistrableDomain> subresourceUniqueRedirectsTo;
    HashSet<WebCore::RegistrableDomain> subresourceUniqueRedirectsFrom;
    bool isPrevalentResource;
    bool isVeryPrevalentResource;
    unsigned dataRecordsRemoved;
    unsigned timesAccessedAsFirstPartyDueToUserInteraction;
    unsigned timesAccessedAsFirstPartyDueToStorageAccessAPI;
#if ENABLE(WEB_API_STATISTICS)
    HashSet<WebCore::RegistrableDomain> topFrameRegistrableDomainsWhichAccessedWebAPIs;
    HashSet<String> fontsFailedToLoad;
    HashSet<String> fontsSuccessfullyLoaded;
    WebCore::CanvasActivityRecord canvasActivityRecord;
    OptionSet<WebCore::NavigatorAPIsAccessed> navigatorFunctionsAccessed;
    OptionSet<WebCore::ScreenAPIsAccessed> screenFunctionsAccessed;
#endif
};

[OptionSet] enum class WebCore::NavigatorAPIsAccessed : uint64_t {
    AppVersion,
    UserAgent,
    Plugins,
    MimeTypes,
    CookieEnabled
};

[OptionSet] enum class WebCore::ScreenAPIsAccessed : uint64_t {
    Height,
    Width,
    ColorDepth,
    AvailLeft,
    AvailTop,
    AvailHeight,
    AvailWidth
};

#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
header: <WebCore/GraphicsContextGLActiveInfo.h>
[AdditionalEncoder=StreamConnectionEncoder, CustomHeader] struct WebCore::GraphicsContextGLActiveInfo {
    String name;
    GCGLenum type;
    GCGLint size;
};
#endif

enum class WebCore::ViewportFit : uint8_t {
    Auto,
    Contain,
    Cover,
};

header: <WebCore/ViewportArguments.h>
[CustomHeader] struct WebCore::ViewportAttributes {
    WebCore::FloatSize layoutSize;

    float initialScale;
    float minimumScale;
    float maximumScale;

    float userScalable;
    float orientation;
    float shrinkToFit;

    WebCore::ViewportFit viewportFit;
};

header: <WebCore/ShareData.h>
[CustomHeader] struct WebCore::ShareDataWithParsedURL {
    WebCore::ShareData shareData;
    std::optional<URL> url;
    Vector<WebCore::RawFile> files;
    WebCore::ShareDataOriginator originator;
};

struct WebCore::ShareData {
    String title;
    String text;
    String url;
    [NotSerialized] Vector<RefPtr<WebCore::File>> files;
};

enum class WebCore::ShareDataOriginator : bool

[CustomHeader] struct WebCore::RawFile {
    String fileName;
    RefPtr<WebCore::SharedBuffer> fileData;
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatRoundedRect {
    WebCore::FloatRect rect();
    WebCore::FloatSize radii().topLeft();
    WebCore::FloatSize radii().topRight();
    WebCore::FloatSize radii().bottomLeft();
    WebCore::FloatSize radii().bottomRight();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::IntRect {
    WebCore::IntPoint location();
    [Validator='WebCore::IntRect { *location, *size }.isValid()'] WebCore::IntSize size();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::IntPoint {
    int x();
    int y();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::IntSize {
    int width();
    int height();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatSize {
    float width();
    float height();
}

[AdditionalEncoder=StreamConnectionEncoder, CreateUsing=fromRawValue] class WebCore::LayoutUnit {
    int rawValue()
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::LayoutPoint {
    WebCore::LayoutUnit x();
    WebCore::LayoutUnit y();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::LayoutSize {
    WebCore::LayoutUnit width();
    WebCore::LayoutUnit height();
}

struct WebCore::DictionaryPopupInfo {
    WebCore::FloatPoint origin;
    WebCore::TextIndicatorData textIndicator;
#if PLATFORM(COCOA)
    WebCore::DictionaryPopupInfoCocoa platformData;
#endif
};

enum class WebCore::PCM::AttributionEphemeral : bool
enum class WebCore::PCM::WasSent : bool

class WebCore::PrivateClickMeasurement {
    uint8_t sourceID()
    WebCore::PCM::SourceSite sourceSite()
    WebCore::PCM::AttributionDestinationSite destinationSite()
    WallTime timeOfAdClick()
    WebCore::PCM::AttributionEphemeral isEphemeral()
    std::optional<uint64_t> adamID()
    std::optional<WebCore::PCM::AttributionTriggerData> attributionTriggerData()
    WebCore::PCM::AttributionTimeToSendData timesToSend()
    std::optional<WebCore::PCM::EphemeralNonce> ephemeralSourceNonce()
    String sourceApplicationBundleID()
}

[CustomHeader] struct WebCore::PCM::SourceSite {
    WebCore::RegistrableDomain registrableDomain
}

[CustomHeader] struct WebCore::PCM::AttributionDestinationSite {
    WebCore::RegistrableDomain registrableDomain
}

[CustomHeader] struct WebCore::PCM::EphemeralNonce {
    String nonce
}

[CustomHeader] struct WebCore::PCM::AttributionTriggerData {
    uint8_t data
    uint8_t priority;
    WebCore::PCM::WasSent wasSent;
    std::optional<WebCore::RegistrableDomain> sourceRegistrableDomain;
    std::optional<WebCore::PCM::EphemeralNonce> ephemeralDestinationNonce;
    std::optional<WebCore::RegistrableDomain> destinationSite;
    [NotSerialized] std::optional<WebCore::PCM::DestinationUnlinkableToken> destinationUnlinkableToken;
    [NotSerialized] std::optional<WebCore::PCM::DestinationSecretToken> destinationSecretToken;
}

[CustomHeader] struct WebCore::PCM::AttributionTimeToSendData {
    std::optional<WallTime> sourceEarliestTimeToSend;
    std::optional<WallTime> destinationEarliestTimeToSend;
}

#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
struct WebCore::ApplePayRecurringPaymentRequest {
    String paymentDescription
    WebCore::ApplePayLineItem regularBilling
    std::optional<WebCore::ApplePayLineItem> trialBilling
    String billingAgreement
    String managementURL
    String tokenNotificationURL
};
#endif

#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
struct WebCore::ApplePayPaymentTokenContext {
    String merchantIdentifier
    String externalIdentifier
    String merchantName
    String merchantDomain
    String amount
}
#endif

#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
struct WebCore::ApplePayDeferredPaymentRequest {
    String billingAgreement
    WebCore::ApplePayLineItem deferredBilling
    WallTime freeCancellationDate
    String freeCancellationDateTimeZone
    String managementURL
    String paymentDescription
    String tokenNotificationURL
};
#endif

#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
struct WebCore::ApplePayPaymentOrderDetails {
    String orderTypeIdentifier
    String orderIdentifier
    String webServiceURL
    String authenticationToken
}
#endif

#if ENABLE(APPLE_PAY_AMS_UI) && ENABLE(PAYMENT_REQUEST)
struct WebCore::ApplePayAMSUIRequest {
    String engagementRequest
}
#endif

#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
struct WebCore::ApplePayAutomaticReloadPaymentRequest {
    String paymentDescription
    WebCore::ApplePayLineItem automaticReloadBilling
    String billingAgreement
    String managementURL
    String tokenNotificationURL
}
#endif

#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
struct WebCore::ApplePayDateComponents {
    std::optional<unsigned> years;
    std::optional<unsigned> months;
    std::optional<unsigned> days;
    std::optional<unsigned> hours;
}

struct WebCore::ApplePayDateComponentsRange {
    WebCore::ApplePayDateComponents startDateComponents;
    WebCore::ApplePayDateComponents endDateComponents;
}
#endif // ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)

#if ENABLE(APPLE_PAY)
struct WebCore::ApplePaySetupConfiguration {
    String merchantIdentifier;
    String referrerIdentifier;
    String signature;
    Vector<String> signedFields;
};

[Nested] enum class WebCore::ApplePayLineItem::Type : bool;

struct WebCore::ApplePayLineItem {
    WebCore::ApplePayLineItem::Type type
    String label
    String amount
    WebCore::ApplePayPaymentTiming paymentTiming
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    WallTime recurringPaymentStartDate
    WebCore::ApplePayRecurringPaymentDateUnit recurringPaymentIntervalUnit
    unsigned recurringPaymentIntervalCount
    WallTime recurringPaymentEndDate
#endif
#if ENABLE(APPLE_PAY_DEFERRED_LINE_ITEM)
    WallTime deferredPaymentDate
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_LINE_ITEM)
    String automaticReloadPaymentThresholdAmount
#endif
}

struct WebCore::ApplePayShippingMethod {
    String label
    String detail
    String amount
    String identifier
#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
    std::optional<WebCore::ApplePayDateComponentsRange> dateComponentsRange
#endif
#if ENABLE(APPLE_PAY_SELECTED_SHIPPING_METHOD)
    bool selected
#endif
}

[RefCounted] class WebCore::ApplePayError {
    WebCore::ApplePayErrorCode code()
    std::optional<WebCore::ApplePayErrorContactField> contactField()
    String message()
}

enum class WebCore::ApplePayLogoStyle : bool
[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::ApplePayLogoSystemImage {
    WebCore::ApplePayLogoStyle applePayLogoStyle()
}

struct WebCore::ApplePayDetailsUpdateBase {
    WebCore::ApplePayLineItem newTotal;
    Vector<WebCore::ApplePayLineItem> newLineItems;
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    std::optional<WebCore::ApplePayRecurringPaymentRequest> newRecurringPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest> newAutomaticReloadPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    std::optional<Vector<WebCore::ApplePayPaymentTokenContext>> newMultiTokenContexts;
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    std::optional<WebCore::ApplePayDeferredPaymentRequest> newDeferredPaymentRequest;
#endif
}

struct WebCore::ApplePayPaymentMethodUpdate : WebCore::ApplePayDetailsUpdateBase {
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    Vector<RefPtr<WebCore::ApplePayError>> errors;
    Vector<WebCore::ApplePayShippingMethod> newShippingMethods;
#endif
#if ENABLE(APPLE_PAY_INSTALLMENTS)
    String installmentGroupIdentifier;
#endif
};

struct WebCore::ApplePayShippingContactUpdate : WebCore::ApplePayDetailsUpdateBase {
    Vector<RefPtr<WebCore::ApplePayError>> errors;
    Vector<WebCore::ApplePayShippingMethod> newShippingMethods;
};

struct WebCore::ApplePayShippingMethodUpdate : WebCore::ApplePayDetailsUpdateBase {
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    Vector<WebCore::ApplePayShippingMethod> newShippingMethods;
#endif
};

struct WebCore::ApplePayPaymentAuthorizationResult {
    unsigned short status;
    Vector<RefPtr<WebCore::ApplePayError>> errors;
#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
    std::optional<WebCore::ApplePayPaymentOrderDetails> orderDetails;
#endif
}

enum class WebCore::ApplePayErrorContactField : uint8_t {
    PhoneNumber,
    EmailAddress,
    Name,
    PhoneticName,
    PostalAddress,
    AddressLines,
    SubLocality,
    Locality,
    PostalCode,
    SubAdministrativeArea,
    AdministrativeArea,
    Country,
    CountryCode,
};

enum class WebCore::ApplePayErrorCode : uint8_t {
    Unknown,
    ShippingContactInvalid,
    BillingContactInvalid,
    AddressUnserviceable,
#if ENABLE(APPLE_PAY_COUPON_CODE)
    CouponCodeInvalid,
    CouponCodeExpired,
#endif
};
#endif // ENABLE(APPLE_PAY)

#if ENABLE(APPLE_PAY_INSTALLMENTS)
header: <WebCore/ApplePayInstallmentConfigurationWebCore.h>
[CustomHeader] struct WebCore::ApplePayInstallmentConfiguration {
    WebCore::ApplePaySetupFeatureType featureType;
    String merchandisingImageData;
    String openToBuyThresholdAmount;
    String bindingTotalAmount;
    String currencyCode;
    bool isInStorePurchase;
    String merchantIdentifier;
    String referrerIdentifier;
    Vector<WebCore::ApplePayInstallmentItem> items;
    String applicationMetadata;
    WebCore::ApplePayInstallmentRetailChannel retailChannel;
};
header: <WebCore/PaymentInstallmentConfigurationWebCore.h>
[CustomHeader] class WebCore::PaymentInstallmentConfiguration {
    std::optional<WebCore::ApplePayInstallmentConfiguration> applePayInstallmentConfiguration()
}
struct WebCore::ApplePayInstallmentItem {
    WebCore::ApplePayInstallmentItemType type;
    String amount;
    String currencyCode;
    String programIdentifier;
    String apr;
    String programTerms;
};
enum class WebCore::ApplePaySetupFeatureType : bool
enum class WebCore::ApplePayInstallmentItemType : uint8_t {
    Generic,
    Phone,
    Pad,
    Watch,
    Mac,
};
enum class WebCore::ApplePayInstallmentRetailChannel : uint8_t {
    Unknown,
    App,
    Web,
    InStore,
};
#endif // ENABLE(APPLE_PAY_INSTALLMENTS)

#if ENABLE(APPLE_PAY_COUPON_CODE)
struct WebCore::ApplePayCouponCodeUpdate : WebCore::ApplePayDetailsUpdateBase {
    Vector<RefPtr<WebCore::ApplePayError>> errors;
    Vector<WebCore::ApplePayShippingMethod> newShippingMethods;
};
#endif

header: <WebCore/ScreenOrientationLockType.h>
enum class WebCore::ScreenOrientationLockType : uint8_t {
    Any
    Natural
    Landscape
    Portrait
    PortraitPrimary
    PortraitSecondary
    LandscapePrimary
    LandscapeSecondary
};

#if ENABLE(APPLICATION_MANIFEST)
[Nested] enum class WebCore::ApplicationManifest::Display : uint8_t {
    Browser
    MinimalUI
    Standalone
    Fullscreen
};

[Nested, OptionSet] enum class WebCore::ApplicationManifest::Icon::Purpose : uint8_t {
    Any
    Monochrome
    Maskable
}

[Nested] struct WebCore::ApplicationManifest::Icon {
    URL src
    Vector<String> sizes
    String type
    OptionSet<WebCore::ApplicationManifest::Icon::Purpose> purposes
}

[Nested] struct WebCore::ApplicationManifest::Shortcut {
    String name
    URL url
    Vector<WebCore::ApplicationManifest::Icon> icons
}

struct WebCore::ApplicationManifest {
    String rawJSON
    String name
    String shortName
    String description
    URL scope
    bool isDefaultScope
    WebCore::ApplicationManifest::Display display
    std::optional<WebCore::ScreenOrientationLockType> orientation
    URL manifestURL
    URL startURL
    URL id
    WebCore::Color backgroundColor
    WebCore::Color themeColor
    Vector<String> categories
    Vector<WebCore::ApplicationManifest::Icon> icons
    Vector<WebCore::ApplicationManifest::Shortcut> shortcuts
}
#endif // ENABLE(APPLICATION_MANIFEST)

enum class WebCore::DOMCacheEngine::Error : uint8_t {
    NotImplemented,
    ReadDisk,
    WriteDisk,
    QuotaExceeded,
    Internal,
    Stopped,
    CORP
};

struct WebCore::RetrieveRecordsOptions {
    WebCore::ResourceRequest request;
    WebCore::CrossOriginEmbedderPolicy crossOriginEmbedderPolicy;
    Ref<WebCore::SecurityOrigin> sourceOrigin;
    bool ignoreSearch;
    bool ignoreMethod;
    bool ignoreVary;
    bool shouldProvideResponse;
};

struct WebCore::ContactInfo {
    Vector<String> name;
    Vector<String> email;
    Vector<String> tel;
};

struct WebCore::ContactsRequestData {
    Vector<WebCore::ContactProperty> properties;
    bool multiple;
    String url;
};

#if ENABLE(MEDIA_SESSION)
struct WebCore::MediaPositionState {
    double duration;
    double playbackRate;
    double position;
};
#endif // ENABLE(MEDIA_SESSION)

#if ENABLE(WEB_RTC)
struct WebCore::DetachedRTCDataChannel {
    WebCore::RTCDataChannelIdentifier identifier;
    String label;
    WebCore::RTCDataChannelInit options;
    WebCore::RTCDataChannelState state;
};
#endif

header: <WebCore/WebCodecsEncodedVideoChunk.h>
#if ENABLE(WEB_CODECS)
enum class WebCore::WebCodecsEncodedVideoChunkType : bool;
struct WebCore::WebCodecsEncodedVideoChunkData {
    WebCore::WebCodecsEncodedVideoChunkType type;
    int64_t timestamp;
    std::optional<uint64_t> duration;
    Vector<uint8_t> buffer;
};
#endif

header: <WebCore/WebCodecsEncodedAudioChunk.h>
#if ENABLE(WEB_CODECS)
enum class WebCore::WebCodecsEncodedAudioChunkType : bool;
struct WebCore::WebCodecsEncodedAudioChunkData {
    WebCore::WebCodecsEncodedAudioChunkType type;
    int64_t timestamp;
    std::optional<uint64_t> duration;
    Vector<uint8_t> buffer;
};
#endif

header: <WebCore/VideoEncoderScalabilityMode.h>
#if ENABLE(WEB_CODECS)
enum class WebCore::VideoEncoderScalabilityMode : uint8_t {
    L1T1,
    L1T2,
    L1T3
}
#endif

struct WebCore::HTMLModelElementCamera {
    double pitch;
    double yaw;
    double scale;
};

struct WebCore::NotificationData {
    URL defaultActionURL;
    String title;
    String body;
    String iconURL;
    String tag;
    String language;
    WebCore::NotificationDirection direction;
    String originString;
    URL serviceWorkerRegistrationURL;
    WTF::UUID notificationID;
    WebCore::ScriptExecutionContextIdentifier contextIdentifier;
    PAL::SessionID sourceSession;
    MonotonicTime creationTime;
    Vector<uint8_t> data;
    std::optional<bool> silent;
};

struct WebCore::PermissionDescriptor {
    WebCore::PermissionName name;
}

struct WebCore::PushSubscriptionData {
    WebCore::PushSubscriptionIdentifier identifier;
    String endpoint;
    std::optional<WebCore::EpochTimeStamp> expirationTime;
    Vector<uint8_t> serverVAPIDPublicKey;
    Vector<uint8_t> clientECDHPublicKey;
    Vector<uint8_t> sharedAuthenticationSecret;
};

[RefCounted] class WebCore::DeprecationReportBody {
    String id()
    WallTime anticipatedRemoval()
    String message()
    String sourceFile()
    std::optional<unsigned> lineNumber()
    std::optional<unsigned> columnNumber()
};

[RefCounted] class WebCore::Report {
    String type()
    String url()
    RefPtr<WebCore::ReportBody> body()
};

[RefCounted] class WebCore::TestReportBody {
    String message()
}

enum class WebCore::SpeechRecognitionErrorType : uint8_t {
    NoSpeech,
    Aborted,
    AudioCapture,
    Network,
    NotAllowed,
    ServiceNotAllowed,
    BadGrammar,
    LanguageNotSupported
};

struct WebCore::SpeechRecognitionError {
    WebCore::SpeechRecognitionErrorType type;
    String message;
};

struct WebCore::SpeechRecognitionRequestInfo {
    WebCore::SpeechRecognitionConnectionClientIdentifier clientIdentifier;
    String lang;
    bool continuous;
    bool interimResults;
    uint64_t maxAlternatives;
    WebCore::ClientOrigin clientOrigin;
    WebCore::FrameIdentifier frameIdentifier;
};

[CustomHeader] struct WebCore::SpeechRecognitionAlternativeData {
    String transcript;
    double confidence;
};

struct WebCore::SpeechRecognitionResultData {
    Vector<WebCore::SpeechRecognitionAlternativeData> alternatives;
    bool isFinal;
};

struct WebCore::WebLockManagerSnapshot {
    Vector<WebCore::WebLockManagerSnapshot::Info> held;
    Vector<WebCore::WebLockManagerSnapshot::Info> pending;
};

[Nested] struct WebCore::WebLockManagerSnapshot::Info {
    String name;
    WebCore::WebLockMode mode;
    String clientId;
};

#if ENABLE(WEB_AUTHN)

[CustomHeader] struct WebCore::AuthenticatorResponseBaseData {
    RefPtr<JSC::ArrayBuffer> rawId;
    std::optional<WebCore::AuthenticationExtensionsClientOutputs> extensionOutputs;
};

[CustomHeader] struct WebCore::AuthenticatorAttestationResponseData {
    RefPtr<JSC::ArrayBuffer> rawId;
    std::optional<WebCore::AuthenticationExtensionsClientOutputs> extensionOutputs;
    RefPtr<JSC::ArrayBuffer> clientDataJSON;
    RefPtr<JSC::ArrayBuffer> attestationObject;
    Vector<WebCore::AuthenticatorTransport> transports;
};

[CustomHeader] struct WebCore::AuthenticatorAssertionResponseData {
    RefPtr<JSC::ArrayBuffer> rawId;
    std::optional<WebCore::AuthenticationExtensionsClientOutputs> extensionOutputs;
    RefPtr<JSC::ArrayBuffer> clientDataJSON;
    RefPtr<JSC::ArrayBuffer> authenticatorData;
    RefPtr<JSC::ArrayBuffer> signature;
    RefPtr<JSC::ArrayBuffer> userHandle;
};

using WebCore::AuthenticatorResponseDataSerializableForm = std::variant<std::nullptr_t, WebCore::AuthenticatorResponseDataBase, WebCore::AuthenticatorAttestationResponseData, WebCore::AuthenticatorAssertionResponseData>;

struct WebCore::AuthenticatorResponseData {
    WebCore::AuthenticatorResponseDataSerializableForm getSerializableForm();
};

[Nested] struct WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs {
    String support;
    std::optional<bool> read;
    std::optional<WebCore::BufferSource> write;
}

[LegacyPopulateFromEmptyConstructor] struct WebCore::AuthenticationExtensionsClientInputs {
    String appid;
    [NotSerialized] bool credProps;
    std::optional<WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs> largeBlob;
}

[Nested] struct WebCore::AuthenticationExtensionsClientOutputs::CredentialPropertiesOutput {
    bool rk;
};

[Nested] struct WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs {
    std::optional<bool> supported;
    RefPtr<JSC::ArrayBuffer> blob;
    std::optional<bool> written;
};

struct WebCore::AuthenticationExtensionsClientOutputs {
    std::optional<bool> appid;
    std::optional<WebCore::AuthenticationExtensionsClientOutputs::CredentialPropertiesOutput> credProps;
    std::optional<WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs> largeBlob;
}

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::Parameters {
    WebCore::PublicKeyCredentialType type;
    int64_t alg;
};

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::AuthenticatorSelectionCriteria {
    std::optional<WebCore::AuthenticatorAttachment> authenticatorAttachment;
    std::optional<WebCore::ResidentKeyRequirement> residentKey;
    bool requireResidentKey;
    WebCore::UserVerificationRequirement userVerification;
};

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::Entity {
    String name;
    String icon;
};

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::RpEntity : WebCore::PublicKeyCredentialCreationOptions::Entity {
    std::optional<String> id;
};

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::UserEntity : WebCore::PublicKeyCredentialCreationOptions::Entity {
    WebCore::BufferSource id;
    String displayName;
};

struct WebCore::PublicKeyCredentialDescriptor {
    WebCore::PublicKeyCredentialType type;
    WebCore::BufferSource id;
    Vector<WebCore::AuthenticatorTransport> transports;
};
#endif // ENABLE(WEB_AUTHN)

#if ENABLE(WEB_AUTHN)
enum class WebCore::AttestationConveyancePreference : uint8_t {
    None,
    Indirect,
    Direct,
    Enterprise
};
#endif

struct WebCore::PublicKeyCredentialCreationOptions {
#if ENABLE(WEB_AUTHN)
    WebCore::PublicKeyCredentialCreationOptions::RpEntity rp;
    WebCore::PublicKeyCredentialCreationOptions::UserEntity user;

    WebCore::BufferSource challenge;
    Vector<WebCore::PublicKeyCredentialCreationOptions::Parameters> pubKeyCredParams;

    std::optional<unsigned> timeout;
    Vector<WebCore::PublicKeyCredentialDescriptor> excludeCredentials;
    std::optional<WebCore::PublicKeyCredentialCreationOptions::AuthenticatorSelectionCriteria> authenticatorSelection;
    WebCore::AttestationConveyancePreference attestation;
    std::optional<WebCore::AuthenticationExtensionsClientInputs> extensions;
#endif // ENABLE(WEB_AUTHN)
};

struct WebCore::PublicKeyCredentialRequestOptions {
#if ENABLE(WEB_AUTHN)
    WebCore::BufferSource challenge;
    std::optional<unsigned> timeout;
    String rpId;
    Vector<WebCore::PublicKeyCredentialDescriptor> allowCredentials;
    WebCore::UserVerificationRequirement userVerification;
    std::optional<WebCore::AuthenticationExtensionsClientInputs> extensions;
    [NotSerialized] std::optional<WebCore::AuthenticatorAttachment> authenticatorAttachment;
#endif // ENABLE(WEB_AUTHN)
};

[CreateUsing=fromRawString] class WebCore::RegistrableDomain {
    String string()
}

struct WebCore::AudioConfiguration {
    String contentType;
    String channels;
    std::optional<uint64_t> bitrate;
    std::optional<uint32_t> samplerate;
    std::optional<bool> spatialRendering;
};

[Nested] enum class WebCore::Cookie::SameSitePolicy : uint8_t {
    None
    Lax
    Strict
};

struct WebCore::Cookie {
    String name;
    String value;
    String domain;
    String path;
    double created;
    std::optional<double> expires;
    bool httpOnly;
    bool secure;
    bool session;
    String comment;
    URL commentURL;
    Vector<uint16_t> ports;
    WebCore::Cookie::SameSitePolicy sameSite;
};

#if ENABLE(VIDEO)
struct WebCore::VideoFrameMetadata {
    double presentationTime;
    double expectedDisplayTime;

    unsigned width;
    unsigned height;
    double mediaTime;

    unsigned presentedFrames;
    std::optional<double> processingDuration;

    std::optional<double> captureTime;
    std::optional<double> receiveTime;
    std::optional<unsigned> rtpTimestamp;
};
#endif // ENABLE(VIDEO)

struct WebCore::NavigationPreloadState {
    bool enabled;
    String headerValue;
};

enum class WebCore::RenderingMode : bool

enum class WebCore::RenderingPurpose : uint8_t {
    Unspecified,
    Canvas,
    DOM,
    LayerBacking,
    BitmapOnlyLayerBacking,
    Snapshot,
    ShareableSnapshot,
    ShareableLocalSnapshot,
    MediaPainting,
};

enum class WebCore::RotationDirection : bool

#if ENABLE(CONTENT_FILTERING)
[LegacyPopulateFromEmptyConstructor] class WebCore::MockContentFilterSettings {
    bool m_enabled;
    WebCore::MockContentFilterSettings::DecisionPoint m_decisionPoint;
    WebCore::MockContentFilterSettings::Decision m_decision;
    WebCore::MockContentFilterSettings::Decision m_unblockRequestDecision;
    String m_blockedString;
    String m_modifiedRequestURL;
}
[Nested] enum class WebCore::MockContentFilterSettings::DecisionPoint : uint8_t {
    AfterWillSendRequest,
    AfterRedirect,
    AfterResponse,
    AfterAddData,
    AfterFinishedAddingData,
    Never
};
[Nested] enum class WebCore::MockContentFilterSettings::Decision : bool
#endif

enum class WebCore::AutoplayEvent : uint8_t {
    DidPreventMediaFromPlaying,
    DidPlayMediaWithUserGesture,
    DidAutoplayMediaPastThresholdWithoutUserInterference,
    UserDidInterfereWithPlayback
};

enum class WebCore::InputMode : uint8_t {
    Unspecified,
    None,
    Text,
    Telephone,
    Url,
    Email,
    Numeric,
    Decimal,
    Search
};

enum class WebCore::IndexedDB::GetAllType : bool

enum class WebCore::WorkerType : bool

enum class WebCore::StoredCredentialsPolicy : uint8_t {
    DoNotUse,
    Use,
    EphemeralStateless
};

enum class WebCore::ContentSniffingPolicy : bool;
enum class WebCore::ContentEncodingSniffingPolicy : bool;
enum class WebCore::ClientCredentialPolicy : bool;
enum class WebCore::ShouldRelaxThirdPartyCookieBlocking : bool;

enum class WebCore::PreflightPolicy : uint8_t {
    Consider,
    Force,
    Prevent
};

enum class WTFLogChannelState : uint8_t {
    Off,
    On,
    OnWithAccumulation
};

enum class WebCore::ScrollSnapStrictness : uint8_t {
    None,
    Proximity,
    Mandatory
};

enum class WebCore::LengthType : uint8_t {
    Auto,
    Relative,
    Percent,
    Fixed,
    Intrinsic,
    MinIntrinsic,
    MinContent,
    MaxContent,
    FillAvailable,
    FitContent,
    Calculated,
    Undefined
};

enum class WebCore::OverscrollBehavior : uint8_t {
    Auto,
    Contain,
    None
};

enum class WebCore::ScrollPinningBehavior : uint8_t {
    DoNotPin,
    PinToTop,
    PinToBottom
};

header: <WebCore/PlatformWheelEvent.h>
enum class WebCore::WheelScrollGestureState : uint8_t {
    Blocking,
    NonBlocking
};

struct WebCore::ExceptionDetails {
    String message;
    int lineNumber;
    int columnNumber;
    WebCore::ExceptionDetails::Type type;
    String sourceURL;
};

header: <WebCore/RectEdges.h>
[Alias=class RectEdges<float>, AdditionalEncoder=StreamConnectionEncoder, CustomHeader] alias WebCore::FloatBoxExtent {
    float top()
    float right()
    float bottom()
    float left()
};

[Alias=class RectEdges<bool>, AdditionalEncoder=StreamConnectionEncoder, CustomHeader] alias WebCore::BoolBoxExtent {
    bool top();
    bool right();
    bool bottom();
    bool left();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::Path {
    Vector<WebCore::PathSegment> segments();
}

#if ENABLE(META_VIEWPORT)

[Nested] enum class WebCore::ViewportArguments::Type : uint8_t {
    Implicit,
#if PLATFORM(IOS_FAMILY)
    PluginDocument,
    ImageDocument,
#endif
    ViewportMeta,
    CSSDeviceAdaptation
};

struct WebCore::ViewportArguments {
    WebCore::ViewportArguments::Type type;
    float width;
    float minWidth;
    float maxWidth;
    float height;
    float minHeight;
    float maxHeight;
    float zoom;
    float minZoom;
    float maxZoom;
    float userZoom;
    float orientation;
    float shrinkToFit;
    WebCore::ViewportFit viewportFit;
    bool widthWasExplicit;
};
#endif // ENABLE(META_VIEWPORT)

header: <WebCore/HTTPHeaderMap.h>
[Nested, CustomHeader] struct WebCore::HTTPHeaderMap::CommonHeader {
    WebCore::HTTPHeaderName key;
    String value;
};

header: <WebCore/HTTPHeaderMap.h>
[Nested, CustomHeader] struct WebCore::HTTPHeaderMap::UncommonHeader {
    String key;
    String value;
};

class WebCore::HTTPHeaderMap {
    Vector<WebCore::HTTPHeaderMap::CommonHeader, 0, CrashOnOverflow, 6> commonHeaders();
    Vector<WebCore::HTTPHeaderMap::UncommonHeader, 0, CrashOnOverflow, 0> uncommonHeaders();
}

struct WebCore::ElementContext {
    WebCore::FloatRect boundingRect;
    WebCore::PageIdentifier webPageIdentifier;
    WebCore::ScriptExecutionContextIdentifier documentIdentifier;
    WebCore::ElementIdentifier elementIdentifier;
};

struct WebCore::ElementAnimationContext {
    WebCore::ElementContext element;
    bool isAnimating;
};

header: <WebCore/FrameLoaderTypes.h>
[CustomHeader] struct WebCore::SystemPreviewInfo {
    WebCore::ElementContext element;
    WebCore::IntRect previewRect;
    bool isPreview;
};

header: <WebCore/ResourceRequest.h>
[CustomHeader, Nested] class WebCore::ResourceRequest::RequestData {
    URL m_url;
    URL m_firstPartyForCookies;
    double m_timeoutInterval;
    String m_httpMethod;
    WebCore::HTTPHeaderMap m_httpHeaderFields;
    Vector<String> m_responseContentDispositionEncodingFallbackArray;
    WebCore::ResourceRequestCachePolicy m_cachePolicy;
    WebCore::ResourceRequestBase::SameSiteDisposition m_sameSiteDisposition;
    WebCore::ResourceLoadPriority m_priority;
    WebCore::ResourceRequestRequester m_requester;
    [BitField] bool m_allowCookies;
    [BitField] bool m_isTopSite;
    [BitField] bool m_isAppInitiated;
    [BitField] bool m_privacyProxyFailClosedForUnreachableNonMainHosts;
    [BitField] bool m_useAdvancedPrivacyProtections;
    [BitField] bool m_didFilterLinkDecoration;
    [BitField] bool m_isPrivateTokenUsageByThirdPartyAllowed;
};

#if USE(SOUP)
header: <WebCore/ResourceRequest.h>
[CustomHeader] struct WebCore::ResourceRequestPlatformData {
    WebCore::ResourceRequest::RequestData requestData;
    bool acceptEncoding;
    uint16_t redirectCount;
};
#endif

#if PLATFORM(COCOA)
[CreateUsing=fromResourceRequestData] class WebCore::ResourceRequest {
    std::variant<WebCore::ResourceRequest::RequestData, WebCore::ResourceRequestPlatformData> getRequestDataToSerialize();
    String cachePartition();
    bool hiddenFromInspector();
};
#endif

#if USE(CURL)
[CreateUsing=fromResourceRequestData] class WebCore::ResourceRequest {
    WebCore::ResourceRequest::RequestData getRequestDataToSerialize();
};
#endif

#if !USE(CURL) && !PLATFORM(COCOA)
header: <WebCore/ResourceRequest.h>
[CreateUsing=fromResourceRequestData] class WebCore::ResourceRequest {
    std::variant<WebCore::ResourceRequest::RequestData, WebCore::ResourceRequestPlatformData> getRequestDataToSerialize();
};
#endif

[Nested] struct WebCore::ResourceError::IPCData {
    [Validator='*type != WebCore::ResourceError::Type::Null'] WebCore::ResourceError::Type type;
#if PLATFORM(COCOA)
    RetainPtr<NSError> nsError;
    bool isSanitized;
#endif // PLATFORM(COCOA)
#if !PLATFORM(COCOA)
    String domain;
    int errorCode;
    URL failingURL;
    String localizedDescription;
    WebCore::ResourceError::IsSanitized isSanitized;
#endif // !PLATFORM(COCOA)
#if USE(SOUP)
    WebCore::CertificateInfo certificateInfo;
#endif // USE(SOUP)
};

header: <WebCore/ResourceError.h>
[CreateUsing=fromIPCData] class WebCore::ResourceError {
    std::optional<WebCore::ResourceError::IPCData> ipcData();
};

header: <WebCore/DiagnosticLoggingDomain.h>
enum class WebCore::DiagnosticLoggingDomain : uint8_t {
    Media
};

#if !USE(CG)
[Nested] enum class WebCore::PlatformColorSpace::Name : uint8_t {
        SRGB
#if ENABLE(DESTINATION_COLOR_SPACE_LINEAR_SRGB)
        , LinearSRGB
#endif
#if ENABLE(DESTINATION_COLOR_SPACE_DISPLAY_P3)
        , DisplayP3
#endif
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::PlatformColorSpace {
    WebCore::PlatformColorSpace::Name get();
};
#endif

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::DestinationColorSpace {
        WebCore::PlatformColorSpace serializableColorSpace();
};

struct WebCore::WindowFeatures {
    bool hasAdditionalFeatures;

    std::optional<float> x;
    std::optional<float> y;
    std::optional<float> width;
    std::optional<float> height;

    std::optional<bool> popup;
    std::optional<bool> menuBarVisible;
    std::optional<bool> statusBarVisible;
    std::optional<bool> toolBarVisible;
    std::optional<bool> locationBarVisible;
    std::optional<bool> scrollbarsVisible;
    std::optional<bool> resizable;

    std::optional<bool> fullscreen;
    std::optional<bool> dialog;
    [NotSerialized] std::optional<bool> noopener;
    [NotSerialized] std::optional<bool> noreferrer;

    [NotSerialized] Vector<String> additionalFeatures;
};

[Nested] enum class WebCore::CompositionUnderlineColor : bool

struct WebCore::CompositionUnderline {
    unsigned startOffset;
    unsigned endOffset;
    WebCore::CompositionUnderlineColor compositionUnderlineColor;
    WebCore::Color color;
    bool thick;
};

enum class WebCore::MediaCaptureType : uint8_t {
    MediaCaptureTypeNone,
    MediaCaptureTypeUser,
    MediaCaptureTypeEnvironment
};

#if PLATFORM(COCOA) && ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
header: <WebCore/GraphicsContextGL.h>
[CustomHeader, RValue] struct WebCore::GraphicsContextGLEGLImageSourceIOSurfaceHandle {
    MachSendRight handle;
};

[CustomHeader, RValue] struct WebCore::GraphicsContextGLEGLImageSourceMTLSharedTextureHandle {
    MachSendRight handle;
};
#endif // PLATFORM(COCOA) && ENABLE(GPU_PROCESS) && ENABLE(WEBGL)

#if ENABLE(ATTACHMENT_ELEMENT)
struct WebCore::SerializedAttachmentData {
    String identifier;
    String mimeType;
    Ref<WebCore::SharedBuffer> data;
};

header: <WebCore/AttachmentAssociatedElement.h>
[CustomHeader] enum class WebCore::AttachmentAssociatedElementType : uint8_t {
    None,
    Image,
    Source,
};

#endif // ENABLE(ATTACHMENT_ELEMENT)

header: <WebCore/FileChooser.h>
[CustomHeader] struct WebCore::FileChooserSettings {
    bool allowsDirectories;
    bool allowsMultipleFiles;
    Vector<String> acceptMIMETypes;
    Vector<String> acceptFileExtensions;
    Vector<String> selectedFiles;
#if ENABLE(MEDIA_CAPTURE)
    WebCore::MediaCaptureType mediaCaptureType;
#endif
};

header: <WebCore/TextChecking.h>
[CustomHeader] struct WebCore::GrammarDetail {
    WebCore::CharacterRange range;
    Vector<String> guesses;
    String userDescription;
};

header: <WebCore/TextChecking.h>
[CustomHeader] struct WebCore::TextCheckingResult {
    OptionSet<WebCore::TextCheckingType> type;
    WebCore::CharacterRange range;
    Vector<WebCore::GrammarDetail> details;
    String replacement;
};

header: <WebCore/TextChecking.h>
[CustomHeader] enum class WebCore::TextCheckingProcessType : bool

header: <WebCore/TextChecking.h>
[CustomHeader] class WebCore::TextCheckingRequestData {
    std::optional<WebCore::TextCheckingRequestIdentifier> identifier();
    String text();
    OptionSet<WebCore::TextCheckingType> checkingTypes();
    WebCore::TextCheckingProcessType processType();
};

class WebCore::LayoutRect {
    WebCore::LayoutPoint m_location;
    WebCore::LayoutSize m_size;
};

header: <WebCore/VP9Utilities.h>
[CustomHeader] struct WebCore::ScreenDataOverrides {
    double width;
    double height;
    double scale;
}

class WebCore::BlobPart {
    std::variant<Vector<uint8_t>, URL> m_dataOrURL;
};

[WebKitPlatform] enum class WebCore::ColorSpace : uint8_t {
    A98RGB,
    DisplayP3,
    ExtendedA98RGB,
    ExtendedDisplayP3,
    ExtendedLinearSRGB,
    ExtendedProPhotoRGB,
    ExtendedRec2020,
    ExtendedSRGB,
    HSL,
    HWB,
    LCH,
    Lab,
    LinearSRGB,
    OKLCH,
    OKLab,
    ProPhotoRGB,
    Rec2020,
    SRGB,
    XYZ_D50,
    XYZ_D65,
}

header: <WebCore/ColorTypes.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder, WebKitPlatform] struct WebCore::PackedColor::RGBA {
    uint32_t value;
}

header: <WebCore/Color.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder, WebKitPlatform] struct WebCore::OutOfLineColorDataForIPC {
    WebCore::ColorSpace colorSpace;
    float c1;
    float c2;
    float c3;
    float alpha;
}

[CustomHeader, AdditionalEncoder=StreamConnectionEncoder, WebKitPlatform] struct WebCore::ColorDataForIPC {
    bool isSemantic;
    bool usesFunctionSerialization;
    std::variant<WebCore::PackedColor::RGBA, WebCore::OutOfLineColorDataForIPC> data;
}

[AdditionalEncoder=StreamConnectionEncoder, WebKitPlatform] class WebCore::Color {
    std::optional<WebCore::ColorDataForIPC> data();
}

struct WebCore::MediaCapabilitiesInfo {
    bool supported;
    bool smooth;
    bool powerEfficient;
}
header: <WebCore/MediaStreamRequest.h>
[Nested, CustomHeader] enum class WebCore::MediaStreamRequest::Type : uint8_t {
    UserMedia,
    DisplayMedia,
    DisplayMediaWithAudio
}
#if ENABLE(MEDIA_STREAM)
struct WebCore::MediaStreamRequest {
    WebCore::MediaStreamRequest::Type type;
    WebCore::MediaConstraints audioConstraints;
    WebCore::MediaConstraints videoConstraints;
    bool isUserGesturePriviledged;
    WebCore::PageIdentifier pageIdentifier;
}
[LegacyPopulateFromEmptyConstructor, CustomHeader] class WebCore::MediaTrackConstraintSetMap {
    std::optional<WebCore::IntConstraint> m_width;
    std::optional<WebCore::IntConstraint> m_height;
    std::optional<WebCore::IntConstraint> m_sampleRate;
    std::optional<WebCore::IntConstraint> m_sampleSize;
    std::optional<WebCore::DoubleConstraint> m_aspectRatio;
    std::optional<WebCore::DoubleConstraint> m_frameRate;
    std::optional<WebCore::DoubleConstraint> m_volume;
    std::optional<WebCore::BooleanConstraint> m_echoCancellation;
    std::optional<WebCore::BooleanConstraint> m_displaySurface;
    std::optional<WebCore::BooleanConstraint> m_logicalSurface;
    std::optional<WebCore::StringConstraint> m_facingMode;
    std::optional<WebCore::StringConstraint> m_deviceId;
    std::optional<WebCore::StringConstraint> m_groupId;
    std::optional<WebCore::StringConstraint> m_whiteBalanceMode;
    std::optional<WebCore::DoubleConstraint> m_zoom;
    std::optional<WebCore::BooleanConstraint> m_torch;
}
#endif

#if ! ENABLE(MEDIA_STREAM)
struct WebCore::MediaStreamRequest {
    WebCore::MediaStreamRequest::Type type;
};
#endif
struct WebCore::MediaCapabilitiesDecodingInfo : WebCore::MediaCapabilitiesInfo {
    WebCore::MediaDecodingConfiguration supportedConfiguration;
}

struct WebCore::MediaCapabilitiesEncodingInfo : WebCore::MediaCapabilitiesInfo {
    WebCore::MediaEncodingConfiguration supportedConfiguration;
}

header: <WebCore/FormData.h>
[CustomHeader] struct WebCore::FormDataElement {
    std::variant<Vector<uint8_t>, WebCore::FormDataElement::EncodedFileData, WebCore::FormDataElement::EncodedBlobData> data
}

[Nested] struct WebCore::FormDataElement::EncodedFileData {
    String filename;
    int64_t fileStart;
    int64_t fileLength;
    std::optional<WallTime> expectedFileModificationTime;
}

[Nested] struct WebCore::FormDataElement::EncodedBlobData {
    URL url;
}

header: <WebCore/NetworkLoadInformation.h>
[CustomHeader] struct WebCore::NetworkTransactionInformation {
    WebCore::NetworkTransactionInformation::Type type;
    WebCore::ResourceRequest request;
    WebCore::ResourceResponse response;
    WebCore::NetworkLoadMetrics metrics;
};

[Nested] enum class WebCore::NetworkTransactionInformation::Type : bool

class WebCore::ContentType {
    String raw()
}

#if ENABLE(DATE_AND_TIME_INPUT_TYPES)
struct WebCore::DateTimeChooserParameters {
    AtomString type;
    WebCore::IntRect anchorRectInRootView;
    AtomString locale;
    String currentValue;
    Vector<String> suggestionValues;
    Vector<String> localizedSuggestionValues;
    Vector<String> suggestionLabels;
    double minimum;
    double maximum;
    double step;
    double stepBase;
    bool required;
    bool isAnchorElementRTL;
    bool useDarkAppearance;
    bool hasSecondField;
    bool hasMillisecondField;
}
#endif

header: <WebCore/ScreenProperties.h>
[CustomHeader] struct WebCore::ScreenData {
    WebCore::FloatRect screenAvailableRect;
    WebCore::FloatRect screenRect;
    WebCore::DestinationColorSpace colorSpace;
    int screenDepth;
    int screenDepthPerComponent;
    bool screenSupportsExtendedColor;
    bool screenHasInvertedColors;
    bool screenSupportsHighDynamicRange;
#if PLATFORM(MAC)
    WebCore::FloatSize screenSize;
    bool screenIsMonochrome;
    uint32_t displayMask;
    WebCore::PlatformGPUID gpuID;
    WebCore::DynamicRangeMode preferredDynamicRangeMode;
#endif
#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
    WebCore::IntSize screenSize;
    double dpi;
#endif
#if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
    float scaleFactor;
#endif
};

using WebCore::PlatformDisplayID = uint32_t;
struct WebCore::ScreenProperties {
    WebCore::PlatformDisplayID primaryDisplayID;
    HashMap<WebCore::PlatformDisplayID, WebCore::ScreenData> screenDataMap;
};

class WebCore::PlatformTimeRanges {
    Vector<WebCore::PlatformTimeRanges::Range> m_ranges;
}

[Nested] struct WebCore::PlatformTimeRanges::Range {
    MediaTime start;
    MediaTime end;
}

#if ENABLE(VIDEO)
struct WebCore::VideoPlaybackQualityMetrics {
    uint32_t totalVideoFrames;
    uint32_t droppedVideoFrames;
    uint32_t corruptedVideoFrames;
    double totalFrameDelay;
    uint32_t displayCompositedVideoFrames;
}
#endif

#if ENABLE(WEB_AUTHN)
enum class WebCore::AuthenticatorTransport : uint8_t {
    Usb,
    Nfc,
    Ble,
    Internal,
    Cable,
    Hybrid,
    SmartCard
};

enum class WebCore::PublicKeyCredentialType : bool
#endif

#if PLATFORM(IOS_FAMILY)
class WebCore::SelectionGeometry {
    WebCore::FloatQuad quad();
    WebCore::SelectionRenderingBehavior behavior();
    WebCore::TextDirection direction();
    int minX();
    int maxX();
    int maxY();
    int lineNumber();
    bool isLineBreak();
    bool isFirstOnLine();
    bool isLastOnLine();
    bool containsStart();
    bool containsEnd();
    bool isHorizontal();
};
#endif

#if ENABLE(DATALIST_ELEMENT)
header: <WebCore/DataListSuggestionInformation.h>
[CustomHeader] enum class WebCore::DataListSuggestionActivationType : uint8_t {
    ControlClicked,
    IndicatorClicked,
    TextChanged,
    DataListMayHaveChanged,
};

header: <WebCore/DataListSuggestionInformation.h>
[CustomHeader] struct WebCore::DataListSuggestion {
    String value;
    String label;
};

struct WebCore::DataListSuggestionInformation {
    WebCore::DataListSuggestionActivationType activationType;
    Vector<WebCore::DataListSuggestion> suggestions;
    WebCore::IntRect elementRect;
};
#endif

struct WebCore::ClientOrigin {
    [Validator='!topOrigin->isNull()'] WebCore::SecurityOriginData topOrigin;
    [Validator='!clientOrigin->isNull()'] WebCore::SecurityOriginData clientOrigin;
};

enum class WebCore::AlphaPremultiplication : uint8_t {
    Premultiplied,
    Unpremultiplied
};

enum class WebCore::PixelFormat : uint8_t {
    RGBA8,
    BGRX8,
    BGRA8,
    RGB10,
    RGB10A8,
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::PixelBufferFormat {
    WebCore::AlphaPremultiplication alphaFormat;
    WebCore::PixelFormat pixelFormat;
    WebCore::DestinationColorSpace colorSpace;
};

[RefCounted] class WebCore::TextIndicator {
    WebCore::TextIndicatorData data();
};

#if USE(SOUP)
header: "ArgumentCodersGLib.h"
#endif
class WebCore::CertificateInfo {
#if PLATFORM(COCOA)
    RetainPtr<SecTrustRef> trust()
#endif
#if USE(CURL)
    int verificationError()
    Vector<Vector<uint8_t>> certificateChain()
#endif
#if USE(SOUP)
    GRefPtr<GTlsCertificate> certificate()
    GTlsCertificateFlags tlsErrors()
#endif
}

[Nested] struct WebCore::PasteboardCustomData::Entry {
    String type;
    String customData;
    std::variant<String, Ref<WebCore::SharedBuffer>> platformData;
};

class WebCore::PasteboardCustomData {
    String origin();
    Vector<WebCore::PasteboardCustomData::Entry> data();
};

#if USE(UNIX_DOMAIN_SOCKETS)
headers: <wtf/unix/UnixFileDescriptor.h> "ArgumentCodersUnix.h"
#endif
#if OS(DARWIN)
header: <wtf/MachSendRight.h>
#endif
#if OS(WINDOWS)
headers: <wtf/win/Win32Handle.h> "ArgumentCodersWin.h"
#endif

[CustomHeader, RValue] class WebCore::SharedMemoryHandle {
#if USE(UNIX_DOMAIN_SOCKETS)
    [Validator='!!m_handle'] UnixFileDescriptor m_handle;
#endif
#if OS(DARWIN)
    [Validator='!!m_handle'] MachSendRight m_handle;
#endif
#if OS(WINDOWS)
    [Validator='!!m_handle'] Win32Handle m_handle;
#endif
    size_t m_size;
};

class WebCore::DatabaseDetails {
    String name();
    String displayName();
    uint64_t expectedUsage();
    uint64_t currentUsage();
    std::optional<WallTime> creationTime();
    std::optional<WallTime> modificationTime();
};

[RefCounted] class WebCore::DecomposedGlyphs {
    WebCore::PositionedGlyphs positionedGlyphs();
    WebCore::RenderingResourceIdentifier renderingResourceIdentifier();
}

header: <WebCore/TextIndicator.h>
[CustomHeader] struct WebCore::TextIndicatorData {
    WebCore::FloatRect selectionRectInRootViewCoordinates;
    WebCore::FloatRect textBoundingRectInRootViewCoordinates;
    WebCore::FloatRect contentImageWithoutSelectionRectInRootViewCoordinates;
    Vector<WebCore::FloatRect> textRectsInBoundingRectCoordinates;
    float contentImageScaleFactor;
    RefPtr<WebCore::Image> contentImageWithHighlight;
    RefPtr<WebCore::Image> contentImageWithoutSelection;
    RefPtr<WebCore::Image> contentImage;
    WebCore::Color estimatedBackgroundColor;
    WebCore::TextIndicatorPresentationTransition presentationTransition;
    OptionSet<WebCore::TextIndicatorOption> options;
}

#if ENABLE(MEDIA_STREAM)
struct WebCore::MediaConstraints {
    WebCore::MediaTrackConstraintSetMap mandatoryConstraints;
    Vector<WebCore::MediaTrackConstraintSetMap> advancedConstraints;
    bool isValid;
};
#endif

struct WebCore::PromisedAttachmentInfo {
#if ENABLE(ATTACHMENT_ELEMENT)
    String attachmentIdentifier;
#endif
    Vector<String> additionalTypes;
    Vector<RefPtr<WebCore::SharedBuffer>> additionalData;
}

header: <WebCore/SearchPopupMenu.h>
[CustomHeader] struct WebCore::RecentSearch {
    String string;
    WallTime time;
};

[Nested] enum class WebCore::EventTrackingRegions::EventType : uint8_t {
    Mousedown,
    Mousemove,
    Mouseup,
    Mousewheel,
    Pointerdown,
    Pointerenter,
    Pointerleave,
    Pointermove,
    Pointerout,
    Pointerover,
    Pointerup,
    Touchend,
    Touchforcechange,
    Touchmove,
    Touchstart,
    Wheel
};

struct WebCore::EventTrackingRegions {
    WebCore::Region asynchronousDispatchRegion;
    HashMap<WebCore::EventTrackingRegions::EventType, WebCore::Region, WTF::IntHash<WebCore::EventTrackingRegions::EventType>, WTF::StrongEnumHashTraits<WebCore::EventTrackingRegions::EventType>> eventSpecificSynchronousDispatchRegions;
};

enum class WebCore::HasInsecureContent : bool

struct WebCore::TextManipulationItem {
    WebCore::FrameIdentifier frameID;
    bool isSubframe;
    bool isCrossSiteSubframe;
    WebCore::TextManipulationItemIdentifier identifier;
    Vector<WebCore::TextManipulationToken> tokens;
}

header: <WebCore/TextManipulationToken.h>
[CustomHeader] struct WebCore::TextManipulationToken {
    WebCore::TextManipulationTokenIdentifier identifier;
    String content;
    std::optional<WebCore::TextManipulationTokenInfo> info;
    bool isExcluded;
};

header: <WebCore/TextManipulationToken.h>
[CustomHeader] struct WebCore::TextManipulationTokenInfo {
    String tagName;
    String roleAttribute;
    URL documentURL;
    bool isVisible;
};

struct WebCore::VelocityData {
    float horizontalVelocity;
    float verticalVelocity;
    float scaleChangeRate;
    MonotonicTime lastUpdateTime;
};

header: <WebCore/PluginData.h>
[CustomHeader] struct WebCore::MimeClassInfo {
    AtomString type;
    String desc;
    Vector<String> extensions;
};

class WebCore::AuthenticationChallenge {
    WebCore::ProtectionSpace protectionSpace();
    WebCore::Credential proposedCredential();
    unsigned previousFailureCount();
    WebCore::ResourceResponse failureResponse();
    WebCore::ResourceError error();

#if USE(SOUP)
    uint32_t tlsPasswordFlags();
#endif
};

#if ENABLE(DRAG_SUPPORT)
class WebCore::DragData {
#if PLATFORM(COCOA)
    String pasteboardName();
#endif
    WebCore::IntPoint clientPosition();
    WebCore::IntPoint globalPosition();
#if PLATFORM(COCOA)
    Vector<String> fileNames();
#endif
    OptionSet<WebCore::DragOperation> draggingSourceOperationMask();
    OptionSet<WebCore::DragApplicationFlags> flags();
    OptionSet<WebCore::DragDestinationAction> dragDestinationActionMask();
    std::optional<WebCore::PageIdentifier> pageID();
};
#endif

struct WebCore::DictationAlternative {
    WebCore::CharacterRange range;
    WebCore::DictationContext context;
};

class WebCore::UserStyleSheet {
    String source();
    URL url();
    Vector<String> allowlist();
    Vector<String> blocklist();
    WebCore::UserContentInjectedFrames injectedFrames();
    WebCore::UserStyleLevel level();
    std::optional<WebCore::PageIdentifier> pageID();
};

header: <WebCore/ScrollTypes.h>
[CustomHeader] enum class WebCore::ScrollElasticity : uint8_t {
    Automatic,
    None,
    Allowed
};

header: <WebCore/ScrollTypes.h>
[CustomHeader] enum class WebCore::ScrollbarMode : uint8_t {
    Auto,
    AlwaysOff,
    AlwaysOn
};

header: <WebCore/ScrollTypes.h>
[CustomHeader] enum class WebCore::NativeScrollbarVisibility : uint8_t {
    Visible,
    HiddenByStyle,
    ReplacedByCustomScrollbar
};

header: <WebCore/ScrollingCoordinatorTypes.h>
[CustomHeader] struct WebCore::ScrollableAreaParameters {
    WebCore::ScrollElasticity horizontalScrollElasticity;
    WebCore::ScrollElasticity verticalScrollElasticity;
    WebCore::ScrollbarMode horizontalScrollbarMode;
    WebCore::ScrollbarMode verticalScrollbarMode;
    WebCore::OverscrollBehavior horizontalOverscrollBehavior;
    WebCore::OverscrollBehavior verticalOverscrollBehavior;
    bool allowsHorizontalScrolling;
    bool allowsVerticalScrolling;
    WebCore::NativeScrollbarVisibility horizontalNativeScrollbarVisibility;
    WebCore::NativeScrollbarVisibility verticalNativeScrollbarVisibility;
    bool useDarkAppearanceForScrollbars;
    WebCore::ScrollbarWidth scrollbarWidthStyle;
};

header: <WebCore/ScrollingCoordinatorTypes.h>
[CustomHeader] struct WebCore::RequestedKeyboardScrollData {
    WebCore::KeyboardScrollAction action;
    std::optional<WebCore::KeyboardScroll> keyboardScroll;
};

header: <WebCore/ScrollingCoordinatorTypes.h>
[OptionSet] enum class WebCore::WheelEventProcessingSteps : uint8_t {
    AsyncScrolling,
    SynchronousScrolling,
    NonBlockingDOMEventDispatch,
    BlockingDOMEventDispatch,
};

header: <WebCore/ScrollingConstraints.h>
[CustomHeader] class WebCore::AbsolutePositionConstraints {
    WebCore::FloatSize alignmentOffset();
    WebCore::FloatPoint layerPositionAtLastLayout();
};

header: <WebCore/KeyboardScroll.h>
[CustomHeader] struct WebCore::KeyboardScroll {
    WebCore::FloatSize offset;
    WebCore::FloatSize maximumVelocity;
    WebCore::FloatSize force;
    WebCore::ScrollGranularity granularity;
    WebCore::ScrollDirection direction;
};

[RefCounted] class WebCore::NotificationResources {
    RefPtr<WebCore::Image> icon();
};

[RefCounted] class WebCore::IdentityTransformOperation {
    [NotSerialized] WebCore::TransformOperation::Type type();
}

[RefCounted] class WebCore::TranslateTransformOperation {
    WebCore::Length x();
    WebCore::Length y();
    WebCore::Length z();
    [Validator='WebCore::TransformOperation::isTranslateTransformOperationType(*type)'] WebCore::TransformOperation::Type type();
}

[RefCounted] class WebCore::RotateTransformOperation {
    double x();
    double y();
    double z();
    double angle();
    [Validator='WebCore::TransformOperation::isRotateTransformOperationType(*type)'] WebCore::TransformOperation::Type type();
}

[RefCounted] class WebCore::ScaleTransformOperation {
    double x();
    double y();
    double z();
    [Validator='WebCore::TransformOperation::isScaleTransformOperationType(*type)'] WebCore::TransformOperation::Type type();
}

[RefCounted] class WebCore::SkewTransformOperation {
    double angleX();
    double angleY();
    [Validator='WebCore::TransformOperation::isSkewTransformOperationType(*type)'] WebCore::TransformOperation::Type type();
}

[RefCounted] class WebCore::PerspectiveTransformOperation {
    std::optional<WebCore::Length> perspective();
}

[RefCounted] class WebCore::MatrixTransformOperation {
    WebCore::TransformationMatrix matrix();
}

[RefCounted] class WebCore::Matrix3DTransformOperation {
    WebCore::TransformationMatrix matrix();
}

#if PLATFORM(COCOA)
struct AudioStreamBasicDescription {
    double  mSampleRate;
    UInt32  mFormatID;
    UInt32  mFormatFlags;
    UInt32  mBytesPerPacket;
    UInt32  mFramesPerPacket;
    UInt32  mBytesPerFrame;
    UInt32  mChannelsPerFrame;
    UInt32  mBitsPerChannel;
    UInt32  mReserved;
};

class WebCore::CAAudioStreamDescription {
    AudioStreamBasicDescription streamDescription();
}
#endif

class WebCore::TransformOperations {
    Vector<RefPtr<WebCore::TransformOperation>> operations();
}

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::Gradient::LinearData {
    WebCore::FloatPoint point0;
    WebCore::FloatPoint point1;
};

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::Gradient::RadialData {
    WebCore::FloatPoint point0;
    WebCore::FloatPoint point1;
    float startRadius;
    float endRadius;
    float aspectRatio;
};

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::Gradient::ConicData {
    WebCore::FloatPoint point0;
    float angleRadians;
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::Gradient {
    std::variant<WebCore::Gradient::LinearData, WebCore::Gradient::RadialData, WebCore::Gradient::ConicData> data();
    WebCore::ColorInterpolationMethod colorInterpolationMethod();
    WebCore::GradientSpreadMethod spreadMethod();
    WebCore::GradientColorStops stops();
    std::optional<WebCore::RenderingResourceIdentifier> renderingResourceIdentifierIfExists();
}

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::Pattern::Parameters {
    bool repeatX;
    bool repeatY;
    WebCore::AffineTransform patternSpaceTransform;
}

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::Pattern {
    WebCore::SourceImage tileImage();
    WebCore::Pattern::Parameters parameters();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::SourceBrush {
    WebCore::Color color();
    WebCore::SourceBrush::OptionalPatternGradient patternGradient();
}

header: <WebCore/ThreadSafeDataBuffer.h>
[RefCounted, CustomHeader] class WebCore::ThreadSafeDataBufferImpl {
    Vector<uint8_t> m_data;
};

class WebCore::ThreadSafeDataBuffer {
    RefPtr<WebCore::ThreadSafeDataBufferImpl> m_impl;
};

#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
header: <WebCore/GraphicsContextGLAttributes.h>
[CustomHeader] enum class WebCore::GraphicsContextGLPowerPreference : uint8_t {
    Default,
    LowPower,
    HighPerformance
};

header: <WebCore/GraphicsContextGLAttributes.h>
[CustomHeader] enum class WebCore::GraphicsContextGLSimulatedCreationFailure : uint8_t {
    None,
    IPCBufferOOM,
    CreationTimeout,
    FailPlatformContextCreation
};

struct WebCore::GraphicsContextGLAttributes {
    bool alpha;
    bool depth;
    bool stencil;
    bool antialias;
    bool premultipliedAlpha;
    bool preserveDrawingBuffer;
    WebCore::GraphicsContextGLPowerPreference powerPreference;
    bool isWebGL2;
#if PLATFORM(MAC) || PLATFORM(MACCATALYST)
    uint64_t windowGPUID;
#endif
#if PLATFORM(COCOA)
    bool useMetal;
#endif
#if ENABLE(WEBXR)
    bool xrCompatible;
#endif
    WebCore::GraphicsContextGLSimulatedCreationFailure failContextCreationForTesting;
};

enum class WebCore::GraphicsContextGLSimulatedEventForTesting : uint8_t {
    GPUStatusFailure,
    Timeout,
    DisplayBufferAllocationFailure
};

#endif // ENABLE(GPU_PROCESS) && ENABLE(WEBGL)

[RefCounted] class WebCore::TimingFunction subclasses {
  WebCore::LinearTimingFunction,
  WebCore::CubicBezierTimingFunction,
  WebCore::StepsTimingFunction,
  WebCore::SpringTimingFunction
}

[RefCounted] class WebCore::TransformOperation subclasses {
    WebCore::TranslateTransformOperation
    WebCore::ScaleTransformOperation
    WebCore::RotateTransformOperation
    WebCore::SkewTransformOperation
    WebCore::MatrixTransformOperation
    WebCore::Matrix3DTransformOperation
    WebCore::PerspectiveTransformOperation
    WebCore::IdentityTransformOperation
}

struct WebCore::LengthSize {
    WebCore::Length width;
    WebCore::Length height;
}

class WebCore::SVGPathByteStream {
    Vector<unsigned char> data();
}

header: <WebCore/BasicShapes.h>
[Nested, CustomHeader] enum class WebCore::BasicShapeCenterCoordinate::Direction : bool

[CustomHeader] class WebCore::BasicShapeCenterCoordinate {
    WebCore::BasicShapeCenterCoordinate::Direction direction();
    WebCore::Length length();
}

[Nested, CustomHeader] enum class WebCore::BasicShapeRadius::Type : uint8_t {
    Value,
    ClosestSide,
    FarthestSide
};

[CustomHeader] class WebCore::BasicShapeRadius {
    WebCore::Length value();
    WebCore::BasicShapeRadius::Type type();
}

[RefCounted, CustomHeader] class WebCore::BasicShapeCircle {
    WebCore::BasicShapeCenterCoordinate centerX();
    WebCore::BasicShapeCenterCoordinate centerY();
    WebCore::BasicShapeRadius radius();
}

[RefCounted, CustomHeader] class WebCore::BasicShapeEllipse {
    WebCore::BasicShapeCenterCoordinate centerX();
    WebCore::BasicShapeCenterCoordinate centerY();
    WebCore::BasicShapeRadius radiusX();
    WebCore::BasicShapeRadius radiusY();
}

[RefCounted, CustomHeader] class WebCore::BasicShapePolygon {
    WebCore::WindRule windRule();
    Vector<WebCore::Length> values();
}

[RefCounted, CustomHeader] class WebCore::BasicShapePath {
    std::unique_ptr<WebCore::SVGPathByteStream> byteStream();
    float zoom();
    WebCore::WindRule windRule();
}

[RefCounted, CustomHeader] class WebCore::BasicShapeInset {
    WebCore::Length right();
    WebCore::Length top();
    WebCore::Length bottom();
    WebCore::Length left();
    WebCore::LengthSize topLeftRadius();
    WebCore::LengthSize topRightRadius();
    WebCore::LengthSize bottomRightRadius();
    WebCore::LengthSize bottomLeftRadius();
}

[RefCounted, CustomHeader] class WebCore::BasicShape subclasses {
    WebCore::BasicShapeCircle
    WebCore::BasicShapeEllipse
    WebCore::BasicShapePolygon
    WebCore::BasicShapePath
    WebCore::BasicShapeInset
}

[AdditionalEncoder=StreamConnectionEncoder, RefCounted] class WebCore::PixelBuffer subclasses {
    WebCore::ByteArrayPixelBuffer
}

header: <WebCore/RenderStyleConstants.h>
[CustomHeader] enum class WebCore::CSSBoxType : uint8_t {
    BoxMissing,
    MarginBox,
    BorderBox,
    PaddingBox,
    ContentBox,
    FillBox,
    StrokeBox,
    ViewBox
};

header: <WebCore/MotionPath.h>
[CustomHeader] struct WebCore::MotionPathData {
    WebCore::FloatRoundedRect containingBlockBoundingRect;
    WebCore::FloatPoint offsetFromContainingBlock;
    WebCore::FloatPoint usedStartingPosition;
};

header: <WebCore/TransformOperationData.h>
[CustomHeader] struct WebCore::TransformOperationData {
    WebCore::FloatRect boundingBox;
    std::optional<WebCore::MotionPathData> motionPathData;
    bool isSVGRenderer;
}

header: <WebCore/PathOperation.h>
[RefCounted, CustomHeader] class WebCore::ReferencePathOperation {
    std::optional<WebCore::Path> path();
}

[RefCounted, CustomHeader] class WebCore::ShapePathOperation {
    Ref<WebCore::BasicShape> shape();
    WebCore::CSSBoxType referenceBox();
}

[RefCounted, CustomHeader] class WebCore::BoxPathOperation {
    WebCore::CSSBoxType referenceBox();
}

[Nested, CustomHeader] enum class WebCore::RayPathOperation::Size : uint8_t {
    ClosestSide,
    ClosestCorner,
    FarthestSide,
    FarthestCorner,
    Sides
};

header: <WebCore/LengthPoint.h>
struct WebCore::LengthPoint {
    WebCore::Length x();
    WebCore::Length y();
}

[RefCounted, CustomHeader] class WebCore::RayPathOperation {
    float angle();
    WebCore::RayPathOperation::Size size();
    bool isContaining();
    WebCore::LengthPoint position();
}

[RefCounted] class WebCore::PathOperation subclasses {
    WebCore::ReferencePathOperation,
    WebCore::ShapePathOperation,
    WebCore::BoxPathOperation,
    WebCore::RayPathOperation
}

#if PLATFORM(IOS_FAMILY)
enum class WebCore::SelectionRenderingBehavior : bool
#endif

#if ENABLE(WEB_AUTHN)
enum class WebCore::UserVerificationRequirement : uint8_t {
    Required,
    Preferred,
    Discouraged
};

enum class WebCore::ResidentKeyRequirement : uint8_t {
    Required,
    Preferred,
    Discouraged
};

enum class WebCore::AuthenticatorAttachment : uint8_t {
    Platform,
    CrossPlatform
};

#endif // ENABLE(WEB_AUTHN)

#if ENABLE(ENCRYPTED_MEDIA)
struct WebCore::CDMKeySystemConfiguration {
    String label;
    Vector<AtomString> initDataTypes;
    Vector<WebCore::CDMMediaCapability> audioCapabilities;
    Vector<WebCore::CDMMediaCapability> videoCapabilities;
    WebCore::CDMRequirement distinctiveIdentifier;
    WebCore::CDMRequirement persistentState;
    Vector<WebCore::CDMSessionType> sessionTypes;
}
#endif // ENABLE(ENCRYPTED_MEDIA)

struct WebCore::MediaConfiguration {
    std::optional<WebCore::VideoConfiguration> video;
    std::optional<WebCore::AudioConfiguration> audio;

    std::optional<Vector<String>> allowedMediaContainerTypes;
    std::optional<Vector<String>> allowedMediaCodecTypes;
};

struct WebCore::MediaEncodingConfiguration : WebCore::MediaConfiguration {
    WebCore::MediaEncodingType type;
};

struct WebCore::MediaDecodingConfiguration : WebCore::MediaConfiguration {
    WebCore::MediaDecodingType type;
    bool canExposeVP9;
};

enum class WebCore::ResourceRequestCachePolicy : uint8_t {
    UseProtocolCachePolicy,
    ReloadIgnoringCacheData,
    ReturnCacheDataElseLoad,
    ReturnCacheDataDontLoad,
    DoNotUseAnyCache,
    RefreshAnyCacheData,
};

[Nested] enum class WebCore::ResourceRequestBase::SameSiteDisposition : uint8_t {
    Unspecified,
    SameSite,
    CrossSite
};

[Nested] enum class WebCore::ResourceRequestRequester : uint8_t {
    Unspecified,
    Main,
    XHR,
    Fetch,
    Media,
    Model,
    ImportScripts,
    Ping,
    Beacon,
    EventSource
};

enum class WebCore::ResourceLoadPriority : uint8_t {
    VeryLow,
    Low,
    Medium,
    High,
    VeryHigh,
};

[Nested] enum class WebCore::ResourceResponseBaseType : uint8_t {
    Basic,
    Cors,
    Default,
    Error,
    Opaque,
    Opaqueredirect
};

[Nested] enum class WebCore::ResourceResponseBaseTainting : uint8_t {
    Basic,
    Cors,
    Opaque,
    Opaqueredirect
};

[Nested] enum class WebCore::ResourceResponseBaseSource : uint8_t {
    Unknown,
    Network,
    DiskCache,
    DiskCacheAfterValidation,
    MemoryCache,
    MemoryCacheAfterValidation,
    ServiceWorker,
    ApplicationCache,
    DOMCache,
    InspectorOverride
};

using WebCore::ResourceResponseBase::Type = WebCore::ResourceResponseBaseType;
using WebCore::ResourceResponseBase::Tainting = WebCore::ResourceResponseBaseTainting;
using WebCore::ResourceResponseBase::Source = WebCore::ResourceResponseBaseSource;

class WebCore::ResourceResponseBase {
    std::optional<WebCore::ResourceResponseData> getResponseData()
}

class WebCore::ResourceResponse : WebCore::ResourceResponseBase {
}

header: <WebCore/ResourceResponseBase.h>
[CustomHeader] struct WebCore::ResourceResponseData {
    URL url;
    String mimeType;
    long long expectedContentLength;
    String textEncodingName;
    short httpStatusCode;
    String httpStatusText;
    String httpVersion;
    WebCore::HTTPHeaderMap httpHeaderFields;
    std::optional<WebCore::NetworkLoadMetrics> networkLoadMetrics;
    WebCore::ResourceResponseBase::Source source;
    WebCore::ResourceResponseBase::Type type;
    WebCore::ResourceResponseBase::Tainting tainting;
    bool isRedirected;
    WebCore::UsedLegacyTLS usedLegacyTLS;
    WebCore::WasPrivateRelayed wasPrivateRelayed;
    bool isRangeRequested;
    std::optional<WebCore::CertificateInfo> certificateInfo;
};

enum class WebCore::ReferrerPolicy : uint8_t {
    EmptyString,
    NoReferrer,
    NoReferrerWhenDowngrade,
    SameOrigin,
    Origin,
    StrictOrigin,
    OriginWhenCrossOrigin,
    StrictOriginWhenCrossOrigin,
    UnsafeUrl,
};

enum class WebCore::FetchOptionsDestination : uint8_t {
    EmptyString,
    Audio,
    Audioworklet,
    Document,
    Embed,
    Font,
    Image,
    Iframe,
    Manifest,
    Model,
    Object,
    Paintworklet,
    Report,
    Script,
    Serviceworker,
    Sharedworker,
    Style,
    Track,
    Video,
    Worker,
    Xslt
};

enum class WebCore::FetchOptionsMode : uint8_t {
    Navigate,
    SameOrigin,
    NoCors,
    Cors
};

enum class WebCore::FetchOptionsCredentials : uint8_t {
    Omit,
    SameOrigin,
    Include
};

enum class WebCore::FetchOptionsCache : uint8_t {
    Default,
    NoStore,
    Reload,
    NoCache,
    ForceCache,
    OnlyIfCached
};

enum class WebCore::FetchOptionsRedirect : uint8_t {
    Follow,
    Error,
    Manual
};

struct WebCore::FetchOptions {
    WebCore::FetchOptionsDestination destination;
    WebCore::FetchOptionsMode mode;
    WebCore::FetchOptionsCredentials credentials;
    WebCore::FetchOptionsCache cache;
    WebCore::FetchOptionsRedirect redirect;
    WebCore::ReferrerPolicy referrerPolicy;
    bool keepAlive;
    String integrity;
    Markable<WTF::UUID> clientIdentifier;
    Markable<WTF::UUID> resultingClientIdentifier;
}

enum class WebCore::FetchHeadersGuard : uint8_t {
    None,
    Immutable,
    Request,
    RequestNoCors,
    Response
};

[Nested OptionSet] enum class WebCore::ControlStyle::State : unsigned {
    Hovered,
    Pressed,
    Focused,
    Enabled,
    Checked,
    Default,
    WindowActive,
    Indeterminate,
    SpinUp,
    Presenting,
    FormSemanticContext,
    DarkAppearance,
    RightToLeft,
    LargeControls,
    ReadOnly,
    ListButton,
    ListButtonPressed,
    VerticalWritingMode
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ControlStyle {
    OptionSet<WebCore::ControlStyle::State> states;
    float fontSize;
    float zoomFactor;
    WebCore::Color accentColor;
    WebCore::Color textColor;
    WebCore::FloatBoxExtent borderWidth;
};

enum class WebCore::StyleAppearance : uint8_t {
    None,
    Auto,
    Checkbox,
    Radio,
    PushButton,
    SquareButton,
    Button,
    DefaultButton,
    Listbox,
    Menulist,
    MenulistButton,
    Meter,
    ProgressBar,
    SliderHorizontal,
    SliderVertical,
    SearchField,
#if ENABLE(APPLE_PAY)
    ApplePayButton,
#endif
#if ENABLE(ATTACHMENT_ELEMENT)
    Attachment,
    BorderlessAttachment,
#endif
    TextArea,
    TextField,
    CapsLockIndicator,
#if ENABLE(INPUT_TYPE_COLOR)
    ColorWell,
#endif
#if ENABLE(SERVICE_CONTROLS)
    ImageControlsButton,
#endif
    InnerSpinButton,
#if ENABLE(DATALIST_ELEMENT)
    ListButton,
#endif
    SearchFieldDecoration,
    SearchFieldResultsDecoration,
    SearchFieldResultsButton,
    SearchFieldCancelButton,
    SliderThumbHorizontal,
    SliderThumbVertical,
    Switch,
    SwitchThumb,
    SwitchTrack
};

header: <WebCore/ControlPart.h>
[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::ControlPart subclasses {
    WebCore::ButtonPart,
    WebCore::InnerSpinButtonPart,
    WebCore::MenuListButtonPart,
    WebCore::MenuListPart,
    WebCore::MeterPart,
    WebCore::ProgressBarPart,
    WebCore::SearchFieldPart,
    WebCore::SearchFieldResultsPart,
    WebCore::SearchFieldCancelButtonPart,
    WebCore::SliderThumbPart,
    WebCore::SliderTrackPart,
    WebCore::SwitchThumbPart,
    WebCore::SwitchTrackPart,
    WebCore::TextAreaPart,
    WebCore::TextFieldPart,
    WebCore::ToggleButtonPart,
#if ENABLE(APPLE_PAY)
    WebCore::ApplePayButtonPart,
#endif
#if ENABLE(SERVICE_CONTROLS)
    WebCore::ImageControlsButtonPart,
#endif
#if ENABLE(INPUT_TYPE_COLOR)
    WebCore::ColorWellPart,
#endif
}

header: <WebCore/ButtonPart.h>
[RefCounted, AdditionalEncoder=StreamConnectionEncoder, DisableMissingMemberCheck] class WebCore::ButtonPart {
    WebCore::StyleAppearance type();
}

header: <WebCore/InnerSpinButtonPart.h>
[RefCounted, AdditionalEncoder=StreamConnectionEncoder, DisableMissingMemberCheck] class WebCore::InnerSpinButtonPart {
}

header: <WebCore/MenuListButtonPart.h>
[RefCounted, AdditionalEncoder=StreamConnectionEncoder, DisableMissingMemberCheck] class WebCore::MenuListButtonPart {
}

header: <WebCore/MenuListPart.h>
[RefCounted, AdditionalEncoder=StreamConnectionEncoder, DisableMissingMemberCheck] class WebCore::MenuListPart {
}

header: <WebCore/SearchFieldPart.h>
[RefCounted, AdditionalEncoder=StreamConnectionEncoder, DisableMissingMemberCheck] class WebCore::SearchFieldPart {
}

header: <WebCore/SliderThumbPart.h>
[RefCounted, AdditionalEncoder=StreamConnectionEncoder, DisableMissingMemberCheck] class WebCore::SliderThumbPart {
    WebCore::StyleAppearance type();
}

header: <WebCore/SearchFieldResultsPart.h>
[RefCounted, AdditionalEncoder=StreamConnectionEncoder, DisableMissingMemberCheck] class WebCore::SearchFieldResultsPart {
    WebCore::StyleAppearance type();
}

header: <WebCore/SearchFieldCancelButtonPart.h>
[RefCounted, AdditionalEncoder=StreamConnectionEncoder, DisableMissingMemberCheck] class WebCore::SearchFieldCancelButtonPart {
}

header: <WebCore/TextAreaPart.h>
[RefCounted, AdditionalEncoder=StreamConnectionEncoder, DisableMissingMemberCheck] class WebCore::TextAreaPart {
    WebCore::StyleAppearance type();
}

header: <WebCore/TextFieldPart.h>
[RefCounted, AdditionalEncoder=StreamConnectionEncoder, DisableMissingMemberCheck] class WebCore::TextFieldPart {
}

header: <WebCore/ToggleButtonPart.h>
[RefCounted, AdditionalEncoder=StreamConnectionEncoder, DisableMissingMemberCheck] class WebCore::ToggleButtonPart {
    WebCore::StyleAppearance type();
}

#if ENABLE(SERVICE_CONTROLS)
header: <WebCore/ImageControlsButtonPart.h>
[RefCounted, AdditionalEncoder=StreamConnectionEncoder, DisableMissingMemberCheck] class WebCore::ImageControlsButtonPart {
}
#endif

#if ENABLE(INPUT_TYPE_COLOR)
header: <WebCore/ColorWellPart.h>
[RefCounted, AdditionalEncoder=StreamConnectionEncoder, DisableMissingMemberCheck] class WebCore::ColorWellPart {
}
#endif

#if ENABLE(APPLE_PAY)
header: <WebCore/ApplePayButtonPart.h>
enum class WebCore::ApplePayButtonType : uint8_t {
    Plain,
    Buy,
    SetUp,
    Donate,
    CheckOut,
    Book,
    Subscribe,
#if ENABLE(APPLE_PAY_NEW_BUTTON_TYPES)
    Reload,
    AddMoney,
    TopUp,
    Order,
    Rent,
    Support,
    Contribute,
    Tip,
#endif
}

enum class WebCore::ApplePayButtonStyle : uint8_t {
    White,
    WhiteOutline,
    Black,
}

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::ApplePayButtonPart {
    WebCore::ApplePayButtonType buttonType();
    WebCore::ApplePayButtonStyle buttonStyle();
    String locale();
};
#endif

[Nested] enum class WebCore::MeterPart::GaugeRegion : uint8_t {
    Optimum,
    Suboptimal,
    EvenLessGood
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::MeterPart {
    WebCore::MeterPart::GaugeRegion gaugeRegion();
    double value();
    double minimum();
    double maximum();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::ProgressBarPart {
    double position();
    Seconds animationStartTime();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::SliderTrackPart {
    WebCore::StyleAppearance type();
    WebCore::IntSize thumbSize();
    WebCore::IntRect trackBounds();
    Vector<double> tickRatios();
}

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::SwitchThumbPart {
    bool isOn();
    [Validator='progress >= 0.0f && progress <= 1.0f'] float progress();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::SwitchTrackPart {
    bool isOn();
    [Validator='progress >= 0.0f && progress <= 1.0f'] float progress();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DistantLightSource {
    float azimuth();
    float elevation();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::PointLightSource {
    WebCore::FloatPoint3D position();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::SpotLightSource {
    WebCore::FloatPoint3D position();
    WebCore::FloatPoint3D direction();
    float specularExponent();
    float limitingConeAngle();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEBlend {
    WebCore::BlendMode blendMode();

    WebCore::DestinationColorSpace operatingColorSpace();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEColorMatrix {
    WebCore::ColorMatrixType type();
    Vector<float> values();

    WebCore::DestinationColorSpace operatingColorSpace();
};

header: <WebCore/FEComponentTransfer.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ComponentTransferFunction {
    WebCore::ComponentTransferType type;
    float slope;
    float intercept;
    float amplitude;
    float exponent;
    float offset;
    Vector<float> tableValues;
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEComponentTransfer {
    WebCore::ComponentTransferFunction redFunction();
    WebCore::ComponentTransferFunction greenFunction();
    WebCore::ComponentTransferFunction blueFunction();
    WebCore::ComponentTransferFunction alphaFunction();

    WebCore::DestinationColorSpace operatingColorSpace();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEComposite {
    WebCore::CompositeOperationType operation();
    float k1();
    float k2();
    float k3();
    float k4();

    WebCore::DestinationColorSpace operatingColorSpace();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEConvolveMatrix {
    WebCore::IntSize kernelSize();
    float divisor();
    float bias();
    WebCore::IntPoint targetOffset();
    WebCore::EdgeModeType edgeMode();
    WebCore::FloatPoint kernelUnitLength();
    bool preserveAlpha();
    Vector<float> kernel();

    WebCore::DestinationColorSpace operatingColorSpace();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEDiffuseLighting {
    WebCore::Color lightingColor();
    float surfaceScale();
    float diffuseConstant();
    float kernelUnitLengthX();
    float kernelUnitLengthY();
    Ref<WebCore::LightSource> lightSource();

    WebCore::DestinationColorSpace operatingColorSpace();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEDisplacementMap {
    WebCore::ChannelSelectorType xChannelSelector();
    WebCore::ChannelSelectorType yChannelSelector();
    float scale();

    WebCore::DestinationColorSpace operatingColorSpace();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEDropShadow {
    float stdDeviationX();
    float stdDeviationY();
    float dx();
    float dy();
    WebCore::Color shadowColor();
    float shadowOpacity()

    WebCore::DestinationColorSpace operatingColorSpace();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEFlood {
    WebCore::Color floodColor();
    float floodOpacity();

    WebCore::DestinationColorSpace operatingColorSpace();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEGaussianBlur {
    float stdDeviationX();
    float stdDeviationY();
    WebCore::EdgeModeType edgeMode();

    WebCore::DestinationColorSpace operatingColorSpace();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEImage {
    WebCore::SourceImage sourceImage();
    WebCore::FloatRect sourceImageRect();
    WebCore::SVGPreserveAspectRatioValue preserveAspectRatio();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEMerge {
    unsigned numberOfEffectInputs();

    WebCore::DestinationColorSpace operatingColorSpace();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEMorphology {
    WebCore::MorphologyOperatorType morphologyOperator();
    float radiusX();
    float radiusY();

    WebCore::DestinationColorSpace operatingColorSpace();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEOffset {
    float dx();
    float dy();

    WebCore::DestinationColorSpace operatingColorSpace();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FETile {
    WebCore::DestinationColorSpace operatingColorSpace();
}

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FESpecularLighting {
    WebCore::Color lightingColor();
    float surfaceScale();
    float specularConstant();
    float specularExponent();
    float kernelUnitLengthX();
    float kernelUnitLengthY();
    Ref<WebCore::LightSource> lightSource();

    WebCore::DestinationColorSpace operatingColorSpace();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FETurbulence {
    WebCore::TurbulenceType type();
    float baseFrequencyX();
    float baseFrequencyY();
    int numOctaves();
    float seed();
    bool stitchTiles();

    WebCore::DestinationColorSpace operatingColorSpace();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::SourceAlpha {
    WebCore::DestinationColorSpace operatingColorSpace();
}

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::SourceGraphic {
    WebCore::DestinationColorSpace operatingColorSpace();
}

[Nested, OptionSet] enum class WebCore::FilterEffectGeometry::Flags : uint8_t {
    HasX,
    HasY,
    HasWidth,
    HasHeight
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FilterEffectGeometry {
    WebCore::FloatRect m_boundaries;
    OptionSet<WebCore::FilterEffectGeometry::Flags> m_flags;
};

header: <WebCore/SVGFilterExpression.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::SVGFilterExpressionTerm {
    unsigned index;
    unsigned level;
    std::optional<WebCore::FilterEffectGeometry> geometry;
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::SVGPreserveAspectRatioValue {
    WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType m_align;
    WebCore::SVGPreserveAspectRatioValue::SVGMeetOrSliceType m_meetOrSlice;
};

enum class WebCore::HasInsecureContent : bool

header: <WebCore/ModalContainerTypes.h>
[CustomHeader] enum class WebCore::ModalContainerDecision : uint8_t {
    Show,
    HideAndIgnore,
    HideAndAllow,
    HideAndDisallow,
};

[OptionSet] enum class WebCore::AutoplayEventFlags : uint8_t {
    HasAudio,
    PlaybackWasPrevented,
    MediaIsMainContent,
};

header: <WebCore/FocusDirection.h>
enum class WebCore::FocusDirection : uint8_t {
    None,
    Forward,
    Backward,
    Up,
    Down,
    Left,
    Right
};

#if ENABLE(GAMEPAD)
struct WebCore::GamepadEffectParameters {
    double duration;
    double startDelay;
    double strongMagnitude;
    double weakMagnitude;
    double leftTrigger;
    double rightTrigger;
};

header: <WebCore/GamepadHapticEffectType.h>
enum class WebCore::GamepadHapticEffectType : uint8_t {
    DualRumble,
    TriggerRumble
};
#endif

header: <WebCore/StorageEstimate.h>
struct WebCore::StorageEstimate {
    uint64_t usage
    uint64_t quota
};

header: <WebCore/DOMPasteAccess.h>
enum class WebCore::DOMPasteAccessCategory : uint8_t {
    General,
    Fonts
};

enum class WebCore::DOMPasteAccessPolicy : uint8_t {
    NotRequestedYet,
    Denied,
    Granted
};

enum class WebCore::DOMPasteAccessResponse : uint8_t {
    DeniedForGesture,
    GrantedForCommand,
    GrantedForGesture
};

header: <WebCore/DeviceOrientationOrMotionPermissionState.h>
enum class WebCore::DeviceOrientationOrMotionPermissionState : uint8_t {
    Granted,
    Denied,
    Prompt
};

header: <WebCore/ExceptionDetails.h>
[Nested] enum class WebCore::ExceptionDetails::Type : uint8_t {
    Script,
    InvalidTargetFrame,
    AppBoundDomain
};

header: <WebCore/SecurityPolicyViolationEventDisposition.h>
enum class WebCore::SecurityPolicyViolationEventDisposition : bool

header: <WebCore/FontAttributeChanges.h>
enum class WebCore::VerticalAlignChange : uint8_t {
    Superscript,
    Baseline,
    Subscript
};

header: <WebCore/TextGranularity.h>
enum class WebCore::TextGranularity : uint8_t {
    CharacterGranularity,
    WordGranularity,
    SentenceGranularity,
    LineGranularity,
    ParagraphGranularity,
    DocumentGranularity,
    SentenceBoundary,
    LineBoundary,
    ParagraphBoundary,
    DocumentBoundary
};

struct WebCore::ListStyleType {
    WebCore::ListStyleType::Type type;
    AtomString identifier;
};

header: <pal/SessionID.h>
[CustomHeader] class PAL::SessionID {
    [Validator='PAL::SessionID::isValidSessionIDValue(*toUInt64)'] uint64_t toUInt64();
}

enum class WebCore::RunAsAsyncFunction : bool;
enum class WebCore::ForceUserGesture : bool;
enum class WebCore::RemoveTransientActivation : bool;

struct WebCore::RunJavaScriptParameters {
    String source;
    JSC::SourceTaintedOrigin taintedness;
    URL sourceURL;
    WebCore::RunAsAsyncFunction runAsAsyncFunction;
    std::optional<WebCore::ArgumentWireBytesMap> arguments;
    WebCore::ForceUserGesture forceUserGesture;
    WebCore::RemoveTransientActivation removeTransientActivation;
}

header: <WebCore/FontAttributes.h>
[CustomHeader] struct WebCore::TextList {
    WebCore::ListStyleType styleType;
    int startingItemNumber
    bool ordered
};

[Nested] enum class WebCore::FontAttributes::SubscriptOrSuperscript : uint8_t {
    None,
    Subscript,
    Superscript
};

[Nested] enum class WebCore::FontAttributes::HorizontalAlignment : uint8_t {
    Left,
    Center,
    Right,
    Justify,
    Natural
};

#if USE(CORE_TEXT)
[RefCounted] class WebCore::Font {
    WebCore::FontInternalAttributes attributes();
    WebCore::FontPlatformData platformData();
}
#endif

[CustomHeader] struct WebCore::FontAttributes {
    RefPtr<WebCore::Font> font
    WebCore::Color backgroundColor
    WebCore::Color foregroundColor
    WebCore::FontShadow fontShadow
    WebCore::FontAttributes::SubscriptOrSuperscript subscriptOrSuperscript
    WebCore::FontAttributes::HorizontalAlignment horizontalAlignment
    Vector<WebCore::TextList> textLists
    bool hasUnderline
    bool hasStrikeThrough
    bool hasMultipleFonts
};

header: <WebCore/WritingDirection.h>
enum class WebCore::WritingDirection : uint8_t {
    Natural,
    LeftToRight,
    RightToLeft
};

header: <WebCore/VisibleSelection.h>
enum class WebCore::SelectionDirection : uint8_t {
    Forward,
    Backward,
    Right,
    Left
};

#if ENABLE(DATA_DETECTION)
header: <WebCore/DataDetectorType.h>
[OptionSet] enum class WebCore::DataDetectorType : uint8_t {
    PhoneNumber,
    Link,
    Address,
    CalendarEvent,
    TrackingNumber,
    FlightNumber,
    LookupSuggestion,
};
#endif

header: <WebCore/AutocapitalizeTypes.h>
enum class WebCore::AutocapitalizeType : uint8_t {
    Default,
    None,
    Words,
    Sentences,
    AllCharacters
};

enum class WebCore::CrossOriginEmbedderPolicyValue : bool

struct WebCore::CrossOriginEmbedderPolicy {
    WebCore::CrossOriginEmbedderPolicyValue value;
    WebCore::CrossOriginEmbedderPolicyValue reportOnlyValue;
    String reportingEndpoint;
    String reportOnlyReportingEndpoint;
};

struct WebCore::SameSiteInfo {
    bool isSameSite;
    bool isTopSite;
    bool isSafeHTTPMethod;
};

[RefCounted] class WebCore::SecurityOrigin {
    WebCore::SecurityOriginData m_data;
    String m_domain;
    String m_filePath;
    bool m_universalAccess;
    bool m_domainWasSetInDOM;
    bool m_canLoadLocalResources;
    bool m_enforcesFilePathSeparation;
    bool m_needsStorageAccessFromFileURLsQuirk;
    std::optional<bool> m_isPotentiallyTrustworthy;
    bool m_isLocal;
}

enum class WebCore::IncludeSecureCookies : bool;

struct WebCore::CookieRequestHeaderFieldProxy {
    URL firstParty;
    WebCore::SameSiteInfo sameSiteInfo;
    URL url;
    std::optional<WebCore::FrameIdentifier> frameID;
    std::optional<WebCore::PageIdentifier> pageID;
    WebCore::IncludeSecureCookies includeSecureCookies;
};

[RefCounted] class WebCore::FormData {
    Vector<WebCore::FormDataElement> m_elements;
    int64_t m_identifier;
    bool m_alwaysStream;
    Vector<char> m_boundary;
    [NotSerialized] std::optional<uint64_t> m_lengthInBytes;
};

#if ENABLE(ASYNC_SCROLLING)
header: <WebCore/ScrollingStateNode.h>
[OptionSet] enum class WebCore::ScrollingStateNodeProperty : uint64_t {
    Layer
    ChildNodes
    ScrollableAreaSize
    TotalContentsSize
    ReachableContentsSize
    ScrollPosition
    ScrollOrigin
    ScrollableAreaParams
#if ENABLE(SCROLLING_THREAD)
    ReasonsForSynchronousScrolling
#endif
    RequestedScrollPosition
    SnapOffsetsInfo
    CurrentHorizontalSnapOffsetIndex
    CurrentVerticalSnapOffsetIndex
    IsMonitoringWheelEvents
    ScrollContainerLayer
    ScrolledContentsLayer
    HorizontalScrollbarLayer
    VerticalScrollbarLayer
    PainterForScrollbar
    ContentAreaHoverState
    MouseActivityState
    ScrollbarHoverState
    ScrollbarEnabledState
    FrameScaleFactor
    EventTrackingRegion
    RootContentsLayer
    CounterScrollingLayer
    InsetClipLayer
    ContentShadowLayer
    HeaderHeight
    FooterHeight
    HeaderLayer
    FooterLayer
    BehaviorForFixedElements
    TopContentInset
    FixedElementsLayoutRelativeToFrame
    VisualViewportIsSmallerThanLayoutViewport
    AsyncFrameOrOverflowScrollingEnabled
    WheelEventGesturesBecomeNonBlocking
    ScrollingPerformanceTestingEnabled
    LayoutViewport
    MinLayoutViewportOrigin
    MaxLayoutViewportOrigin
    OverrideVisualViewportSize
    RelatedOverflowScrollingNodes
    LayoutConstraintData
    ViewportConstraints
    OverflowScrollingNode
    KeyboardScrollData
    OverlayScrollbarsEnabled
    LayerHostingContextIdentifier
};
#endif

[CustomHeader] struct WebCore::RequestedScrollData {
    WebCore::ScrollRequestType requestType;
    std::variant<WebCore::FloatPoint, WebCore::FloatSize> scrollPositionOrDelta;
    WebCore::ScrollType scrollType;
    WebCore::ScrollClamping clamping;
    WebCore::ScrollIsAnimated animated;
    std::optional<std::tuple<WebCore::ScrollRequestType, std::variant<WebCore::FloatPoint, WebCore::FloatSize>, WebCore::ScrollType, WebCore::ScrollClamping>> requestedDataBeforeAnimatedScroll;
}

[Alias=struct ScrollSnapOffsetsInfo<float,WebCore::FloatRect>, CustomHeader] alias WebCore::FloatScrollSnapOffsetsInfo {
    WebCore::ScrollSnapStrictness strictness;
    Vector<WebCore::FloatSnapOffset> horizontalSnapOffsets;
    Vector<WebCore::FloatSnapOffset> verticalSnapOffsets;
    Vector<WebCore::FloatRect> snapAreas;
    Vector<WebCore::ElementIdentifier> snapAreasIDs;
}

[Alias=struct SnapOffset<float>, CustomHeader] alias WebCore::FloatSnapOffset {
    float offset;
    WebCore::ScrollSnapStop stop;
    bool hasSnapAreaLargerThanViewport;
    WebCore::ElementIdentifier snapTargetID;
    bool isFocused;
    Vector<size_t> snapAreaIndices;
};

#if ENABLE(ENCRYPTED_MEDIA)

enum class WebCore::CDMEncryptionScheme : bool;

enum class WebCore::CDMKeyGroupingStrategy : bool;

struct WebCore::CDMMediaCapability {
    String contentType;
    String robustness;
    std::optional<WebCore::CDMEncryptionScheme> encryptionScheme;
};

enum class WebCore::CDMSessionType : uint8_t {
    Temporary,
    PersistentUsageRecord,
    PersistentLicense
};
using WebCore::CDMInstanceSession::LicenseType = WebCore::CDMSessionType;

struct WebCore::CDMRestrictions {
    bool distinctiveIdentifierDenied;
    bool persistentStateDenied;
    HashSet<WebCore::CDMSessionType, IntHash<WebCore::CDMSessionType>, WTF::StrongEnumHashTraits<WebCore::CDMSessionType>> deniedSessionTypes;
};

#endif

struct WebCore::MediaSelectionOption {
    WebCore::MediaSelectionOption::MediaType mediaType;
    String displayName;
    WebCore::MediaSelectionOption::LegibleType legibleType;
};

[Nested] enum class WebCore::MediaSelectionOption::MediaType : uint8_t {
    Unknown,
    Audio,
    Subtitles,
    Captions,
    Metadata,
};

[Nested] enum class WebCore::MediaSelectionOption::LegibleType : uint8_t {
    Regular,
    LegibleOff,
    LegibleAuto,
};

enum class WebCore::MediaDecodingType : uint8_t {
    File,
    MediaSource,
    WebRTC
};

enum class WebCore::MediaEncodingType : bool;

class WebCore::BufferSource {
    std::span<const uint8_t> span()
}

struct WebCore::FontShadow {
    WebCore::Color color;
    WebCore::FloatSize offset;
    double blurRadius;
};

struct WebCore::CompositionHighlight {
    unsigned startOffset;
    unsigned endOffset;
    std::optional<WebCore::Color> backgroundColor;
    std::optional<WebCore::Color> foregroundColor;
};

header: <WebCore/FontAttributeChanges.h>
[CustomHeader] class WebCore::FontChanges {
    String m_fontName;
    String m_fontFamily;
    std::optional<double> m_fontSize;
    [Validator='!*m_fontSize || !*m_fontSizeDelta'] std::optional<double> m_fontSizeDelta;
    std::optional<bool> m_bold;
    std::optional<bool> m_italic;
};

class WebCore::FontAttributeChanges {
    std::optional<WebCore::VerticalAlignChange> m_verticalAlign;
    std::optional<WebCore::Color> m_backgroundColor;
    std::optional<WebCore::Color> m_foregroundColor;
    std::optional<WebCore::FontShadow> m_shadow;
    std::optional<bool> m_strikeThrough;
    std::optional<bool> m_underline;
    WebCore::FontChanges m_fontChanges;
};

header: <WebCore/TextManipulationController.h>
[Nested, CustomHeader] enum class WebCore::TextManipulationControllerExclusionRule::Type : uint8_t {
    Exclude,
    Include
};

header: <WebCore/TextManipulationController.h>
[Nested, CustomHeader] struct WebCore::TextManipulationControllerExclusionRule::ElementRule {
    AtomString localName;
};

header: <WebCore/TextManipulationController.h>
[Nested, CustomHeader] struct WebCore::TextManipulationControllerExclusionRule::AttributeRule {
    AtomString name;
    String value;
};

header: <WebCore/TextManipulationController.h>
[Nested, CustomHeader] struct WebCore::TextManipulationControllerExclusionRule::ClassRule {
    AtomString className;
};

header: <WebCore/TextManipulationController.h>
[CustomHeader] struct WebCore::TextManipulationControllerExclusionRule {
    WebCore::TextManipulationControllerExclusionRule::Type type;
    std::variant<WebCore::TextManipulationControllerExclusionRule::ElementRule, WebCore::TextManipulationControllerExclusionRule::AttributeRule, WebCore::TextManipulationControllerExclusionRule::ClassRule> rule;
};

header: <WebCore/TextManipulationController.h>
[Nested, CustomHeader] enum class WebCore::TextManipulationControllerManipulationFailure::Type : uint8_t {
    NotAvailable,
    ContentChanged,
    InvalidItem,
    InvalidToken,
    ExclusionViolation,
};

header: <WebCore/TextManipulationController.h>
[CustomHeader] struct WebCore::TextManipulationControllerManipulationFailure {
    WebCore::FrameIdentifier frameID;
    WebCore::TextManipulationItemIdentifier identifier;
    uint64_t index;
    WebCore::TextManipulationControllerManipulationFailure::Type type;
};

struct WebCore::BackgroundFetchInformation {
    WebCore::ServiceWorkerRegistrationIdentifier registrationIdentifier;
    String identifier;
    uint64_t uploadTotal;
    uint64_t uploaded;
    uint64_t downloadTotal;
    uint64_t downloaded;
    WebCore::BackgroundFetchResult result;
    WebCore::BackgroundFetchFailureReason failureReason;
    bool recordsAvailable;
};

struct WebCore::BackgroundFetchRequest {
    WebCore::ResourceRequest internalRequest;
    WebCore::FetchOptions options;
    WebCore::FetchHeadersGuard guard;
    WebCore::HTTPHeaderMap httpHeaders;
    String referrer;
    Markable<WebCore::ContentSecurityPolicyResponseHeaders, WebCore::ContentSecurityPolicyResponseHeaders::MarkableTraits> cspResponseHeaders;
};

struct WebCore::BackgroundFetchRecordInformation {
    WebCore::BackgroundFetchRecordIdentifier identifier;
    WebCore::ResourceRequest internalRequest;
    WebCore::FetchOptions options;
    WebCore::FetchHeadersGuard guard;
    WebCore::HTTPHeaderMap httpHeaders;
    String referrer;
};

struct WebCore::BackgroundFetchOptions {
    Vector<WebCore::ImageResource> icons;
    String title;
    uint64_t downloadTotal;
};

struct WebCore::ImageResource {
    String src;
    String sizes;
    String type;
    String label;
};

using WebCore::SharedStringHash = uint32_t

struct WebCore::FourCC {
    uint32_t value;
};

#if ENABLE(VIDEO)
header: <WebCore/MediaPlayer.h>
[CustomHeader] struct WebCore::MediaEngineSupportParameters {
    WebCore::ContentType type;
    URL url;
    bool isMediaSource;
    bool isMediaStream;
    bool requiresRemotePlayback;
    Vector<WebCore::ContentType> contentTypesRequiringHardwareSupport;
    std::optional<Vector<String>> allowedMediaContainerTypes;
    std::optional<Vector<String>> allowedMediaCodecTypes;
    std::optional<Vector<WebCore::FourCC>> allowedMediaVideoCodecIDs;
    std::optional<Vector<WebCore::FourCC>> allowedMediaAudioCodecIDs;
    std::optional<Vector<WebCore::FourCC>> allowedMediaCaptionFormatTypes;
};

header: <WebCore/MediaPlayer.h>
[CustomHeader] struct WebCore::SeekTarget {
    MediaTime time;
    MediaTime negativeThreshold;
    MediaTime positiveThreshold;
};

#endif

enum class WebCore::MediaPlayerNetworkState : uint8_t {
    Empty,
    Idle,
    Loading,
    Loaded,
    FormatError,
    NetworkError,
    DecodeError
};

enum class WebCore::MediaPlayerReadyState : uint8_t {
    HaveNothing,
    HaveMetadata,
    HaveCurrentData,
    HaveFutureData,
    HaveEnoughData
};

enum class WebCore::MediaPlayerMovieLoadType : uint8_t {
    Unknown,
    Download,
    StoredStream,
    LiveStream,
    HttpLiveStream
};

enum class WebCore::MediaPlayerPreload : uint8_t {
    None,
    MetaData,
    Auto
};

enum class WebCore::MediaPlayerVideoGravity : uint8_t {
    Resize,
    ResizeAspect,
    ResizeAspectFill
};

enum class WebCore::MediaPlayerSupportsType : uint8_t {
    IsNotSupported,
    IsSupported,
    MayBeSupported
};

enum class WebCore::MediaPlayerBufferingPolicy : uint8_t {
    Default,
    LimitReadAhead,
    MakeResourcesPurgeable,
    PurgeResources,
};

enum class WebCore::MediaPlayerMediaEngineIdentifier : uint8_t {
    AVFoundation,
    AVFoundationMSE,
    AVFoundationMediaStream,
    AVFoundationCF,
    GStreamer,
    GStreamerMSE,
    HolePunch,
    MediaFoundation,
    MockMSE,
    CocoaWebM
};

enum class WebCore::MediaPlayerWirelessPlaybackTargetType : uint8_t {
    TargetTypeNone,
    TargetTypeAirPlay,
    TargetTypeTVOut
};

enum class WebCore::MediaPlayerPitchCorrectionAlgorithm : uint8_t {
    BestAllAround,
    BestForMusic,
    BestForSpeech,
};

class WebCore::GeolocationPositionData {
    double timestamp;
    double latitude;
    double longitude;
    double accuracy;
    std::optional<double> altitude;
    std::optional<double> altitudeAccuracy;
    std::optional<double> heading;
    std::optional<double> speed;
    std::optional<double> floorLevel;
};

#if ENABLE(APP_HIGHLIGHTS)
enum class WebCore::CreateNewGroupForHighlight : bool

enum class WebCore::HighlightRequestOriginatedInApp : bool

struct WebCore::AppHighlight {
    Ref<WebCore::FragmentedSharedBuffer> highlight;
    std::optional<String> text;
    WebCore::CreateNewGroupForHighlight isNewGroup;
    WebCore::HighlightRequestOriginatedInApp requestOriginatedInApp;
};
#endif // ENABLE(APP_HIGHLIGHTS)

struct WebCore::MediaDeviceHashSalts {
    String persistentDeviceSalt;
    String ephemeralDeviceSalt;
};

enum class WebCore::SpeechRecognitionUpdateType : uint8_t {
    Start,
    AudioStart,
    SoundStart,
    SpeechStart,
    SpeechEnd,
    SoundEnd,
    AudioEnd,
    Result,
    NoMatch,
    Error,
    End
};

class WebCore::SpeechRecognitionUpdate {
    WebCore::SpeechRecognitionConnectionClientIdentifier m_clientIdentifier;
    WebCore::SpeechRecognitionUpdateType m_type;
    std::variant<std::monostate, WebCore::SpeechRecognitionError, Vector<WebCore::SpeechRecognitionResultData>> m_content;
};

#if USE(SYSTEM_PREVIEW)
[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::ARKitBadgeSystemImage {
    WebCore::RenderingResourceIdentifier imageIdentifier();
    WebCore::FloatSize m_imageSize;
};
#endif

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::CompositeOperator : uint8_t {
    Clear,
    Copy,
    SourceOver,
    SourceIn,
    SourceOut,
    SourceAtop,
    DestinationOver,
    DestinationIn,
    DestinationOut,
    DestinationAtop,
    XOR,
    PlusDarker,
    PlusLighter,
    Difference
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::BlendMode : uint8_t {
    Normal,
    Multiply,
    Screen,
    Darken,
    Lighten,
    Overlay,
    ColorDodge,
    ColorBurn,
    HardLight,
    SoftLight,
    Difference,
    Exclusion,
    Hue,
    Saturation,
    Color,
    Luminosity,
    PlusDarker,
    PlusLighter
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::GradientSpreadMethod : uint8_t {
    Pad,
    Reflect,
    Repeat
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::InterpolationQuality : uint8_t {
    Default,
    DoNotInterpolate,
    Low,
    Medium,
    High
};

header: <WebCore/AudioIOCallback.h>
[CustomHeader] struct WebCore::AudioIOPosition {
    Seconds position;
    MonotonicTime timestamp;
};

#if ENABLE(VIDEO)
header: <WebCore/VideoFrame.h>
enum class WebCore::VideoFrameRotation : uint16_t {
    None,
    UpsideDown,
    Right,
    Left,
};
#endif

#if ENABLE(VIDEO) && USE(AVFOUNDATION)
[RefCounted] class WebCore::VideoFrameCV {
    MediaTime presentationTime();
    bool isMirrored();
    WebCore::VideoFrameRotation rotation();
    RetainPtr<CVPixelBufferRef> m_pixelBuffer;
    WebCore::PlatformVideoColorSpace colorSpace();
};
#endif

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::GradientColorStop {
    float offset;
    WebCore::Color color;
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::GradientColorStops {
    Vector<WebCore::GradientColorStop, 2> stops();
};

header: <WebCore/ImageBuffer.h>
[CustomHeader] struct WebCore::ImageBufferParameters {
    WebCore::FloatSize logicalSize;
    float resolutionScale;
    WebCore::DestinationColorSpace colorSpace
    WebCore::PixelFormat pixelFormat;
    WebCore::RenderingPurpose purpose;
};

enum class WebCore::PreserveResolution : bool;

[RValue] class WebCore::ProcessIdentity {
#if HAVE(TASK_IDENTITY_TOKEN)
    MachSendRight m_taskIdToken;
#endif
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::ColorInterpolationColorSpace : uint8_t {
    HSL,
    HWB,
    LCH,
    Lab,
    OKLCH,
    OKLab,
    SRGB,
    SRGBLinear,
    XYZD50,
    XYZD65
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::HueInterpolationMethod : uint8_t {
    Shorter,
    Longer,
    Increasing,
    Decreasing
};

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::HSL {
    WebCore::HueInterpolationMethod hueInterpolationMethod;
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::HWB {
    WebCore::HueInterpolationMethod hueInterpolationMethod;
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::LCH {
    WebCore::HueInterpolationMethod hueInterpolationMethod;
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::Lab {
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::OKLCH {
    WebCore::HueInterpolationMethod hueInterpolationMethod;
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::OKLab {
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::SRGB {
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::SRGBLinear {
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::XYZD50 {
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::XYZD65 {
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod {
    std::variant<WebCore::ColorInterpolationMethod::HSL, WebCore::ColorInterpolationMethod::HWB, WebCore::ColorInterpolationMethod::LCH, WebCore::ColorInterpolationMethod::Lab, WebCore::ColorInterpolationMethod::OKLCH, WebCore::ColorInterpolationMethod::OKLab, WebCore::ColorInterpolationMethod::SRGB, WebCore::ColorInterpolationMethod::SRGBLinear, WebCore::ColorInterpolationMethod::XYZD50, WebCore::ColorInterpolationMethod::XYZD65> colorSpace;
    WebCore::AlphaPremultiplication alphaPremultiplication;
};

#if USE(AUDIO_SESSION)
header: <WebCore/AudioSession.h>
[CustomHeader] enum class WebCore::RouteSharingPolicy : uint8_t {
    Default,
    LongFormAudio,
    Independent,
    LongFormVideo
};

enum class WebCore::AudioSessionCategory : uint8_t {
    None,
    AmbientSound,
    SoloAmbientSound,
    MediaPlayback,
    RecordAudio,
    PlayAndRecord,
    AudioProcessing,
};

enum class WebCore::AudioSessionMode : uint8_t {
    Default,
    VideoChat,
    MoviePlayback,
};

[Nested] enum class WebCore::AudioSession::MayResume : bool;

enum class WebCore::AudioSessionRoutingArbitrationError : uint8_t {
    None,
    Failed,
    Cancelled
};

[Nested] enum class WebCore::AudioSessionRoutingArbitrationClient::DefaultRouteChanged : bool;
#endif

#if ENABLE(ENCRYPTED_MEDIA)
enum class WebCore::CDMKeyStatus : uint8_t {
    Usable,
    Expired,
    Released,
    OutputRestricted,
    OutputDownscaled,
    StatusPending,
    InternalError
};

enum class WebCore::CDMMessageType : uint8_t {
    LicenseRequest,
    LicenseRenewal,
    LicenseRelease,
    IndividualizationRequest
};

enum class WebCore::CDMRequirement : uint8_t {
    Required,
    Optional,
    NotAllowed
};

header: <WebCore/CDMInstanceSession.h>
enum class WebCore::CDMInstanceSessionLoadFailure : uint8_t {
    None,
    NoSessionData,
    MismatchedSessionType,
    QuotaExceeded,
    Other,
};

header: <WebCore/CDMInstance.h>
[Nested] enum class WebCore::CDMInstance::HDCPStatus : uint8_t {
    Unknown,
    Valid,
    OutputRestricted,
    OutputDownscaled,
};
#endif

#if ENABLE(WEB_RTC)
enum class WebCore::RTCDataChannelState : uint8_t {
    Connecting,
    Open,
    Closing,
    Closed
};

enum class WebCore::RTCPriorityType : uint8_t {
    VeryLow,
    Low,
    Medium,
    High
};
#endif

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::LineCap : uint8_t {
    Butt,
    Round,
    Square
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::LineJoin : uint8_t {
    Miter,
    Round,
    Bevel
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::StrokeStyle : uint8_t {
    NoStroke,
    SolidStroke,
    DottedStroke,
    DashedStroke,
    DoubleStroke,
    WavyStroke,
};

[OptionSet, AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::TextDrawingMode : uint8_t {
    Fill,
    Stroke,
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::DecodingMode : uint8_t {
    Auto,
    Synchronous,
    Asynchronous
};

header: <WebCore/GraphicsTypes.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::CompositeMode {
    WebCore::CompositeOperator operation;
    WebCore::BlendMode blendMode;
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::DocumentMarkerLineStyleMode : uint8_t {
    TextCheckingDictationPhraseWithAlternatives,
    Spelling,
    Grammar,
    AutocorrectionReplacement,
    DictationAlternatives
};

header: <WebCore/GraphicsTypes.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::DocumentMarkerLineStyle {
    WebCore::DocumentMarkerLineStyleMode mode;
    WebCore::Color color;
};

[Nested, AdditionalEncoder=StreamConnectionEncoder]  enum class WebCore::ShadowRadiusMode : bool;

header: <WebCore/GraphicsStyle.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::GraphicsDropShadow {
    WebCore::FloatSize offset;
    float radius;
    WebCore::Color color;
    WebCore::ShadowRadiusMode radiusMode;
    float opacity;
};

header: <WebCore/GraphicsStyle.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::GraphicsGaussianBlur {
    WebCore::FloatSize radius;
};

header: <WebCore/GraphicsStyle.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::GraphicsColorMatrix {
    std::array<float, 20> values;
};

header: <WebCore/PlatformMediaSession.h>
[CustomHeader] struct WebCore::PlatformMediaSessionRemoteCommandArgument {
    std::optional<double> time;
    std::optional<bool> fastSeek;
}
using WebCore::PlatformMediaSession::RemoteCommandArgument = WebCore::PlatformMediaSessionRemoteCommandArgument;

class WebCore::SocketStreamError {
    int m_errorCode;
    String m_failingURL;
    String m_localizedDescription;
    bool m_isNull;
}

#if ENABLE(VIDEO)
[Nested, AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::GenericCueData::Alignment : uint8_t {
    None,
    Start,
    Middle,
    End
};

[Nested, AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::GenericCueData::Status : uint8_t {
    Uninitialized,
    Partial,
    Complete
};

header: <WebCore/InbandGenericCue.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::GenericCueData {
    WebCore::InbandGenericCueIdentifier m_uniqueId;
    MediaTime m_startTime;
    MediaTime m_endTime;
    AtomString m_id;
    String m_content;
    String m_fontName;
    double m_line;
    double m_position;
    double m_size;
    double m_baseFontSize;
    double m_relativeFontSize;
    WebCore::Color m_foregroundColor;
    WebCore::Color m_backgroundColor;
    WebCore::Color m_highlightColor;
    WebCore::GenericCueData::Alignment m_positionAlign;
    WebCore::GenericCueData::Alignment m_align;
    WebCore::GenericCueData::Status m_status;
};
#endif

header: <WebCore/ImageDecoder.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ImageDecoderFrameInfo {
    bool hasAlpha;
    Seconds duration;
}

header: <WebCore/DisplayListItems.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::DrawDotsForDocumentMarker {
    WebCore::FloatRect rect();
    WebCore::DocumentMarkerLineStyle style();
};

[Nested] enum class WebCore::ImageOrientation::Orientation : uint8_t {
    FromImage,
    OriginTopLeft,
    OriginTopRight,
    OriginBottomRight,
    OriginBottomLeft,
    OriginLeftTop,
    OriginRightTop,
    OriginRightBottom,
    OriginLeftBottom,
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ImageOrientation {
    WebCore::ImageOrientation::Orientation orientation()
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ImagePaintingOptions {
     WebCore::CompositeOperator compositeOperator();
     WebCore::BlendMode blendMode();
     WebCore::DecodingMode decodingMode();
     WebCore::ImageOrientation::Orientation orientation().orientation();
     WebCore::InterpolationQuality interpolationQuality();
};

struct WebCore::CanvasActivityRecord {
    HashSet<String> textWritten;
    bool wasDataRead;
};

header: <WebCore/AttributionSecondsUntilSendData.h>
[CustomHeader] struct WebCore::PCM::AttributionSecondsUntilSendData {
    std::optional<Seconds> sourceSeconds;
    std::optional<Seconds> destinationSeconds;
};

enum class WebCore::CrossOriginOpenerPolicyValue : uint8_t {
    UnsafeNone,
    SameOrigin,
    SameOriginPlusCOEP,
    SameOriginAllowPopups
};

struct WebCore::CrossOriginOpenerPolicy {
    WebCore::CrossOriginOpenerPolicyValue value;
    WebCore::CrossOriginOpenerPolicyValue reportOnlyValue;
    String reportingEndpoint;
    String reportOnlyReportingEndpoint;
};

struct WebCore::CustomHeaderFields {
    Vector<WebCore::HTTPHeaderField> fields;
    Vector<String> thirdPartyDomains;
};

[CreateUsing=create] class WebCore::HTTPHeaderField {
    String name();
    String value();
};

struct WebCore::NavigationRequester {
    URL url;
    Ref<WebCore::SecurityOrigin> securityOrigin;
    Ref<WebCore::SecurityOrigin> topOrigin;
    WebCore::PolicyContainer policyContainer;
    std::optional<WebCore::FrameIdentifier> frameID;
    std::optional<WebCore::PageIdentifier> pageID;
    WebCore::ScriptExecutionContextIdentifier documentIdentifier;
    WebCore::SandboxFlags sandboxFlags;
};

struct WebCore::PolicyContainer {
    WebCore::ContentSecurityPolicyResponseHeaders contentSecurityPolicyResponseHeaders;
    WebCore::CrossOriginEmbedderPolicy crossOriginEmbedderPolicy;
    WebCore::CrossOriginOpenerPolicy crossOriginOpenerPolicy;
    WebCore::ReferrerPolicy referrerPolicy;
};

[Nested] enum class WebCore::SubstituteData::SessionHistoryVisibility : bool

class WebCore::SubstituteData {
    RefPtr<WebCore::FragmentedSharedBuffer> content();
    URL failingURL();
    WebCore::ResourceResponse response();
    WebCore::SubstituteData::SessionHistoryVisibility shouldRevealToSessionHistory();
};

header: <WebCore/HTTPCookieAcceptPolicy.h>
enum class WebCore::HTTPCookieAcceptPolicy : uint8_t {
    AlwaysAccept,
    Never,
    OnlyFromMainDocumentDomain,
    ExclusivelyFromMainDocumentDomain,
};

enum class WebCore::NetworkLoadPriority : uint8_t {
    Low,
    Medium,
    High,
    Unknown,
};

enum class WebCore::PrivacyStance : uint8_t {
    Unknown,
    NotEligible,
    Proxied,
    Failed,
    Direct,
    FailedUnreachable,
};

enum class WebCore::ThirdPartyCookieBlockingMode : uint8_t {
    All,
    AllExceptBetweenAppBoundDomains,
    AllExceptManagedDomains,
    AllOnSitesWithoutUserInteraction,
    OnlyAccordingToPerDomainPolicy
};

enum class WebCore::FirstPartyWebsiteDataRemovalMode : uint8_t {
    AllButCookies,
    None,
    AllButCookiesLiveOnTestingTimeout,
    AllButCookiesReproTestingTimeout
};

header: <WebCore/DragData.h>
[OptionSet, CustomHeader] enum class WebCore::DragApplicationFlags : uint8_t {
    IsModal,
    IsSource,
    HasAttachedSheet,
    IsCopyKeyDown
};

[OptionSet] enum class WebCore::TextCheckingType : uint8_t {
    None,
    Spelling,
    Grammar,
    Link,
    Quote,
    Dash,
    Replacement,
    Correction,
    ShowCorrectionPanel,
};

enum class WebCore::ServiceWorkerClientType : uint8_t {
    Window,
    Worker,
    Sharedworker,
    All
};

enum class WebCore::ServiceWorkerJobType : uint8_t {
    Register,
    Unregister,
    Update,
};

enum class WebCore::ServiceWorkerRegistrationState : uint8_t {
    Installing,
    Waiting,
    Active,
};

enum class WebCore::ServiceWorkerState : uint8_t {
    Parsed,
    Installing,
    Installed,
    Activating,
    Activated,
    Redundant,
};

enum class WebCore::ServiceWorkerClientFrameType : uint8_t {
    Auxiliary,
    TopLevel,
    Nested,
    None
};

enum class WebCore::ServiceWorkerIsInspectable : bool
enum class WebCore::ShouldNotifyWhenResolved : bool

enum class WebCore::ServiceWorkerUpdateViaCache : uint8_t {
    Imports,
    All,
    None,
};

struct WebCore::ServiceWorkerClientData {
    WebCore::ScriptExecutionContextIdentifier identifier;
    WebCore::ServiceWorkerClientType type;
    WebCore::ServiceWorkerClientFrameType frameType;
    URL url;
    URL ownerURL;
    std::optional<WebCore::PageIdentifier> pageIdentifier;
    std::optional<WebCore::FrameIdentifier> frameIdentifier;
    WebCore::LastNavigationWasAppInitiated lastNavigationWasAppInitiated;
    OptionSet<WebCore::AdvancedPrivacyProtections> advancedPrivacyProtections;
    bool isVisible;
    bool isFocused;
    uint64_t focusOrder;
    Vector<String> ancestorOrigins;
};


header: <WebCore/ServiceWorkerClientPendingMessage.h>
[CustomHeader] struct WebCore::ServiceWorkerClientPendingMessage {
    WebCore::MessageWithMessagePorts message;
    WebCore::ServiceWorkerData sourceData;
    String sourceOrigin;
};

struct WebCore::ServiceWorkerClientQueryOptions {
    bool includeUncontrolled;
    WebCore::ServiceWorkerClientType type;

};

struct WebCore::ServiceWorkerData {
    WebCore::ServiceWorkerIdentifier identifier;
    WebCore::ServiceWorkerRegistrationIdentifier registrationIdentifier;
    URL scriptURL;
    WebCore::ServiceWorkerState state;
    WebCore::WorkerType type;
};

struct WebCore::ServiceWorkerJobData {
    WebCore::ServiceWorkerJobDataIdentifier identifier();
    URL scriptURL;
    URL clientCreationURL;
    WebCore::SecurityOriginData topOrigin;
    URL scopeURL;
    WebCore::ServiceWorkerOrClientIdentifier sourceContext;
    WebCore::WorkerType workerType;

    WebCore::ServiceWorkerJobType type;

    String domainForCachePartition;
    bool isFromServiceWorkerPage;

    [Validator='( type == WebCore::ServiceWorkerJobType::Register && registrationOptions->has_value()) || (type != WebCore::ServiceWorkerJobType::Register && !registrationOptions->has_value() )'] std::optional<WebCore::ServiceWorkerRegistrationOptions> registrationOptions;
};

struct WebCore::EventInit {
    bool bubbles;
    bool cancelable;
    bool composed;
};

struct WebCore::MessageWithMessagePorts {
    RefPtr<WebCore::SerializedScriptValue> message;
    Vector<WebCore::TransferredMessagePort> transferredPorts;
};

enum class WebCore::StorageAccessWasGranted : bool

enum class WebCore::StorageAccessPromptWasShown : bool

enum class WebCore::StorageAccessScope : bool

enum class WebCore::StorageAccessQuickResult : bool

header: <WebCore/DocumentStorageAccess.h>
[CustomHeader] struct WebCore::RequestStorageAccessResult {
    WebCore::StorageAccessWasGranted wasGranted;
    WebCore::StorageAccessPromptWasShown promptWasShown;
    WebCore::StorageAccessScope scope;
    WebCore::RegistrableDomain topFrameDomain;
    WebCore::RegistrableDomain subFrameDomain;
};

class WebCore::Exception {
    WebCore::ExceptionCode code();
    String message();
};

struct WebCore::ExceptionData {
    WebCore::ExceptionCode code;
    String message;
};

struct WebCore::MessagePortIdentifier {
    WebCore::ProcessIdentifier processIdentifier;
    WebCore::PortIdentifier portIdentifier;
};

header: <WebCore/SecurityPolicyViolationEvent.h>
[CustomHeader] struct WebCore::SecurityPolicyViolationEventInit : WebCore::EventInit {
    String documentURI;
    String referrer;
    String blockedURI;
    String violatedDirective;
    String effectiveDirective;
    String originalPolicy;
    String sourceFile;
    String sample;
    WebCore::SecurityPolicyViolationEventDisposition disposition;
    unsigned short statusCode;
    unsigned lineNumber;
    unsigned columnNumber;
};

[RefCounted] class WebCore::CSPViolationReportBody {
    String documentURL();
    String referrer();
    String blockedURL();
    String effectiveDirective();
    String originalPolicy();
    String sourceFile();
    String sample();
    WebCore::SecurityPolicyViolationEventDisposition disposition();
    unsigned short statusCode();
    unsigned long lineNumber();
    unsigned long columnNumber();
};

class WebCore::SecurityOriginData {
    std::variant<WebCore::SecurityOriginData::Tuple, WebCore::ProcessQualified<WebCore::OpaqueOriginIdentifier>> data();
};

[Nested] class WebCore::SecurityOriginData::Tuple {
    [Validator='!protocol->isHashTableDeletedValue()'] String protocol;
    String host;
    std::optional<uint16_t> port;
};

#if ENABLE(MEDIA_STREAM)

[Nested] enum class WebCore::MediaConstraint::DataType : uint8_t {
    Integer,
    Double,
    Boolean,
    String
};

enum class WebCore::MediaConstraintType : uint8_t {
    Unknown,
    Width,
    Height,
    AspectRatio,
    FrameRate,
    FacingMode,
    Volume,
    SampleRate,
    SampleSize,
    EchoCancellation,
    DeviceId,
    GroupId,
    DisplaySurface,
    LogicalSurface,
    WhiteBalanceMode,
    Zoom,
    Torch,
};

header: <WebCore/MediaConstraints.h>
[CustomHeader] class WebCore::MediaConstraint {
    WebCore::MediaConstraint::DataType dataType();
};

[CustomHeader] class WebCore::IntConstraint : WebCore::MediaConstraint {
    std::optional<int> m_min;
    std::optional<int> m_max;
    std::optional<int> m_exact;
    [Validator='*dataType == WebCore::MediaConstraint::DataType::Integer'] std::optional<int> m_ideal;
};

[CustomHeader] class WebCore::DoubleConstraint : WebCore::MediaConstraint {
    std::optional<double> m_min;
    std::optional<double> m_max;
    std::optional<double> m_exact;
    [Validator='*dataType == WebCore::MediaConstraint::DataType::Double'] std::optional<double> m_ideal;
};

[CustomHeader] class WebCore::BooleanConstraint : WebCore::MediaConstraint {
    std::optional<bool> m_exact;
    [Validator='*dataType == WebCore::MediaConstraint::DataType::Boolean'] std::optional<bool> m_ideal;
};

[CustomHeader] class WebCore::StringConstraint : WebCore::MediaConstraint {
    Vector<String> m_exact;
    [Validator='*dataType == WebCore::MediaConstraint::DataType::String'] Vector<String> m_ideal;
};

header: <WebCore/VideoPreset.h>
[CustomHeader] struct WebCore::FrameRateRange {
    double minimum;
    double maximum;
};

[CustomHeader] struct WebCore::VideoPresetData {
    WebCore::IntSize size;
    Vector<WebCore::FrameRateRange> frameRateRanges;
    double minZoom;
    double maxZoom;
};

class WebCore::RealtimeMediaSourceSupportedConstraints {
    bool supportsWidth();
    bool supportsHeight();
    bool supportsAspectRatio();
    bool supportsFrameRate();
    bool supportsFacingMode();
    bool supportsVolume();
    bool supportsSampleRate();
    bool supportsSampleSize();
    bool supportsEchoCancellation();
    bool supportsDeviceId();
    bool supportsGroupId();
    bool supportsDisplaySurface();
    bool supportsLogicalSurface();
    bool supportsFocusDistance();
    bool supportsWhiteBalanceMode();
    bool supportsZoom();
    bool supportsTorch();
};

[Nested] class WebCore::RealtimeMediaSource::Type : uint8_t {
    Audio,
    Video,
};

enum class WebCore::VideoFacingMode : uint8_t {
    Unknown,
    User,
    Environment,
    Left,
    Right
};

enum class WebCore::DisplaySurfaceType : uint8_t {
    Monitor,
    Window,
    Application,
    Browser,
    Invalid,
};

header: <WebCore/MeteringMode.h>
[CustomHeader] enum class WebCore::MeteringMode : uint8_t {
    None,
    Manual,
    SingleShot,
    Continuous,
};

class WebCore::RealtimeMediaSourceSettings {
    uint32_t width();
    uint32_t height();
    float frameRate();
    WebCore::VideoFacingMode facingMode();
    double volume();
    uint32_t sampleRate();
    uint32_t sampleSize();
    bool echoCancellation();
    String deviceId();
    String groupId();
    String label();
    WebCore::DisplaySurfaceType displaySurface();
    bool logicalSurface();
    WebCore::MeteringMode whiteBalanceMode();
    double zoom();
    bool torch();
    WebCore::RealtimeMediaSourceSupportedConstraints supportedConstraints();
};

[Nested] enum class WebCore::CaptureDevice::DeviceType : uint8_t {
    Unknown,
    Microphone,
    Speaker,
    Camera,
    Screen,
    Window,
    SystemAudio
};

class WebCore::CaptureDevice {
    String persistentId();
    WebCore::CaptureDevice::DeviceType type();
    String label();
    String groupId();
    bool enabled();
    bool isDefault();
    bool isMockDevice();
    bool isEphemeral();
};

struct WebCore::CaptureDeviceWithCapabilities {
    WebCore::CaptureDevice device;
    WebCore::RealtimeMediaSourceCapabilities capabilities;
};

[Nested] enum class WebCore::RealtimeMediaSourceCapabilities::EchoCancellation : bool

[Nested] struct WebCore::CapabilityRange::DoubleRange {
    double max;
    [Validator='min <= max'] double min;
};

[Nested] struct WebCore::CapabilityRange::LongRange {
    int max;
    [Validator='min <= max'] int min;
};

header: <WebCore/RealtimeMediaSourceCapabilities.h>
[CustomHeader, LegacyPopulateFromEmptyConstructor] class WebCore::CapabilityRange {
    std::optional<WebCore::CapabilityRange::DoubleRange> m_doubleRange;
    std::optional<WebCore::CapabilityRange::LongRange> m_longRange;
};

class WebCore::RealtimeMediaSourceCapabilities {
    WebCore::CapabilityRange width();
    WebCore::CapabilityRange height();
    WebCore::CapabilityRange aspectRatio();
    WebCore::CapabilityRange frameRate();
    Vector<WebCore::VideoFacingMode> facingMode();
    WebCore::CapabilityRange volume();
    WebCore::CapabilityRange sampleRate();
    WebCore::CapabilityRange sampleSize();
    WebCore::RealtimeMediaSourceCapabilities::EchoCancellation echoCancellation();
    String deviceId();
    String groupId();
    WebCore::CapabilityRange focusDistance();
    Vector<WebCore::MeteringMode> whiteBalanceModes();
    WebCore::CapabilityRange zoom();
    bool torch();
    WebCore::RealtimeMediaSourceSupportedConstraints supportedConstraints();
};

header: <WebCore/MockMediaDevice.h>
[Nested, OptionSet] enum class WebCore::MockMediaDevice::Flag : uint8_t {
    Ephemeral
    Invalid
};

#endif // ENABLE(MEDIA_STREAM)

enum class WebCore::PlatformVideoColorPrimaries : uint8_t {
    Bt709,
    Bt470bg,
    Smpte170m,
    Bt470m,
    Smpte240m,
    Film,
    Bt2020,
    SmpteSt4281,
    SmpteRp431,
    SmpteEg432,
    JedecP22Phosphors,
    Unspecified,
};

enum class WebCore::PlatformVideoTransferCharacteristics : uint8_t {
    Bt709,
    Smpte170m,
    Iec6196621,
    Gamma22curve,
    Gamma28curve,
    Smpte240m,
    Linear,
    Log,
    LogSqrt,
    Iec6196624,
    Bt1361ExtendedColourGamut,
    Bt2020_10bit,
    Bt2020_12bit,
    SmpteSt2084,
    SmpteSt4281,
    AribStdB67Hlg,
    Unspecified
};

enum class WebCore::PlatformVideoMatrixCoefficients : uint8_t {
    Rgb,
    Bt709,
    Bt470bg,
    Smpte170m,
    Smpte240m,
    Fcc,
    YCgCo,
    Bt2020NonconstantLuminance,
    Bt2020ConstantLuminance,
    Unspecified,
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::PlatformVideoColorSpace {
    std::optional<WebCore::PlatformVideoColorPrimaries> primaries;
    std::optional<WebCore::PlatformVideoTransferCharacteristics> transfer;
    std::optional<WebCore::PlatformVideoMatrixCoefficients> matrix;
    std::optional<bool> fullRange;
};

#if ENABLE(VIDEO)

struct WebCore::PlatformTrackConfiguration {
    String codec;
};

struct WebCore::PlatformAudioTrackConfiguration : WebCore::PlatformTrackConfiguration {
    uint32_t sampleRate;
    uint32_t numberOfChannels;
    uint64_t bitrate;
};

struct WebCore::PlatformVideoTrackConfiguration : WebCore::PlatformTrackConfiguration {
    uint32_t width;
    uint32_t height;
    WebCore::PlatformVideoColorSpace colorSpace;
    double framerate;
    uint64_t bitrate;
};

#endif

#if ENABLE(WEB_RTC)

header: <WebCore/RTCDataChannelHandler.h>
[CustomHeader] struct WebCore::RTCDataChannelInit {
    std::optional<bool> ordered;
    std::optional<unsigned short> maxPacketLifeTime;
    std::optional<unsigned short> maxRetransmits;
    String protocol;
    std::optional<bool> negotiated;
    std::optional<unsigned short> id;
    WebCore::RTCPriorityType priority;
};

struct WebCore::RTCDataChannelIdentifier {
    WebCore::ProcessIdentifier processIdentifier;
    WebCore::RTCDataChannelLocalIdentifier channelIdentifier;
};

#endif // ENABLE(WEB_RTC)

#if ENABLE(CONTENT_EXTENSIONS)

[Nested] struct WebCore::ContentRuleListResults::Result {
    bool blockedLoad;
    bool madeHTTPS;
    bool blockedCookies;
    bool modifiedHeaders;
    bool redirected;
    Vector<String> notifications;
};

[Nested] struct WebCore::ContentRuleListResults::Summary {
    bool blockedLoad;
    bool madeHTTPS;
    bool blockedCookies;
    bool hasNotifications;
    [NotSerialized] Vector<WebCore::ContentExtensions::ModifyHeadersAction> modifyHeadersActions;
    [NotSerialized] Vector<std::pair<WebCore::ContentExtensions::RedirectAction, URL>> redirectActions;
};

struct WebCore::ContentRuleListResults {
    WebCore::ContentRuleListResults::Summary summary;
    Vector<std::pair<String, WebCore::ContentRuleListResults::Result>> results;
};

#endif

enum class WebCore::PolicyAction : uint8_t {
    Use,
    Download,
    Ignore,
    LoadWillContinueInAnotherProcess
};

[OptionSet] enum class WebCore::ReloadOption : uint8_t {
    ExpiredOnly,
    FromOrigin,
    DisableContentBlockers
};

enum class WebCore::FrameLoadType : uint8_t {
    Standard,
    Back,
    Forward,
    IndexedBackForward,
    Reload,
    Same,
    RedirectWithLockedBackForwardList,
    Replace,
    ReloadFromOrigin,
    ReloadExpiredOnly
};

enum class WebCore::NavigationType : uint8_t {
    LinkClicked,
    FormSubmitted,
    BackForward,
    Reload,
    FormResubmitted,
    Other
};

enum class WebCore::BrowsingContextGroupSwitchDecision : uint8_t {
    StayInGroup,
    NewSharedGroup,
    NewIsolatedGroup,
};

enum class WebCore::ShouldOpenExternalURLsPolicy : uint8_t {
    ShouldNotAllow,
    ShouldAllowExternalSchemesButNotAppLinks,
    ShouldAllow,
};

header: <WebCore/NavigationScheduler.h>
enum class WebCore::ScheduleLocationChangeResult : uint8_t {
    Stopped,
    Completed,
    Started
};

header: <WebCore/DocumentLoader.h>
[CustomHeader] enum class WebCore::MouseEventPolicy : uint8_t {
    Default,
#if ENABLE(IOS_TOUCH_EVENTS)
    SynthesizeTouchEvents,
#endif
};

enum class WebCore::ColorSchemePreference : uint8_t {
    NoPreference,
    Light,
    Dark
};

enum class WebCore::ModalContainerObservationPolicy : bool

enum class WebCore::AllowsContentJavaScript : bool

[OptionSet] enum class WebCore::AdvancedPrivacyProtections : uint16_t {
    BaselineProtections,
    HTTPSFirst,
    HTTPSOnly,
    HTTPSOnlyExplicitlyBypassedForDomain,
    FailClosed,
    WebSearchContent,
    FingerprintingProtections,
    EnhancedNetworkPrivacy,
    LinkDecorationFiltering,
};

enum class WebCore::ViolationReportType : uint8_t {
    COEPInheritenceViolation,
    CORPViolation,
    ContentSecurityPolicy,
    CrossOriginOpenerPolicy,
    Deprecation,
    StandardReportingAPIViolation,
    Test
};

enum class WebCore::COEPDisposition : bool;

[RefCounted] class WebCore::COEPInheritenceViolationReportBody {
    WebCore::COEPDisposition m_disposition;
    URL m_blockedURL;
    String m_type;
};

[RefCounted] class WebCore::CORPViolationReportBody {
    WebCore::COEPDisposition m_disposition;
    URL m_blockedURL;
    WebCore::FetchOptionsDestination m_destination;
};

[RefCounted] class WebCore::ReportBody subclasses {
  WebCore::CSPViolationReportBody,
  WebCore::COEPInheritenceViolationReportBody,
  WebCore::CORPViolationReportBody,
  WebCore::DeprecationReportBody
  WebCore::TestReportBody
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::SourceImage {
    WebCore::RenderingResourceIdentifier imageIdentifier();
}

enum class WebCore::LinkIconType : uint8_t {
    Favicon,
    TouchIcon,
    TouchPrecomposedIcon
};

struct WebCore::LinkIcon {
    URL url;
    WebCore::LinkIconType type;
    String mimeType;
    std::optional<unsigned> size;
    Vector<std::pair<String, String>> attributes;
};

header: <WebCore/PluginData.h>
[CustomHeader] struct WebCore::SupportedPluginIdentifier {
    String matchingDomain;
    String pluginIdentifier;
};

enum class WebCore::PluginLoadClientPolicy : uint8_t {
    Undefined,
    Block,
    Ask,
    Allow,
    AllowAlways,
};

struct WebCore::CSSValueKey {
    unsigned cssValueID;
    bool useDarkAppearance;
    bool useElevatedUserInterfaceLevel;
};

struct WebCore::VideoFrameTimeMetadata {
    std::optional<double> processingDuration;
    std::optional<Seconds> captureTime;
    std::optional<Seconds> receiveTime;
    std::optional<unsigned> rtpTimestamp;
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::PositionedGlyphs {
    Vector<WebCore::GlyphBufferGlyph> glyphs;
    [Validator='glyphs->size() == advances->size()'] Vector<WebCore::GlyphBufferAdvance> advances;
    WebCore::FloatPoint localAnchor;
    WebCore::FontSmoothingMode smoothingMode;
};

class WebCore::EventRegion {
    WebCore::Region m_region;
#if ENABLE(TOUCH_ACTION_REGIONS)
    Vector<WebCore::Region> m_touchActionRegions;
#endif
#if ENABLE(WHEEL_EVENT_REGIONS)
    WebCore::Region m_wheelEventListenerRegion;
    WebCore::Region m_nonPassiveWheelEventListenerRegion;
#endif
#if ENABLE(EDITABLE_REGION)
    std::optional<WebCore::Region> m_editableRegion;
#endif
#if ENABLE(INTERACTION_REGIONS_IN_EVENT_REGION)
    Vector<WebCore::InteractionRegion> m_interactionRegions;
#endif
};

enum class WebCore::PasteboardItemPresentationStyle : uint8_t {
    Unspecified,
    Inline,
    Attachment
};

[CustomHeader] struct WebCore::PresentationSize {
    std::optional<double> width;
    std::optional<double> height;
};

struct WebCore::PasteboardItemInfo {
    Vector<String> pathsForFileUpload;
    Vector<String> platformTypesForFileUpload;
    Vector<String> platformTypesByFidelity;
    String suggestedFileName;
    WebCore::PresentationSize preferredPresentationSize;
    bool isNonTextType;
    bool containsFileURLAndFileUploadContent;
    Vector<String> webSafeTypesByFidelity;
    WebCore::PasteboardItemPresentationStyle preferredPresentationStyle;
};

#if ENABLE(MEDIA_CONTROLS_CONTEXT_MENUS) && USE(UICONTEXTMENU)
struct WebCore::MediaControlsContextMenuItem {
    uint64_t id;
    String title;
    String icon;
    bool checked;
    Vector<WebCore::MediaControlsContextMenuItem> children;
};
#endif

struct WebCore::WorkerOptions {
    WebCore::WorkerType type;
    WebCore::FetchRequestCredentials credentials;
    String name;
};

struct WebCore::WorkerInitializationData {
    std::optional<WebCore::ServiceWorkerData> serviceWorkerData;
    std::optional<WebCore::ScriptExecutionContextIdentifier> clientIdentifier;
    OptionSet<WebCore::AdvancedPrivacyProtections> advancedPrivacyProtections;
    String userAgent;
};

struct WebCore::WorkerFetchResult {
    WebCore::ScriptBuffer script;
    URL responseURL;
    WebCore::CertificateInfo certificateInfo;
    WebCore::ContentSecurityPolicyResponseHeaders contentSecurityPolicy;
    WebCore::CrossOriginEmbedderPolicy crossOriginEmbedderPolicy;
    String referrerPolicy;
    WebCore::ResourceError error;
};

struct WebCore::SharedWorkerKey {
    WebCore::ClientOrigin origin;
    URL url;
    String name;
};

struct WebCore::ServiceWorkerRegistrationOptions {
    String scope;
    WebCore::WorkerType type;
    WebCore::ServiceWorkerUpdateViaCache updateViaCache;
};

class WebCore::ServiceWorkerRegistrationKey {
    WebCore::SecurityOriginData topOrigin();
    URL scope();
};

struct WebCore::ServiceWorkerRegistrationData {
    WebCore::ServiceWorkerRegistrationKey key;
    WebCore::ServiceWorkerRegistrationIdentifier identifier;
    URL scopeURL;
    WebCore::ServiceWorkerUpdateViaCache updateViaCache;
    WallTime lastUpdateTime;
    std::optional<WebCore::ServiceWorkerData> installingWorker;
    std::optional<WebCore::ServiceWorkerData> waitingWorker;
    std::optional<WebCore::ServiceWorkerData> activeWorker;
};

struct WebCore::ServiceWorkerJobDataIdentifier {
    WebCore::SWServerConnectionIdentifier connectionIdentifier;
    WebCore::ServiceWorkerJobIdentifier jobIdentifier;
};

struct WebCore::ServiceWorkerImportedScript {
    WebCore::ScriptBuffer script;
    URL responseURL;
    String mimeType;
};

#if ENABLE(SHAREABLE_RESOURCE) && PLATFORM(COCOA)
[CreateUsing=fromIPCData] class WebCore::ScriptBuffer {
    std::variant<WebCore::ShareableResourceHandle, RefPtr<WebCore::FragmentedSharedBuffer>> ipcData();
};
#endif

#if !ENABLE(SHAREABLE_RESOURCE) || !PLATFORM(COCOA)
[CreateUsing=fromIPCData] class WebCore::ScriptBuffer {
    RefPtr<WebCore::FragmentedSharedBuffer> ipcData();
};
#endif

header: <wtf/RobinHoodHashTable.h>
struct WebCore::ServiceWorkerContextData {
    std::optional<WebCore::ServiceWorkerJobDataIdentifier> jobDataIdentifier;
    WebCore::ServiceWorkerRegistrationData registration;
    WebCore::ServiceWorkerIdentifier serviceWorkerIdentifier;
    WebCore::ScriptBuffer script;
    WebCore::CertificateInfo certificateInfo;
    WebCore::ContentSecurityPolicyResponseHeaders contentSecurityPolicy;
    WebCore::CrossOriginEmbedderPolicy crossOriginEmbedderPolicy;
    String referrerPolicy;
    URL scriptURL;
    WebCore::WorkerType workerType;
    bool loadedFromDisk;
    std::optional<WebCore::LastNavigationWasAppInitiated> lastNavigationWasAppInitiated;
    MemoryCompactRobinHoodHashMap<URL, WebCore::ServiceWorkerImportedScript> scriptResourceMap;
    std::optional<WebCore::ScriptExecutionContextIdentifier> serviceWorkerPageIdentifier;
    WebCore::NavigationPreloadState navigationPreloadState;
};

#if HAVE(SCREEN_CAPTURE_KIT)
header: <WebCore/DisplayCapturePromptType.h>
enum class WebCore::DisplayCapturePromptType : uint8_t {
    Window,
    Screen,
    UserChoose
};
#endif

header: <JavaScriptCore/ArrayBuffer.h>
[RefCounted, CustomHeader] class JSC::ArrayBuffer {
    Vector<uint8_t> toVector();
}

header: <JavaScriptCore/ArrayBuffer.h>
[CustomHeader, CreateUsing=fromDataSpan] class JSC::ArrayBufferContents {
    std::span<const uint8_t> dataSpan();
}

enum class WebCore::TextIndicatorPresentationTransition : uint8_t {
    None,
    Bounce,
    BounceAndCrossfade,
    FadeIn,
};

[OptionSet] enum class WebCore::TextIndicatorOption : uint16_t {
    RespectTextColor,
    PaintBackgrounds,
    PaintAllContent,
    IncludeSnapshotWithSelectionHighlight,
    TightlyFitContent,
    UseBoundingRectAndPaintAllContentForComplexRanges,
    IncludeMarginIfRangeMatchesSelection,
    ExpandClipBeyondVisibleRect,
    DoNotClipToVisibleRect,
    IncludeSnapshotOfAllVisibleContentWithoutSelection,
    UseSelectionRectForSizing,
    ComputeEstimatedBackgroundColor,
    UseUserSelectAllCommonAncestor,
};

using WebCore::IDBConnectionIdentifier = WebCore::ProcessIdentifier;

using WebCore::TransferredMessagePort = std::pair<WebCore::MessagePortIdentifier, WebCore::MessagePortIdentifier>;

struct WebCore::GlobalFrameIdentifier {
    WebCore::PageIdentifier pageID;
    WebCore::FrameIdentifier frameID;
};

struct WebCore::GlobalWindowIdentifier {
    WebCore::ProcessIdentifier processIdentifier;
    WebCore::WindowIdentifier windowIdentifier;
};

[Nested] enum class WebCore::InteractionRegion::Type : uint8_t {
    Interaction,
    Occlusion,
    Guard
};
[Nested, OptionSet] enum class WebCore::InteractionRegion::CornerMask : uint8_t {
    MinXMinYCorner
    MaxXMinYCorner
    MinXMaxYCorner
    MaxXMaxYCorner
};

struct WebCore::InteractionRegion {
    WebCore::InteractionRegion::Type type;
    WebCore::ElementIdentifier elementIdentifier;
    WebCore::FloatRect rectInLayerCoordinates;
    float cornerRadius;
    OptionSet<WebCore::InteractionRegion::CornerMask> maskedCorners;
    std::optional<WebCore::Path> clipPath;
};

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::Region::Span {
    int y;
    size_t segmentIndex;
};

[Nested, AdditionalEncoder=StreamConnectionEncoder] class WebCore::Region::Shape {
    Vector<int, 32> m_segments;
    Vector<WebCore::Region::Span, 16> m_spans;
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::Region {
    WebCore::IntRect bounds();
    [Validator='!*copyShape || (*copyShape)->isValid()'] std::unique_ptr<WebCore::Region::Shape> copyShape();
}

header: <WebCore/ISOVTTCue.h>
[CustomHeader] class WebCore::ISOWebVTTCue {
    MediaTime presentationTime();
    MediaTime duration();
    AtomString id();
    String cueText();
    String settings();
    String sourceID();
    String originalStartTime();
}

#if ENABLE(WEB_AUTHN)

[Nested] enum class WebCore::MockWebAuthenticationConfiguration::UserVerification : uint8_t {
    No,
    Yes,
    Cancel,
    Presence
};

[Nested] struct WebCore::MockWebAuthenticationConfiguration::LocalConfiguration {
    WebCore::MockWebAuthenticationConfiguration::UserVerification userVerification;
    bool acceptAttestation;
    String privateKeyBase64;
    String userCertificateBase64;
    String intermediateCACertificateBase64;
    String preferredCredentialIdBase64;
};

[Nested] enum class WebCore::MockWebAuthenticationConfiguration::HidStage : bool;

[Nested] enum class WebCore::MockWebAuthenticationConfiguration::HidSubStage : bool;

[Nested] enum class WebCore::MockWebAuthenticationConfiguration::HidError : uint8_t {
    Success,
    DataNotSent,
    EmptyReport,
    WrongChannelId,
    MaliciousPayload,
    UnsupportedOptions,
    WrongNonce
};

[Nested] struct WebCore::MockWebAuthenticationConfiguration::HidConfiguration {
    Vector<String> payloadBase64;
    WebCore::MockWebAuthenticationConfiguration::HidStage stage;
    WebCore::MockWebAuthenticationConfiguration::HidSubStage subStage;
    WebCore::MockWebAuthenticationConfiguration::HidError error;
    bool isU2f;
    bool keepAlive;
    bool fastDataArrival;
    bool continueAfterErrorData;
    bool canDowngrade;
    bool expectCancel;
    bool supportClientPin;
    bool supportInternalUV;
};

[Nested] enum class WebCore::MockWebAuthenticationConfiguration::NfcError : uint8_t {
    Success,
    NoTags,
    WrongTagType,
    NoConnections,
    MaliciousPayload
};

[Nested] struct WebCore::MockWebAuthenticationConfiguration::NfcConfiguration {
    WebCore::MockWebAuthenticationConfiguration::NfcError error;
    Vector<String> payloadBase64;
    bool multipleTags;
    bool multiplePhysicalTags;
};

[Nested] struct WebCore::MockWebAuthenticationConfiguration::CcidConfiguration {
    Vector<String> payloadBase64;
};

struct WebCore::MockWebAuthenticationConfiguration {
    bool silentFailure;
    std::optional<WebCore::MockWebAuthenticationConfiguration::LocalConfiguration> local;
    std::optional<WebCore::MockWebAuthenticationConfiguration::HidConfiguration> hid;
    std::optional<WebCore::MockWebAuthenticationConfiguration::NfcConfiguration> nfc;
    std::optional<WebCore::MockWebAuthenticationConfiguration::CcidConfiguration> ccid;
};

#endif // ENABLE(WEB_AUTHN)

#if ENABLE(MEDIA_STREAM)

header: <WebCore/MockMediaDevice.h>
[CustomHeader] struct WebCore::MockMicrophoneProperties {
    int defaultSampleRate;
};

header: <WebCore/MockMediaDevice.h>
[CustomHeader] struct WebCore::MockSpeakerProperties {
    String relatedMicrophoneId;
    int defaultSampleRate;
};

header: <WebCore/MockMediaDevice.h>
[CustomHeader] struct WebCore::MockCameraProperties {
    double defaultFrameRate;
    WebCore::VideoFacingMode facingMode;
    Vector<WebCore::VideoPresetData> presets;
    WebCore::Color fillColor;
    Vector<WebCore::MeteringMode> whiteBalanceMode;
    bool hasTorch;
};

header: <WebCore/MockMediaDevice.h>
[CustomHeader] struct WebCore::MockDisplayProperties {
    WebCore::CaptureDevice::DeviceType type;
    WebCore::Color fillColor;
    WebCore::IntSize defaultSize;
};

header: <WebCore/MockMediaDevice.h>
[CustomHeader] struct WebCore::MockMediaDevice {
    String persistentId;
    String label;
    WebCore::MockMediaDevice::Flags flags;
    std::variant<WebCore::MockMicrophoneProperties, WebCore::MockSpeakerProperties, WebCore::MockCameraProperties, WebCore::MockDisplayProperties> properties;
};

#endif // ENABLE(MEDIA_STREAM)

header: <WebCore/StorageType.h>
enum class WebCore::StorageType : uint8_t {
    Session,
    Local,
    TransientLocal,
};

#if ENABLE(THREADED_ANIMATION_RESOLUTION)

class WebCore::OffsetRotation {
    bool hasAuto();
    float angle();
}

[OptionSet] enum class WebCore::AcceleratedEffectProperty : uint16_t {
    Opacity,
    Transform,
    Translate,
    Rotate,
    Scale,
    OffsetPath,
    OffsetDistance,
    OffsetPosition,
    OffsetAnchor,
    OffsetRotate,
    Filter,
    BackdropFilter
};

header: <WebCore/WebAnimationTypes.h>
[CustomHeader] enum class WebCore::WebAnimationType : uint8_t {
    CSSAnimation,
    CSSTransition,
    WebAnimation
};

enum class WebCore::FillMode : uint8_t {
    None,
    Forwards,
    Backwards,
    Both,
    Auto
};

enum class WebCore::PlaybackDirection : uint8_t {
    Normal,
    Reverse,
    Alternate,
    AlternateReverse
};

enum class WebCore::CompositeOperation : uint8_t {
    Replace,
    Add,
    Accumulate
};

struct WebCore::AcceleratedEffectValues {
    float opacity;
    WebCore::LengthPoint transformOrigin;
    WebCore::TransformOperations transform;
    RefPtr<WebCore::TransformOperation> translate;
    RefPtr<WebCore::TransformOperation> scale;
    RefPtr<WebCore::TransformOperation> rotate;
    RefPtr<WebCore::PathOperation> offsetPath;
    WebCore::Length offsetDistance;
    WebCore::LengthPoint offsetPosition;
    WebCore::LengthPoint offsetAnchor;
    WebCore::OffsetRotation offsetRotate;
    WebCore::FilterOperations filter;
    WebCore::FilterOperations backdropFilter;
}

struct WebCore::AnimationEffectTiming {
    RefPtr<WebCore::TimingFunction> timingFunction;
    WebCore::FillMode fill;
    WebCore::PlaybackDirection direction;
    double iterationStart;
    double iterations;
    WTF::Seconds delay;
    WTF::Seconds endDelay;
    WTF::Seconds iterationDuration;
    WTF::Seconds activeDuration;
    WTF::Seconds endTime;
};

header: <WebCore/AcceleratedEffect.h>
[CustomHeader, Nested] class WebCore::AcceleratedEffect::Keyframe {
    double offset();
    WebCore::AcceleratedEffectValues values();
    RefPtr<WebCore::TimingFunction> timingFunction();
    std::optional<WebCore::CompositeOperation> compositeOperation();
    OptionSet<WebCore::AcceleratedEffectProperty> animatedProperties();
};

[RefCounted] class WebCore::AcceleratedEffect {
    WebCore::AnimationEffectTiming timing();
    Vector<WebCore::AcceleratedEffect::Keyframe> keyframes();
    WebCore::WebAnimationType animationType();
    WebCore::CompositeOperation compositeOperation();
    RefPtr<WebCore::TimingFunction> defaultKeyframeTimingFunction();
    OptionSet<WebCore::AcceleratedEffectProperty> animatedProperties();
    bool paused();
    double playbackRate();
    std::optional<WTF::Seconds> startTime();
    std::optional<WTF::Seconds> holdTime();
};
#endif // ENABLE(THREADED_ANIMATION_RESOLUTION)

#if PLATFORM(MAC)
header: <WebCore/CaretAnimator.h>
[CustomHeader] enum class WebCore::CaretAnimatorType : uint8_t {
    Default,
    Dictation,
};
#endif

class WebCore::ProtectionSpace {
    String host();
    int port();
    WebCore::ProtectionSpace::ServerType serverType();
    String realm();
    WebCore::ProtectionSpace::AuthenticationScheme authenticationScheme();
#if USE(CURL)
    WebCore::CertificateInfo certificateInfo();
#endif
#if PLATFORM(COCOA)
    std::optional<WebCore::ProtectionSpace::PlatformData> getPlatformDataToSerialize();
#endif
};

header: <WebCore/Credential.h>
[Nested] struct WebCore::Credential::NonPlatformData {
    String user;
    String password;
    WebCore::CredentialPersistence persistence;
}

#if PLATFORM(COCOA)
[CreateUsing=fromIPCData] class WebCore::Credential {
    std::variant<WebCore::Credential::NonPlatformData, RetainPtr<NSURLCredential>> ipcData();
};
#endif

#if USE(SOUP)
[Nested] struct WebCore::Credential::PlatformData {
    GRefPtr<GTlsCertificate> certificate;
    WebCore::CredentialPersistence persistence;
};

[CreateUsing=fromIPCData] class WebCore::Credential {
    std::variant<WebCore::Credential::NonPlatformData, WebCore::Credential::PlatformData> ipcData();
};
#endif

#if USE(CURL)
class WebCore::Credential {
    WebCore::Credential::NonPlatformData nonPlatformData();
};
#endif // USE(CURL)

#if ENABLE(GPU_PROCESS)
header: <WebCore/BarcodeDetectorOptionsInterface.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ShapeDetection::BarcodeDetectorOptions {
    Vector<WebCore::ShapeDetection::BarcodeFormat> formats;
};

header: <WebCore/BarcodeFormatInterface.h>
[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::ShapeDetection::BarcodeFormat : uint8_t {
    Aztec,
    Code_128,
    Code_39,
    Code_93,
    Codabar,
    Data_matrix,
    Ean_13,
    Ean_8,
    Itf,
    Pdf417,
    Qr_code,
    Unknown,
    Upc_a,
    Upc_e,
};

header: <WebCore/DetectedBarcodeInterface.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ShapeDetection::DetectedBarcode {
    WebCore::FloatRect boundingBox;
    String rawValue;
    WebCore::ShapeDetection::BarcodeFormat format;
    Vector<WebCore::FloatPoint> cornerPoints;
};

header: <WebCore/DetectedFaceInterface.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ShapeDetection::DetectedFace {
    WebCore::FloatRect boundingBox;
    std::optional<Vector<WebCore::ShapeDetection::Landmark>> landmarks;
};

header: <WebCore/DetectedTextInterface.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ShapeDetection::DetectedText {
    WebCore::FloatRect boundingBox;
    String rawValue;
    Vector<WebCore::FloatPoint> cornerPoints;
};

header: <WebCore/FaceDetectorOptionsInterface.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ShapeDetection::FaceDetectorOptions {
    uint16_t maxDetectedFaces;
    bool fastMode;
};

header: <WebCore/LandmarkInterface.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ShapeDetection::Landmark {
    Vector<WebCore::FloatPoint> locations;
    WebCore::ShapeDetection::LandmarkType type;
};

header: <WebCore/LandmarkTypeInterface.h>
[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::ShapeDetection::LandmarkType : uint8_t {
    Mouth,
    Eye,
    Nose,
};
#endif // GPU_PROCESS

header: <WebCore/RenderTreeAsText.h>
[OptionSet] enum class WebCore::RenderAsTextFlag : uint16_t {
    ShowAllLayers,
    ShowLayerNesting,
    ShowCompositedLayers,
    ShowOverflow,
    ShowSVGGeometry,
    ShowLayerFragments,
    ShowAddresses,
    ShowIDAndClass,
    PrintingMode,
    DontUpdateLayout,
    ShowLayoutState
};

header: <WebCore/TextExtractionTypes.h>
[CustomHeader] struct WebCore::TextExtraction::TextItemData {
    String content;
};

header: <WebCore/TextExtractionTypes.h>
[CustomHeader] struct WebCore::TextExtraction::ScrollableItemData {
    WebCore::FloatSize contentSize;
};

header: <WebCore/TextExtractionTypes.h>
[CustomHeader] struct WebCore::TextExtraction::EditableItemData {
    bool isFocused;
};

header: <WebCore/TextExtractionTypes.h>
[CustomHeader] struct WebCore::TextExtraction::ImageItemData {
    String name;
    String altText;
};

header: <WebCore/TextExtractionTypes.h>
[CustomHeader] struct WebCore::TextExtraction::InteractiveItemData {
    bool isEnabled;
};

header: <WebCore/TextExtractionTypes.h>
[CustomHeader] enum class WebCore::TextExtraction::ContainerType : uint8_t {
    Root,
    ViewportConstrained,
    Link,
    List,
    ListItem,
    BlockQuote,
    Article,
    Section,
    Nav
};

header: <WebCore/TextExtractionTypes.h>
[CustomHeader] struct WebCore::TextExtraction::Item {
    std::variant<WebCore::TextExtraction::ContainerType, WebCore::TextExtraction::TextItemData, WebCore::TextExtraction::ScrollableItemData, WebCore::TextExtraction::EditableItemData, WebCore::TextExtraction::ImageItemData, WebCore::TextExtraction::InteractiveItemData> data;
    WebCore::FloatRect rectInRootView;
    Vector<WebCore::TextExtraction::Item> children;
};

header: <WebCore/WebGPUTextureFormat.h>
enum class WebCore::WebGPU::TextureFormat : uint8_t {
    R8unorm,
    R8snorm,
    R8uint,
    R8sint,
    R16uint,
    R16sint,
    R16float,
    Rg8unorm,
    Rg8snorm,
    Rg8uint,
    Rg8sint,
    R32uint,
    R32sint,
    R32float,
    Rg16uint,
    Rg16sint,
    Rg16float,
    Rgba8unorm,
    Rgba8unormSRGB,
    Rgba8snorm,
    Rgba8uint,
    Rgba8sint,
    Bgra8unorm,
    Bgra8unormSRGB,
    Rgb9e5ufloat,
    Rgb10a2uint,
    Rgb10a2unorm,
    Rg11b10ufloat,
    Rg32uint,
    Rg32sint,
    Rg32float,
    Rgba16uint,
    Rgba16sint,
    Rgba16float,
    Rgba32uint,
    Rgba32sint,
    Rgba32float,
    Stencil8,
    Depth16unorm,
    Depth24plus,
    Depth24plusStencil8,
    Depth32float,
    Depth32floatStencil8,
    Bc1RgbaUnorm,
    Bc1RgbaUnormSRGB,
    Bc2RgbaUnorm,
    Bc2RgbaUnormSRGB,
    Bc3RgbaUnorm,
    Bc3RgbaUnormSRGB,
    Bc4RUnorm,
    Bc4RSnorm,
    Bc5RgUnorm,
    Bc5RgSnorm,
    Bc6hRgbUfloat,
    Bc6hRgbFloat,
    Bc7RgbaUnorm,
    Bc7RgbaUnormSRGB,
    Etc2Rgb8unorm,
    Etc2Rgb8unormSRGB,
    Etc2Rgb8a1unorm,
    Etc2Rgb8a1unormSRGB,
    Etc2Rgba8unorm,
    Etc2Rgba8unormSRGB,
    EacR11unorm,
    EacR11snorm,
    EacRg11unorm,
    EacRg11snorm,
    Astc4x4Unorm,
    Astc4x4UnormSRGB,
    Astc5x4Unorm,
    Astc5x4UnormSRGB,
    Astc5x5Unorm,
    Astc5x5UnormSRGB,
    Astc6x5Unorm,
    Astc6x5UnormSRGB,
    Astc6x6Unorm,
    Astc6x6UnormSRGB,
    Astc8x5Unorm,
    Astc8x5UnormSRGB,
    Astc8x6Unorm,
    Astc8x6UnormSRGB,
    Astc8x8Unorm,
    Astc8x8UnormSRGB,
    Astc10x5Unorm,
    Astc10x5UnormSRGB,
    Astc10x6Unorm,
    Astc10x6UnormSRGB,
    Astc10x8Unorm,
    Astc10x8UnormSRGB,
    Astc10x10Unorm,
    Astc10x10UnormSRGB,
    Astc12x10Unorm,
    Astc12x10UnormSRGB,
    Astc12x12Unorm,
    Astc12x12UnormSRGB,
};

#if ENABLE(MEDIA_STREAM)
enum class WebCore::MediaAccessDenialReason : uint8_t {
    NoReason,
    NoConstraints,
    UserMediaDisabled,
    NoCaptureDevices,
    InvalidConstraint,
    HardwareError,
    PermissionDenied,
    InvalidAccess,
    OtherFailure
};

header: <WebCore/RealtimeMediaSource.h>
[CustomHeader] struct WebCore::CaptureSourceError {
    String errorMessage;
    WebCore::MediaAccessDenialReason denialReason;
    WebCore::MediaConstraintType invalidConstraint;
};

header: <WebCore/FillLightMode.h>
enum class WebCore::FillLightMode : uint8_t {
    Auto,
    Off,
    Flash,
};

header: <WebCore/RedEyeReduction.h>
enum class WebCore::RedEyeReduction : uint8_t {
    Never,
    Always,
    Controllable,
};

header: <WebCore/MediaSettingsRange.h>
[CustomHeader] struct WebCore::MediaSettingsRange {
    std::optional<double> max;
    std::optional<double> min;
    std::optional<double> step;
};

header: <WebCore/PhotoCapabilities.h>
[CustomHeader] struct WebCore::PhotoCapabilities {
    std::optional<WebCore::RedEyeReduction> redEyeReduction;
    std::optional<WebCore::MediaSettingsRange> imageHeight;
    std::optional<WebCore::MediaSettingsRange> imageWidth;
    std::optional<Vector<WebCore::FillLightMode>> fillLightMode;
};

header: <WebCore/PhotoSettings.h>
[CustomHeader] struct WebCore::PhotoSettings {
    std::optional<WebCore::FillLightMode> fillLightMode;
    std::optional<double> imageHeight;
    std::optional<double> imageWidth;
    std::optional<bool> redEyeReduction;
};
#endif

header: <WebCore/WebGPUTextureAspect.h>
enum class WebCore::WebGPU::TextureAspect : uint8_t {
    All,
    StencilOnly,
    DepthOnly,
};

enum class WebCore::WebGPU::PowerPreference : bool

header: <WebCore/WebGPUPredefinedColorSpace.h>
enum class WebCore::WebGPU::PredefinedColorSpace : uint8_t {
    SRGB
};

struct WebCore::CookieStoreGetOptions {
    String name;
    String url;
};

[RefCounted] class WebCore::Model {
    Ref<WebCore::SharedBuffer> data()
    String mimeType()
    URL url()
}

#if PLATFORM(IOS_FAMILY)
[Nested] enum class WebCore::InspectorOverlayLabel::Arrow::Direction : uint8_t {
    None,
    Down,
    Up,
    Left,
    Right
};

[Nested] enum class WebCore::InspectorOverlayLabel::Arrow::Alignment : uint8_t {
    None,
    Leading,
    Middle,
    Trailing,
};

[Nested] enum class WebCore::InspectorOverlayLabel::Content::Decoration::Type : uint8_t {
    None,
    Bordered
};

[Nested] struct WebCore::InspectorOverlayLabel::Content::Decoration {
    WebCore::InspectorOverlayLabel::Content::Decoration::Type type;
    WebCore::Color color;
};

[Nested] struct WebCore::InspectorOverlayLabel::Content {
    String text;
    WebCore::Color textColor;
    WebCore::InspectorOverlayLabel::Content::Decoration decoration;
};

[Nested] struct WebCore::InspectorOverlayLabel::Arrow {
    WebCore::InspectorOverlayLabel::Arrow::Direction direction;
    WebCore::InspectorOverlayLabel::Arrow::Alignment alignment
};

class WebCore::InspectorOverlayLabel {
    Vector<WebCore::InspectorOverlayLabel::Content> m_contents;
    WebCore::FloatPoint m_location;
    WebCore::Color m_backgroundColor;
    WebCore::InspectorOverlayLabel::Arrow m_arrow;
};

[Nested] struct WebCore::InspectorOverlayHighlight::FlexHighlightOverlay {
        WebCore::Color color;
        WebCore::FloatQuad containerBounds;
        Vector<WebCore::FloatQuad> itemBounds;
        Vector<WebCore::FloatQuad> mainAxisGaps;
        Vector<WebCore::FloatQuad> mainAxisSpaceBetweenItemsAndGaps;
        Vector<WebCore::FloatQuad> spaceBetweenItemsAndCrossAxisSpace;
        Vector<WebCore::FloatQuad> crossAxisGaps;
        Vector<WebCore::InspectorOverlayLabel> labels;
};

[Nested] struct WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area {
    String name;
    WebCore::FloatQuad quad;
};

[Nested] struct WebCore::InspectorOverlayHighlight::GridHighlightOverlay {
    WebCore::Color color;
    Vector<WebCore::FloatLine> gridLines;
    Vector<WebCore::FloatQuad> gaps;
    Vector<WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area> areas;
    Vector<WebCore::InspectorOverlayLabel> labels;
};

[Nested] enum class WebCore::InspectorOverlayHighlight::Type : uint8_t {
    None,
    Node,
    NodeList,
    Rects,
};

header: <WebCore/InspectorOverlay.h>
[CustomHeader] struct WebCore::InspectorOverlayHighlight {
    WebCore::Color contentColor;
    WebCore::Color contentOutlineColor;
    WebCore::Color paddingColor;
    WebCore::Color borderColor;
    WebCore::Color marginColor;
    WebCore::InspectorOverlayHighlight::Type type;
    Vector<WebCore::FloatQuad> quads;
    Vector<WebCore::InspectorOverlayHighlight::GridHighlightOverlay> gridHighlightOverlays;
    Vector<WebCore::InspectorOverlayHighlight::FlexHighlightOverlay> flexHighlightOverlays;
    bool usePageCoordinates;
};

#endif

header: <WebCore/DiagnosticLoggingClient.h>
[CustomHeader] struct WebCore::DiagnosticLoggingDictionary {
    HashMap<String, std::variant<String, uint64_t, int64_t, bool, double>> dictionary;
};

using WebCore::ViewportConstraints::AnchorEdges = unsigned;

header: <WebCore/ScrollingConstraints.h>
[CustomHeader] class WebCore::FixedPositionViewportConstraints : WebCore::ViewportConstraints {
    WebCore::FloatSize alignmentOffset();
    WebCore::ViewportConstraints::AnchorEdges anchorEdges();
    WebCore::FloatRect viewportRectAtLastLayout();
    WebCore::FloatPoint layerPositionAtLastLayout();
};

[CustomHeader] class WebCore::StickyPositionViewportConstraints : WebCore::ViewportConstraints {
    WebCore::FloatSize alignmentOffset();
    WebCore::ViewportConstraints::AnchorEdges anchorEdges();
    float leftOffset();
    float rightOffset();
    float topOffset();
    float bottomOffset();
    WebCore::FloatRect constrainingRectAtLastLayout();
    WebCore::FloatRect containingBlockRect();
    WebCore::FloatRect stickyBoxRect();
    WebCore::FloatSize stickyOffsetAtLastLayout();
    WebCore::FloatPoint layerPositionAtLastLayout();
};

class WebCore::FloatLine {
    WebCore::FloatPoint start();
    WebCore::FloatPoint end();
};

header: <WebCore/FontCache.h>
[CustomHeader] struct WebCore::FontCachePrewarmInformation {
    Vector<String> seenFamilies;
    Vector<String> fontNamesRequiringSystemFallback;
};

struct WebCore::PrewarmInformation {
    WebCore::FontCachePrewarmInformation fontCache;
};

using WebCore::PlatformLayerIdentifier = ProcessQualified<ObjectIdentifier<WebCore::PlatformLayerIdentifierType>>;
using WebCore::ScriptExecutionContextIdentifier = ProcessQualified<WTF::UUID>;

header: <WebCore/FontSelectionAlgorithm.h>
using WebCore::FontSelectionValue::BackingType = int16_t;
[CustomHeader] class WebCore::FontSelectionValue {
    WebCore::FontSelectionValue::BackingType rawValue();
};

[CustomHeader] struct WebCore::FontSelectionRange {
    WebCore::FontSelectionValue minimum;
    WebCore::FontSelectionValue maximum;
};

[CustomHeader] struct WebCore::FontSelectionSpecifiedCapabilities {
    std::optional<WebCore::FontSelectionRange> weight;
    std::optional<WebCore::FontSelectionRange> width;
    std::optional<WebCore::FontSelectionRange> slope;
};

struct WebCore::RemoteUserInputEventData {
    WebCore::FrameIdentifier targetFrameID;
    WebCore::IntPoint transformedPoint;
};

struct WebCore::LinkDecorationFilteringData {
    WebCore::RegistrableDomain domain;
    String path;
    String linkDecoration;
};

header: <WebCore/InspectorFrontendClient.h>
[CustomHeader] enum class WebCore::InspectorFrontendClientAppearance : uint8_t {
    System,
    Light,
    Dark,
};
using WebCore::InspectorFrontendClient::Appearance = WebCore::InspectorFrontendClientAppearance;

[Nested] enum class WebCore::InspectorFrontendClient::SaveMode : uint8_t {
    SingleFile,
    FileVariants,
};

header: <WebCore/InspectorFrontendClient.h>
[CustomHeader] struct WebCore::InspectorFrontendClientSaveData {
    String displayType;
    String url;
    String content;
    bool base64Encoded;
};
using WebCore::InspectorFrontendClient::SaveData = WebCore::InspectorFrontendClientSaveData;

#if ENABLE(VIDEO)
header: <WebCore/PlatformTextTrack.h>
[Nested, CustomHeader] enum class WebCore::PlatformTextTrackData::TrackKind : uint8_t {
    Subtitle,
    Caption,
    Description,
    Chapter,
    MetaData,
    Forced,
};

header: <WebCore/PlatformTextTrack.h>
[Nested, CustomHeader] enum class WebCore::PlatformTextTrackData::TrackType : uint8_t {
    InBand,
    OutOfBand,
    Script,
};

header: <WebCore/PlatformTextTrack.h>
[Nested, CustomHeader] enum class WebCore::PlatformTextTrackData::TrackMode : uint8_t {
    Disabled,
    Hidden,
    Showing,
};

header: <WebCore/PlatformTextTrack.h>
[CustomHeader] struct WebCore::PlatformTextTrackData {
    String m_label;
    String m_language;
    String m_url;
    WebCore::PlatformTextTrackData::TrackMode m_mode;
    WebCore::PlatformTextTrackData::TrackKind m_kind;
    WebCore::PlatformTextTrackData::TrackType m_type;
    int m_uniqueId;
    bool m_isDefault;
}
#endif // ENABLE(VIDEO)

[WebKitPlatform] struct WebCore::NotificationPayload {
    URL defaultActionURL;
    String title;
    std::optional<unsigned long long> appBadge;
    std::optional<WebCore::NotificationOptionsPayload> options;
    bool isMutable;
};

[WebKitPlatform] struct WebCore::NotificationOptionsPayload {
    WebCore::NotificationDirection dir;
    String lang;
    String body;
    String tag;
    String icon;
    String dataJSONString;
    std::optional<bool> silent;
};

class WebCore::NetworkLoadMetrics {
    MonotonicTime redirectStart;
    MonotonicTime fetchStart;
    MonotonicTime domainLookupStart;
    MonotonicTime domainLookupEnd;
    MonotonicTime connectStart;
    MonotonicTime secureConnectionStart;
    MonotonicTime connectEnd;
    MonotonicTime requestStart;
    MonotonicTime responseStart;
    MonotonicTime responseEnd;
    MonotonicTime workerStart;

    String protocol;

    uint16_t redirectCount;

    bool isComplete();
    bool isCellular();
    bool isExpensive();
    bool isConstrained();
    bool isMultipath();
    bool reusedConnection();
    bool doesFailTAOCheck();
    bool crossOriginRedirect();

    WebCore::PrivacyStance privacyStance;

    uint64_t responseBodyBytesReceived;
    uint64_t responseBodyDecodedSize;

    RefPtr<WebCore::AdditionalNetworkLoadMetricsForWebInspector> additionalNetworkLoadMetricsForWebInspector;
}

header: <WebCore/NetworkLoadMetrics.h>
[RefCounted, CustomHeader] struct WebCore::AdditionalNetworkLoadMetricsForWebInspector {
    WebCore::NetworkLoadPriority priority;
    String remoteAddress;
    String connectionIdentifier;
    String tlsProtocol;
    String tlsCipher;
    WebCore::HTTPHeaderMap requestHeaders;
    uint64_t requestHeaderBytesSent;
    uint64_t responseHeaderBytesReceived;
    uint64_t requestBodyBytesSent;
    bool isProxyConnection;
}

struct WebCore::DisplayUpdate {
    unsigned updateIndex;
    WebCore::FramesPerSecond updatesPerSecond;
}

struct WebCore::MediaUsageInfo {
    URL mediaURL;
    bool hasSource;
    bool isPlaying;
    bool canShowControlsManager;
    bool canShowNowPlayingControls;
    bool isSuspended;
    bool isInActiveDocument;
    bool isFullscreen;
    bool isMuted;
    bool isMediaDocumentInMainFrame;
    bool isVideo;
    bool isAudio;
    bool hasVideo;
    bool hasAudio;
    bool hasRenderer;
    bool audioElementWithUserGesture;
    bool userHasPlayedAudioBefore;
    bool isElementRectMostlyInMainFrame;
    bool playbackPermitted;
    bool pageMediaPlaybackSuspended;
    bool isMediaDocumentAndNotOwnerElement;
    bool pageExplicitlyAllowsElementToAutoplayInline;
    bool requiresFullscreenForVideoPlaybackAndFullscreenNotPermitted;
    bool isVideoAndRequiresUserGestureForVideoRateChange;
    bool isAudioAndRequiresUserGestureForAudioRateChange;
    bool isVideoAndRequiresUserGestureForVideoDueToLowPowerMode;
    bool noUserGestureRequired;
    bool requiresPlaybackAndIsNotPlaying;
    bool hasEverNotifiedAboutPlaying;
    bool outsideOfFullscreen;
    bool isLargeEnoughForMainContent;
#if PLATFORM(COCOA) && !HAVE(CGS_FIX_FOR_RADAR_97530095)
    bool isInViewport;
#endif
}

header: <WebCore/NowPlayingInfo.h>
[CustomHeader] struct WebCore::NowPlayingInfoArtwork {
    String src;
    String mimeType;
    RefPtr<WebCore::Image> image;
}

struct WebCore::NowPlayingInfo {
    String title;
    String artist;
    String album;
    String sourceApplicationIdentifier;
    double duration;
    double currentTime;
    double rate;
    bool supportsSeeking;
    WebCore::MediaUniqueIdentifier uniqueIdentifier;
    bool isPlaying;
    bool allowsNowPlayingControlsVisibility;
    std::optional<WebCore::NowPlayingInfoArtwork> artwork;
}

struct WebCore::VideoConfiguration {
    String contentType;
    uint32_t width;
    uint32_t height;
    uint64_t bitrate;
    double framerate;
    std::optional<bool> alphaChannel;
    std::optional<WebCore::ColorGamut> colorGamut;
    std::optional<WebCore::HdrMetadataType> hdrMetadataType;
    std::optional<WebCore::TransferFunction> transferFunction;
}

using WebCore::FontTag = std::array<char, 4>;

header: <WebCore/FontTaggedSettings.h>
[Alias=class FontTaggedSetting<float>, CustomHeader] class WebCore::FloatFontTaggedSetting {
    WebCore::FontTag m_tag;
    float m_value;
};

header: <WebCore/FontTaggedSettings.h>
[Alias=class FontTaggedSetting<int>, CustomHeader] class WebCore::IntFontTaggedSetting {
    WebCore::FontTag m_tag;
    int m_value;
};

header: <WebCore/FontTaggedSettings.h>
[Alias=class FontTaggedSettings<float>, CustomHeader, LegacyPopulateFromEmptyConstructor] class WebCore::FontVariationSettings {
    Vector<WebCore::FloatFontTaggedSetting> m_list;
};

header: <WebCore/FontTaggedSettings.h>
[Alias=class FontTaggedSettings<int>, CustomHeader, LegacyPopulateFromEmptyConstructor] class WebCore::FontFeatureSettings {
    Vector<WebCore::IntFontTaggedSetting> m_list;
};

enum class WebCore::UserScriptInjectionTime : bool;

enum class WebCore::WaitForNotificationBeforeInjecting : bool;

enum class WebCore::UserContentInjectedFrames : bool;

class WebCore::UserScript {
    String source();
    URL url();
    Vector<String> allowlist();
    Vector<String> blocklist();
    WebCore::UserScriptInjectionTime injectionTime();
    WebCore::UserContentInjectedFrames injectedFrames();
    WebCore::WaitForNotificationBeforeInjecting waitForNotificationBeforeInjecting();
}

header: <WebCore/GraphicsContextState.h>
[Nested, OptionSet] enum class WebCore::GraphicsContextState::Change : uint32_t {
    FillBrush,
    FillRule,
    StrokeBrush,
    StrokeThickness,
    StrokeStyle,
    CompositeMode,
    DropShadow,
    Style,
    Alpha,
    TextDrawingMode,
    ImageInterpolationQuality,
    ShouldAntialias,
    ShouldSmoothFonts,
    ShouldSubpixelQuantizeFonts,
    ShadowsIgnoreTransforms,
    DrawLuminanceMask,
#if HAVE(OS_DARK_MODE_SUPPORT)
    UseDarkAppearance,
#endif
};

header: <WebCore/GraphicsContextState.h>
[Nested] enum class WebCore::GraphicsContextState::Purpose : uint8_t {
    Initial,
    SaveRestore,
    TransparencyLayer,
};

[LegacyPopulateFromEmptyConstructor, AdditionalEncoder=StreamConnectionEncoder] class WebCore::GraphicsContextState {
    WebCore::SourceBrush m_fillBrush;
    WebCore::SourceBrush m_strokeBrush;
    OptionSet<WebCore::GraphicsContextState::Change> m_changeFlags;
    float m_strokeThickness;
    WebCore::WindRule m_fillRule;
    WebCore::StrokeStyle m_strokeStyle;
    WebCore::CompositeMode m_compositeMode;
    std::optional<WebCore::GraphicsDropShadow> m_dropShadow;
    std::optional<WebCore::GraphicsStyle> m_style;
    float m_alpha;
    WebCore::InterpolationQuality m_imageInterpolationQuality;
    OptionSet<WebCore::TextDrawingMode> m_textDrawingMode;
    bool m_shouldAntialias;
    bool m_shouldSmoothFonts;
    bool m_shouldSubpixelQuantizeFonts;
    bool m_shadowsIgnoreTransforms;
    bool m_drawLuminanceMask;
#if HAVE(OS_DARK_MODE_SUPPORT)
    bool m_useDarkAppearance;
#endif

    WebCore::GraphicsContextState::Purpose m_purpose;
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::SourceBrushLogicalGradient {
    std::variant<Ref<WebCore::Gradient>, WebCore::RenderingResourceIdentifier> serializableGradient();
    WebCore::AffineTransform spaceTransform;
};

class WebCore::ContentSecurityPolicyResponseHeaders {
    Vector<std::pair<String, WebCore::ContentSecurityPolicyHeaderType>> headers();
    int httpStatusCode();
};

class WebCore::DragImage {
    std::optional<WebCore::TextIndicatorData> indicatorData();
    std::optional<WebCore::Path> visiblePath();
};

struct WebCore::DragItem {
    WebCore::DragImage image;
    WebCore::FloatPoint imageAnchorPoint;
    std::optional<WebCore::DragSourceAction> sourceAction;
    WebCore::IntPoint eventPositionInContentCoordinates;
    WebCore::IntPoint dragLocationInContentCoordinates;
    WebCore::IntPoint dragLocationInWindowCoordinates;
    String title;
    URL url;
    WebCore::IntRect dragPreviewFrameInRootViewCoordinates;
    bool containsSelection;
    WebCore::PromisedAttachmentInfo promisedAttachmentInfo;
    [NotSerialized] WebCore::PasteboardWriterData data;
};

#if PLATFORM(COCOA)
struct WebCore::KeypressCommand {
    String commandName;
    String text;
}
#endif

#if !USE(COORDINATED_GRAPHICS)
class WebCore::FilterOperations {
    Vector<RefPtr<WebCore::FilterOperation>> operations();
}
#endif // !USE(COORDINATED_GRAPHICS)

[AdditionalEncoder=StreamConnectionEncoder, RefCounted] class WebCore::Filter subclasses {
    WebCore::CSSFilter
    WebCore::SVGFilter
}

[AdditionalEncoder=StreamConnectionEncoder, RefCounted] class WebCore::CSSFilter {
    Vector<Ref<WebCore::FilterFunction>> functions();

    OptionSet<WebCore::FilterRenderingMode> filterRenderingModes();
    WebCore::FloatSize filterScale();
    WebCore::FloatRect filterRegion();
}

[AdditionalEncoder=StreamConnectionEncoder, RefCounted] class WebCore::SVGFilter {
    WebCore::FloatRect targetBoundingBox();
    WebCore::SVGUnitTypes::SVGUnitType primitiveUnits();
    WebCore::SVGFilterExpression expression();
    Vector<Ref<WebCore::FilterEffect>> effects();
    std::optional<WebCore::RenderingResourceIdentifier> renderingResourceIdentifierIfExists();

    OptionSet<WebCore::FilterRenderingMode> filterRenderingModes();
    WebCore::FloatSize filterScale();
    WebCore::FloatRect filterRegion();
}

[Nested] enum class WebCore::UserStyleLevel : bool;

header: <WebCore/WheelEventTestMonitor.h>
[OptionSet] enum class WebCore::WheelEventTestMonitorDeferReason : uint16_t {
    HandlingWheelEvent,
    HandlingWheelEventOnMainThread,
    PostMainThreadWheelEventHandling,
    RubberbandInProgress,
    ScrollSnapInProgress,
    ScrollAnimationInProgress,
    ScrollingThreadSyncNeeded,
    ContentScrollInProgress,
    RequestedScrollPosition,
    CommittingTransientZoom,
};

header: <WebCore/CrossOriginAccessControl.h>
[OptionSet] enum class WebCore::HTTPHeadersToKeepFromCleaning : uint8_t {
    AcceptEncoding,
    CacheControl,
    ContentType,
    Origin,
    Pragma,
    Referer,
    UserAgent,
};

enum class WebCore::ExceptionCode : uint8_t {
    IndexSizeError,
    HierarchyRequestError,
    WrongDocumentError,
    InvalidCharacterError,
    NoModificationAllowedError,
    NotFoundError,
    NotSupportedError,
    InUseAttributeError,
    InvalidStateError,
    SyntaxError,
    InvalidModificationError,
    NamespaceError,
    InvalidAccessError,
    TypeMismatchError,
    SecurityError,
    NetworkError,
    AbortError,
    URLMismatchError,
    QuotaExceededError,
    TimeoutError,
    InvalidNodeTypeError,
    DataCloneError,
    EncodingError,
    NotReadableError,
    UnknownError,
    ConstraintError,
    DataError,
    TransactionInactiveError,
    ReadonlyError,
    VersionError,
    OperationError,
    NotAllowedError,
    RangeError,
    TypeError,
    JSSyntaxError,
    StackOverflowError,
    OutOfMemoryError,
    ExistingExceptionError,
}

header: <WebCore/BackgroundFetchFailureReason.h>
enum class WebCore::BackgroundFetchFailureReason : uint8_t {
    EmptyString,
    Aborted,
    BadStatus,
    FetchError,
    QuotaExceeded,
    DownloadTotalExceeded
};

header: <WebCore/BackgroundFetchResult.h>
enum class WebCore::BackgroundFetchResult : uint8_t {
    EmptyString,
    Success,
    Failure
};

enum class WebCore::ResourceErrorBaseType : uint8_t {
     Null,
     General,
     AccessControl,
     Cancellation,
     Timeout,
}

enum class WebCore::CredentialPersistence : uint8_t {
     None,
     ForSession,
     Permanent,
}
header: <WebCore/Pagination.h>
enum class WebCore::PaginationMode : uint8_t {
    Unpaginated,
    LeftToRightPaginated,
    RightToLeftPaginated,
    TopToBottomPaginated,
    BottomToTopPaginated
};

header: <WebCore/RenderObject.h>
enum class WebCore::RepaintRectCalculation : bool;

[Nested] enum class WebCore::HdrMetadataType : uint8_t {
    SmpteSt2086,
    SmpteSt209410,
    SmpteSt209440,
};

[Nested] enum class WebCore::TransferFunction : uint8_t {
     SRGB,
     PQ,
     HLG,
};

[Nested] enum class WebCore::ColorGamut : uint8_t {
    SRGB,
    P3,
    Rec2020,
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::ByteArrayPixelBuffer {
    WebCore:: PixelBufferFormat format();
    WebCore::IntSize size();
    std::span<const uint8_t> dataSpan();
}

#if ENABLE(WEB_AUTHN)
header: <WebCore/MediationRequirement.h>
enum class WebCore::MediationRequirement : uint8_t {
    Silent,
    Optional,
    Required,
    Conditional,
};
#endif

#if ENABLE(VIDEO)
header: <WebCore/VTTCue.h>
[Nested] enum class WebCore::VTTDirectionSetting : uint8_t {
    Horizontal,
    VerticalGrowingLeft,
    VerticalGrowingRight,
};

[Nested] enum class WebCore::VTTLineAlignSetting : uint8_t {
    Start,
    Center,
    End,
};

[Nested] enum class WebCore::VTTPositionAlignSetting : uint8_t {
    LineLeft,
    Center,
    LineRight,
    Auto,
};

[Nested] enum class WebCore::VTTAlignSetting : uint8_t {
    Start,
    Center,
    End,
    Left,
    Right,
};
#endif

#if ENABLE(CONTEXT_MENUS)
header: <WebCore/ContextMenuContext.h>
enum class WebCore::ContextMenuContextType : uint8_t {
    ContextMenu,
#if ENABLE(SERVICE_CONTROLS)
    ServicesMenu,
#endif
#if ENABLE(MEDIA_CONTROLS_CONTEXT_MENUS)
    MediaControls,
#endif
};
#endif

header: <WebCore/CrossSiteNavigationDataTransfer.h>
[OptionSet] enum class WebCore::CrossSiteNavigationDataTransferFlag : uint8_t {
    DestinationLinkDecoration,
    ReferrerLinkDecoration
};

header: <WebCore/ScrollingCoordinatorTypes.h>
[Nested, OptionSet] enum class WebCore::SynchronousScrollingReason : uint8_t {
    ForcedOnMainThread,
    HasViewportConstrainedObjectsWithoutSupportingFixedLayers,
    HasNonLayerViewportConstrainedObjects,
    IsImageDocument,
    HasSlowRepaintObjects,
    DescendantScrollersHaveSynchronousScrolling
};

header: <WebCore/ScrollingCoordinatorTypes.h>
[Nested] enum class WebCore::ScrollRequestType : uint8_t {
    PositionUpdate,
    DeltaUpdate,
    CancelAnimatedScroll
};

header: <WebCore/ScrollingCoordinatorTypes.h>
[Nested] enum class WebCore::KeyboardScrollAction : uint8_t {
    StartAnimation,
    StopWithAnimation,
    StopImmediately
};

struct WebCore::MarkupExclusionRule {
    AtomString elementLocalName;
    Vector<std::pair<AtomString, AtomString>> attributes;
};

header: <WebCore/Font.h>
[Nested] enum class WebCore::FontOrigin : bool;
[Nested] enum class WebCore::FontIsInterstitial : bool;
[Nested] enum class WebCore::FontVisibility : bool;
[Nested] enum class WebCore::FontIsOrientationFallback : bool;

#if ENABLE(VIDEO)
header: <WebCore/CaptionUserPreferences.h>
enum class WebCore::CaptionUserPreferencesDisplayMode : uint8_t {
    Automatic,
    ForcedOnly,
    AlwaysOn,
    Manual,
};
#endif

header: <WebCore/InspectorClient.h>
enum class WebCore::InspectorClientDeveloperPreference : uint8_t {
    PrivateClickMeasurementDebugModeEnabled,
    ITPDebugModeEnabled,
    MockCaptureDevicesEnabled,
};

[AdditionalEncoder=StreamConnectionEncoder, RefCounted] class WebCore::SystemImage subclasses {
#if ENABLE(APPLE_PAY)
    WebCore::ApplePayLogoSystemImage
#endif
#if USE(SYSTEM_PREVIEW)
    WebCore::ARKitBadgeSystemImage
#endif
#if USE(APPKIT)
    WebCore::AppKitControlSystemImage
#endif
}

#if ENABLE(WEB_CODECS)
header: <WebCore/WebCodecsEncodedVideoChunk.h>
[CustomHeader, RefCounted] class WebCore::WebCodecsEncodedVideoChunkStorage {
    WebCore::WebCodecsEncodedVideoChunkData data();
};

header: <WebCore/WebCodecsEncodedAudioChunk.h>
[CustomHeader, RefCounted] class WebCore::WebCodecsEncodedAudioChunkStorage {
    WebCore::WebCodecsEncodedAudioChunkData data();
};
#endif

headers: <JavaScriptCore/WasmModule.h> <WebCore/ImageBitmap.h> <WebCore/MessagePort.h> <WebCore/OffscreenCanvas.h>
[Nested] class WebCore::SerializedScriptValue::Internals {
    Vector<uint8_t> data;
    std::unique_ptr<Vector<JSC::ArrayBufferContents>> arrayBufferContentsArray;
#if ENABLE(WEB_RTC)
    Vector<std::unique_ptr<WebCore::DetachedRTCDataChannel>> detachedRTCDataChannels;
#endif
#if ENABLE(WEB_CODECS)
    Vector<RefPtr<WebCore::WebCodecsEncodedVideoChunkStorage>> serializedVideoChunks;
    Vector<RefPtr<WebCore::WebCodecsEncodedAudioChunkStorage>> serializedAudioChunks;
    [NotSerialized] Vector<WebCore::WebCodecsVideoFrameData> serializedVideoFrames;
    [NotSerialized] Vector<WebCore::WebCodecsAudioInternalData> serializedAudioData;
#endif
#if ENABLE(MEDIA_STREAM)
    [NotSerialized] Vector<std::unique_ptr<WebCore::MediaStreamTrackDataHolder>> serializedMediaStreamTracks;
#endif
    [NotSerialized] std::unique_ptr<Vector<JSC::ArrayBufferContents>> sharedBufferContentsArray;
    [NotSerialized] Vector<std::optional<WebCore::DetachedImageBitmap>> detachedImageBitmaps;
#if ENABLE(OFFSCREEN_CANVAS_IN_WORKERS)
    [NotSerialized] Vector<std::unique_ptr<WebCore::DetachedOffscreenCanvas>> detachedOffscreenCanvases;
    [NotSerialized] Vector<RefPtr<WebCore::OffscreenCanvas>> inMemoryOffscreenCanvases;
#endif
    [NotSerialized] Vector<RefPtr<WebCore::MessagePort>> inMemoryMessagePorts;
#if ENABLE(WEBASSEMBLY)
    [NotSerialized] std::unique_ptr<Vector<RefPtr<JSC::Wasm::Module>>> wasmModulesArray;
    [NotSerialized] std::unique_ptr<Vector<RefPtr<JSC::SharedArrayBufferContents>>> wasmMemoryHandlesArray;
#endif
    [NotSerialized] Vector<WebCore::URLKeepingBlobAlive> blobHandles;
    [NotSerialized] size_t memoryCost;
};

[RefCounted] class WebCore::SerializedScriptValue {
    WebCore::SerializedScriptValue::Internals m_internals;
};

header: <WebCore/SharedBuffer.h>
[RefCounted] class WebCore::SharedBuffer {
    Ref<WebCore::FragmentedSharedBuffer> asFragmentedSharedBuffer();
};

#if !USE(COORDINATED_GRAPHICS)
[RefCounted] class WebCore::FilterOperation subclasses {
    WebCore::BasicColorMatrixFilterOperation
    WebCore::BasicComponentTransferFilterOperation
    WebCore::BlurFilterOperation
    WebCore::DropShadowFilterOperation
    WebCore::DefaultFilterOperation
    WebCore::PassthroughFilterOperation
}

[CustomHeader, RefCounted] class WebCore::BasicColorMatrixFilterOperation {
    double amount();
    [Validator='WebCore::FilterOperation::isBasicColorMatrixFilterOperationType(*type)'] WebCore::FilterOperation::Type type();
};
[CustomHeader, RefCounted] class WebCore::BasicComponentTransferFilterOperation {
    double amount();
    [Validator='WebCore::FilterOperation::isBasicComponentTransferFilterOperationType(*type)'] WebCore::FilterOperation::Type type();
};
[CustomHeader, RefCounted] class WebCore::BlurFilterOperation {
    WebCore::Length stdDeviation();
};
[CustomHeader, RefCounted] class WebCore::DropShadowFilterOperation {
    WebCore::IntPoint location();
    int stdDeviation();
    WebCore::Color color();
};
[CustomHeader, RefCounted] class WebCore::DefaultFilterOperation {
    WebCore::FilterOperation::Type representedType();
};
[CustomHeader, RefCounted] class WebCore::PassthroughFilterOperation {
    [NotSerialized] WebCore::FilterOperation::Type type();
};
#endif // !USE(COORDINATED_GRAPHICS)

[AdditionalEncoder=StreamConnectionEncoder, RefCounted] class WebCore::FilterEffect subclasses {
    WebCore::FEBlend
    WebCore::FEColorMatrix
    WebCore::FEComponentTransfer
    WebCore::FEComposite
    WebCore::FEConvolveMatrix
    WebCore::FEDiffuseLighting
    WebCore::FEDisplacementMap
    WebCore::FEDropShadow
    WebCore::FEFlood
    WebCore::FEGaussianBlur
    WebCore::FEImage
    WebCore::FEMerge
    WebCore::FEMorphology
    WebCore::FEOffset
    WebCore::FETile
    WebCore::FESpecularLighting
    WebCore::FETurbulence
    WebCore::SourceAlpha
    WebCore::SourceGraphic
}

#if ENABLE(MEDIA_SOURCE)

header: <WebCore/MediaSourcePrivate.h>
enum class WebCore::MediaSourcePrivateAddStatus : uint8_t {
    Ok,
    NotSupported,
    ReachedIdLimit
};

header: <WebCore/MediaSourcePrivate.h>
enum class WebCore::MediaSourcePrivateEndOfStreamStatus : uint8_t {
    NoError,
    NetworkError,
    DecodeError
};

header: <WebCore/SourceBufferPrivate.h>
enum class WebCore::SourceBufferAppendMode : uint8_t {
    Segments,
    Sequence
};

#endif

header: <WebCore/Font.h>
[CustomHeader] struct WebCore::FontInternalAttributes {
    std::optional<WebCore::RenderingResourceIdentifier> renderingResourceIdentifier;
    [BitField] WebCore::FontOrigin origin;
    [BitField] WebCore::FontIsInterstitial isInterstitial;
    [BitField] WebCore::FontVisibility visibility;
    [BitField] WebCore::FontIsOrientationFallback isTextOrientationFallback;
};

[CustomHeader, Nested] struct WebCore::Cursor::CustomCursorIPCData {
    Ref<WebCore::Image> image;
    [Validator='(*image)->rect().contains(*hotSpot)'] WebCore::IntPoint hotSpot;
#if ENABLE(MOUSE_CURSOR_SCALE)
    float scaleFactor;
#endif
};

[CreateUsing=fromIPCData] class WebCore::Cursor {
    std::variant<WebCore::Cursor::Type, std::optional<WebCore::Cursor::CustomCursorIPCData>> ipcData();
};

header: <WebCore/DOMCacheEngine.h>
[CustomHeader] struct WebCore::DOMCacheEngine::Record {
    uint64_t identifier;
    uint64_t updateResponseCounter;

    WebCore::FetchHeaders::Guard requestHeadersGuard;
    WebCore::ResourceRequest request;
    WebCore::FetchOptions options;
    String referrer;

    WebCore::FetchHeaders::Guard responseHeadersGuard;
    WebCore::ResourceResponse response;
    std::variant<std::nullptr_t, Ref<WebCore::FormData>, Ref<WebCore::SharedBuffer>> responseBody;
    uint64_t responseBodySize;
};

[AdditionalEncoder=StreamConnectionEncoder, RefCounted] class WebCore::LightSource subclasses {
    WebCore::DistantLightSource
    WebCore::PointLightSource
    WebCore::SpotLightSource
}

enum class WebCore::WindowProxyProperty : uint8_t {
    Other,
    Closed,
    PostMessage,
};

header: <WebCore/Image.h>
[RefCounted] class WebCore::Image {
    RefPtr<WebCore::ShareableBitmap> toShareableBitmap();
};

struct WebCore::Length {
    std::variant<WebCore::Length::AutoData, WebCore::Length::NormalData, WebCore::Length::RelativeData, WebCore::Length::PercentData, WebCore::Length::FixedData, WebCore::Length::IntrinsicData, WebCore::Length::MinIntrinsicData, WebCore::Length::MinContentData, WebCore::Length::MaxContentData, WebCore::Length::FillAvailableData, WebCore::Length::FitContentData, WebCore::Length::ContentData, WebCore::Length::UndefinedData> ipcData()
}
[Nested] struct WebCore::Length::AutoData {
};
[Nested] struct WebCore::Length::NormalData {
};
[Nested] struct WebCore::Length::RelativeData {
    std::variant<float, int> value
    bool hasQuirk
};
[Nested] struct WebCore::Length::PercentData {
    std::variant<float, int> value
    bool hasQuirk
};
[Nested] struct WebCore::Length::FixedData {
    std::variant<float, int> value
    bool hasQuirk
};
[Nested] struct WebCore::Length::IntrinsicData {
    std::variant<float, int> value
    bool hasQuirk
};
[Nested] struct WebCore::Length::MinIntrinsicData {
    std::variant<float, int> value
    bool hasQuirk
};
[Nested] struct WebCore::Length::MinContentData {
    std::variant<float, int> value
    bool hasQuirk
};
[Nested] struct WebCore::Length::MaxContentData {
    std::variant<float, int> value
    bool hasQuirk
};
[Nested] struct WebCore::Length::FillAvailableData {
    std::variant<float, int> value
    bool hasQuirk
};
[Nested] struct WebCore::Length::FitContentData {
    std::variant<float, int> value
    bool hasQuirk
};
[Nested] struct WebCore::Length::ContentData {
};
[Nested] struct WebCore::Length::UndefinedData {
};

[AdditionalEncoder=StreamConnectionEncoder, RefCounted] class WebCore::FilterFunction subclasses {
    WebCore::SVGFilter
    WebCore::FEBlend
    WebCore::FEColorMatrix
    WebCore::FEComponentTransfer
    WebCore::FEComposite
    WebCore::FEConvolveMatrix
    WebCore::FEDiffuseLighting
    WebCore::FEDisplacementMap
    WebCore::FEDropShadow
    WebCore::FEFlood
    WebCore::FEGaussianBlur
    WebCore::FEImage
    WebCore::FEMerge
    WebCore::FEMorphology
    WebCore::FEOffset
    WebCore::FESpecularLighting
    WebCore::FETile
    WebCore::FETurbulence
    WebCore::SourceAlpha
    WebCore::SourceGraphic
}

struct WebCore::OrganizationStorageAccessPromptQuirk {
    String organizationName;
    HashMap<WebCore::RegistrableDomain, Vector<WebCore::RegistrableDomain>> domainPairings;
};

#if ENABLE(SHAREABLE_RESOURCE)
header: <WebCore/ShareableResource.h>
[CustomHeader, RValue] class WebCore::ShareableResourceHandle {
    WebCore::SharedMemoryHandle m_handle;
    unsigned m_offset;
    [Validator='!(Checked<unsigned> { *m_offset } + *m_size).hasOverflowed() && (*m_offset + *m_size <= m_handle->size())'] unsigned m_size;
}
#endif

#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
[RValue] class WebCore::DynamicContentScalingDisplayList {
    Ref<WebCore::SharedBuffer> displayList();
    Vector<MachSendRight> takeSurfaces();
}
#endif

enum class WebCore::PlatformCursorType : uint8_t {
    Invalid,
    Pointer,
    Cross,
    Hand,
    IBeam,
    Wait,
    Help,
    EastResize,
    NorthResize,
    NorthEastResize,
    NorthWestResize,
    SouthResize,
    SouthEastResize,
    SouthWestResize,
    WestResize,
    NorthSouthResize,
    EastWestResize,
    NorthEastSouthWestResize,
    NorthWestSouthEastResize,
    ColumnResize,
    RowResize,
    MiddlePanning,
    EastPanning,
    NorthPanning,
    NorthEastPanning,
    NorthWestPanning,
    SouthPanning,
    SouthEastPanning,
    SouthWestPanning,
    WestPanning,
    Move,
    VerticalText,
    Cell,
    ContextMenu,
    Alias,
    Progress,
    NoDrop,
    Copy,
    None,
    NotAllowed,
    ZoomIn,
    ZoomOut,
    Grab,
    Grabbing,
    Custom,
};

header: <WebCore/ContextMenuItem.h>
enum class WebCore::ContextMenuItemType : uint8_t {
    Action,
    CheckableAction,
    Separator,
    Submenu,
};

#if PLATFORM(COCOA)
header: <WebCore/TextAttachmentForSerialization.h>
[CustomHeader] struct WebCore::TextAttachmentMissingImage {
}

[CustomHeader] struct WebCore::TextAttachmentFileWrapper {
#if !PLATFORM(IOS_FAMILY)
    bool ignoresOrientation;
#endif
    String preferredFilename;
    RetainPtr<CFDataRef> data;
    String accessibilityLabel;
}
#endif

[Nested] enum class WebCore::PopupMenuStyle::Size : uint8_t {
    Normal,
    Small,
    Mini,
    Large,
};

header: <WebCore/PredefinedColorSpace.h>
enum class WebCore::PredefinedColorSpace : uint8_t {
    SRGB
#if ENABLE(PREDEFINED_COLOR_SPACE_DISPLAY_P3)
    , DisplayP3
#endif
};

header: <WebCore/TransformOperation.h>
enum class WebCore::TransformOperationType : uint8_t {
    ScaleX,
    ScaleY,
    Scale,
    TranslateX,
    TranslateY,
    Translate,
    RotateX,
    RotateY,
    Rotate,
    SkewX,
    SkewY,
    Skew,
    Matrix,
    ScaleZ,
    Scale3D,
    TranslateZ,
    Translate3D,
    RotateZ,
    Rotate3D,
    Matrix3D,
    Perspective,
    Identity,
    None
};

enum class WebCore::GraphicsContextGLSurfaceBuffer : bool;

[Nested] enum class WebCore::GraphicsLayer::CustomAppearance : bool;

[OptionSet] enum class GCGLErrorCode : uint8_t {
    ContextLost,
    InvalidFramebufferOperation,
    OutOfMemory,
    InvalidOperation,
    InvalidValue,
    InvalidEnum
};

#if ENABLE(IMAGE_ANALYSIS) && ENABLE(DATA_DETECTION)
header: <WebCore/TextRecognitionResult.h>
[CustomHeader] struct WebCore::TextRecognitionDataDetector {
    RetainPtr<DDScannerResult> result;
    Vector<WebCore::FloatQuad> normalizedQuads;
};
#endif // ENABLE(IMAGE_ANALYSIS) && ENABLE(DATA_DETECTION)

#if ENABLE(VIDEO)

header: <WebCore/AudioTrackPrivate.h>
[Nested] enum class WebCore::AudioTrackPrivate::Kind : uint8_t {
    Alternative,
    Description,
    Main,
    MainDesc,
    Translation,
    Commentary,
    None
};

header: <WebCore/VideoTrackPrivate.h>
[Nested] enum class WebCore::VideoTrackPrivate::Kind : uint8_t {
    Alternative,
    Captions,
    Main,
    Sign,
    Subtitles,
    Commentary,
    None
};

#endif

header: <WebCore/ShareableBitmap.h>
[CustomHeader] class WebCore::ShareableBitmapConfiguration {
    [Validator='m_size->width() >= 0 && m_size->height() >= 0'] WebCore::IntSize m_size;
    std::optional<WebCore::DestinationColorSpace> m_colorSpace;
    bool m_isOpaque;
    unsigned bytesPerPixel();
    unsigned bytesPerRow();
#if USE(CG)
    CGBitmapInfo m_bitmapInfo;
#endif
}

[CustomHeader, RValue] class WebCore::ShareableBitmapHandle {
    WebCore::SharedMemoryHandle m_handle;
    [Validator='!m_configuration->sizeInBytes().hasOverflowed() && m_handle->size() >= m_configuration->sizeInBytes()'] WebCore::ShareableBitmapConfiguration m_configuration;
}

[RefCounted, CreateUsing=createReadOnly] class WebCore::ShareableBitmap {
    std::optional<WebCore::ShareableBitmapHandle> createReadOnlyHandle()
}

#if ENABLE(DATA_DETECTION)
header: <WebCore/DataDetectorElementInfo.h>
struct WebCore::DataDetectorElementInfo {
    RetainPtr<DDScannerResult> result;
    WebCore::IntRect elementBounds;
};
#endif

header: <WebCore/FEComposite.h>
enum class WebCore::CompositeOperationType : uint8_t {
    FECOMPOSITE_OPERATOR_UNKNOWN,
    FECOMPOSITE_OPERATOR_OVER,
    FECOMPOSITE_OPERATOR_IN,
    FECOMPOSITE_OPERATOR_OUT,
    FECOMPOSITE_OPERATOR_ATOP,
    FECOMPOSITE_OPERATOR_XOR,
    FECOMPOSITE_OPERATOR_ARITHMETIC,
    FECOMPOSITE_OPERATOR_LIGHTER
};

header: <WebCore/FEColorMatrix.h>
enum class WebCore::ColorMatrixType : uint8_t {
    FECOLORMATRIX_TYPE_UNKNOWN,
    FECOLORMATRIX_TYPE_MATRIX,
    FECOLORMATRIX_TYPE_SATURATE,
    FECOLORMATRIX_TYPE_HUEROTATE,
    FECOLORMATRIX_TYPE_LUMINANCETOALPHA
};

header: <WebCore/FETurbulence.h>
enum class WebCore::TurbulenceType : uint8_t {
    Unknown,
    FractalNoise,
    Turbulence
};

header: <WebCore/FilterRenderingMode.h>
[OptionSet] enum class WebCore::FilterRenderingMode : uint8_t {
    Software,
    Accelerated,
    GraphicsContext
};

header: <WebCore/LightSource.h>
enum class WebCore::LightType : uint8_t {
    LS_DISTANT,
    LS_POINT,
    LS_SPOT
};

header: <WebCore/FEComponentTransfer.h>
enum class WebCore::ComponentTransferType : uint8_t {
    FECOMPONENTTRANSFER_TYPE_UNKNOWN,
    FECOMPONENTTRANSFER_TYPE_IDENTITY,
    FECOMPONENTTRANSFER_TYPE_TABLE,
    FECOMPONENTTRANSFER_TYPE_DISCRETE,
    FECOMPONENTTRANSFER_TYPE_LINEAR,
    FECOMPONENTTRANSFER_TYPE_GAMMA
};

enum class WebCore::ComponentTransferChannel : uint8_t {
    Red,
    Green,
    Blue,
    Alpha
};

header: <WebCore/FEMorphology.h>
enum class WebCore::MorphologyOperatorType : uint8_t {
    Unknown,
    Erode,
    Dilate
};

header: <WebCore/FEDisplacementMap.h>
enum class WebCore::ChannelSelectorType : uint8_t {
    CHANNEL_UNKNOWN,
    CHANNEL_R,
    CHANNEL_G,
    CHANNEL_B,
    CHANNEL_A
};

header: <WebCore/FEConvolveMatrix.h>
enum class WebCore::EdgeModeType : uint8_t {
    Unknown,
    Duplicate,
    Wrap,
    None
};

header: <WebCore/FilterOperation.h>
[Nested] enum class WebCore::FilterOperation::Type : uint8_t {
    Reference,
    Grayscale,
    Sepia,
    Saturate,
    HueRotate,
    Invert,
    AppleInvertLightness,
    Opacity,
    Brightness,
    Contrast,
    Blur,
    DropShadow,
    Passthrough,
    Default,
    None
};

header: <WebCore/FilterFunction.h>
[Nested] enum class WebCore::FilterFunction::Type : uint8_t {
    CSSFilter,
    SVGFilter,
    FEBlend,
    FEColorMatrix,
    FEComponentTransfer,
    FEComposite,
    FEConvolveMatrix,
    FEDiffuseLighting,
    FEDisplacementMap,
    FEDropShadow,
    FEFlood,
    FEGaussianBlur,
    FEImage,
    FEMerge,
    FEMorphology,
    FEOffset,
    FESpecularLighting,
    FETile,
    FETurbulence,
    SourceAlpha,
    SourceGraphic
};

#if ENABLE(VIDEO)
class WebCore::SerializedPlatformDataCueValue {
    std::optional<WebCore::SerializedPlatformDataCueValue::Data> data()
}

[Nested] struct WebCore::SerializedPlatformDataCueValue::Data {
#if PLATFORM(COCOA)
    String type;
    HashMap<String, String> otherAttributes;
    String key;
    RetainPtr<NSLocale> locale;
    std::variant<std::nullptr_t, RetainPtr<NSString>, RetainPtr<NSDate>, RetainPtr<NSNumber>, RetainPtr<NSData>> value;
#endif
#endif
};
