# Copyright (C) 2022-2023 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

header: <WebCore/DOMCacheEngine.h>
[CustomHeader] struct WebCore::DOMCacheEngine::CacheInfo {
    WebCore::DOMCacheIdentifier identifier
    String name
}

[CustomHeader] struct WebCore::DOMCacheEngine::CacheInfos {
    Vector<WebCore::DOMCacheEngine::CacheInfo> infos;
    uint64_t updateCounter;
};

[CustomHeader] struct WebCore::DOMCacheEngine::CacheIdentifierOperationResult {
    WebCore::DOMCacheIdentifier identifier;
    bool hadStorageError;
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::TransformationMatrix {
    double m11()
    double m12()
    double m13()
    double m14()
    double m21()
    double m22()
    double m23()
    double m24()
    double m31()
    double m32()
    double m33()
    double m34()
    double m41()
    double m42()
    double m43()
    double m44()
}

struct WebCore::CacheQueryOptions {
    bool ignoreSearch;
    bool ignoreMethod;
    bool ignoreVary;
}

struct WebCore::CharacterRange {
    uint64_t location
    uint64_t length
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::AffineTransform {
    double a()
    double b()
    double c()
    double d()
    double e()
    double f()
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatPoint {
    float x()
    float y()
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatPoint3D {
    float x()
    float y()
    float z()
}

class WebCore::FloatQuad {
    WebCore::FloatPoint p1();
    WebCore::FloatPoint p2();
    WebCore::FloatPoint p3();
    WebCore::FloatPoint p4();
}

struct WebCore::IDBCursorRecord {
    WebCore::IDBKeyData key;
    WebCore::IDBKeyData primaryKey;
    WebCore::IDBValue value;
}

class WebCore::IDBCursorInfo {
    WebCore::IDBResourceIdentifier identifier();
    WebCore::IDBResourceIdentifier transactionIdentifier();
    uint64_t objectStoreIdentifier();
    uint64_t sourceIdentifier();

    WebCore::IDBKeyRangeData range();

    WebCore::IndexedDB::CursorSource cursorSource();
    WebCore::IndexedDB::CursorDirection cursorDirection();
    WebCore::IndexedDB::CursorType cursorType();
};

class WebCore::IDBError {
    std::optional<WebCore::ExceptionCode> code()
    String messageForSerialization()
}

struct WebCore::IDBGetAllRecordsData {
    WebCore::IDBKeyRangeData keyRangeData;
    WebCore::IndexedDB::GetAllType getAllType;
    std::optional<uint32_t> count;
    uint64_t objectStoreIdentifier;
    uint64_t indexIdentifier;
}

class WebCore::IDBGetResult {
    WebCore::IDBKeyData keyData()
    WebCore::IDBKeyData primaryKeyData()
    WebCore::IDBValue value()
    std::optional<WebCore::IDBKeyPath> keyPath()
    Vector<WebCore::IDBCursorRecord> prefetchedRecords()
    bool isDefined()
}

class WebCore::IDBGetAllResult {
    WebCore::IndexedDB::GetAllType type()
    Vector<WebCore::IDBKeyData> keys()
    Vector<WebCore::IDBValue> values()
    std::optional<WebCore::IDBKeyPath> keyPath()
}

class WebCore::IDBDatabaseInfo {
    String m_name
    uint64_t m_version
    uint64_t m_maxIndexID
    uint64_t m_maxObjectStoreID
    HashMap<uint64_t, WebCore::IDBObjectStoreInfo> m_objectStoreMap
}

struct WebCore::IDBKeyRangeData {
    WebCore::IDBKeyData lowerKey;
    WebCore::IDBKeyData upperKey;

    bool lowerOpen;
    bool upperOpen;
};

class WebCore::IDBTransactionInfo {
    WebCore::IDBResourceIdentifier identifier();
    WebCore::IDBTransactionMode mode();
    WebCore::IDBTransactionDurability durability();
    uint64_t newVersion();
    Vector<String> objectStores();
    std::unique_ptr<WebCore::IDBDatabaseInfo> originalDatabaseInfo();
};

struct WebCore::IDBGetRecordData {
    WebCore::IDBKeyRangeData keyRangeData;
    WebCore::IDBGetRecordDataType type;
}

class WebCore::IDBIndexInfo {
    uint64_t identifier()
    uint64_t objectStoreIdentifier()
    String name()
    WebCore::IDBKeyPath keyPath()
    bool unique()
    bool multiEntry()
}

class WebCore::IDBObjectStoreInfo {
    uint64_t identifier()
    String name()
    std::optional<WebCore::IDBKeyPath> keyPath()
    bool autoIncrement()
    HashMap<uint64_t, WebCore::IDBIndexInfo> indexMap()
}

struct WebCore::IDBIterateCursorData {
    WebCore::IDBKeyData keyData;
    WebCore::IDBKeyData primaryKeyData;
    unsigned count;
    WebCore::IndexedDB::CursorIterateOption option;
}

class WebCore::IDBResourceIdentifier {
    WebCore::IDBConnectionIdentifier m_idbConnectionIdentifier
    uint64_t m_resourceNumber
}

class WebCore::IDBValue {
    WebCore::ThreadSafeDataBuffer data()
    Vector<String> blobURLs()
    Vector<String> blobFilePaths()
};

class WebCore::IDBRequestData {
    WebCore::IDBConnectionIdentifier m_serverConnectionIdentifier;
    WebCore::IDBResourceIdentifier m_requestIdentifier;
    std::optional<WebCore::IDBResourceIdentifier> m_transactionIdentifier;
    std::optional<WebCore::IDBResourceIdentifier> m_cursorIdentifier;
    uint64_t m_objectStoreIdentifier;
    uint64_t m_indexIdentifier;
    WebCore::IndexedDB::IndexRecordType m_indexRecordType;
    std::optional<WebCore::IDBDatabaseIdentifier> m_databaseIdentifier;
    uint64_t m_requestedVersion;
    WebCore::IndexedDB::RequestType m_requestType;
}

# FIXME: When decoding from IPC, databaseName can be null, and the non-empty constructor asserts that this is not the case.
[LegacyPopulateFromEmptyConstructor] class WebCore::IDBDatabaseIdentifier {
    String m_databaseName
    WebCore::ClientOrigin m_origin
    bool m_isTransient
}

struct WebCore::IDBDatabaseNameAndVersion {
    String name;
    uint64_t version;
}

[LegacyPopulateFromEmptyConstructor] class WebCore::IDBResultData {
    WebCore::IDBResultType m_type;
    WebCore::IDBResourceIdentifier m_requestIdentifier;
    WebCore::IDBError m_error;
    uint64_t m_databaseConnectionIdentifier;
    std::unique_ptr<WebCore::IDBDatabaseInfo> m_databaseInfo;
    std::unique_ptr<WebCore::IDBTransactionInfo> m_transactionInfo;
    std::unique_ptr<WebCore::IDBKeyData> m_resultKey;
    std::unique_ptr<WebCore::IDBGetResult> m_getResult;
    std::unique_ptr<WebCore::IDBGetAllResult> m_getAllResult;
    uint64_t m_resultInteger;
}

class WebCore::IDBKeyData {
    std::variant<std::nullptr_t, WebCore::IDBKeyData::Invalid, Vector<WebCore::IDBKeyData>, String, double, WebCore::IDBKeyData::Date, WebCore::ThreadSafeDataBuffer, WebCore::IDBKeyData::Min, WebCore::IDBKeyData::Max> value()
}

[Nested] struct WebCore::IDBKeyData::Invalid {
}

[Nested] struct WebCore::IDBKeyData::Min {
}

[Nested] struct WebCore::IDBKeyData::Max {
}

[Nested] struct WebCore::IDBKeyData::Date {
    double value
}

enum class WebCore::IndexedDB::KeyType : int8_t {
    Max,
    Invalid,
    Array,
    Binary,
    String,
    Date,
    Number,
    Min,
};

enum class WebCore::IndexedDB::CursorDirection : uint8_t {
    Next,
    Nextunique,
    Prev,
    Prevunique,
};

enum class WebCore::IndexedDB::ObjectStoreOverwriteMode : uint8_t {
    Overwrite,
    OverwriteForCursor,
    NoOverwrite,
};

enum class WebCore::IndexedDB::RequestType : uint8_t {
    Open,
    Delete,
    Other,
};

#if USE(CG)
headers: <CoreGraphics/CGGeometry.h> <CoreGraphics/CGAffineTransform.h>
[AdditionalEncoder=StreamConnectionEncoder] struct CGSize {
    CGFloat width
    CGFloat height
};

struct CGPoint {
    CGFloat x
    CGFloat y
};

struct CGRect {
    CGPoint origin
    CGSize size
};

struct CGAffineTransform {
  CGFloat a
  CGFloat b
  CGFloat c
  CGFloat d
  CGFloat tx
  CGFloat ty
};
#endif

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatRect {
    WebCore::FloatPoint location()
    WebCore::FloatSize size()
}

[RefCounted, CustomHeader] class WebCore::LinearTimingFunction {
};

[Nested] enum class WebCore::CubicBezierTimingFunction::TimingFunctionPreset : uint8_t {
    Ease,
    EaseIn,
    EaseOut,
    EaseInOut,
    Custom
};

[RefCounted, CustomHeader] class WebCore::CubicBezierTimingFunction {
    WebCore::CubicBezierTimingFunction::TimingFunctionPreset timingFunctionPreset()
    double x1()
    double y1()
    double x2()
    double y2()
};

[Nested] enum class WebCore::StepsTimingFunction::StepPosition : uint8_t {
    JumpStart,
    JumpEnd,
    JumpNone,
    JumpBoth,
    Start,
    End,
};

[RefCounted, CustomHeader] class WebCore::StepsTimingFunction {
    int numberOfSteps()
    std::optional<WebCore::StepsTimingFunction::StepPosition> stepPosition()
};

[RefCounted, CustomHeader] class WebCore::SpringTimingFunction {
    double mass()
    double stiffness()
    double damping()
    double initialVelocity()
};

[LegacyPopulateFromEmptyConstructor] struct WebCore::ResourceLoadStatistics {
    WebCore::RegistrableDomain registrableDomain;
    WallTime lastSeen;
    bool hadUserInteraction;
    WallTime mostRecentUserInteractionTime;
    bool grandfathered;
    HashSet<WebCore::RegistrableDomain> storageAccessUnderTopFrameDomains;
    HashSet<WebCore::RegistrableDomain> topFrameUniqueRedirectsTo;
    HashSet<WebCore::RegistrableDomain> topFrameUniqueRedirectsToSinceSameSiteStrictEnforcement;
    HashSet<WebCore::RegistrableDomain> topFrameUniqueRedirectsFrom;
    HashSet<WebCore::RegistrableDomain> topFrameLinkDecorationsFrom;
    bool gotLinkDecorationFromPrevalentResource;
    HashSet<WebCore::RegistrableDomain> topFrameLoadedThirdPartyScripts;
    HashSet<WebCore::RegistrableDomain> subframeUnderTopFrameDomains;
    HashSet<WebCore::RegistrableDomain> subresourceUnderTopFrameDomains;
    HashSet<WebCore::RegistrableDomain> subresourceUniqueRedirectsTo;
    HashSet<WebCore::RegistrableDomain> subresourceUniqueRedirectsFrom;
    bool isPrevalentResource;
    bool isVeryPrevalentResource;
    unsigned dataRecordsRemoved;
    unsigned timesAccessedAsFirstPartyDueToUserInteraction;
    unsigned timesAccessedAsFirstPartyDueToStorageAccessAPI;
#if ENABLE(WEB_API_STATISTICS)
    HashSet<WebCore::RegistrableDomain> topFrameRegistrableDomainsWhichAccessedWebAPIs;
    HashSet<String> fontsFailedToLoad;
    HashSet<String> fontsSuccessfullyLoaded;
    WebCore::CanvasActivityRecord canvasActivityRecord;
    OptionSet<WebCore::NavigatorAPIsAccessed> navigatorFunctionsAccessed;
    OptionSet<WebCore::ScreenAPIsAccessed> screenFunctionsAccessed;
#endif
};

[OptionSet] enum class WebCore::NavigatorAPIsAccessed : uint64_t {
    AppVersion,
    UserAgent,
    Plugins,
    MimeTypes,
    CookieEnabled
};

[OptionSet] enum class WebCore::ScreenAPIsAccessed : uint64_t {
    Height,
    Width,
    ColorDepth,
    PixelDepth,
    AvailLeft,
    AvailTop,
    AvailHeight,
    AvailWidth
};

#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
header: <WebCore/GraphicsContextGLActiveInfo.h>
[AdditionalEncoder=StreamConnectionEncoder, CustomHeader] struct WebCore::GraphicsContextGLActiveInfo {
    String name;
    GCGLenum type;
    GCGLint size;
};
#endif

enum class WebCore::ViewportFit : uint8_t {
    Auto,
    Contain,
    Cover,
};

header: <WebCore/ViewportArguments.h>
[CustomHeader] struct WebCore::ViewportAttributes {
    WebCore::FloatSize layoutSize;

    float initialScale;
    float minimumScale;
    float maximumScale;

    float userScalable;
    float orientation;
    float shrinkToFit;

    WebCore::ViewportFit viewportFit;
};

header: <WebCore/ShareData.h>
[CustomHeader] struct WebCore::ShareDataWithParsedURL {
    WebCore::ShareData shareData;
    std::optional<URL> url;
    Vector<WebCore::RawFile> files;
    WebCore::ShareDataOriginator originator;
};

struct WebCore::ShareData {
    String title;
    String text;
    String url;
};

enum class WebCore::ShareDataOriginator : bool

[CustomHeader] struct WebCore::RawFile {
    String fileName;
    RefPtr<WebCore::SharedBuffer> fileData;
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatRoundedRect {
    WebCore::FloatRect rect();
    WebCore::FloatSize radii().topLeft();
    WebCore::FloatSize radii().topRight();
    WebCore::FloatSize radii().bottomLeft();
    WebCore::FloatSize radii().bottomRight();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::IntRect {
    WebCore::IntPoint location();
    WebCore::IntSize size();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::IntPoint {
    int x();
    int y();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::IntSize {
    int width();
    int height();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FloatSize {
    float width();
    float height();
}

[AdditionalEncoder=StreamConnectionEncoder, CreateUsing=fromRawValue] class WebCore::LayoutUnit {
    int rawValue()
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::LayoutPoint {
    WebCore::LayoutUnit x();
    WebCore::LayoutUnit y();
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::LayoutSize {
    WebCore::LayoutUnit width();
    WebCore::LayoutUnit height();
}

struct WebCore::DictionaryPopupInfo {
    WebCore::FloatPoint origin;
    WebCore::TextIndicatorData textIndicator;
#if PLATFORM(COCOA)
    WebCore::DictionaryPopupInfoCocoa platformData;
#endif
};

enum class WebCore::PCM::AttributionEphemeral : bool
enum class WebCore::PCM::WasSent : bool

class WebCore::PrivateClickMeasurement {
    uint8_t sourceID()
    WebCore::PCM::SourceSite sourceSite()
    WebCore::PCM::AttributionDestinationSite destinationSite()
    WallTime timeOfAdClick()
    WebCore::PCM::AttributionEphemeral isEphemeral()
    std::optional<uint64_t> adamID()
    std::optional<WebCore::PCM::AttributionTriggerData> attributionTriggerData()
    WebCore::PCM::AttributionTimeToSendData timesToSend()
    std::optional<WebCore::PCM::EphemeralNonce> ephemeralSourceNonce()
    String sourceApplicationBundleID()
}

[CustomHeader] struct WebCore::PCM::SourceSite {
    WebCore::RegistrableDomain registrableDomain
}

[CustomHeader] struct WebCore::PCM::AttributionDestinationSite {
    WebCore::RegistrableDomain registrableDomain
}

[CustomHeader] struct WebCore::PCM::EphemeralNonce {
    String nonce
}

[CustomHeader] struct WebCore::PCM::AttributionTriggerData {
    uint8_t data
    uint8_t priority;
    WebCore::PCM::WasSent wasSent;
    std::optional<WebCore::RegistrableDomain> sourceRegistrableDomain;
    std::optional<WebCore::PCM::EphemeralNonce> ephemeralDestinationNonce;
    std::optional<WebCore::RegistrableDomain> destinationSite;
# destinationUnlinkableToken and destinationSecretToken are not serialized.
}

[CustomHeader] struct WebCore::PCM::AttributionTimeToSendData {
    std::optional<WallTime> sourceEarliestTimeToSend;
    std::optional<WallTime> destinationEarliestTimeToSend;
}

#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
struct WebCore::ApplePayRecurringPaymentRequest {
    String paymentDescription
    WebCore::ApplePayLineItem regularBilling
    std::optional<WebCore::ApplePayLineItem> trialBilling
    String billingAgreement
    String managementURL
    String tokenNotificationURL
};
#endif

#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
struct WebCore::ApplePayPaymentTokenContext {
    String merchantIdentifier
    String externalIdentifier
    String merchantName
    String merchantDomain
    String amount
}
#endif

#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
struct WebCore::ApplePayDeferredPaymentRequest {
    String billingAgreement
    WebCore::ApplePayLineItem deferredBilling
    WallTime freeCancellationDate
    String freeCancellationDateTimeZone
    String managementURL
    String paymentDescription
    String tokenNotificationURL
};
#endif

#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
struct WebCore::ApplePayPaymentOrderDetails {
    String orderTypeIdentifier
    String orderIdentifier
    String webServiceURL
    String authenticationToken
}
#endif

#if ENABLE(APPLE_PAY_AMS_UI) && ENABLE(PAYMENT_REQUEST)
struct WebCore::ApplePayAMSUIRequest {
    String engagementRequest
}
#endif

#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
struct WebCore::ApplePayAutomaticReloadPaymentRequest {
    String paymentDescription
    WebCore::ApplePayLineItem automaticReloadBilling
    String billingAgreement
    String managementURL
    String tokenNotificationURL
}
#endif

#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
struct WebCore::ApplePayDateComponents {
    std::optional<unsigned> years;
    std::optional<unsigned> months;
    std::optional<unsigned> days;
    std::optional<unsigned> hours;
}

struct WebCore::ApplePayDateComponentsRange {
    WebCore::ApplePayDateComponents startDateComponents;
    WebCore::ApplePayDateComponents endDateComponents;
}
#endif // ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)

#if ENABLE(APPLE_PAY)
struct WebCore::ApplePayLineItem {
    WebCore::ApplePayLineItem::Type type
    String label
    String amount
    WebCore::ApplePayPaymentTiming paymentTiming
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    WallTime recurringPaymentStartDate
    WebCore::ApplePayRecurringPaymentDateUnit recurringPaymentIntervalUnit
    unsigned recurringPaymentIntervalCount
    WallTime recurringPaymentEndDate
#endif
#if ENABLE(APPLE_PAY_DEFERRED_LINE_ITEM)
    WallTime deferredPaymentDate
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_LINE_ITEM)
    String automaticReloadPaymentThresholdAmount
#endif
}

struct WebCore::ApplePayShippingMethod {
    String label
    String detail
    String amount
    String identifier
#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
    std::optional<WebCore::ApplePayDateComponentsRange> dateComponentsRange
#endif
#if ENABLE(APPLE_PAY_SELECTED_SHIPPING_METHOD)
    bool selected
#endif
}

[RefCounted] class WebCore::ApplePayError {
    WebCore::ApplePayErrorCode code()
    std::optional<WebCore::ApplePayErrorContactField> contactField()
    String message()
}

enum class WebCore::ApplePayLogoStyle : bool
[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::ApplePayLogoSystemImage {
    WebCore::ApplePayLogoStyle applePayLogoStyle()
}

struct WebCore::ApplePayDetailsUpdateBase {
    WebCore::ApplePayLineItem newTotal;
    Vector<WebCore::ApplePayLineItem> newLineItems;
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    std::optional<WebCore::ApplePayRecurringPaymentRequest> newRecurringPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest> newAutomaticReloadPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    std::optional<Vector<WebCore::ApplePayPaymentTokenContext>> newMultiTokenContexts;
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    std::optional<WebCore::ApplePayDeferredPaymentRequest> newDeferredPaymentRequest;
#endif
}

struct WebCore::ApplePayPaymentMethodUpdate : WebCore::ApplePayDetailsUpdateBase {
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    Vector<RefPtr<WebCore::ApplePayError>> errors;
    Vector<WebCore::ApplePayShippingMethod> newShippingMethods;
#endif
#if ENABLE(APPLE_PAY_INSTALLMENTS)
    String installmentGroupIdentifier;
#endif
};

struct WebCore::ApplePayShippingContactUpdate : WebCore::ApplePayDetailsUpdateBase {
    Vector<RefPtr<WebCore::ApplePayError>> errors;
    Vector<WebCore::ApplePayShippingMethod> newShippingMethods;
};

struct WebCore::ApplePayShippingMethodUpdate : WebCore::ApplePayDetailsUpdateBase {
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    Vector<WebCore::ApplePayShippingMethod> newShippingMethods;
#endif
};

struct WebCore::ApplePayPaymentAuthorizationResult {
    unsigned short status;
    Vector<RefPtr<WebCore::ApplePayError>> errors;
#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
    std::optional<WebCore::ApplePayPaymentOrderDetails> orderDetails;
#endif
}

enum class WebCore::ApplePayErrorContactField : uint8_t {
    PhoneNumber,
    EmailAddress,
    Name,
    PhoneticName,
    PostalAddress,
    AddressLines,
    SubLocality,
    Locality,
    PostalCode,
    SubAdministrativeArea,
    AdministrativeArea,
    Country,
    CountryCode,
};

enum class WebCore::ApplePayErrorCode : uint8_t {
    Unknown,
    ShippingContactInvalid,
    BillingContactInvalid,
    AddressUnserviceable,
#if ENABLE(APPLE_PAY_COUPON_CODE)
    CouponCodeInvalid,
    CouponCodeExpired,
#endif
};
#endif // ENABLE(APPLE_PAY)

#if ENABLE(APPLE_PAY_COUPON_CODE)
struct WebCore::ApplePayCouponCodeUpdate : WebCore::ApplePayDetailsUpdateBase {
    Vector<RefPtr<WebCore::ApplePayError>> errors;
    Vector<WebCore::ApplePayShippingMethod> newShippingMethods;
};
#endif

#if ENABLE(APPLICATION_MANIFEST)
[Nested] enum class WebCore::ApplicationManifest::Display : uint8_t {
    Browser
    MinimalUI
    Standalone
    Fullscreen
};

[Nested, OptionSet] enum class WebCore::ApplicationManifest::Icon::Purpose : uint8_t {
    Any
    Monochrome
    Maskable
}

[Nested] struct WebCore::ApplicationManifest::Icon {
    URL src
    Vector<String> sizes
    String type
    OptionSet<WebCore::ApplicationManifest::Icon::Purpose> purposes
}

struct WebCore::ApplicationManifest {
    String name
    String shortName
    String description
    URL scope
    WebCore::ApplicationManifest::Display display
    URL startURL
    URL id
    WebCore::Color themeColor
    Vector<WebCore::ApplicationManifest::Icon> icons
}
#endif // ENABLE(APPLICATION_MANIFEST)

enum class WebCore::DOMCacheEngine::Error : uint8_t {
    NotImplemented,
    ReadDisk,
    WriteDisk,
    QuotaExceeded,
    Internal,
    Stopped,
    CORP
};

struct WebCore::RetrieveRecordsOptions {
    WebCore::ResourceRequest request;
    WebCore::CrossOriginEmbedderPolicy crossOriginEmbedderPolicy;
    Ref<WebCore::SecurityOrigin> sourceOrigin;
    bool ignoreSearch;
    bool ignoreMethod;
    bool ignoreVary;
    bool shouldProvideResponse;
};

struct WebCore::ContactInfo {
    Vector<String> name;
    Vector<String> email;
    Vector<String> tel;
};

struct WebCore::ContactsRequestData {
    Vector<WebCore::ContactProperty> properties;
    bool multiple;
    String url;
};

#if ENABLE(MEDIA_SESSION)
struct WebCore::MediaPositionState {
    double duration;
    double playbackRate;
    double position;
};
#endif // ENABLE(MEDIA_SESSION)

#if ENABLE(WEB_RTC)
struct WebCore::DetachedRTCDataChannel {
    WebCore::RTCDataChannelIdentifier identifier;
    String label;
    WebCore::RTCDataChannelInit options;
    WebCore::RTCDataChannelState state;
};
#endif

header: <WebCore/WebCodecsEncodedVideoChunk.h>
#if ENABLE(WEB_CODECS)
struct WebCore::WebCodecsEncodedVideoChunkData {
    WebCore::WebCodecsEncodedVideoChunkType type;
    int64_t timestamp;
    std::optional<uint64_t> duration;
    Vector<uint8_t> buffer;
};
#endif

struct WebCore::HTMLModelElementCamera {
    double pitch;
    double yaw;
    double scale;
};

struct WebCore::NotificationData {
    String title;
    String body;
    String iconURL;
    String tag;
    String language;
    WebCore::NotificationDirection direction;
    String originString;
    URL serviceWorkerRegistrationURL;
    UUID notificationID;
    WebCore::ScriptExecutionContextIdentifier contextIdentifier;
    PAL::SessionID sourceSession;
    MonotonicTime creationTime;
    Vector<uint8_t> data;
};

struct WebCore::PermissionDescriptor {
    WebCore::PermissionName name;
}

#if ENABLE(SERVICE_WORKER)
struct WebCore::PushSubscriptionData {
    WebCore::PushSubscriptionIdentifier identifier;
    String endpoint;
    std::optional<WebCore::EpochTimeStamp> expirationTime;
    Vector<uint8_t> serverVAPIDPublicKey;
    Vector<uint8_t> clientECDHPublicKey;
    Vector<uint8_t> sharedAuthenticationSecret;
};
#endif

[RefCounted] class WebCore::DeprecationReportBody {
    String id()
    WallTime anticipatedRemoval()
    String message()
    String sourceFile()
    std::optional<unsigned> lineNumber()
    std::optional<unsigned> columnNumber()
};

[RefCounted] class WebCore::Report {
    String type()
    String url()
    RefPtr<WebCore::ReportBody> body()
};

[RefCounted] class WebCore::TestReportBody {
    String message()
}

enum class WebCore::SpeechRecognitionErrorType : uint8_t {
    NoSpeech,
    Aborted,
    AudioCapture,
    Network,
    NotAllowed,
    ServiceNotAllowed,
    BadGrammar,
    LanguageNotSupported
};

struct WebCore::SpeechRecognitionError {
    WebCore::SpeechRecognitionErrorType type;
    String message;
};

struct WebCore::SpeechRecognitionRequestInfo {
    WebCore::SpeechRecognitionConnectionClientIdentifier clientIdentifier;
    String lang;
    bool continuous;
    bool interimResults;
    uint64_t maxAlternatives;
    WebCore::ClientOrigin clientOrigin;
    WebCore::FrameIdentifier frameIdentifier;
};

[CustomHeader] struct WebCore::SpeechRecognitionAlternativeData {
    String transcript;
    double confidence;
};

struct WebCore::SpeechRecognitionResultData {
    Vector<WebCore::SpeechRecognitionAlternativeData> alternatives;
    bool isFinal;
};

struct WebCore::WebLockManagerSnapshot {
    Vector<WebCore::WebLockManagerSnapshot::Info> held;
    Vector<WebCore::WebLockManagerSnapshot::Info> pending;
};

[Nested] struct WebCore::WebLockManagerSnapshot::Info {
    String name;
    WebCore::WebLockMode mode;
    String clientId;
};

#if ENABLE(WEB_AUTHN)
[Nested] struct WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs {
    String support;
    std::optional<bool> read;
    std::optional<WebCore::BufferSource> write;
}

[LegacyPopulateFromEmptyConstructor] struct WebCore::AuthenticationExtensionsClientInputs {
    String appid;
    bool googleLegacyAppidSupport;
    std::optional<WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs> largeBlob;
}

[Nested] struct WebCore::AuthenticationExtensionsClientOutputs::CredentialPropertiesOutput {
    bool rk;
};

[Nested] struct WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs {
    std::optional<bool> supported;
    RefPtr<JSC::ArrayBuffer> blob;
    std::optional<bool> written;
};

struct WebCore::AuthenticationExtensionsClientOutputs {
    std::optional<bool> appid;
    std::optional<WebCore::AuthenticationExtensionsClientOutputs::CredentialPropertiesOutput> credProps;
    std::optional<WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs> largeBlob;
}

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::Parameters {
    WebCore::PublicKeyCredentialType type;
    int64_t alg;
};

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::AuthenticatorSelectionCriteria {
    std::optional<WebCore::AuthenticatorAttachment> authenticatorAttachment;
    std::optional<WebCore::ResidentKeyRequirement> residentKey;
    bool requireResidentKey;
    WebCore::UserVerificationRequirement userVerification;
};

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::Entity {
    String name;
    String icon;
};

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::RpEntity : WebCore::PublicKeyCredentialCreationOptions::Entity {
    std::optional<String> id;
};

[Nested] struct WebCore::PublicKeyCredentialCreationOptions::UserEntity : WebCore::PublicKeyCredentialCreationOptions::Entity {
    WebCore::BufferSource id;
    String displayName;
};

struct WebCore::PublicKeyCredentialDescriptor {
    WebCore::PublicKeyCredentialType type;
    WebCore::BufferSource id;
    Vector<WebCore::AuthenticatorTransport> transports;
};
#endif // ENABLE(WEB_AUTHN)

#if ENABLE(WEB_AUTHN)
enum class WebCore::AttestationConveyancePreference : uint8_t {
    None,
    Indirect,
    Direct,
    Enterprise
};
#endif

struct WebCore::PublicKeyCredentialCreationOptions {
#if ENABLE(WEB_AUTHN)
    WebCore::PublicKeyCredentialCreationOptions::RpEntity rp;
    WebCore::PublicKeyCredentialCreationOptions::UserEntity user;

    WebCore::BufferSource challenge;
    Vector<WebCore::PublicKeyCredentialCreationOptions::Parameters> pubKeyCredParams;

    std::optional<unsigned> timeout;
    Vector<WebCore::PublicKeyCredentialDescriptor> excludeCredentials;
    std::optional<WebCore::PublicKeyCredentialCreationOptions::AuthenticatorSelectionCriteria> authenticatorSelection;
    WebCore::AttestationConveyancePreference attestation;
    std::optional<WebCore::AuthenticationExtensionsClientInputs> extensions;
#endif // ENABLE(WEB_AUTHN)
};

struct WebCore::PublicKeyCredentialRequestOptions {
#if ENABLE(WEB_AUTHN)
    WebCore::BufferSource challenge;
    std::optional<unsigned> timeout;
    String rpId;
    Vector<WebCore::PublicKeyCredentialDescriptor> allowCredentials;
    WebCore::UserVerificationRequirement userVerification;
    std::optional<WebCore::AuthenticationExtensionsClientInputs> extensions;
#endif // ENABLE(WEB_AUTHN)
};

[CreateUsing=fromRawString] class WebCore::RegistrableDomain {
    String string()
}

struct WebCore::AudioConfiguration {
    String contentType;
    String channels;
    std::optional<uint64_t> bitrate;
    std::optional<uint32_t> samplerate;
    std::optional<bool> spatialRendering;
};

[Nested] enum class WebCore::Cookie::SameSitePolicy : uint8_t {
    None
    Lax
    Strict
};

struct WebCore::Cookie {
    String name;
    String value;
    String domain;
    String path;
    double created;
    std::optional<double> expires;
    bool httpOnly;
    bool secure;
    bool session;
    String comment;
    URL commentURL;
    Vector<uint16_t> ports;
    WebCore::Cookie::SameSitePolicy sameSite;
};

#if ENABLE(VIDEO)
struct WebCore::VideoFrameMetadata {
    double presentationTime;
    double expectedDisplayTime;

    unsigned width;
    unsigned height;
    double mediaTime;

    unsigned presentedFrames;
    std::optional<double> processingDuration;

    std::optional<double> captureTime;
    std::optional<double> receiveTime;
    std::optional<unsigned> rtpTimestamp;
};
#endif // ENABLE(VIDEO)

#if ENABLE(SERVICE_WORKER)
struct WebCore::NavigationPreloadState {
    bool enabled;
    String headerValue;
};
#endif // ENABLE(SERVICE_WORKER)

enum class WebCore::RenderingMode : bool

enum class WebCore::RenderingPurpose : uint8_t {
    Unspecified,
    Canvas,
    DOM,
    LayerBacking,
    Snapshot,
    ShareableSnapshot,
    MediaPainting
};

#if ENABLE(CONTENT_FILTERING_IN_NETWORKING_PROCESS)
[LegacyPopulateFromEmptyConstructor] class WebCore::MockContentFilterSettings {
    bool m_enabled;
    WebCore::MockContentFilterSettings::DecisionPoint m_decisionPoint;
    WebCore::MockContentFilterSettings::Decision m_decision;
    WebCore::MockContentFilterSettings::Decision m_unblockRequestDecision;
    String m_blockedString;
    String m_modifiedRequestURL;
}
[Nested] enum class WebCore::MockContentFilterSettings::DecisionPoint : uint8_t {
    AfterWillSendRequest,
    AfterRedirect,
    AfterResponse,
    AfterAddData,
    AfterFinishedAddingData,
    Never
};
[Nested] enum class WebCore::MockContentFilterSettings::Decision : bool
#endif

enum class WebCore::AutoplayEvent : uint8_t {
    DidPreventMediaFromPlaying,
    DidPlayMediaWithUserGesture,
    DidAutoplayMediaPastThresholdWithoutUserInterference,
    UserDidInterfereWithPlayback
};

enum class WebCore::InputMode : uint8_t {
    Unspecified,
    None,
    Text,
    Telephone,
    Url,
    Email,
    Numeric,
    Decimal,
    Search
};

enum class WebCore::NotificationDirection : uint8_t {
    Auto,
    Ltr,
    Rtl
};

enum class WebCore::IndexedDB::GetAllType : bool

enum class WebCore::WorkerType : bool

enum class WebCore::StoredCredentialsPolicy : uint8_t {
    DoNotUse,
    Use,
    EphemeralStateless
};

enum class WebCore::ContentSniffingPolicy : bool;
enum class WebCore::ContentEncodingSniffingPolicy : bool;
enum class WebCore::ClientCredentialPolicy : bool;
enum class WebCore::ShouldRelaxThirdPartyCookieBlocking : bool;

enum class WebCore::PreflightPolicy : uint8_t {
    Consider,
    Force,
    Prevent
};

enum class WTFLogChannelState : uint8_t {
    Off,
    On,
    OnWithAccumulation
};

enum class WebCore::ScrollSnapStrictness : uint8_t {
    None,
    Proximity,
    Mandatory
};

enum class WebCore::LengthType : uint8_t {
    Auto,
    Relative,
    Percent,
    Fixed,
    Intrinsic,
    MinIntrinsic,
    MinContent,
    MaxContent,
    FillAvailable,
    FitContent,
    Calculated,
    Undefined
};

enum class WebCore::OverscrollBehavior : uint8_t {
    Auto,
    Contain,
    None
};

enum class WebCore::ScrollPinningBehavior : uint8_t {
    DoNotPin,
    PinToTop,
    PinToBottom
};

struct WebCore::ExceptionDetails {
    String message;
    int lineNumber;
    int columnNumber;
    WebCore::ExceptionDetails::Type type;
    String sourceURL;
};

header: <WebCore/RectEdges.h>
[Alias=class RectEdges<float>, AdditionalEncoder=StreamConnectionEncoder, CustomHeader] alias WebCore::FloatBoxExtent {
    float top()
    float right()
    float bottom()
    float left()
};

header: <WebCore/DisplayListItems.h>
[AdditionalEncoder=StreamConnectionEncoder, CustomHeader] class WebCore::DisplayList::SetInlineFillColor {
    uint8_t colorData().resolved().red
    uint8_t colorData().resolved().green
    uint8_t colorData().resolved().blue
    uint8_t colorData().resolved().alpha
}

[AdditionalEncoder=StreamConnectionEncoder, CustomHeader] class WebCore::DisplayList::SetInlineStrokeColor {
    uint8_t colorData().resolved().red
    uint8_t colorData().resolved().green
    uint8_t colorData().resolved().blue
    uint8_t colorData().resolved().alpha
}

header: <WebCore/HTTPHeaderMap.h>
[Nested, CustomHeader] struct WebCore::HTTPHeaderMap::CommonHeader {
    WebCore::HTTPHeaderName key;
    String value;
};

header: <WebCore/HTTPHeaderMap.h>
[Nested, CustomHeader] struct WebCore::HTTPHeaderMap::UncommonHeader {
    String key;
    String value;
};

class WebCore::HTTPHeaderMap {
    Vector<WebCore::HTTPHeaderMap::CommonHeader, 0, CrashOnOverflow, 6> commonHeaders();
    Vector<WebCore::HTTPHeaderMap::UncommonHeader, 0, CrashOnOverflow, 0> uncommonHeaders();
}

struct WebCore::ElementContext {
    WebCore::FloatRect boundingRect;
    WebCore::PageIdentifier webPageIdentifier;
    WebCore::ScriptExecutionContextIdentifier documentIdentifier;
    WebCore::ElementIdentifier elementIdentifier;
};

header: <WebCore/FrameLoaderTypes.h>
[CustomHeader] struct WebCore::SystemPreviewInfo {
    WebCore::ElementContext element;
    WebCore::IntRect previewRect;
    bool isPreview;
};

header: <WebCore/ResourceRequest.h>
[CustomHeader, Nested] class WebCore::ResourceRequest::RequestData {
    URL m_url;
    URL m_firstPartyForCookies;
    double m_timeoutInterval;
    String m_httpMethod;
    WebCore::HTTPHeaderMap m_httpHeaderFields;
    Vector<String> m_responseContentDispositionEncodingFallbackArray;
    WebCore::ResourceRequestCachePolicy m_cachePolicy;
    WebCore::ResourceRequestBase::SameSiteDisposition m_sameSiteDisposition;
    WebCore::ResourceLoadPriority m_priority;
    WebCore::ResourceRequestRequester m_requester;
    [BitField] bool m_allowCookies;
    [BitField] bool m_isTopSite;
    [BitField] bool m_isAppInitiated;
};

#if USE(SOUP)
header: <WebCore/ResourceRequest.h>
[CustomHeader] struct WebCore::ResourceRequestPlatformData {
    WebCore::ResourceRequest::RequestData requestData;
    bool acceptEncoding;
    uint16_t redirectCount;
};
#endif

#if PLATFORM(COCOA) && USE(SYSTEM_PREVIEW)
[CreateUsing=fromResourceRequestData] class WebCore::ResourceRequest {
    std::variant<WebCore::ResourceRequest::RequestData, WebCore::ResourceRequestPlatformData> getRequestDataToSerialize();
    String cachePartition();
    bool hiddenFromInspector();
    std::optional<WebCore::SystemPreviewInfo> systemPreviewInfo();
};
#endif

#if PLATFORM(COCOA) && !USE(SYSTEM_PREVIEW)
[CreateUsing=fromResourceRequestData] class WebCore::ResourceRequest {
    std::variant<WebCore::ResourceRequest::RequestData, WebCore::ResourceRequestPlatformData> getRequestDataToSerialize();
    String cachePartition();
    bool hiddenFromInspector();
};
#endif

#if USE(CURL)
[CreateUsing=fromResourceRequestData] class WebCore::ResourceRequest {
    WebCore::ResourceRequest::RequestData getRequestDataToSerialize();
};
#endif

#if !USE(CURL) && !PLATFORM(COCOA)
header: <WebCore/ResourceRequest.h>
[CreateUsing=fromResourceRequestData] class WebCore::ResourceRequest {
    std::variant<WebCore::ResourceRequest::RequestData, WebCore::ResourceRequestPlatformData> getRequestDataToSerialize();
};
#endif

enum class WebCore::DiagnosticLoggingDomain : uint8_t {
    Media
};

#if !USE(CG)
[Nested] enum class WebCore::PlatformColorSpace::Name : uint8_t {
        SRGB
#if ENABLE(DESTINATION_COLOR_SPACE_LINEAR_SRGB)
        , LinearSRGB
#endif
#if ENABLE(DESTINATION_COLOR_SPACE_DISPLAY_P3)
        , DisplayP3
#endif
};
    
[AdditionalEncoder=StreamConnectionEncoder] class WebCore::PlatformColorSpace {
    WebCore::PlatformColorSpace::Name get();
};
#endif

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::DestinationColorSpace {
        WebCore::PlatformColorSpace serializableColorSpace();
};

struct WebCore::WindowFeatures {
    std::optional<float> x;
    std::optional<float> y;
    std::optional<float> width;
    std::optional<float> height;

    bool menuBarVisible;
    bool statusBarVisible;
    bool toolBarVisible;
    bool locationBarVisible;
    bool scrollbarsVisible;
    bool resizable;

    bool fullscreen;
    bool dialog;
};

[Nested] enum class WebCore::CompositionUnderlineColor : bool

struct WebCore::CompositionUnderline {
    unsigned startOffset;
    unsigned endOffset;
    WebCore::CompositionUnderlineColor compositionUnderlineColor;
    WebCore::Color color;
    bool thick;
};

enum class WebCore::MediaCaptureType : uint8_t {
    MediaCaptureTypeNone,
    MediaCaptureTypeUser,
    MediaCaptureTypeEnvironment
};

header: <WebCore/FileChooser.h>
[CustomHeader] struct WebCore::FileChooserSettings {
    bool allowsDirectories;
    bool allowsMultipleFiles;
    Vector<String> acceptMIMETypes;
    Vector<String> acceptFileExtensions;
    Vector<String> selectedFiles;
#if ENABLE(MEDIA_CAPTURE)
    WebCore::MediaCaptureType mediaCaptureType;
#endif
};

header: <WebCore/TextChecking.h>
[CustomHeader] struct WebCore::GrammarDetail {
    WebCore::CharacterRange range;
    Vector<String> guesses;
    String userDescription;
};

header: <WebCore/TextChecking.h>
[CustomHeader] struct WebCore::TextCheckingResult {
    OptionSet<WebCore::TextCheckingType> type;
    WebCore::CharacterRange range;
    Vector<WebCore::GrammarDetail> details;
    String replacement;
};

header: <WebCore/TextChecking.h>
[CustomHeader] enum class WebCore::TextCheckingProcessType : bool

header: <WebCore/TextChecking.h>
[CustomHeader] class WebCore::TextCheckingRequestData {
    std::optional<WebCore::TextCheckingRequestIdentifier> identifier();
    String text();
    OptionSet<WebCore::TextCheckingType> checkingTypes();
    WebCore::TextCheckingProcessType processType();
};

class WebCore::LayoutRect {
    WebCore::LayoutPoint m_location;
    WebCore::LayoutSize m_size;
};

header: <WebCore/VP9Utilities.h>
[CustomHeader] struct WebCore::ScreenDataOverrides {
    double width;
    double height;
    double scale;
}

struct WebCore::MediaCapabilitiesInfo {
    bool supported;
    bool smooth;
    bool powerEfficient;
}
header: <WebCore/MediaStreamRequest.h>
[Nested, CustomHeader] enum class WebCore::MediaStreamRequest::Type : uint8_t {
    UserMedia,
    DisplayMedia,
    DisplayMediaWithAudio
}
#if ENABLE(MEDIA_STREAM)
struct WebCore::MediaStreamRequest {
    WebCore::MediaStreamRequest::Type type;
    WebCore::MediaConstraints audioConstraints;
    WebCore::MediaConstraints videoConstraints;
    bool isUserGesturePriviledged;
    WebCore::PageIdentifier pageIdentifier;
}
[LegacyPopulateFromEmptyConstructor, CustomHeader] class WebCore::MediaTrackConstraintSetMap {
    std::optional<WebCore::IntConstraint> m_width;
    std::optional<WebCore::IntConstraint> m_height;
    std::optional<WebCore::IntConstraint> m_sampleRate;
    std::optional<WebCore::IntConstraint> m_sampleSize;
    std::optional<WebCore::DoubleConstraint> m_aspectRatio;
    std::optional<WebCore::DoubleConstraint> m_zoom;
    std::optional<WebCore::DoubleConstraint> m_frameRate;
    std::optional<WebCore::DoubleConstraint> m_volume;
    std::optional<WebCore::BooleanConstraint> m_echoCancellation;
    std::optional<WebCore::BooleanConstraint> m_displaySurface;
    std::optional<WebCore::BooleanConstraint> m_logicalSurface;
    std::optional<WebCore::StringConstraint> m_facingMode;
    std::optional<WebCore::StringConstraint> m_deviceId;
    std::optional<WebCore::StringConstraint> m_groupId;
}
#endif

#if ! ENABLE(MEDIA_STREAM)
struct WebCore::MediaStreamRequest {
    WebCore::MediaStreamRequest::Type type;
};
#endif
struct WebCore::MediaCapabilitiesDecodingInfo : WebCore::MediaCapabilitiesInfo {
    WebCore::MediaDecodingConfiguration supportedConfiguration;
}

struct WebCore::MediaCapabilitiesEncodingInfo : WebCore::MediaCapabilitiesInfo {
    WebCore::MediaEncodingConfiguration supportedConfiguration;
}

header: <WebCore/FormData.h>
[CustomHeader] struct WebCore::FormDataElement {
    std::variant<Vector<uint8_t>, WebCore::FormDataElement::EncodedFileData, WebCore::FormDataElement::EncodedBlobData> data
}

[Nested] struct WebCore::FormDataElement::EncodedFileData {
    String filename;
    int64_t fileStart;
    int64_t fileLength;
    std::optional<WallTime> expectedFileModificationTime;
}

[Nested] struct WebCore::FormDataElement::EncodedBlobData {
    URL url;
}

header: <WebCore/NetworkLoadInformation.h>
[CustomHeader] struct WebCore::NetworkTransactionInformation {
    WebCore::NetworkTransactionInformation::Type type;
    WebCore::ResourceRequest request;
    WebCore::ResourceResponse response;
    WebCore::NetworkLoadMetrics metrics;
};

[Nested] enum class WebCore::NetworkTransactionInformation::Type : bool

class WebCore::ContentType {
    String raw()
}

#if ENABLE(DATE_AND_TIME_INPUT_TYPES)
struct WebCore::DateTimeChooserParameters {
    AtomString type;
    WebCore::IntRect anchorRectInRootView;
    AtomString locale;
    String currentValue;
    Vector<String> suggestionValues;
    Vector<String> localizedSuggestionValues;
    Vector<String> suggestionLabels;
    double minimum;
    double maximum;
    double step;
    double stepBase;
    bool required;
    bool isAnchorElementRTL;
    bool useDarkAppearance;
    bool hasSecondField;
    bool hasMillisecondField;
}
#endif

header: <WebCore/ScreenProperties.h>
[CustomHeader] struct WebCore::ScreenData {
    WebCore::FloatRect screenAvailableRect;
    WebCore::FloatRect screenRect;
    WebCore::DestinationColorSpace colorSpace;
    int screenDepth;
    int screenDepthPerComponent;
    bool screenSupportsExtendedColor;
    bool screenHasInvertedColors;
    bool screenSupportsHighDynamicRange;
#if PLATFORM(MAC)
    bool screenIsMonochrome;
    uint32_t displayMask;
    WebCore::PlatformGPUID gpuID;
    WebCore::DynamicRangeMode preferredDynamicRangeMode;
#endif
#if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
    float scaleFactor;
#endif
};

using WebCore::PlatformDisplayID = uint32_t;
struct WebCore::ScreenProperties {
    WebCore::PlatformDisplayID primaryDisplayID;
    HashMap<WebCore::PlatformDisplayID, WebCore::ScreenData> screenDataMap;
};

class WebCore::PlatformTimeRanges {
    Vector<WebCore::PlatformTimeRanges::Range> m_ranges;
}

[Nested] struct WebCore::PlatformTimeRanges::Range {
    MediaTime start;
    MediaTime end;
}

#if ENABLE(VIDEO)
struct WebCore::VideoPlaybackQualityMetrics {
    uint32_t totalVideoFrames;
    uint32_t droppedVideoFrames;
    uint32_t corruptedVideoFrames;
    double totalFrameDelay;
    uint32_t displayCompositedVideoFrames;
}
#endif

#if ENABLE(WEB_AUTHN)
enum class WebCore::AuthenticatorTransport : uint8_t {
    Usb,
    Nfc,
    Ble,
    Internal,
    Cable,
    Hybrid,
    SmartCard
};

enum class WebCore::PublicKeyCredentialType : bool
#endif

#if PLATFORM(IOS_FAMILY)
class WebCore::SelectionGeometry {
    WebCore::FloatQuad quad();
    WebCore::SelectionRenderingBehavior behavior();
    WebCore::TextDirection direction();
    int minX();
    int maxX();
    int maxY();
    int lineNumber();
    bool isLineBreak();
    bool isFirstOnLine();
    bool isLastOnLine();
    bool containsStart();
    bool containsEnd();
    bool isHorizontal();
};
#endif

#if ENABLE(DATALIST_ELEMENT)
header: <WebCore/DataListSuggestionInformation.h>
[CustomHeader] enum class WebCore::DataListSuggestionActivationType : uint8_t {
    ControlClicked,
    IndicatorClicked,
    TextChanged,
};

header: <WebCore/DataListSuggestionInformation.h>
[CustomHeader] struct WebCore::DataListSuggestion {
    String value;
    String label;
};

struct WebCore::DataListSuggestionInformation {
    WebCore::DataListSuggestionActivationType activationType;
    Vector<WebCore::DataListSuggestion> suggestions;
    WebCore::IntRect elementRect;
};
#endif

struct WebCore::ClientOrigin {
    [Validator='!topOrigin->isNull()'] WebCore::SecurityOriginData topOrigin;
    [Validator='!topOrigin->isNull()'] WebCore::SecurityOriginData clientOrigin;
};

enum class WebCore::AlphaPremultiplication : uint8_t {
    Premultiplied,
    Unpremultiplied
};

enum class WebCore::PixelFormat : uint8_t {
    RGBA8,
    BGRX8,
    BGRA8,
    RGB10,
    RGB10A8,
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::PixelBufferFormat {
    WebCore::AlphaPremultiplication alphaFormat;
    WebCore::PixelFormat pixelFormat;
    WebCore::DestinationColorSpace colorSpace;
};

[RefCounted] class WebCore::TextIndicator {
    WebCore::TextIndicatorData data();
};

#if USE(SOUP)
header: "ArgumentCodersGLib.h"
#endif
class WebCore::CertificateInfo {
#if PLATFORM(COCOA)
    RetainPtr<SecTrustRef> trust()
#endif
#if USE(CURL)
    int verificationError()
    Vector<Vector<uint8_t>> certificateChain()
#endif
#if USE(SOUP)
    GRefPtr<GTlsCertificate> certificate()
    GTlsCertificateFlags tlsErrors()
#endif
}

[Nested] struct WebCore::PasteboardCustomData::Entry {
    String type;
    String customData;
    std::variant<String, Ref<WebCore::SharedBuffer>> platformData;
};

class WebCore::PasteboardCustomData {
    String origin();
    Vector<WebCore::PasteboardCustomData::Entry> data();
};

class WebCore::DatabaseDetails {
    String name();
    String displayName();
    uint64_t expectedUsage();
    uint64_t currentUsage();
    std::optional<WallTime> creationTime();
    std::optional<WallTime> modificationTime();
};

[RefCounted] class WebCore::DecomposedGlyphs {
    WebCore::PositionedGlyphs positionedGlyphs();
    WebCore::RenderingResourceIdentifier renderingResourceIdentifier();
}

header: <WebCore/TextIndicator.h>
[CustomHeader] struct WebCore::TextIndicatorData {
    WebCore::FloatRect selectionRectInRootViewCoordinates;
    WebCore::FloatRect textBoundingRectInRootViewCoordinates;
    WebCore::FloatRect contentImageWithoutSelectionRectInRootViewCoordinates;
    Vector<WebCore::FloatRect> textRectsInBoundingRectCoordinates;
    float contentImageScaleFactor;
    RefPtr<WebCore::Image> contentImageWithHighlight;
    RefPtr<WebCore::Image> contentImageWithoutSelection;
    RefPtr<WebCore::Image> contentImage;
    WebCore::Color estimatedBackgroundColor;
    WebCore::TextIndicatorPresentationTransition presentationTransition;
    OptionSet<WebCore::TextIndicatorOption> options;
}

#if ENABLE(MEDIA_STREAM)
struct WebCore::MediaConstraints {
    WebCore::MediaTrackConstraintSetMap mandatoryConstraints;
    Vector<WebCore::MediaTrackConstraintSetMap> advancedConstraints;
    bool isValid;
};
#endif

struct WebCore::PromisedAttachmentInfo {
#if ENABLE(ATTACHMENT_ELEMENT)
    String attachmentIdentifier;
#endif
    Vector<String> additionalTypes;
    Vector<RefPtr<WebCore::SharedBuffer>> additionalData;
}

header: <WebCore/SearchPopupMenu.h>
[CustomHeader] struct WebCore::RecentSearch {
    String string;
    WallTime time;
};

[Nested] enum class WebCore::EventTrackingRegions::EventType : uint8_t {
    Mousedown,
    Mousemove,
    Mouseup,
    Mousewheel,
    Pointerdown,
    Pointerenter,
    Pointerleave,
    Pointermove,
    Pointerout,
    Pointerover,
    Pointerup,
    Touchend,
    Touchforcechange,
    Touchmove,
    Touchstart,
    Wheel
};

struct WebCore::EventTrackingRegions {
    WebCore::Region asynchronousDispatchRegion;
    HashMap<WebCore::EventTrackingRegions::EventType, WebCore::Region, WTF::IntHash<WebCore::EventTrackingRegions::EventType>, WTF::StrongEnumHashTraits<WebCore::EventTrackingRegions::EventType>> eventSpecificSynchronousDispatchRegions;
};

enum class WebCore::HasInsecureContent : bool

struct WebCore::TextManipulationItem {
    WebCore::FrameIdentifier frameID;
    bool isSubframe;
    bool isCrossSiteSubframe;
    WebCore::TextManipulationItemIdentifier identifier;
    Vector<WebCore::TextManipulationToken> tokens;
}

header: <WebCore/TextManipulationToken.h>
[CustomHeader] struct WebCore::TextManipulationToken {
    WebCore::TextManipulationTokenIdentifier identifier;
    String content;
    std::optional<WebCore::TextManipulationTokenInfo> info;
    bool isExcluded;
};

header: <WebCore/TextManipulationToken.h>
[CustomHeader] struct WebCore::TextManipulationTokenInfo {
    String tagName;
    String roleAttribute;
    URL documentURL;
    bool isVisible;
};

struct WebCore::VelocityData {
    float horizontalVelocity;
    float verticalVelocity;
    float scaleChangeRate;
    MonotonicTime lastUpdateTime;
};

header: <WebCore/PluginData.h>
[CustomHeader] struct WebCore::MimeClassInfo {
    AtomString type;
    String desc;
    Vector<String> extensions;
};

class WebCore::AuthenticationChallenge {
    WebCore::ProtectionSpace protectionSpace();
    WebCore::Credential proposedCredential();
    unsigned previousFailureCount();
    WebCore::ResourceResponse failureResponse();
    WebCore::ResourceError error();
    
#if USE(SOUP)
    uint32_t tlsPasswordFlags();
#endif
};

#if ENABLE(DRAG_SUPPORT)
class WebCore::DragData {
#if PLATFORM(COCOA)
    String pasteboardName();
#endif
    WebCore::IntPoint clientPosition();
    WebCore::IntPoint globalPosition();
#if PLATFORM(COCOA)
    Vector<String> fileNames();
#endif
    OptionSet<WebCore::DragOperation> draggingSourceOperationMask();
    OptionSet<WebCore::DragApplicationFlags> flags();
    OptionSet<WebCore::DragDestinationAction> dragDestinationActionMask();
    std::optional<WebCore::PageIdentifier> pageID();
};
#endif

struct WebCore::DictationAlternative {
    WebCore::CharacterRange range;
    WebCore::DictationContext context;
};

class WebCore::UserStyleSheet {
    String source();
    URL url();
    Vector<String> allowlist();
    Vector<String> blocklist();
    WebCore::UserContentInjectedFrames injectedFrames();
    WebCore::UserStyleLevel level();
    std::optional<WebCore::PageIdentifier> pageID();
};

header: <WebCore/ScrollTypes.h>
[CustomHeader] enum class WebCore::ScrollElasticity : uint8_t {
    Automatic,
    None,
    Allowed
};

header: <WebCore/ScrollTypes.h>
[CustomHeader] enum class WebCore::ScrollbarMode : uint8_t {
    Auto,
    AlwaysOff,
    AlwaysOn
};

header: <WebCore/ScrollTypes.h>
[CustomHeader] enum class WebCore::NativeScrollbarVisibility : uint8_t {
    Visible,
    HiddenByStyle,
    ReplacedByCustomScrollbar
};

header: <WebCore/ScrollingCoordinatorTypes.h>
[CustomHeader] struct WebCore::ScrollableAreaParameters {
    WebCore::ScrollElasticity horizontalScrollElasticity;
    WebCore::ScrollElasticity verticalScrollElasticity;
    WebCore::ScrollbarMode horizontalScrollbarMode;
    WebCore::ScrollbarMode verticalScrollbarMode;
    WebCore::OverscrollBehavior horizontalOverscrollBehavior;
    WebCore::OverscrollBehavior verticalOverscrollBehavior;
    bool allowsHorizontalScrolling;
    bool allowsVerticalScrolling;
    WebCore::NativeScrollbarVisibility horizontalNativeScrollbarVisibility;
    WebCore::NativeScrollbarVisibility verticalNativeScrollbarVisibility;
    bool useDarkAppearanceForScrollbars;
};

header: <WebCore/ScrollingCoordinatorTypes.h>
[CustomHeader] struct WebCore::RequestedKeyboardScrollData {
    WebCore::KeyboardScrollAction action;
    std::optional<WebCore::KeyboardScroll> keyboardScroll;
};

header: <WebCore/ScrollingCoordinatorTypes.h>
[OptionSet] enum class WebCore::WheelEventProcessingSteps : uint8_t {
    AsyncScrolling,
    SynchronousScrolling,
    NonBlockingDOMEventDispatch,
    BlockingDOMEventDispatch,
};

header: <WebCore/ScrollingConstraints.h>
[CustomHeader] class WebCore::AbsolutePositionConstraints {
    WebCore::FloatSize alignmentOffset();
    WebCore::FloatPoint layerPositionAtLastLayout();
};

header: <WebCore/KeyboardScroll.h>
[CustomHeader] struct WebCore::KeyboardScroll {
    WebCore::FloatSize offset;
    WebCore::FloatSize maximumVelocity;
    WebCore::FloatSize force;
    WebCore::ScrollGranularity granularity;
    WebCore::ScrollDirection direction;
};

[RefCounted] class WebCore::NotificationResources {
    RefPtr<WebCore::Image> icon();
};

[RefCounted] class WebCore::IdentityTransformOperation {
}

[RefCounted] class WebCore::TranslateTransformOperation {
    WebCore::Length x();
    WebCore::Length y();
    WebCore::Length z();
    WebCore::TransformOperation::Type type();
}

[RefCounted] class WebCore::RotateTransformOperation {
    double x();
    double y();
    double z();
    double angle();
    WebCore::TransformOperation::Type type();
}

[RefCounted] class WebCore::ScaleTransformOperation {
    double x();
    double y();
    double z();
    WebCore::TransformOperation::Type type();
}

[RefCounted] class WebCore::SkewTransformOperation {
    double angleX();
    double angleY();
    WebCore::TransformOperation::Type type();
}

[RefCounted] class WebCore::PerspectiveTransformOperation {
    std::optional<WebCore::Length> perspective();
}

[RefCounted] class WebCore::MatrixTransformOperation {
    WebCore::TransformationMatrix matrix();
}

[RefCounted] class WebCore::Matrix3DTransformOperation {
    WebCore::TransformationMatrix matrix();
}

class WebCore::TransformOperations {
    Vector<RefPtr<WebCore::TransformOperation>> operations();
}

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::Gradient::LinearData {
    WebCore::FloatPoint point0;
    WebCore::FloatPoint point1;
};

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::Gradient::RadialData {
    WebCore::FloatPoint point0;
    WebCore::FloatPoint point1;
    float startRadius;
    float endRadius;
    float aspectRatio;
};

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::Gradient::ConicData {
    WebCore::FloatPoint point0;
    float angleRadians;
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::Gradient {
    std::variant<WebCore::Gradient::LinearData, WebCore::Gradient::RadialData, WebCore::Gradient::ConicData> data();
    WebCore::ColorInterpolationMethod colorInterpolationMethod();
    WebCore::GradientSpreadMethod spreadMethod();
    WebCore::GradientColorStops stops();
}

[Nested, AdditionalEncoder=StreamConnectionEncoder] class WebCore::SourceBrush::Brush::LogicalGradient {
    Ref<WebCore::Gradient> gradient;
    WebCore::AffineTransform spaceTransform;
}

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::Pattern::Parameters {
    bool repeatX;
    bool repeatY;
    WebCore::AffineTransform patternSpaceTransform;
}

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::Pattern {
    WebCore::SourceImage tileImage();
    WebCore::Pattern::Parameters parameters();
}

[Nested, AdditionalEncoder=StreamConnectionEncoder] class WebCore::SourceBrush::Brush {
    std::variant<WebCore::SourceBrush::Brush::LogicalGradient, Ref<WebCore::Pattern>> brush;
}

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::SourceBrush {
    WebCore::Color color();
    std::optional<WebCore::SourceBrush::Brush> brush();
}

#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
header: <WebCore/GraphicsContextGLAttributes.h>
[CustomHeader] enum class WebCore::GraphicsContextGLPowerPreference : uint8_t {
    Default,
    LowPower,
    HighPerformance
};

header: <WebCore/GraphicsContextGLAttributes.h>
[CustomHeader] enum class WebCore::GraphicsContextGLWebGLVersion : uint8_t {
    WebGL1,
    WebGL2
};

struct WebCore::GraphicsContextGLAttributes {
    bool alpha;
    bool depth;
    bool stencil;
    bool antialias;
    bool premultipliedAlpha;
    bool preserveDrawingBuffer;
    bool failIfMajorPerformanceCaveat;
    WebCore::GraphicsContextGLPowerPreference powerPreference;
    bool shareResources;
    bool noExtensions;
    float devicePixelRatio;
    WebCore::GraphicsContextGLPowerPreference initialPowerPreference;
    WebCore::GraphicsContextGLWebGLVersion webGLVersion;
    bool forceRequestForHighPerformanceGPU;
#if PLATFORM(MAC) || PLATFORM(MACCATALYST)
    uint64_t windowGPUID;
#endif
#if PLATFORM(COCOA)
    bool useMetal;
#endif
#if ENABLE(WEBXR)
    bool xrCompatible;
#endif
    bool failPlatformContextCreationForTesting;
};
#endif // ENABLE(GPU_PROCESS) && ENABLE(WEBGL)

[RefCounted] class WebCore::TimingFunction subclasses {
  WebCore::LinearTimingFunction,
  WebCore::CubicBezierTimingFunction,
  WebCore::StepsTimingFunction,
  WebCore::SpringTimingFunction
}

[RefCounted] class WebCore::TransformOperation subclasses {
    WebCore::TranslateTransformOperation
    WebCore::ScaleTransformOperation
    WebCore::RotateTransformOperation
    WebCore::SkewTransformOperation
    WebCore::MatrixTransformOperation
    WebCore::Matrix3DTransformOperation
    WebCore::PerspectiveTransformOperation
    WebCore::IdentityTransformOperation
}

struct WebCore::LengthSize {
    WebCore::Length width;
    WebCore::Length height;
}

class WebCore::SVGPathByteStream {
    Vector<unsigned char> data();
}

header: <WebCore/BasicShapes.h>
[Nested, CustomHeader] enum class WebCore::BasicShapeCenterCoordinate::Direction : bool

[CustomHeader] class WebCore::BasicShapeCenterCoordinate {
    WebCore::BasicShapeCenterCoordinate::Direction direction();
    WebCore::Length length();
}

[Nested, CustomHeader] enum class WebCore::BasicShapeRadius::Type : uint8_t {
    Value,
    ClosestSide,
    FarthestSide
};

[CustomHeader] class WebCore::BasicShapeRadius {
    WebCore::Length value();
    WebCore::BasicShapeRadius::Type type();
}

[RefCounted, CustomHeader] class WebCore::BasicShapeCircle {
    WebCore::BasicShapeCenterCoordinate centerX();
    WebCore::BasicShapeCenterCoordinate centerY();
    WebCore::BasicShapeRadius radius();
}

[RefCounted, CustomHeader] class WebCore::BasicShapeEllipse {
    WebCore::BasicShapeCenterCoordinate centerX();
    WebCore::BasicShapeCenterCoordinate centerY();
    WebCore::BasicShapeRadius radiusX();
    WebCore::BasicShapeRadius radiusY();
}

[RefCounted, CustomHeader] class WebCore::BasicShapePolygon {
    WebCore::WindRule windRule();
    Vector<WebCore::Length> values();
}

[RefCounted, CustomHeader] class WebCore::BasicShapePath {
    std::unique_ptr<WebCore::SVGPathByteStream> byteStream();
    float zoom();
    WebCore::WindRule windRule();
}

[RefCounted, CustomHeader] class WebCore::BasicShapeInset {
    WebCore::Length right();
    WebCore::Length top();
    WebCore::Length bottom();
    WebCore::Length left();
    WebCore::LengthSize topLeftRadius();
    WebCore::LengthSize topRightRadius();
    WebCore::LengthSize bottomRightRadius();
    WebCore::LengthSize bottomLeftRadius();
}

[RefCounted, CustomHeader] class WebCore::BasicShape subclasses {
    WebCore::BasicShapeCircle
    WebCore::BasicShapeEllipse
    WebCore::BasicShapePolygon
    WebCore::BasicShapePath
    WebCore::BasicShapeInset
}

header: <WebCore/RenderStyleConstants.h>
[CustomHeader] enum class WebCore::CSSBoxType : uint8_t {
    BoxMissing,
    MarginBox,
    BorderBox,
    PaddingBox,
    ContentBox,
    FillBox,
    StrokeBox,
    ViewBox
};

header: <WebCore/PathOperation.h>
[RefCounted, CustomHeader] class WebCore::ReferencePathOperation {
    std::optional<WebCore::Path> path();
}

[RefCounted, CustomHeader] class WebCore::ShapePathOperation {
    Ref<WebCore::BasicShape> shape();
    WebCore::CSSBoxType referenceBox();
}

[RefCounted, CustomHeader] class WebCore::BoxPathOperation {
    WebCore::Path path();
    WebCore::CSSBoxType referenceBox();
}

[Nested, CustomHeader] enum class WebCore::RayPathOperation::Size : uint8_t {
    ClosestSide,
    ClosestCorner,
    FarthestSide,
    FarthestCorner,
    Sides
};

[RefCounted, CustomHeader] class WebCore::RayPathOperation {
    float angle();
    WebCore::RayPathOperation::Size size();
    bool isContaining();
    WebCore::FloatRect containingBlockBoundingRect();
    WebCore::FloatPoint position();
}

[RefCounted] class WebCore::PathOperation subclasses {
    WebCore::ReferencePathOperation,
    WebCore::ShapePathOperation,
    WebCore::BoxPathOperation,
    WebCore::RayPathOperation
}

#if PLATFORM(IOS_FAMILY)
enum class WebCore::SelectionRenderingBehavior : bool
#endif

#if ENABLE(WEB_AUTHN)
enum class WebCore::UserVerificationRequirement : uint8_t {
    Required,
    Preferred,
    Discouraged
};

enum class WebCore::ResidentKeyRequirement : uint8_t {
    Required,
    Preferred,
    Discouraged
};

enum class WebCore::AuthenticatorAttachment : uint8_t {
    Platform,
    CrossPlatform
};

#endif // ENABLE(WEB_AUTHN)

#if ENABLE(ENCRYPTED_MEDIA)
struct WebCore::CDMKeySystemConfiguration {
    String label;
    Vector<AtomString> initDataTypes;
    Vector<WebCore::CDMMediaCapability> audioCapabilities;
    Vector<WebCore::CDMMediaCapability> videoCapabilities;
    WebCore::CDMRequirement distinctiveIdentifier;
    WebCore::CDMRequirement persistentState;
    Vector<WebCore::CDMSessionType> sessionTypes;
}
#endif // ENABLE(ENCRYPTED_MEDIA)

struct WebCore::MediaConfiguration {
    std::optional<WebCore::VideoConfiguration> video;
    std::optional<WebCore::AudioConfiguration> audio;

    std::optional<Vector<String>> allowedMediaContainerTypes;
    std::optional<Vector<String>> allowedMediaCodecTypes;
};

struct WebCore::MediaEncodingConfiguration : WebCore::MediaConfiguration {
    WebCore::MediaEncodingType type;
};

struct WebCore::MediaDecodingConfiguration : WebCore::MediaConfiguration {
    WebCore::MediaDecodingType type;
    bool canExposeVP9;
};
    
enum class WebCore::ResourceRequestCachePolicy : uint8_t {
    UseProtocolCachePolicy,
    ReloadIgnoringCacheData,
    ReturnCacheDataElseLoad,
    ReturnCacheDataDontLoad,
    DoNotUseAnyCache,
    RefreshAnyCacheData,
};

[Nested] enum class WebCore::ResourceRequestBase::SameSiteDisposition : uint8_t {
    Unspecified,
    SameSite,
    CrossSite
};

[Nested] enum class WebCore::ResourceRequestRequester : uint8_t {
    Unspecified,
    Main,
    XHR,
    Fetch,
    Media,
    Model,
    ImportScripts,
    Ping,
    Beacon,
    EventSource
};

enum class WebCore::ResourceLoadPriority : uint8_t {
    VeryLow,
    Low,
    Medium,
    High,
    VeryHigh,
};

[Nested] enum class WebCore::ResourceResponseBase::Type : uint8_t {
    Basic,
    Cors,
    Default,
    Error,
    Opaque,
    Opaqueredirect
};

[Nested] enum class WebCore::ResourceResponseBase::Tainting : uint8_t {
    Basic,
    Cors,
    Opaque,
    Opaqueredirect
};
    
[Nested] enum class WebCore::ResourceResponseBase::Source : uint8_t {
    Unknown,
    Network,
    DiskCache,
    DiskCacheAfterValidation,
    MemoryCache,
    MemoryCacheAfterValidation,
    ServiceWorker,
    ApplicationCache,
    DOMCache,
    InspectorOverride
};

[Nested] struct WebCore::ResourceResponseBase::ResponseData {
    URL m_url;
    AtomString m_mimeType;
    long long m_expectedContentLength;
    AtomString m_textEncodingName;
    AtomString m_httpStatusText;
    AtomString m_httpVersion;
    WebCore::HTTPHeaderMap m_httpHeaderFields;
    Box<WebCore::NetworkLoadMetrics> m_networkLoadMetrics;

    short m_httpStatusCode;
    std::optional<WebCore::CertificateInfo> m_certificateInfo;
    
    WebCore::ResourceResponseBase::Source m_source;
    WebCore::ResourceResponseBase::Type m_type;
    WebCore::ResourceResponseBase::Tainting m_tainting;

    bool m_isRedirected;
    WebCore::UsedLegacyTLS m_usedLegacyTLS;
    WebCore::WasPrivateRelayed m_wasPrivateRelayed;
    bool m_isRangeRequested;
}

class WebCore::ResourceResponseBase {
    std::optional<WebCore::ResourceResponseBase::ResponseData> getResponseData()
}

class WebCore::ResourceResponse : WebCore::ResourceResponseBase {
}

enum class WebCore::ReferrerPolicy : uint8_t {
    EmptyString,
    NoReferrer,
    NoReferrerWhenDowngrade,
    SameOrigin,
    Origin,
    StrictOrigin,
    OriginWhenCrossOrigin,
    StrictOriginWhenCrossOrigin,
    UnsafeUrl,
};

enum class WebCore::FetchOptionsDestination : uint8_t {
    EmptyString,
    Audio,
    Audioworklet,
    Document,
    Embed,
    Font,
    Image,
    Iframe,
    Manifest,
    Model,
    Object,
    Paintworklet,
    Report,
    Script,
    Serviceworker,
    Sharedworker,
    Style,
    Track,
    Video,
    Worker,
    Xslt
};

enum class WebCore::FetchOptionsMode : uint8_t {
    Navigate,
    SameOrigin,
    NoCors,
    Cors
};

enum class WebCore::FetchOptionsCredentials : uint8_t {
    Omit,
    SameOrigin,
    Include
};

enum class WebCore::FetchOptionsCache : uint8_t {
    Default,
    NoStore,
    Reload,
    NoCache,
    ForceCache,
    OnlyIfCached
};

enum class WebCore::FetchOptionsRedirect : uint8_t {
    Follow,
    Error,
    Manual
};

struct WebCore::FetchOptions {
    WebCore::FetchOptionsDestination destination;
    WebCore::FetchOptionsMode mode;
    WebCore::FetchOptionsCredentials credentials;
    WebCore::FetchOptionsCache cache;
    WebCore::FetchOptionsRedirect redirect;
    WebCore::ReferrerPolicy referrerPolicy;
    bool keepAlive;
    String integrity;
    Markable<UUID> clientIdentifier;
    Markable<UUID> resultingClientIdentifier;
}

enum class WebCore::FetchHeadersGuard : uint8_t {
    None,
    Immutable,
    Request,
    RequestNoCors,
    Response
};

[Nested OptionSet] enum class WebCore::ControlStyle::State : unsigned {
    Hovered,
    Pressed,
    Focused,
    Enabled,
    Checked,
    Default,
    WindowActive,
    Indeterminate,
    SpinUp,
    Presenting,
    FormSemanticContext,
    DarkAppearance,
    RightToLeft,
    LargeControls,
    ReadOnly,
    ListButton,
    ListButtonPressed,
    VerticalWritingMode
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ControlStyle {
    OptionSet<WebCore::ControlStyle::State> states;
    unsigned fontSize;
    float zoomFactor;
    WebCore::Color accentColor;
    WebCore::Color textColor;
    WebCore::FloatBoxExtent borderWidth;
};

enum class WebCore::StyleAppearance : uint8_t {
    None,
    Auto,
    Checkbox,
    Radio,
    PushButton,
    SquareButton,
    Button,
    DefaultButton,
    Listbox,
    Menulist,
    MenulistButton,
    Meter,
    ProgressBar,
    SliderHorizontal,
    SliderVertical,
    SearchField,
#if ENABLE(APPLE_PAY)
    ApplePayButton,
#endif
#if ENABLE(ATTACHMENT_ELEMENT)
    Attachment,
    BorderlessAttachment,
#endif
    TextArea,
    TextField,
    CapsLockIndicator,
#if ENABLE(INPUT_TYPE_COLOR)
    ColorWell,
#endif
#if ENABLE(SERVICE_CONTROLS)
    ImageControlsButton,
#endif
    InnerSpinButton,
#if ENABLE(DATALIST_ELEMENT)
    ListButton,
#endif
    SearchFieldDecoration,
    SearchFieldResultsDecoration,
    SearchFieldResultsButton,
    SearchFieldCancelButton,
    SliderThumbHorizontal,
    SliderThumbVertical
};

#if ENABLE(APPLE_PAY)
header: <WebCore/ApplePayButtonPart.h>
enum class WebCore::ApplePayButtonType : uint8_t {
    Plain,
    Buy,
    SetUp,
    Donate,
    CheckOut,
    Book,
    Subscribe,
#if ENABLE(APPLE_PAY_NEW_BUTTON_TYPES)
    Reload,
    AddMoney,
    TopUp,
    Order,
    Rent,
    Support,
    Contribute,
    Tip,
#endif
}

enum class WebCore::ApplePayButtonStyle : uint8_t {
    White,
    WhiteOutline,
    Black,
}

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::ApplePayButtonPart {
    WebCore::ApplePayButtonType buttonType();
    WebCore::ApplePayButtonStyle buttonStyle();
    String locale();
};
#endif

[Nested] enum class WebCore::MeterPart::GaugeRegion : uint8_t {
    Optimum,
    Suboptimal,
    EvenLessGood
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::MeterPart {
    WebCore::MeterPart::GaugeRegion gaugeRegion();
    double value();
    double minimum();
    double maximum();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::ProgressBarPart {
    double position();
    Seconds animationStartTime();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::SliderTrackPart {
    WebCore::StyleAppearance type();
    WebCore::IntSize thumbSize();
    WebCore::IntRect trackBounds();
    Vector<double> tickRatios();
}

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DistantLightSource {
    float azimuth();
    float elevation();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::PointLightSource {
    WebCore::FloatPoint3D position();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::SpotLightSource {
    WebCore::FloatPoint3D position();
    WebCore::FloatPoint3D direction();
    float specularExponent();
    float limitingConeAngle();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEBlend {
    WebCore::BlendMode blendMode();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEColorMatrix {
    WebCore::ColorMatrixType type();
    Vector<float> values();
};

header: <WebCore/FEComponentTransfer.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ComponentTransferFunction {
    WebCore::ComponentTransferType type;
    float slope;
    float intercept;
    float amplitude;
    float exponent;
    float offset;
    Vector<float> tableValues;
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEComponentTransfer {
    WebCore::ComponentTransferFunction redFunction();
    WebCore::ComponentTransferFunction greenFunction();
    WebCore::ComponentTransferFunction blueFunction();
    WebCore::ComponentTransferFunction alphaFunction();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEComposite {
    WebCore::CompositeOperationType operation();
    float k1();
    float k2();
    float k3();
    float k4();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEConvolveMatrix {
    WebCore::IntSize kernelSize();
    float divisor();
    float bias();
    WebCore::IntPoint targetOffset();
    WebCore::EdgeModeType edgeMode();
    WebCore::FloatPoint kernelUnitLength();
    bool preserveAlpha();
    Vector<float> kernel();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEDiffuseLighting {
    WebCore::Color lightingColor();
    float surfaceScale();
    float diffuseConstant();
    float kernelUnitLengthX();
    float kernelUnitLengthY();
    Ref<WebCore::LightSource> lightSource();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEDisplacementMap {
    WebCore::ChannelSelectorType xChannelSelector();
    WebCore::ChannelSelectorType yChannelSelector();
    float scale();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEDropShadow {
    float stdDeviationX();
    float stdDeviationY();
    float dx();
    float dy();
    WebCore::Color shadowColor();
    float shadowOpacity()
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEFlood {
    WebCore::Color floodColor();
    float floodOpacity();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEGaussianBlur {
    float stdDeviationX();
    float stdDeviationY();
    WebCore::EdgeModeType edgeMode();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEImage {
    WebCore::SourceImage sourceImage();
    WebCore::FloatRect sourceImageRect();
    WebCore::SVGPreserveAspectRatioValue preserveAspectRatio();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEMerge {
    unsigned numberOfEffectInputs();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEMorphology {
    WebCore::MorphologyOperatorType morphologyOperator();
    float radiusX();
    float radiusY();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FEOffset {
    float dx();
    float dy();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FESpecularLighting {
    WebCore::Color lightingColor();
    float surfaceScale();
    float specularConstant();
    float specularExponent();
    float kernelUnitLengthX();
    float kernelUnitLengthY();
    Ref<WebCore::LightSource> lightSource();
};

[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::FETurbulence {
    WebCore::TurbulenceType type();
    float baseFrequencyX();
    float baseFrequencyY();
    int numOctaves();
    float seed();
    bool stitchTiles();
};

enum class WebCore::HasInsecureContent : bool

header: <WebCore/ModalContainerTypes.h>
[CustomHeader] enum class WebCore::ModalContainerDecision : uint8_t {
    Show,
    HideAndIgnore,
    HideAndAllow,
    HideAndDisallow,
};

[OptionSet] enum class WebCore::AutoplayEventFlags : uint8_t {
    HasAudio,
    PlaybackWasPrevented,
    MediaIsMainContent,
};

header: <WebCore/FocusDirection.h>
enum class WebCore::FocusDirection : uint8_t {
    None,
    Forward,
    Backward,
    Up,
    Down,
    Left,
    Right
};

#if ENABLE(GAMEPAD)
struct WebCore::GamepadEffectParameters {
    double duration;
    double startDelay;
    double strongMagnitude;
    double weakMagnitude;
    double leftTrigger;
    double rightTrigger;
};

header: <WebCore/GamepadHapticEffectType.h>
enum class WebCore::GamepadHapticEffectType : uint8_t {
    DualRumble,
    TriggerRumble
};
#endif

header: <WebCore/StorageEstimate.h>
struct WebCore::StorageEstimate {
    uint64_t usage
    uint64_t quota
};

header: <WebCore/DOMPasteAccess.h>
enum class WebCore::DOMPasteAccessCategory : uint8_t {
    General,
    Fonts
};

enum class WebCore::DOMPasteAccessPolicy : uint8_t {
    NotRequestedYet,
    Denied,
    Granted
};

enum class WebCore::DOMPasteAccessResponse : uint8_t {
    DeniedForGesture,
    GrantedForCommand,
    GrantedForGesture
};

header: <WebCore/DeviceOrientationOrMotionPermissionState.h>
enum class WebCore::DeviceOrientationOrMotionPermissionState : uint8_t { 
    Granted,
    Denied,
    Prompt 
};

header: <WebCore/ExceptionDetails.h>
[Nested] enum class WebCore::ExceptionDetails::Type : uint8_t {
    Script,
    InvalidTargetFrame,
    AppBoundDomain
};

header: <WebCore/SecurityPolicyViolationEventDisposition.h>
enum class WebCore::SecurityPolicyViolationEventDisposition : bool

header: <WebCore/FontAttributeChanges.h>
enum class WebCore::VerticalAlignChange : uint8_t { 
    Superscript,
    Baseline,
    Subscript 
};

header: <WebCore/TextGranularity.h>
enum class WebCore::TextGranularity : uint8_t {
    CharacterGranularity,
    WordGranularity,
    SentenceGranularity,
    LineGranularity,
    ParagraphGranularity,
    DocumentGranularity,
    SentenceBoundary,
    LineBoundary,
    ParagraphBoundary,
    DocumentBoundary
};

struct WebCore::ListStyleType {
    WebCore::ListStyleType::Type type;
    AtomString identifier;
};

header: <WebCore/FontAttributes.h>
[CustomHeader] struct WebCore::TextList {
    WebCore::ListStyleType styleType;
    int startingItemNumber
    bool ordered
};

[Nested] enum class WebCore::FontAttributes::SubscriptOrSuperscript : uint8_t {
    None,
    Subscript,
    Superscript
};

[Nested] enum class WebCore::FontAttributes::HorizontalAlignment : uint8_t {
    Left,
    Center,
    Right,
    Justify,
    Natural
};

[CustomHeader] struct WebCore::FontAttributes {
    RefPtr<WebCore::Font> font
    WebCore::Color backgroundColor
    WebCore::Color foregroundColor
    WebCore::FontShadow fontShadow
    WebCore::FontAttributes::SubscriptOrSuperscript subscriptOrSuperscript
    WebCore::FontAttributes::HorizontalAlignment horizontalAlignment
    Vector<WebCore::TextList> textLists
    bool hasUnderline
    bool hasStrikeThrough
    bool hasMultipleFonts
};

header: <WebCore/WritingDirection.h>
enum class WebCore::WritingDirection : uint8_t {
    Natural,
    LeftToRight,
    RightToLeft
};

header: <WebCore/VisibleSelection.h>
enum class WebCore::SelectionDirection : uint8_t {
    Forward,
    Backward,
    Right,
    Left
};

#if ENABLE(DATA_DETECTION)
header: <WebCore/DataDetectorType.h>
[OptionSet] enum class WebCore::DataDetectorType : uint8_t {
    PhoneNumber,
    Link,
    Address,
    CalendarEvent,
    TrackingNumber,
    FlightNumber,
    LookupSuggestion,
};
#endif

header: <WebCore/AutocapitalizeTypes.h>
enum class WebCore::AutocapitalizeType : uint8_t {
    Default,
    None,
    Words,
    Sentences,
    AllCharacters
};

enum class WebCore::CrossOriginEmbedderPolicyValue : bool

struct WebCore::CrossOriginEmbedderPolicy {
    WebCore::CrossOriginEmbedderPolicyValue value;
    WebCore::CrossOriginEmbedderPolicyValue reportOnlyValue;
    String reportingEndpoint;
    String reportOnlyReportingEndpoint;
};

struct WebCore::SameSiteInfo {
    bool isSameSite;
    bool isTopSite;
    bool isSafeHTTPMethod;
};

[RefCounted] class WebCore::SecurityOrigin {
    WebCore::SecurityOriginData m_data;
    String m_domain;
    String m_filePath;
    bool m_universalAccess;
    bool m_domainWasSetInDOM;
    bool m_canLoadLocalResources;
    bool m_enforcesFilePathSeparation;
    bool m_needsStorageAccessFromFileURLsQuirk;
    std::optional<bool> m_isPotentiallyTrustworthy;
    bool m_isLocal;
}

enum class WebCore::IncludeSecureCookies : bool;

struct WebCore::CookieRequestHeaderFieldProxy {
    URL firstParty;
    WebCore::SameSiteInfo sameSiteInfo;
    URL url;
    std::optional<WebCore::FrameIdentifier> frameID;
    std::optional<WebCore::PageIdentifier> pageID;
    WebCore::IncludeSecureCookies includeSecureCookies;
};

[RefCounted, CustomMemberLayout] class WebCore::FormData {
    bool m_alwaysStream;
    Vector<char> m_boundary;
    Vector<WebCore::FormDataElement> m_elements;
    int64_t m_identifier;
};

#if ENABLE(ASYNC_SCROLLING)
header: <WebCore/ScrollingStateNode.h>
[OptionSet] enum class WebCore::ScrollingStateNodeProperty : uint64_t {
    Layer
    ChildNodes
    ScrollableAreaSize
    TotalContentsSize
    ReachableContentsSize
    ScrollPosition
    ScrollOrigin
    ScrollableAreaParams
    ReasonsForSynchronousScrolling
    RequestedScrollPosition
    SnapOffsetsInfo
    CurrentHorizontalSnapOffsetIndex
    CurrentVerticalSnapOffsetIndex
    IsMonitoringWheelEvents
    ScrollContainerLayer
    ScrolledContentsLayer
    HorizontalScrollbarLayer
    VerticalScrollbarLayer
    PainterForScrollbar
    FrameScaleFactor
    EventTrackingRegion
    RootContentsLayer
    CounterScrollingLayer
    InsetClipLayer
    ContentShadowLayer
    HeaderHeight
    FooterHeight
    HeaderLayer
    FooterLayer
    BehaviorForFixedElements
    TopContentInset
    FixedElementsLayoutRelativeToFrame
    VisualViewportIsSmallerThanLayoutViewport
    AsyncFrameOrOverflowScrollingEnabled
    WheelEventGesturesBecomeNonBlocking
    ScrollingPerformanceTestingEnabled
    LayoutViewport
    MinLayoutViewportOrigin
    MaxLayoutViewportOrigin
    OverrideVisualViewportSize
    RelatedOverflowScrollingNodes
    LayoutConstraintData
    ViewportConstraints
    OverflowScrollingNode
    KeyboardScrollData
};
#endif

[CustomHeader] struct WebCore::RequestedScrollData {
    WebCore::ScrollRequestType requestType;
    WebCore::FloatPoint scrollPosition;
    WebCore::ScrollType scrollType;
    WebCore::ScrollClamping clamping;
    WebCore::ScrollIsAnimated animated;
}

[Alias=struct ScrollSnapOffsetsInfo<float,WebCore::FloatRect>, CustomHeader] alias WebCore::FloatScrollSnapOffsetsInfo {
    WebCore::ScrollSnapStrictness strictness;
    Vector<WebCore::FloatSnapOffset> horizontalSnapOffsets;
    Vector<WebCore::FloatSnapOffset> verticalSnapOffsets;
    Vector<WebCore::FloatRect> snapAreas;
    Vector<WebCore::ElementIdentifier> snapAreasIDs;
}

[Alias=struct SnapOffset<float>, CustomHeader] alias WebCore::FloatSnapOffset {
    float offset;
    WebCore::ScrollSnapStop stop;
    bool hasSnapAreaLargerThanViewport;
    WebCore::ElementIdentifier snapTargetID;
    bool isFocused;
    Vector<size_t> snapAreaIndices;
};

#if ENABLE(ENCRYPTED_MEDIA)

enum class WebCore::CDMEncryptionScheme : bool

struct WebCore::CDMMediaCapability {
    String contentType;
    String robustness;
    std::optional<WebCore::CDMEncryptionScheme> encryptionScheme;
};

enum class WebCore::CDMSessionType : uint8_t {
    Temporary,
    PersistentUsageRecord,
    PersistentLicense
};

struct WebCore::CDMRestrictions {
    bool distinctiveIdentifierDenied;
    bool persistentStateDenied;
    HashSet<WebCore::CDMSessionType, IntHash<WebCore::CDMSessionType>, WTF::StrongEnumHashTraits<WebCore::CDMSessionType>> deniedSessionTypes;
}

#endif

struct WebCore::MediaSelectionOption {
    WebCore::MediaSelectionOption::MediaType mediaType;
    String displayName;
    WebCore::MediaSelectionOption::LegibleType legibleType;
};

[Nested] enum class WebCore::MediaSelectionOption::MediaType : uint8_t {
    Unknown,
    Audio,
    Subtitles,
    Captions,
    Metadata,
};

[Nested] enum class WebCore::MediaSelectionOption::LegibleType : uint8_t {
    Regular,
    LegibleOff,
    LegibleAuto,
};

enum class WebCore::MediaDecodingType : uint8_t {
    File,
    MediaSource,
    WebRTC
};

enum class WebCore::MediaEncodingType : bool;

class WebCore::BufferSource {
    Span<const uint8_t> span()
}

struct WebCore::FontShadow {
    WebCore::Color color;
    WebCore::FloatSize offset;
    double blurRadius;
};

struct WebCore::CompositionHighlight {
    unsigned startOffset;
    unsigned endOffset;
    std::optional<WebCore::Color> backgroundColor;
    std::optional<WebCore::Color> foregroundColor;
};

header: <WebCore/FontAttributeChanges.h>
[CustomHeader] class WebCore::FontChanges {
    String m_fontName;
    String m_fontFamily;
    std::optional<double> m_fontSize;
    [Validator='!*m_fontSize || !*m_fontSizeDelta'] std::optional<double> m_fontSizeDelta;
    std::optional<bool> m_bold;
    std::optional<bool> m_italic;
};

class WebCore::FontAttributeChanges {
    std::optional<WebCore::VerticalAlignChange> m_verticalAlign;
    std::optional<WebCore::Color> m_backgroundColor;
    std::optional<WebCore::Color> m_foregroundColor;
    std::optional<WebCore::FontShadow> m_shadow;
    std::optional<bool> m_strikeThrough;
    std::optional<bool> m_underline;
    WebCore::FontChanges m_fontChanges;
};

header: <WebCore/TextManipulationController.h>
[Nested, CustomHeader] enum class WebCore::TextManipulationControllerExclusionRule::Type : uint8_t {
    Exclude,
    Include
};

header: <WebCore/TextManipulationController.h>
[Nested, CustomHeader] struct WebCore::TextManipulationControllerExclusionRule::ElementRule {
    AtomString localName;
};

header: <WebCore/TextManipulationController.h>
[Nested, CustomHeader] struct WebCore::TextManipulationControllerExclusionRule::AttributeRule {
    AtomString name;
    String value;
};

header: <WebCore/TextManipulationController.h>
[Nested, CustomHeader] struct WebCore::TextManipulationControllerExclusionRule::ClassRule {
    AtomString className;
};

header: <WebCore/TextManipulationController.h>
[CustomHeader] struct WebCore::TextManipulationControllerExclusionRule {
    WebCore::TextManipulationControllerExclusionRule::Type type;
    std::variant<WebCore::TextManipulationControllerExclusionRule::ElementRule, WebCore::TextManipulationControllerExclusionRule::AttributeRule, WebCore::TextManipulationControllerExclusionRule::ClassRule> rule;
};

header: <WebCore/TextManipulationController.h>
[Nested, CustomHeader] enum class WebCore::TextManipulationControllerManipulationFailure::Type : uint8_t {
    NotAvailable,
    ContentChanged,
    InvalidItem,
    InvalidToken,
    ExclusionViolation,
};

header: <WebCore/TextManipulationController.h>
[CustomHeader] struct WebCore::TextManipulationControllerManipulationFailure {
    WebCore::FrameIdentifier frameID;
    WebCore::TextManipulationItemIdentifier identifier;
    uint64_t index;
    WebCore::TextManipulationControllerManipulationFailure::Type type;
};

#if ENABLE(SERVICE_WORKER)
struct WebCore::BackgroundFetchInformation {
    WebCore::ServiceWorkerRegistrationIdentifier registrationIdentifier;
    String identifier;
    uint64_t uploadTotal;
    uint64_t uploaded;
    uint64_t downloadTotal;
    uint64_t downloaded;
    WebCore::BackgroundFetchResult result;
    WebCore::BackgroundFetchFailureReason failureReason;
    bool recordsAvailable;
};
#endif

#if ENABLE(SERVICE_WORKER)
struct WebCore::BackgroundFetchRequest {
    WebCore::ResourceRequest internalRequest;
    WebCore::FetchOptions options;
    WebCore::FetchHeadersGuard guard;
    WebCore::HTTPHeaderMap httpHeaders;
    String referrer;
    Markable<WebCore::ContentSecurityPolicyResponseHeaders, WebCore::ContentSecurityPolicyResponseHeaders::MarkableTraits> cspResponseHeaders;
};
#endif

#if ENABLE(SERVICE_WORKER)
struct WebCore::BackgroundFetchRecordInformation {
    WebCore::BackgroundFetchRecordIdentifier identifier;
    WebCore::ResourceRequest internalRequest;
    WebCore::FetchOptions options;
    WebCore::FetchHeadersGuard guard;
    WebCore::HTTPHeaderMap httpHeaders;
    String referrer;
};
#endif

#if ENABLE(SERVICE_WORKER)
struct WebCore::BackgroundFetchOptions {
    Vector<WebCore::ImageResource> icons;
    String title;
    uint64_t downloadTotal;
};
#endif


#if ENABLE(SERVICE_WORKER)
struct WebCore::ImageResource {
    String src;
    String sizes;
    String type;
    String label;
};
#endif // ENABLE(SERVICE_WORKER)

using WebCore::SharedStringHash = uint32_t

struct WebCore::FourCC {
    uint32_t value;
};

#if ENABLE(VIDEO)
header: <WebCore/MediaPlayer.h>
[CustomHeader] struct WebCore::MediaEngineSupportParameters {
    WebCore::ContentType type;
    URL url;
    bool isMediaSource;
    bool isMediaStream;
    bool requiresRemotePlayback;
    Vector<WebCore::ContentType> contentTypesRequiringHardwareSupport;
    std::optional<Vector<String>> allowedMediaContainerTypes;
    std::optional<Vector<String>> allowedMediaCodecTypes;
    std::optional<Vector<WebCore::FourCC>> allowedMediaVideoCodecIDs;
    std::optional<Vector<WebCore::FourCC>> allowedMediaAudioCodecIDs;
    std::optional<Vector<WebCore::FourCC>> allowedMediaCaptionFormatTypes;
};
#endif

enum class WebCore::MediaPlayerNetworkState : uint8_t {
    Empty,
    Idle,
    Loading,
    Loaded,
    FormatError,
    NetworkError,
    DecodeError
};

enum class WebCore::MediaPlayerReadyState : uint8_t {
    HaveNothing,
    HaveMetadata,
    HaveCurrentData,
    HaveFutureData,
    HaveEnoughData
};

enum class WebCore::MediaPlayerMovieLoadType : uint8_t {
    Unknown,
    Download,
    StoredStream,
    LiveStream
};

enum class WebCore::MediaPlayerPreload : uint8_t {
    None,
    MetaData,
    Auto
};

enum class WebCore::MediaPlayerVideoGravity : uint8_t {
    Resize,
    ResizeAspect,
    ResizeAspectFill
};

enum class WebCore::MediaPlayerSupportsType : uint8_t {
    IsNotSupported,
    IsSupported,
    MayBeSupported
};

enum class WebCore::MediaPlayerBufferingPolicy : uint8_t {
    Default,
    LimitReadAhead,
    MakeResourcesPurgeable,
    PurgeResources,
};

enum class WebCore::MediaPlayerMediaEngineIdentifier : uint8_t {
    AVFoundation,
    AVFoundationMSE,
    AVFoundationMediaStream,
    AVFoundationCF,
    GStreamer,
    GStreamerMSE,
    HolePunch,
    MediaFoundation,
    MockMSE,
    CocoaWebM
};

enum class WebCore::MediaPlayerWirelessPlaybackTargetType : uint8_t {
    TargetTypeNone,
    TargetTypeAirPlay,
    TargetTypeTVOut
};

enum class WebCore::MediaPlayerPitchCorrectionAlgorithm : uint8_t {
    BestAllAround,
    BestForMusic,
    BestForSpeech,
};

class WebCore::GeolocationPositionData {
    double timestamp;
    double latitude;
    double longitude;
    double accuracy;
    std::optional<double> altitude;
    std::optional<double> altitudeAccuracy;
    std::optional<double> heading;
    std::optional<double> speed;
    std::optional<double> floorLevel;
};

#if ENABLE(APP_HIGHLIGHTS)
enum class WebCore::CreateNewGroupForHighlight : bool

enum class WebCore::HighlightRequestOriginatedInApp : bool

struct WebCore::AppHighlight {
    Ref<WebCore::FragmentedSharedBuffer> highlight;
    std::optional<String> text;
    WebCore::CreateNewGroupForHighlight isNewGroup;
    WebCore::HighlightRequestOriginatedInApp requestOriginatedInApp;
};
#endif // ENABLE(APP_HIGHLIGHTS)

struct WebCore::MediaDeviceHashSalts {
    String persistentDeviceSalt;
    String ephemeralDeviceSalt;
};

enum class WebCore::SpeechRecognitionUpdateType : uint8_t {
    Start,
    AudioStart,
    SoundStart,
    SpeechStart,
    SpeechEnd,
    SoundEnd,
    AudioEnd,
    Result,
    NoMatch,
    Error,
    End
};

class WebCore::SpeechRecognitionUpdate {
    WebCore::SpeechRecognitionConnectionClientIdentifier m_clientIdentifier;
    WebCore::SpeechRecognitionUpdateType m_type;
    std::variant<std::monostate, WebCore::SpeechRecognitionError, Vector<WebCore::SpeechRecognitionResultData>> m_content;
};

#if USE(SYSTEM_PREVIEW)
[RefCounted, AdditionalEncoder=StreamConnectionEncoder] class WebCore::ARKitBadgeSystemImage {
    WebCore::RenderingResourceIdentifier imageIdentifier();
    WebCore::FloatSize m_imageSize;
};
#endif

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::CompositeOperator : uint8_t {
    Clear,
    Copy,
    SourceOver,
    SourceIn,
    SourceOut,
    SourceAtop,
    DestinationOver,
    DestinationIn,
    DestinationOut,
    DestinationAtop,
    XOR,
    PlusDarker,
    PlusLighter,
    Difference
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::BlendMode : uint8_t {
    Normal,
    Multiply,
    Screen,
    Darken,
    Lighten,
    Overlay,
    ColorDodge,
    ColorBurn,
    HardLight,
    SoftLight,
    Difference,
    Exclusion,
    Hue,
    Saturation,
    Color,
    Luminosity,
    PlusDarker,
    PlusLighter
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::GradientSpreadMethod : uint8_t {
    Pad,
    Reflect,
    Repeat
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::InterpolationQuality : uint8_t {
    Default,
    DoNotInterpolate,
    Low,
    Medium,
    High
};

header: <WebCore/AudioIOCallback.h>
[CustomHeader] struct WebCore::AudioIOPosition {
    Seconds position;
    MonotonicTime timestamp;
};

#if ENABLE(VIDEO)
header: <WebCore/VideoFrame.h>
enum class WebCore::VideoFrameRotation : uint16_t {
    None,
    UpsideDown,
    Right,
    Left,
};
#endif

#if ENABLE(VIDEO) && USE(AVFOUNDATION)
[RefCounted] class WebCore::VideoFrameCV {
    MediaTime presentationTime();
    bool isMirrored();
    WebCore::VideoFrameRotation rotation();
    RetainPtr<CVPixelBufferRef> m_pixelBuffer;
    WebCore::PlatformVideoColorSpace colorSpace();
};
#endif

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::GradientColorStop {
    float offset;
    WebCore::Color color;
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::GradientColorStops {
    Vector<WebCore::GradientColorStop, 2> stops();
};

struct WebCore::ImageBufferBackendParameters {
    WebCore::FloatSize logicalSize;
    float resolutionScale;
    WebCore::DestinationColorSpace colorSpace
    WebCore::PixelFormat pixelFormat;
    WebCore::RenderingPurpose purpose;
};

enum class WebCore::PreserveResolution : bool;

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::PathElementType : uint8_t {
    MoveToPoint,
    AddLineToPoint,
    AddQuadCurveToPoint,
    AddCurveToPoint,
    CloseSubpath
};

header: <WebCore/Path.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::EncodedPathElementType {
    std::optional<WebCore::PathElementType> m_type;
};

class WebCore::ProcessIdentity {
#if HAVE(TASK_IDENTITY_TOKEN)
    MachSendRight m_taskIdToken;
#endif
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::ColorInterpolationColorSpace : uint8_t {
    HSL,
    HWB,
    LCH,
    Lab,
    OKLCH,
    OKLab,
    SRGB,
    SRGBLinear,
    XYZD50,
    XYZD65
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::HueInterpolationMethod : uint8_t {
    Shorter,
    Longer,
    Increasing,
    Decreasing
};

[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::HSL {
    WebCore::HueInterpolationMethod hueInterpolationMethod;
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::HWB {
    WebCore::HueInterpolationMethod hueInterpolationMethod;
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::LCH {
    WebCore::HueInterpolationMethod hueInterpolationMethod;
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::Lab {
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::OKLCH {
    WebCore::HueInterpolationMethod hueInterpolationMethod;
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::OKLab {
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::SRGB {
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::SRGBLinear {
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::XYZD50 {
};
[Nested, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod::XYZD65 {
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ColorInterpolationMethod {
    std::variant<WebCore::ColorInterpolationMethod::HSL, WebCore::ColorInterpolationMethod::HWB, WebCore::ColorInterpolationMethod::LCH, WebCore::ColorInterpolationMethod::Lab, WebCore::ColorInterpolationMethod::OKLCH, WebCore::ColorInterpolationMethod::OKLab, WebCore::ColorInterpolationMethod::SRGB, WebCore::ColorInterpolationMethod::SRGBLinear, WebCore::ColorInterpolationMethod::XYZD50, WebCore::ColorInterpolationMethod::XYZD65> colorSpace;
    WebCore::AlphaPremultiplication alphaPremultiplication;
};

#if USE(AUDIO_SESSION)
header: <WebCore/AudioSession.h>
[CustomHeader] enum class WebCore::RouteSharingPolicy : uint8_t {
    Default,
    LongFormAudio,
    Independent,
    LongFormVideo
};

enum class WebCore::AudioSessionCategory : uint8_t {
    None,
    AmbientSound,
    SoloAmbientSound,
    MediaPlayback,
    RecordAudio,
    PlayAndRecord,
    AudioProcessing,
};

[Nested] enum class WebCore::AudioSession::MayResume : bool;

enum class WebCore::AudioSessionRoutingArbitrationError : uint8_t {
    None,
    Failed,
    Cancelled
};

[Nested] enum class WebCore::AudioSessionRoutingArbitrationClient::DefaultRouteChanged : bool;
#endif

#if ENABLE(ENCRYPTED_MEDIA)
enum class WebCore::CDMKeyStatus : uint8_t {
    Usable,
    Expired,
    Released,
    OutputRestricted,
    OutputDownscaled,
    StatusPending,
    InternalError
};

enum class WebCore::CDMMessageType : uint8_t {
    LicenseRequest,
    LicenseRenewal,
    LicenseRelease,
    IndividualizationRequest
};

enum class WebCore::CDMRequirement : uint8_t {
    Required,
    Optional,
    NotAllowed
};
#endif

#if ENABLE(WEB_RTC)
enum class WebCore::RTCDataChannelState : uint8_t {
    Connecting,
    Open,
    Closing,
    Closed
};

enum class WebCore::RTCPriorityType : uint8_t {
    VeryLow,
    Low,
    Medium,
    High
};
#endif

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::LineCap : uint8_t {
    Butt,
    Round,
    Square
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::LineJoin : uint8_t {
    Miter,
    Round,
    Bevel
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::StrokeStyle : uint8_t {
    NoStroke,
    SolidStroke,
    DottedStroke,
    DashedStroke,
    DoubleStroke,
    WavyStroke,
};

[OptionSet, AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::TextDrawingMode : uint8_t {
    Fill,
    Stroke,
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::DecodingMode : uint8_t {
    Auto,
    SynchronousThumbnail,
    Synchronous,
    Asynchronous
};

header: <WebCore/GraphicsTypes.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::CompositeMode {
    WebCore::CompositeOperator operation;
    WebCore::BlendMode blendMode;
};

[AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::DocumentMarkerLineStyleMode : uint8_t {
    TextCheckingDictationPhraseWithAlternatives,
    Spelling,
    Grammar,
    AutocorrectionReplacement,
    DictationAlternatives
};

header: <WebCore/GraphicsTypes.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::DocumentMarkerLineStyle {
    WebCore::DocumentMarkerLineStyleMode mode;
    WebCore::Color color;
};

[Nested, AdditionalEncoder=StreamConnectionEncoder]  enum class WebCore::ShadowRadiusMode : bool;

header: <WebCore/GraphicsTypes.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::DropShadow {
    WebCore::FloatSize offset;
    float blurRadius;
    WebCore::Color color;
    WebCore::ShadowRadiusMode radiusMode;
};

#if ENABLE(VIDEO)
[Nested, AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::GenericCueData::Alignment : uint8_t {
    None,
    Start,
    Middle,
    End
};

[Nested, AdditionalEncoder=StreamConnectionEncoder] enum class WebCore::GenericCueData::Status : uint8_t {
    Uninitialized,
    Partial,
    Complete
};

header: <WebCore/InbandGenericCue.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::GenericCueData {
    WebCore::InbandGenericCueIdentifier m_uniqueId;
    MediaTime m_startTime;
    MediaTime m_endTime;
    AtomString m_id;
    String m_content;
    String m_fontName;
    double m_line;
    double m_position;
    double m_size;
    double m_baseFontSize;
    double m_relativeFontSize;
    WebCore::Color m_foregroundColor;
    WebCore::Color m_backgroundColor;
    WebCore::Color m_highlightColor;
    WebCore::GenericCueData::Alignment m_align;
    WebCore::GenericCueData::Status m_status;
};
#endif

header: <WebCore/ImageDecoder.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ImageDecoderFrameInfo {
    bool hasAlpha;
    Seconds duration;
}

header: <WebCore/DisplayListItems.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] class WebCore::DisplayList::DrawDotsForDocumentMarker {
    WebCore::FloatRect rect();
    WebCore::DocumentMarkerLineStyle style();
};

[Nested] enum class WebCore::ImageOrientation::Orientation : int {
    FromImage,
    OriginTopLeft,
    OriginTopRight,
    OriginBottomRight,
    OriginBottomLeft,
    OriginLeftTop,
    OriginRightTop,
    OriginRightBottom,
    OriginLeftBottom,
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ImageOrientation {
    WebCore::ImageOrientation::Orientation orientation()
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::ImagePaintingOptions {
     WebCore::CompositeOperator m_compositeOperator;
     WebCore::BlendMode m_blendMode;
     WebCore::DecodingMode m_decodingMode;
     WebCore::ImageOrientation m_orientation;
     WebCore::InterpolationQuality m_interpolationQuality;
};

struct WebCore::CanvasActivityRecord {
    HashSet<String> textWritten;
    bool wasDataRead;
};

header: <WebCore/AttributionSecondsUntilSendData.h>
[CustomHeader] struct WebCore::PCM::AttributionSecondsUntilSendData {
    std::optional<Seconds> sourceSeconds;
    std::optional<Seconds> destinationSeconds;
};

enum class WebCore::CrossOriginOpenerPolicyValue : uint8_t {
    UnsafeNone,
    SameOrigin,
    SameOriginPlusCOEP,
    SameOriginAllowPopups
};

struct WebCore::CrossOriginOpenerPolicy {
    WebCore::CrossOriginOpenerPolicyValue value;
    WebCore::CrossOriginOpenerPolicyValue reportOnlyValue;
    String reportingEndpoint;
    String reportOnlyReportingEndpoint;
};

struct WebCore::CustomHeaderFields {
    Vector<WebCore::HTTPHeaderField> fields;
    Vector<String> thirdPartyDomains;
};

[CreateUsing=create] class WebCore::HTTPHeaderField {
    String name();
    String value();
};

struct WebCore::NavigationRequester {
    URL url;
    Ref<WebCore::SecurityOrigin> securityOrigin;
    Ref<WebCore::SecurityOrigin> topOrigin;
    WebCore::PolicyContainer policyContainer;
    std::optional<WebCore::GlobalFrameIdentifier> globalFrameIdentifier;
};

struct WebCore::PolicyContainer {
    WebCore::ContentSecurityPolicyResponseHeaders contentSecurityPolicyResponseHeaders;
    WebCore::CrossOriginEmbedderPolicy crossOriginEmbedderPolicy;
    WebCore::CrossOriginOpenerPolicy crossOriginOpenerPolicy;
    WebCore::ReferrerPolicy referrerPolicy;
};

[Nested] enum class WebCore::SubstituteData::SessionHistoryVisibility : bool

class WebCore::SubstituteData {
    RefPtr<WebCore::FragmentedSharedBuffer> content();
    URL failingURL();
    WebCore::ResourceResponse response();
    WebCore::SubstituteData::SessionHistoryVisibility shouldRevealToSessionHistory();
};

header: <WebCore/HTTPCookieAcceptPolicy.h>
enum class WebCore::HTTPCookieAcceptPolicy : uint8_t {
    AlwaysAccept,
    Never,
    OnlyFromMainDocumentDomain,
    ExclusivelyFromMainDocumentDomain,
};

enum class WebCore::NetworkLoadPriority : uint8_t {
    Low,
    Medium,
    High,
    Unknown,
};

enum class WebCore::PrivacyStance : uint8_t {
    Unknown,
    NotEligible,
    Proxied,
    Failed,
    Direct,
    FailedUnreachable,
};

enum class WebCore::ThirdPartyCookieBlockingMode : uint8_t {
    All,
    AllExceptBetweenAppBoundDomains,
    AllExceptManagedDomains,
    AllOnSitesWithoutUserInteraction,
    OnlyAccordingToPerDomainPolicy
};

enum class WebCore::FirstPartyWebsiteDataRemovalMode : uint8_t {
    AllButCookies,
    None,
    AllButCookiesLiveOnTestingTimeout,
    AllButCookiesReproTestingTimeout
};

header: <WebCore/DragData.h>
[OptionSet, CustomHeader] enum class WebCore::DragApplicationFlags : uint8_t {
    IsModal,
    IsSource,
    HasAttachedSheet,
    IsCopyKeyDown
};

[OptionSet] enum class WebCore::TextCheckingType : uint8_t {
    None,
    Spelling,
    Grammar,
    Link,
    Quote,
    Dash,
    Replacement,
    Correction,
    ShowCorrectionPanel,
};

#if ENABLE(SERVICE_WORKER)

enum class WebCore::ServiceWorkerClientType : uint8_t {
    Window,
    Worker,
    Sharedworker,
    All
};

enum class WebCore::ServiceWorkerJobType : uint8_t {
    Register,
    Unregister,
    Update,
};

enum class WebCore::ServiceWorkerRegistrationState : uint8_t {
    Installing,
    Waiting,
    Active,
};

enum class WebCore::ServiceWorkerState : uint8_t {
    Parsed,
    Installing,
    Installed,
    Activating,
    Activated,
    Redundant,
};

enum class WebCore::ServiceWorkerClientFrameType : uint8_t {
    Auxiliary,
    TopLevel,
    Nested,
    None
};

enum class WebCore::ShouldNotifyWhenResolved : bool

enum class WebCore::ServiceWorkerUpdateViaCache : uint8_t {
    Imports,
    All,
    None,
};

struct WebCore::ServiceWorkerClientData {
    WebCore::ScriptExecutionContextIdentifier identifier;
    WebCore::ServiceWorkerClientType type;
    WebCore::ServiceWorkerClientFrameType frameType;
    URL url;
    URL ownerURL;
    std::optional<WebCore::PageIdentifier> pageIdentifier;
    std::optional<WebCore::FrameIdentifier> frameIdentifier;
    WebCore::LastNavigationWasAppInitiated lastNavigationWasAppInitiated;
    bool isVisible;
    bool isFocused;
    uint64_t focusOrder;
    Vector<String> ancestorOrigins;
};

struct WebCore::ServiceWorkerClientQueryOptions {
    bool includeUncontrolled;
    WebCore::ServiceWorkerClientType type;

};

struct WebCore::ServiceWorkerData {
    WebCore::ServiceWorkerIdentifier identifier;
    WebCore::ServiceWorkerRegistrationIdentifier registrationIdentifier;
    URL scriptURL;
    WebCore::ServiceWorkerState state;
    WebCore::WorkerType type;
};

struct WebCore::ServiceWorkerJobData {
    WebCore::ServiceWorkerJobDataIdentifier identifier();
    URL scriptURL;
    URL clientCreationURL;
    WebCore::SecurityOriginData topOrigin;
    URL scopeURL;
    WebCore::ServiceWorkerOrClientIdentifier sourceContext;
    WebCore::WorkerType workerType;

    WebCore::ServiceWorkerJobType type;

    String domainForCachePartition;
    bool isFromServiceWorkerPage;

    [Validator='( type == WebCore::ServiceWorkerJobType::Register && registrationOptions->has_value()) || (type != WebCore::ServiceWorkerJobType::Register && !registrationOptions->has_value() )'] std::optional<WebCore::ServiceWorkerRegistrationOptions> registrationOptions;
};

#endif //ENABLE(SERVICE_WORKER)

struct WebCore::EventInit {
    bool bubbles;
    bool cancelable;
    bool composed;
};

struct WebCore::MessageWithMessagePorts {
    RefPtr<WebCore::SerializedScriptValue> message;
    Vector<WebCore::TransferredMessagePort> transferredPorts;
};

enum class WebCore::StorageAccessWasGranted : bool

enum class WebCore::StorageAccessPromptWasShown : bool

enum class WebCore::StorageAccessScope : bool

enum class WebCore::StorageAccessQuickResult : bool

header: <WebCore/DocumentStorageAccess.h>
[CustomHeader] struct WebCore::RequestStorageAccessResult {
    WebCore::StorageAccessWasGranted wasGranted;
    WebCore::StorageAccessPromptWasShown promptWasShown;
    WebCore::StorageAccessScope scope;
    WebCore::RegistrableDomain topFrameDomain;
    WebCore::RegistrableDomain subFrameDomain;
};

class WebCore::Exception {
    WebCore::ExceptionCode code();
    String message();
};

struct WebCore::ExceptionData {
    WebCore::ExceptionCode code;
    String message;
};

struct WebCore::MessagePortIdentifier {
    WebCore::ProcessIdentifier processIdentifier;
    WebCore::PortIdentifier portIdentifier;
};

header: <WebCore/SecurityPolicyViolationEvent.h>
[CustomHeader] struct WebCore::SecurityPolicyViolationEventInit : WebCore::EventInit {
    String documentURI;
    String referrer;
    String blockedURI;
    String violatedDirective;
    String effectiveDirective;
    String originalPolicy;
    String sourceFile;
    String sample;
    WebCore::SecurityPolicyViolationEventDisposition disposition;
    unsigned short statusCode;
    unsigned lineNumber;
    unsigned columnNumber;
};

[RefCounted] class WebCore::CSPViolationReportBody {
    String documentURL();
    String referrer();
    String blockedURL();
    String effectiveDirective();
    String originalPolicy();
    String sourceFile();
    String sample();
    WebCore::SecurityPolicyViolationEventDisposition disposition();
    unsigned short statusCode();
    unsigned long lineNumber();
    unsigned long columnNumber();
};

class WebCore::SecurityOriginData {
    std::variant<WebCore::SecurityOriginData::Tuple, WebCore::ProcessQualified<WebCore::OpaqueOriginIdentifier>> data();
};

[Nested] class WebCore::SecurityOriginData::Tuple {
    [Validator='!protocol->isHashTableDeletedValue()'] String protocol;
    String host;
    std::optional<uint16_t> port;
};

#if ENABLE(MEDIA_STREAM)

[Nested] enum class WebCore::MediaConstraint::DataType : uint8_t {
    None,
    Integer,
    Double,
    Boolean,
    String
};

enum class WebCore::MediaConstraintType : uint8_t {
    Unknown,
    Width,
    Height,
    AspectRatio,
    FrameRate,
    FacingMode,
    Volume,
    SampleRate,
    SampleSize,
    EchoCancellation,
    DeviceId,
    GroupId,
    DisplaySurface,
    LogicalSurface,
    Zoom,
};

header: <WebCore/MediaConstraints.h>
[CustomHeader] class WebCore::MediaConstraint {
    String name();
    WebCore::MediaConstraintType constraintType();
    WebCore::MediaConstraint::DataType dataType();
};

[CustomHeader] class WebCore::IntConstraint : WebCore::MediaConstraint {
    std::optional<int> m_min;
    std::optional<int> m_max;
    std::optional<int> m_exact;
    std::optional<int> m_ideal;
};

[CustomHeader] class WebCore::DoubleConstraint : WebCore::MediaConstraint {
    std::optional<double> m_min;
    std::optional<double> m_max;
    std::optional<double> m_exact;
    std::optional<double> m_ideal;
};

[CustomHeader] class WebCore::BooleanConstraint : WebCore::MediaConstraint {
    std::optional<bool> m_exact;
    std::optional<bool> m_ideal;
};

[CustomHeader] class WebCore::StringConstraint : WebCore::MediaConstraint {
    Vector<String> m_exact;
    Vector<String> m_ideal;
};

header: <WebCore/VideoPreset.h>
[CustomHeader] struct WebCore::FrameRateRange {
    double minimum;
    double maximum;
};

[CustomHeader] struct WebCore::VideoPresetData {
    WebCore::IntSize size;
    Vector<WebCore::FrameRateRange> frameRateRanges;
    double minZoom;
    double maxZoom;
};

class WebCore::RealtimeMediaSourceSupportedConstraints {
    bool supportsWidth();
    bool supportsHeight();
    bool supportsAspectRatio();
    bool supportsFrameRate();
    bool supportsFacingMode();
    bool supportsVolume();
    bool supportsSampleRate();
    bool supportsSampleSize();
    bool supportsEchoCancellation();
    bool supportsDeviceId();
    bool supportsGroupId();
    bool supportsDisplaySurface();
    bool supportsLogicalSurface();
    bool supportsFocusDistance();
    bool supportsZoom();
};

enum class WebCore::VideoFacingMode : uint8_t {
    Unknown,
    User,
    Environment,
    Left,
    Right
};

enum class WebCore::DisplaySurfaceType : uint8_t {
    Monitor,
    Window,
    Application,
    Browser,
    Invalid,
};

class WebCore::RealtimeMediaSourceSettings {
    uint32_t width();
    uint32_t height();
    float aspectRatio();
    float frameRate();
    WebCore::VideoFacingMode facingMode();
    double volume();
    uint32_t sampleRate();
    uint32_t sampleSize();
    bool echoCancellation();
    AtomString deviceId();
    AtomString groupId();
    AtomString label();
    WebCore::DisplaySurfaceType displaySurface();
    bool logicalSurface();
    double zoom();
    WebCore::RealtimeMediaSourceSupportedConstraints supportedConstraints();
};

[Nested] enum class WebCore::CaptureDevice::DeviceType : uint8_t {
    Unknown,
    Microphone,
    Speaker,
    Camera,
    Screen,
    Window,
    SystemAudio
};

class WebCore::CaptureDevice {
    String persistentId();
    WebCore::CaptureDevice::DeviceType type();
    String label();
    String groupId();
    bool enabled();
    bool isDefault();
    bool isMockDevice();
    bool isEphemeral();
};

struct WebCore::CaptureDeviceWithCapabilities {
    WebCore::CaptureDevice device;
    WebCore::RealtimeMediaSourceCapabilities capabilities;
};

[Nested] enum class WebCore::RealtimeMediaSourceCapabilities::EchoCancellation : bool

class WebCore::RealtimeMediaSourceCapabilities {
    WebCore::CapabilityValueOrRange width();
    WebCore::CapabilityValueOrRange height();
    WebCore::CapabilityValueOrRange aspectRatio();
    WebCore::CapabilityValueOrRange frameRate();
    Vector<WebCore::VideoFacingMode> facingMode();
    WebCore::CapabilityValueOrRange volume();
    WebCore::CapabilityValueOrRange sampleRate();
    WebCore::CapabilityValueOrRange sampleSize();
    WebCore::RealtimeMediaSourceCapabilities::EchoCancellation echoCancellation();
    AtomString deviceId();
    AtomString groupId();
    WebCore::CapabilityValueOrRange focusDistance();
    WebCore::CapabilityValueOrRange zoom();
    WebCore::RealtimeMediaSourceSupportedConstraints supportedConstraints();
};

#endif

enum class WebCore::PlatformVideoColorPrimaries : uint8_t {
    Bt709,
    Bt470bg,
    Smpte170m,
    Bt470m,
    Smpte240m,
    Film,
    Bt2020,
    SmpteSt4281,
    SmpteRp431,
    SmpteEg432,
    JedecP22Phosphors,
    Unspecified,
};

enum class WebCore::PlatformVideoTransferCharacteristics : uint8_t {
    Bt709,
    Smpte170m,
    Iec6196621,
    Gamma22curve,
    Gamma28curve,
    Smpte240m,
    Linear,
    Log,
    LogSqrt,
    Iec6196624,
    Bt1361ExtendedColourGamut,
    Bt2020_10bit,
    Bt2020_12bit,
    SmpteSt2084,
    SmpteSt4281,
    AribStdB67Hlg,
    Unspecified
};

enum class WebCore::PlatformVideoMatrixCoefficients : uint8_t {
    Rgb,
    Bt709,
    Bt470bg,
    Smpte170m,
    Smpte240m,
    Fcc,
    YCgCo,
    Bt2020NonconstantLuminance,
    Bt2020ConstantLuminance,
    Unspecified,
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::PlatformVideoColorSpace {
    std::optional<WebCore::PlatformVideoColorPrimaries> primaries;
    std::optional<WebCore::PlatformVideoTransferCharacteristics> transfer;
    std::optional<WebCore::PlatformVideoMatrixCoefficients> matrix;
    std::optional<bool> fullRange;
};

#if ENABLE(VIDEO)

struct WebCore::PlatformTrackConfiguration {
    String codec;
};

struct WebCore::PlatformAudioTrackConfiguration : WebCore::PlatformTrackConfiguration {
    uint32_t sampleRate;
    uint32_t numberOfChannels;
    uint64_t bitrate;
};

struct WebCore::PlatformVideoTrackConfiguration : WebCore::PlatformTrackConfiguration {
    uint32_t width;
    uint32_t height;
    WebCore::PlatformVideoColorSpace colorSpace;
    double framerate;
    uint64_t bitrate;
};

#endif

#if ENABLE(WEB_RTC)

header: <WebCore/RTCDataChannelHandler.h>
[CustomHeader] struct WebCore::RTCDataChannelInit {
    std::optional<bool> ordered;
    std::optional<unsigned short> maxPacketLifeTime;
    std::optional<unsigned short> maxRetransmits;
    String protocol;
    std::optional<bool> negotiated;
    std::optional<unsigned short> id;
    WebCore::RTCPriorityType priority;
};

struct WebCore::RTCDataChannelIdentifier {
    WebCore::ProcessIdentifier processIdentifier;
    WebCore::RTCDataChannelLocalIdentifier channelIdentifier;
};

#endif // ENABLE(WEB_RTC)

header: <WebCore/SVGFilterExpressionReference.h>
[CustomHeader, AdditionalEncoder=StreamConnectionEncoder] struct WebCore::SVGFilterExpressionNode {
    unsigned index;
    std::optional<WebCore::FilterEffectGeometry> geometry;
    unsigned level;
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::SVGPreserveAspectRatioValue {
    WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType m_align;
    WebCore::SVGPreserveAspectRatioValue::SVGMeetOrSliceType m_meetOrSlice;
};

#if ENABLE(CONTENT_EXTENSIONS)

[Nested] struct WebCore::ContentRuleListResults::Result {
    bool blockedLoad;
    bool madeHTTPS;
    bool blockedCookies;
    bool modifiedHeaders;
    bool redirected;
    Vector<String> notifications;
};

[Nested] struct WebCore::ContentRuleListResults::Summary {
    bool blockedLoad;
    bool madeHTTPS;
    bool blockedCookies;
    bool hasNotifications;
};

struct WebCore::ContentRuleListResults {
    WebCore::ContentRuleListResults::Summary summary;
    Vector<std::pair<String, WebCore::ContentRuleListResults::Result>> results;
};

#endif

enum class WebCore::PolicyAction : uint8_t {
    Use,
    Download,
    Ignore,
    StopAllLoads
};

[OptionSet] enum class WebCore::ReloadOption : uint8_t {
    ExpiredOnly,
    FromOrigin,
    DisableContentBlockers
};

enum class WebCore::FrameLoadType : uint8_t {
    Standard,
    Back,
    Forward,
    IndexedBackForward,
    Reload,
    Same,
    RedirectWithLockedBackForwardList,
    Replace,
    ReloadFromOrigin,
    ReloadExpiredOnly
};

enum class WebCore::NavigationType : uint8_t {
    LinkClicked,
    FormSubmitted,
    BackForward,
    Reload,
    FormResubmitted,
    Other
};

enum class WebCore::BrowsingContextGroupSwitchDecision : uint8_t {
    StayInGroup,
    NewSharedGroup,
    NewIsolatedGroup,
};

enum class WebCore::ShouldOpenExternalURLsPolicy : uint8_t {
    ShouldNotAllow,
    ShouldAllowExternalSchemesButNotAppLinks,
    ShouldAllow,
};

header: <WebCore/DocumentLoader.h>
[CustomHeader] enum class WebCore::MouseEventPolicy : uint8_t {
    Default,
#if ENABLE(IOS_TOUCH_EVENTS)
    SynthesizeTouchEvents,
#endif
};

enum class WebCore::ColorSchemePreference : uint8_t {
    NoPreference,
    Light,
    Dark
};

enum class WebCore::ModalContainerObservationPolicy : bool

enum class WebCore::AllowsContentJavaScript : bool

[OptionSet] enum class WebCore::NetworkConnectionIntegrity : uint16_t {
    Enabled,
    HTTPSFirst,
    HTTPSOnly,
    HTTPSOnlyExplicitlyBypassedForDomain,
    FailClosed,
    WebSearchContent,
    EnhancedTelemetry,
    RequestValidation,
    SanitizeLookalikeCharacters,
};

enum class WebCore::ViolationReportType : uint8_t {
    COEPInheritenceViolation,
    CORPViolation,
    ContentSecurityPolicy,
    CrossOriginOpenerPolicy,
    Deprecation,
    StandardReportingAPIViolation,
    Test
};

enum class WebCore::COEPDisposition : bool;

[RefCounted] class WebCore::COEPInheritenceViolationReportBody {
    WebCore::COEPDisposition m_disposition;
    URL m_blockedURL;
    String m_type;
};

[RefCounted] class WebCore::CORPViolationReportBody {
    WebCore::COEPDisposition m_disposition;
    URL m_blockedURL;
    WebCore::FetchOptionsDestination m_destination;
};

[RefCounted] class WebCore::ReportBody subclasses {
  WebCore::CSPViolationReportBody,
  WebCore::COEPInheritenceViolationReportBody,
  WebCore::CORPViolationReportBody,
  WebCore::DeprecationReportBody
  WebCore::TestReportBody
};

[AdditionalEncoder=StreamConnectionEncoder] class WebCore::SourceImage {
    WebCore::RenderingResourceIdentifier imageIdentifier();
}

enum class WebCore::LinkIconType : uint8_t {
    Favicon,
    TouchIcon,
    TouchPrecomposedIcon
};

struct WebCore::LinkIcon {
    URL url;
    WebCore::LinkIconType type;
    String mimeType;
    std::optional<unsigned> size;
    Vector<std::pair<String, String>> attributes;
};

header: <WebCore/PluginData.h>
[CustomHeader] struct WebCore::SupportedPluginIdentifier {
    String matchingDomain;
    String pluginIdentifier;
};

enum class WebCore::PluginLoadClientPolicy : uint8_t {
    Undefined,
    Block,
    Ask,
    Allow,
    AllowAlways,
};

struct WebCore::CSSValueKey {
    unsigned cssValueID;
    bool useDarkAppearance;
    bool useElevatedUserInterfaceLevel;
};

struct WebCore::VideoFrameTimeMetadata {
    std::optional<double> processingDuration;
    std::optional<Seconds> captureTime;
    std::optional<Seconds> receiveTime;
    std::optional<unsigned> rtpTimestamp;
};

[AdditionalEncoder=StreamConnectionEncoder] struct WebCore::PositionedGlyphs {
    Vector<WebCore::GlyphBufferGlyph> glyphs;
    [Validator='glyphs->size() == advances->size()'] Vector<WebCore::GlyphBufferAdvance> advances;
    WebCore::FloatPoint localAnchor;
    WebCore::FontSmoothingMode smoothingMode;
};

class WebCore::EventRegion {
    WebCore::Region m_region;
#if ENABLE(TOUCH_ACTION_REGIONS)
    Vector<WebCore::Region> m_touchActionRegions;
#endif
#if ENABLE(WHEEL_EVENT_REGIONS)
    WebCore::Region m_wheelEventListenerRegion;
    WebCore::Region m_nonPassiveWheelEventListenerRegion;
#endif
#if ENABLE(EDITABLE_REGION)
    std::optional<WebCore::Region> m_editableRegion;
#endif
#if ENABLE(INTERACTION_REGIONS_IN_EVENT_REGION)
    Vector<WebCore::InteractionRegion> m_interactionRegions;
#endif
};

enum class WebCore::PasteboardItemPresentationStyle : uint8_t {
    Unspecified,
    Inline,
    Attachment
};

[CustomHeader] struct WebCore::PresentationSize {
    std::optional<double> width;
    std::optional<double> height;
};

struct WebCore::PasteboardItemInfo {
    Vector<String> pathsForFileUpload;
    Vector<String> platformTypesForFileUpload;
    Vector<String> platformTypesByFidelity;
    String suggestedFileName;
    WebCore::PresentationSize preferredPresentationSize;
    bool isNonTextType;
    bool containsFileURLAndFileUploadContent;
    Vector<String> webSafeTypesByFidelity;
    WebCore::PasteboardItemPresentationStyle preferredPresentationStyle;
};

#if ENABLE(MEDIA_CONTROLS_CONTEXT_MENUS) && USE(UICONTEXTMENU)
struct WebCore::MediaControlsContextMenuItem {
    uint64_t id;
    String title;
    String icon;
    bool checked;
    Vector<WebCore::MediaControlsContextMenuItem> children;
};
#endif

struct WebCore::WorkerOptions {
    WebCore::WorkerType type;
    WebCore::FetchRequestCredentials credentials;
    String name;
};

struct WebCore::WorkerInitializationData {
#if ENABLE(SERVICE_WORKER)
    std::optional<WebCore::ServiceWorkerData> serviceWorkerData;
#endif
    std::optional<WebCore::ScriptExecutionContextIdentifier> clientIdentifier;
    String userAgent;
};

struct WebCore::WorkerFetchResult {
    WebCore::ScriptBuffer script;
    URL responseURL;
    WebCore::CertificateInfo certificateInfo;
    WebCore::ContentSecurityPolicyResponseHeaders contentSecurityPolicy;
    WebCore::CrossOriginEmbedderPolicy crossOriginEmbedderPolicy;
    String referrerPolicy;
    WebCore::ResourceError error;
};

struct WebCore::SharedWorkerKey {
    WebCore::ClientOrigin origin;
    URL url;
    String name;
};

#if ENABLE(SERVICE_WORKER)

struct WebCore::ServiceWorkerRegistrationOptions {
    String scope;
    WebCore::WorkerType type;
    WebCore::ServiceWorkerUpdateViaCache updateViaCache;
};

class WebCore::ServiceWorkerRegistrationKey {
    WebCore::SecurityOriginData topOrigin();
    URL scope();
};

struct WebCore::ServiceWorkerRegistrationData {
    WebCore::ServiceWorkerRegistrationKey key;
    WebCore::ServiceWorkerRegistrationIdentifier identifier;
    URL scopeURL;
    WebCore::ServiceWorkerUpdateViaCache updateViaCache;
    WallTime lastUpdateTime;
    std::optional<WebCore::ServiceWorkerData> installingWorker;
    std::optional<WebCore::ServiceWorkerData> waitingWorker;
    std::optional<WebCore::ServiceWorkerData> activeWorker;
};

struct WebCore::ServiceWorkerJobDataIdentifier {
    WebCore::SWServerConnectionIdentifier connectionIdentifier;
    WebCore::ServiceWorkerJobIdentifier jobIdentifier;
};

struct WebCore::ServiceWorkerImportedScript {
    WebCore::ScriptBuffer script;
    URL responseURL;
    String mimeType;
};

header: <wtf/RobinHoodHashTable.h>
struct WebCore::ServiceWorkerContextData {
    std::optional<WebCore::ServiceWorkerJobDataIdentifier> jobDataIdentifier;
    WebCore::ServiceWorkerRegistrationData registration;
    WebCore::ServiceWorkerIdentifier serviceWorkerIdentifier;
    WebCore::ScriptBuffer script;
    WebCore::CertificateInfo certificateInfo;
    WebCore::ContentSecurityPolicyResponseHeaders contentSecurityPolicy;
    WebCore::CrossOriginEmbedderPolicy crossOriginEmbedderPolicy;
    String referrerPolicy;
    URL scriptURL;
    WebCore::WorkerType workerType;
    bool loadedFromDisk;
    std::optional<WebCore::LastNavigationWasAppInitiated> lastNavigationWasAppInitiated;
    MemoryCompactRobinHoodHashMap<URL, WebCore::ServiceWorkerImportedScript> scriptResourceMap;
    std::optional<WebCore::ScriptExecutionContextIdentifier> serviceWorkerPageIdentifier;
    WebCore::NavigationPreloadState navigationPreloadState;
};

#endif

#if HAVE(SCREEN_CAPTURE_KIT)
header: <WebCore/DisplayCapturePromptType.h>
enum class WebCore::DisplayCapturePromptType : uint8_t {
    Window,
    Screen,
    UserChoose
};
#endif

header: <JavaScriptCore/ArrayBuffer.h>
[RefCounted, CustomHeader] class JSC::ArrayBuffer {
    Vector<uint8_t> toVector();
}

enum class WebCore::TextIndicatorPresentationTransition : uint8_t {
    None,
    Bounce,
    BounceAndCrossfade,
    FadeIn,
};

[OptionSet] enum class WebCore::TextIndicatorOption : uint16_t {
    RespectTextColor,
    PaintBackgrounds,
    PaintAllContent,
    IncludeSnapshotWithSelectionHighlight,
    TightlyFitContent,
    UseBoundingRectAndPaintAllContentForComplexRanges,
    IncludeMarginIfRangeMatchesSelection,
    ExpandClipBeyondVisibleRect,
    DoNotClipToVisibleRect,
    IncludeSnapshotOfAllVisibleContentWithoutSelection,
    UseSelectionRectForSizing,
    ComputeEstimatedBackgroundColor,
    UseUserSelectAllCommonAncestor,
};

using WebCore::IDBConnectionIdentifier = WebCore::ProcessIdentifier;

using WebCore::TransferredMessagePort = std::pair<WebCore::MessagePortIdentifier, WebCore::MessagePortIdentifier>;

struct WebCore::GlobalFrameIdentifier {
    WebCore::PageIdentifier pageID;
    WebCore::FrameIdentifier frameID;
};

struct WebCore::GlobalWindowIdentifier {
    WebCore::ProcessIdentifier processIdentifier;
    WebCore::WindowIdentifier windowIdentifier;
};

[Nested] enum class WebCore::InteractionRegion::Type : bool;

struct WebCore::InteractionRegion {
    WebCore::ElementIdentifier elementIdentifier;
    WebCore::Region regionInLayerCoordinates;
    float borderRadius;
    WebCore::InteractionRegion::Type type;
};

[Nested] struct WebCore::Region::Span {
    int y;
    size_t segmentIndex;
};

[Nested] class WebCore::Region::Shape {
    Vector<int, 32> m_segments;
    Vector<WebCore::Region::Span, 16> m_spans;
};

class WebCore::Region {
    WebCore::IntRect bounds();
    std::unique_ptr<WebCore::Region::Shape> copyShape();
}

[Nested, OptionSet] enum class WebCore::FilterEffectGeometry::Flags : uint8_t {
    HasX,
    HasY,
    HasWidth,
    HasHeight
};
    
[AdditionalEncoder=StreamConnectionEncoder] class WebCore::FilterEffectGeometry {
    WebCore::FloatRect m_boundaries;
    OptionSet<WebCore::FilterEffectGeometry::Flags> m_flags;
};

header: <WebCore/ISOVTTCue.h>
[CustomHeader] class WebCore::ISOWebVTTCue {
    MediaTime presentationTime();
    MediaTime duration();
    AtomString id();
    String cueText();
    String settings();
    String sourceID();
    String originalStartTime();
}

#if ENABLE(WEB_AUTHN)

[Nested] enum class WebCore::MockWebAuthenticationConfiguration::UserVerification : uint8_t {
    No,
    Yes,
    Cancel,
    Presence
};

[Nested] struct WebCore::MockWebAuthenticationConfiguration::LocalConfiguration {
    WebCore::MockWebAuthenticationConfiguration::UserVerification userVerification;
    bool acceptAttestation;
    String privateKeyBase64;
    String userCertificateBase64;
    String intermediateCACertificateBase64;
    String preferredCredentialIdBase64;
};

[Nested] enum class WebCore::MockWebAuthenticationConfiguration::HidStage : bool;

[Nested] enum class WebCore::MockWebAuthenticationConfiguration::HidSubStage : bool;

[Nested] enum class WebCore::MockWebAuthenticationConfiguration::HidError : uint8_t {
    Success,
    DataNotSent,
    EmptyReport,
    WrongChannelId,
    MaliciousPayload,
    UnsupportedOptions,
    WrongNonce
};

[Nested] struct WebCore::MockWebAuthenticationConfiguration::HidConfiguration {
    Vector<String> payloadBase64;
    WebCore::MockWebAuthenticationConfiguration::HidStage stage;
    WebCore::MockWebAuthenticationConfiguration::HidSubStage subStage;
    WebCore::MockWebAuthenticationConfiguration::HidError error;
    bool isU2f;
    bool keepAlive;
    bool fastDataArrival;
    bool continueAfterErrorData;
    bool canDowngrade;
    bool expectCancel;
    bool supportClientPin;
    bool supportInternalUV;
};

[Nested] enum class WebCore::MockWebAuthenticationConfiguration::NfcError : uint8_t {
    Success,
    NoTags,
    WrongTagType,
    NoConnections,
    MaliciousPayload
};

[Nested] struct WebCore::MockWebAuthenticationConfiguration::NfcConfiguration {
    WebCore::MockWebAuthenticationConfiguration::NfcError error;
    Vector<String> payloadBase64;
    bool multipleTags;
    bool multiplePhysicalTags;
};

[Nested] struct WebCore::MockWebAuthenticationConfiguration::CcidConfiguration {
    Vector<String> payloadBase64;
};

struct WebCore::MockWebAuthenticationConfiguration {
    bool silentFailure;
    std::optional<WebCore::MockWebAuthenticationConfiguration::LocalConfiguration> local;
    std::optional<WebCore::MockWebAuthenticationConfiguration::HidConfiguration> hid;
    std::optional<WebCore::MockWebAuthenticationConfiguration::NfcConfiguration> nfc;
    std::optional<WebCore::MockWebAuthenticationConfiguration::CcidConfiguration> ccid;
};

#endif // ENABLE(WEB_AUTHN)

header: <WebCore/StorageType.h>
enum class WebCore::StorageType : uint8_t {
    Session,
    Local,
    TransientLocal,
};

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
struct WebCore::LengthPoint {
    WebCore::Length x();
    WebCore::Length y();
}

class WebCore::OffsetRotation {
    bool hasAuto();
    float angle();
}

[OptionSet] enum class WebCore::AcceleratedEffectProperty : uint16_t {
    Opacity,
    Transform,
    Translate,
    Rotate,
    Scale,
    OffsetPath,
    OffsetDistance,
    OffsetPosition,
    OffsetAnchor,
    OffsetRotate,
    Filter,
#if ENABLE(FILTERS_LEVEL_2)
    BackdropFilter
#endif
};

header: <WebCore/WebAnimationTypes.h>
[CustomHeader] enum class WebCore::WebAnimationType : uint8_t {
    CSSAnimation,
    CSSTransition,
    WebAnimation
};

enum class WebCore::FillMode : uint8_t {
    None,
    Forwards,
    Backwards,
    Both,
    Auto
};

enum class WebCore::PlaybackDirection : uint8_t {
    Normal,
    Reverse,
    Alternate,
    AlternateReverse
};

enum class WebCore::CompositeOperation : uint8_t {
    Replace,
    Add,
    Accumulate
};

struct WebCore::AcceleratedEffectValues {
    float opacity;
    WebCore::LengthPoint transformOrigin;
    WebCore::TransformOperations transform;
    RefPtr<WebCore::TransformOperation> translate;
    RefPtr<WebCore::TransformOperation> scale;
    RefPtr<WebCore::TransformOperation> rotate;
    RefPtr<WebCore::PathOperation> offsetPath;
    WebCore::Length offsetDistance;
    WebCore::LengthPoint offsetPosition;
    WebCore::LengthPoint offsetAnchor;
    WebCore::OffsetRotation offsetRotate;
    WebCore::FilterOperations filter;
#if ENABLE(FILTERS_LEVEL_2)
    WebCore::FilterOperations backdropFilter;
#endif
}

header: <WebCore/AcceleratedEffect.h>
[CustomHeader] struct WebCore::AcceleratedEffectKeyframe {
    double offset;
    WebCore::AcceleratedEffectValues values;
    RefPtr<WebCore::TimingFunction> timingFunction;
    std::optional<WebCore::CompositeOperation> compositeOperation;
    OptionSet<WebCore::AcceleratedEffectProperty> animatedProperties;
};

[RefCounted] class WebCore::AcceleratedEffect {
    Vector<WebCore::AcceleratedEffectKeyframe> keyframes();
    WebCore::WebAnimationType animationType();
    WebCore::FillMode fill();
    WebCore::PlaybackDirection direction();
    WebCore::CompositeOperation compositeOperation();
    RefPtr<WebCore::TimingFunction> timingFunction();
    RefPtr<WebCore::TimingFunction> defaultKeyframeTimingFunction();
    OptionSet<WebCore::AcceleratedEffectProperty> animatedProperties();
    bool paused();
    double iterationStart();
    double iterations();
    double playbackRate();
    WTF::Seconds delay();
    WTF::Seconds endDelay();
    WTF::Seconds iterationDuration();
    WTF::Seconds activeDuration();
    WTF::Seconds endTime();
    std::optional<WTF::Seconds> startTime();
    std::optional<WTF::Seconds> holdTime();
};
#endif // ENABLE(THREADED_ANIMATION_RESOLUTION)

#if PLATFORM(MAC)
header: <WebCore/CaretAnimator.h>
[CustomHeader] enum class WebCore::CaretAnimatorType : uint8_t {
    Default,
    Alternate,
};
#endif

[Nested] enum class WebCore::ProtectionSpace::ServerType : uint8_t {
    HTTP,
    HTTPS,
    FTP,
    FTPS,
    ProxyHTTP,
    ProxyHTTPS,
    ProxyFTP,
    ProxySOCKS
};

[Nested] enum class WebCore::ProtectionSpace::AuthenticationScheme : uint8_t {
    Default,
    HTTPBasic,
    HTTPDigest,
    HTMLForm,
    NTLM,
    Negotiate,
    ClientCertificateRequested,
    ServerTrustEvaluationRequested,
    OAuth,
#if USE(GLIB)
    ClientCertificatePINRequested,
#endif
    Unknown
};

class WebCore::ProtectionSpace {
    String host();
    int port();
    WebCore::ProtectionSpace::ServerType serverType();
    String realm();
    WebCore::ProtectionSpace::AuthenticationScheme authenticationScheme();
#if USE(CURL)
    WebCore::CertificateInfo certificateInfo();
#endif
#if PLATFORM(COCOA)
    std::optional<WebCore::ProtectionSpace::PlatformData> getPlatformDataToSerialize();
#endif
};
