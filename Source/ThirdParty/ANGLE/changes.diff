diff --git a/doc/ExtensionSupport.md b/doc/ExtensionSupport.md
index 79afe10ab0b545b090c0c85257b34d9fb41d8d7b..c92d3929bf29350609f3034a97c07a7a9ba5fcc1 100644
--- a/doc/ExtensionSupport.md
+++ b/doc/ExtensionSupport.md
@@ -221,6 +221,7 @@ using data from registry_xml.py and gl.xml.
 | [GL_ANGLE_memory_object_flags](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_memory_object_flags.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
 | [GL_ANGLE_memory_object_fuchsia](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_memory_object_fuchsia.txt) |  |  |  |  |  |  |  |
 | [GL_ANGLE_memory_size](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_memory_size.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
+| [GL_ANGLE_metal_schedule](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_metal_schedule.txt) |  |  |  |  |  |  |  |
 | [GL_ANGLE_multi_draw](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_multi_draw.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
 | [GL_ANGLE_multiview_multisample](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_multiview_multisample.txt) |  |  |  |  |  |  |  |
 | [GL_ANGLE_program_binary](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_program_binary.txt) |  |  |  |  |  |  |  |
diff --git a/extensions/ANGLE_metal_schedule.txt b/extensions/ANGLE_metal_schedule.txt
new file mode 100644
index 0000000000000000000000000000000000000000..361dacb28dc380e231478a65eea9a1126781dfa0
--- /dev/null
+++ b/extensions/ANGLE_metal_schedule.txt
@@ -0,0 +1,58 @@
+Name
+
+    ANGLE_metal_schedule
+
+Name Strings
+
+    GL_ANGLE_metal_schedule
+
+Contributors
+
+    Dan Glastonbury, Apple
+
+Contact
+
+    Dan Glastonbury, Apple (djg 'at' apple.com)
+
+Status
+
+    Draft
+
+Version
+
+    Last Modified Date: Mar 22, 2023
+    Revision: 1
+
+Number
+
+    TBD
+
+Dependencies
+
+    Written against the OpenGL ES 2.0 specifications
+
+Overview
+
+    This extension provides a way to ensure that all queued operations currently
+    in the pipeline have had their resources readied and are waiting for the GPU
+    to process them.
+
+    The motivation is to allow for the interoperation with multiple APIs through
+    shared resources, where the system needs to observe the dependencies to
+    sequence operations correctly. Currently, Finish() is required to ensure
+    these dependencies are met where Schedule() would suffice.
+ 
+New Procedures and Functions
+
+    The following commands are added:
+
+        void ScheduleANGLE(void);
+
+New Tokens
+
+    None
+
+Revision History
+
+    Revision 1, 2023-03-22 (Dan Glastonbury)
+        - Initial draft
diff --git a/include/GLES2/gl2ext_angle.h b/include/GLES2/gl2ext_angle.h
index 27e14795191c75750a6ac5095ce8ac3d8fcdfd4c..b3d3235607d0bbe02d03b3978448da3a77520a15 100644
--- a/include/GLES2/gl2ext_angle.h
+++ b/include/GLES2/gl2ext_angle.h
@@ -714,4 +714,13 @@ GL_APICALL void GL_APIENTRY glLogicOpANGLE (GLenum);
 #endif
 #endif /* GL_ANGLE_logic_op */
 
+#ifndef GL_ANGLE_metal_schedule
+#define GL_ANGLE_metal_schedule
+
+typedef void (GL_APIENTRYP PFNGLSCHEDULEANGLEPROC) ();
+#ifdef GL_GLEXT_PROTOTYPES
+GL_APICALL void GL_APIENTRY glScheduleANGLE ();
+#endif
+#endif /* GL_ANGLE_metal_schedule */
+
 #endif  // INCLUDE_GLES2_GL2EXT_ANGLE_H_
diff --git a/scripts/code_generation_hashes/Extension_files.json b/scripts/code_generation_hashes/Extension_files.json
index 74908bcf0f3fecbb1bd83559729c4070e7f5889f..6c7783d502394133582a1dd1b2104d523bf999e7 100644
--- a/scripts/code_generation_hashes/Extension_files.json
+++ b/scripts/code_generation_hashes/Extension_files.json
@@ -1,6 +1,6 @@
 {
   "doc/ExtensionSupport.md":
-    "8161eaef2c3f42dadefae2020b3822cc",
+    "94dc37c9ecb0654ae17b61115727e51e",
   "scripts/egl_angle_ext.xml":
     "bee532d3939bddbb2bb823645e2a5ab9",
   "scripts/extension_data/intel_630_linux.json":
@@ -20,15 +20,15 @@
   "scripts/extension_data/swiftshader_win10_gles1.json":
     "bea8e2106d62e1ea0e8938f150865a37",
   "scripts/gl_angle_ext.xml":
-    "a529bc9810e3c3d23e47944465d849f4",
+    "181134f2286068cd00ba52af50f3d5e6",
   "scripts/registry_xml.py":
-    "8dc1bcf2e8324094c19c41613897b212",
+    "3c9eeea85858ea0b4c34a898c5b4b879",
   "src/libANGLE/gen_extensions.py":
     "6ea1cb1733c4df98b527bbf2752e118b",
   "src/libANGLE/gles_extensions_autogen.cpp":
-    "533966f41f2f2fee23fe76ffdc2f00e5",
+    "2224e31d3502f37dfc5b7a5ff3ddb4b0",
   "src/libANGLE/gles_extensions_autogen.h":
-    "e0b24986c8d346e8b1f94d6259f51d87",
+    "9f13492049a80408c1a26b309ecc855b",
   "third_party/EGL-Registry/src/api/egl.xml":
     "2056d54ea07156f1988ca1366bdee21a",
   "third_party/OpenCL-Docs/src/xml/cl.xml":
diff --git a/scripts/code_generation_hashes/GL_EGL_WGL_loader.json b/scripts/code_generation_hashes/GL_EGL_WGL_loader.json
index 8050291f34e9828bced4b62c12da25cb90d23e73..02223719353c20014fa387fd5d20420b88481d7f 100644
--- a/scripts/code_generation_hashes/GL_EGL_WGL_loader.json
+++ b/scripts/code_generation_hashes/GL_EGL_WGL_loader.json
@@ -4,9 +4,9 @@
   "scripts/generate_loader.py":
     "93c78a8d11323fa311fed5118fbcf083",
   "scripts/gl_angle_ext.xml":
-    "a529bc9810e3c3d23e47944465d849f4",
+    "181134f2286068cd00ba52af50f3d5e6",
   "scripts/registry_xml.py":
-    "8dc1bcf2e8324094c19c41613897b212",
+    "3c9eeea85858ea0b4c34a898c5b4b879",
   "src/libEGL/egl_loader_autogen.cpp":
     "8a743c210f7dbe7e306849203dff7889",
   "src/libEGL/egl_loader_autogen.h":
@@ -26,17 +26,17 @@
   "util/capture/trace_egl_loader_autogen.h":
     "b16a510534ee9ee49152fca12b97bd9a",
   "util/capture/trace_gles_loader_autogen.cpp":
-    "1cb4deba2a534fde269ad3bc97853939",
+    "60adc4979eec917de643743b5702550f",
   "util/capture/trace_gles_loader_autogen.h":
-    "fd7217bbbbce239d581f10dffa2c25b0",
+    "dd08ff1017499d09d7549229589b2cfa",
   "util/egl_loader_autogen.cpp":
     "f98a6cfc104fc468efc90ae3789ddba5",
   "util/egl_loader_autogen.h":
     "84247f7f49720e169703fbeffc267023",
   "util/gles_loader_autogen.cpp":
-    "f83b9040aefb2a38c8b1bb7c591e16c1",
+    "c1a933eb4d4bfd4a56e5d63fc1846d56",
   "util/gles_loader_autogen.h":
-    "bc23a28f63f3d25269537ae127ea0d43",
+    "f831374c87ea3d41d4e51f6560e5dbeb",
   "util/windows/wgl_loader_autogen.cpp":
     "373b062587eab8a163121255f54597dc",
   "util/windows/wgl_loader_autogen.h":
diff --git a/scripts/code_generation_hashes/GL_EGL_entry_points.json b/scripts/code_generation_hashes/GL_EGL_entry_points.json
index 7fc4f97d6e4eaf059f7bffffec792eb109f96790..7150de93f70f3857dba61277e80bd32059efdc72 100644
--- a/scripts/code_generation_hashes/GL_EGL_entry_points.json
+++ b/scripts/code_generation_hashes/GL_EGL_entry_points.json
@@ -8,13 +8,13 @@
   "scripts/generate_entry_points.py":
     "9938b48a9bbf813dd245e453ff2fc0cc",
   "scripts/gl_angle_ext.xml":
-    "a529bc9810e3c3d23e47944465d849f4",
+    "181134f2286068cd00ba52af50f3d5e6",
   "scripts/registry_xml.py":
-    "8dc1bcf2e8324094c19c41613897b212",
+    "3c9eeea85858ea0b4c34a898c5b4b879",
   "src/common/entry_points_enum_autogen.cpp":
-    "a3485618a9f2b4d43c534ee26947f005",
+    "8f7e1a6f96fcc039489898bd97cd8fee",
   "src/common/entry_points_enum_autogen.h":
-    "14c10126610715d4980eee0256a526e3",
+    "5795b22181480e959c2d9a035f2fdade",
   "src/common/frame_capture_utils_autogen.cpp":
     "abfea27ee4c458bcd0de8c79e17fb70c",
   "src/common/frame_capture_utils_autogen.h":
@@ -38,7 +38,7 @@
   "src/libANGLE/Context_gles_3_2_autogen.h":
     "48567dca16fd881dfe6d61fee0e3106f",
   "src/libANGLE/Context_gles_ext_autogen.h":
-    "fa436644f856d4ccc85eff7bacb99040",
+    "e129f832cd9e7c5d4294f3d71668e48d",
   "src/libANGLE/capture/capture_egl_autogen.cpp":
     "a5b8f710309de8deab29f2e9d6414cd5",
   "src/libANGLE/capture/capture_egl_autogen.h":
@@ -80,9 +80,9 @@
   "src/libANGLE/capture/capture_gles_3_2_autogen.h":
     "74ed7366af3a46c0661397cfa29ec6fc",
   "src/libANGLE/capture/capture_gles_ext_autogen.cpp":
-    "4c3c24e42c4b11e5fda14849f31a6027",
+    "f35abd1cf40e6356714152671ee09bd2",
   "src/libANGLE/capture/capture_gles_ext_autogen.h":
-    "5d41f931a43c4d958d05c677fa5409aa",
+    "241bc9fc81d9fee69d5574eb16f0ff6e",
   "src/libANGLE/validationCL_autogen.h":
     "0022d0cdb6a9e2ef4a59b71164f62333",
   "src/libANGLE/validationEGL_autogen.h":
@@ -98,7 +98,7 @@
   "src/libANGLE/validationES3_autogen.h":
     "ffffaca63434b2b419614ddb25a57149",
   "src/libANGLE/validationESEXT_autogen.h":
-    "b9bac8b7ce3798075fbbcf74e7bcbef4",
+    "e4c782ac96ec32f12758893ca7606d55",
   "src/libANGLE/validationGL1_autogen.h":
     "a247dddc40418180d4b2dbefeb75f233",
   "src/libANGLE/validationGL2_autogen.h":
@@ -168,17 +168,17 @@
   "src/libGLESv2/entry_points_gles_3_2_autogen.h":
     "647f932a299cdb4726b60bbba059f0d2",
   "src/libGLESv2/entry_points_gles_ext_autogen.cpp":
-    "94c0df149eb8ec3c4bc1b56f66905732",
+    "f54b6981652bd70e418d18e1ccbbca81",
   "src/libGLESv2/entry_points_gles_ext_autogen.h":
-    "374c5d9c2aba33e1586113a84edbca9c",
+    "1bcedd3fa9bb4e1333e18678a5f53f1c",
   "src/libGLESv2/libGLESv2_autogen.cpp":
-    "7dd45f5fd7e709a66b4278a13454d23f",
+    "b253b11d6e5330905de54c0fe51c48f4",
   "src/libGLESv2/libGLESv2_autogen.def":
-    "de8c9ebbe5568444e774c889fde255ec",
+    "cf1ed6dc626da18571da8d39ac662db9",
   "src/libGLESv2/libGLESv2_no_capture_autogen.def":
-    "d9a29cfd4b9655d1a1f2b17040c8c120",
+    "e56e9bbff6d85a8653ceab53bb66e656",
   "src/libGLESv2/libGLESv2_with_capture_autogen.def":
-    "9af40fd332a11b7ae6d8d60fa5b15a04",
+    "fc4cab086bcc8335abb42af09406fab7",
   "src/libOpenCL/libOpenCL_autogen.cpp":
     "10849978c910dc1af5dd4f0c815d1581",
   "third_party/EGL-Registry/src/api/egl.xml":
@@ -192,5 +192,5 @@
   "third_party/OpenGL-Registry/src/xml/wgl.xml":
     "eae784bf4d1b983a42af5671b140b7c4",
   "util/capture/frame_capture_replay_autogen.cpp":
-    "f0759d49c9ecd8eea14233b9cdbbfbd0"
+    "856b7a32e72d7813376ad5dc4c28f7bc"
 }
\ No newline at end of file
diff --git a/scripts/code_generation_hashes/GLenum_value_to_string_map.json b/scripts/code_generation_hashes/GLenum_value_to_string_map.json
index 67642f85c1187e7fc564e68f08d724468705fd92..6b57479855cd9d9d413cb20b4260b1400fecf789 100644
--- a/scripts/code_generation_hashes/GLenum_value_to_string_map.json
+++ b/scripts/code_generation_hashes/GLenum_value_to_string_map.json
@@ -2,9 +2,9 @@
   "scripts/gen_gl_enum_utils.py":
     "3bab69a4a3555ab1551a6e5008534cec",
   "scripts/gl_angle_ext.xml":
-    "a529bc9810e3c3d23e47944465d849f4",
+    "181134f2286068cd00ba52af50f3d5e6",
   "scripts/registry_xml.py":
-    "8dc1bcf2e8324094c19c41613897b212",
+    "3c9eeea85858ea0b4c34a898c5b4b879",
   "src/common/gl_enum_utils_autogen.cpp":
     "707566f71285a34af9586baeef980b9f",
   "src/common/gl_enum_utils_autogen.h":
diff --git a/scripts/code_generation_hashes/Test_spec_JSON.json b/scripts/code_generation_hashes/Test_spec_JSON.json
index 290ab735848851f25a2363a23d9fc9e83b227286..ea5bbf5cd9e29ff4b4a69cd8a4cf4f4a1cb58847 100644
--- a/scripts/code_generation_hashes/Test_spec_JSON.json
+++ b/scripts/code_generation_hashes/Test_spec_JSON.json
@@ -16,5 +16,5 @@
   "testing/buildbot/generate_buildbot_json.py":
     "55e41e1e8f931bdcba3518521567b2b5",
   "testing/buildbot/mixins.pyl":
-    "add29e9f8f300729cff8ca191613b8b6"
+    "9765261683345b3f3acd9b468b1f2416"
 }
\ No newline at end of file
diff --git a/scripts/code_generation_hashes/Vulkan_mandatory_format_support_table.json b/scripts/code_generation_hashes/Vulkan_mandatory_format_support_table.json
index a2c381849acd36d823f077f88bee90429af54819..94bbf0ef70d85e25557732c7d080bf84f1895f55 100644
--- a/scripts/code_generation_hashes/Vulkan_mandatory_format_support_table.json
+++ b/scripts/code_generation_hashes/Vulkan_mandatory_format_support_table.json
@@ -10,5 +10,5 @@
   "src/libANGLE/renderer/vulkan/vk_mandatory_format_support_table_autogen.cpp":
     "a726ee791eb4964c406f3921d9b73346",
   "third_party/vulkan-deps/vulkan-headers/src/registry/vk.xml":
-    "948ee57f212862e34eee2ecaeb8efc0e"
+    "08f85542f828b5a8c38286e1cd2f67e6"
 }
\ No newline at end of file
diff --git a/scripts/code_generation_hashes/interpreter_utils.json b/scripts/code_generation_hashes/interpreter_utils.json
index f49e137ad91b6efe60631a6ea69abd6ea55a3232..918f783003aaab42742f2356757ecbdc38951d6d 100644
--- a/scripts/code_generation_hashes/interpreter_utils.json
+++ b/scripts/code_generation_hashes/interpreter_utils.json
@@ -4,9 +4,9 @@
   "scripts/gen_interpreter_utils.py":
     "10ba16ee78604763fc883525dd275de8",
   "scripts/gl_angle_ext.xml":
-    "a529bc9810e3c3d23e47944465d849f4",
+    "181134f2286068cd00ba52af50f3d5e6",
   "scripts/registry_xml.py":
-    "8dc1bcf2e8324094c19c41613897b212",
+    "3c9eeea85858ea0b4c34a898c5b4b879",
   "third_party/EGL-Registry/src/api/egl.xml":
     "2056d54ea07156f1988ca1366bdee21a",
   "third_party/OpenCL-Docs/src/xml/cl.xml":
@@ -20,5 +20,5 @@
   "util/capture/trace_fixture.h":
     "7eebdec11ef0719cf3fb46d6218eae7f",
   "util/capture/trace_interpreter_autogen.cpp":
-    "b8666163e3fec8bff10a71e4db7c7990"
+    "d804548eceb5c3759b048bd9122a4d72"
 }
\ No newline at end of file
diff --git a/scripts/code_generation_hashes/proc_table.json b/scripts/code_generation_hashes/proc_table.json
index 98f7b4fc569cc50fc8e8868a2c60fc736957f846..6c011608b93fb43ac82c9ff1bb71c88697066786 100644
--- a/scripts/code_generation_hashes/proc_table.json
+++ b/scripts/code_generation_hashes/proc_table.json
@@ -4,17 +4,17 @@
   "scripts/gen_proc_table.py":
     "073351265b085943f816498cecaa281c",
   "scripts/gl_angle_ext.xml":
-    "a529bc9810e3c3d23e47944465d849f4",
+    "181134f2286068cd00ba52af50f3d5e6",
   "scripts/registry_xml.py":
-    "8dc1bcf2e8324094c19c41613897b212",
+    "3c9eeea85858ea0b4c34a898c5b4b879",
   "src/libGLESv2/proc_table_cl_autogen.cpp":
     "ed003b0f041aaaa35b67d3fe07e61f91",
   "src/libGLESv2/proc_table_egl_autogen.cpp":
-    "3c8e273c7d52c66fb752d99f8b2f6014",
+    "a200e7dc88ecf56b81daaea064230186",
   "src/libGLESv2/proc_table_glx_autogen.cpp":
-    "88337654fe75030ccbd833eaebdd1c20",
+    "be8d1be37e13b85791dd800d81dc61ee",
   "src/libGLESv2/proc_table_wgl_autogen.cpp":
-    "eaa8b5c343b2091b4f596dfa509a7979",
+    "a6e473c597cafee9691a646e70f2b58c",
   "src/libOpenCL/libOpenCL_autogen.map":
     "bc5f5cf48227149ed321258a16eff1d7",
   "third_party/EGL-Registry/src/api/egl.xml":
diff --git a/scripts/gl_angle_ext.xml b/scripts/gl_angle_ext.xml
index 778d31a7b2224a16b7f8b54881b00397509d0de4..7b04cb91efbd462cb07b74635be4b5d4b84efae9 100644
--- a/scripts/gl_angle_ext.xml
+++ b/scripts/gl_angle_ext.xml
@@ -1025,6 +1025,9 @@
             <proto>void <name>glLogicOpANGLE</name></proto>
             <param group="LogicOp"><ptype>GLenum</ptype> <name>opcode</name></param>
         </command>
+        <command>
+            <proto>void <name>glScheduleANGLE</name></proto>
+        </command>
     </commands>
 
     <!-- SECTION: ANGLE extension interface definitions -->
@@ -1320,6 +1323,11 @@
                 <command name="glLogicOpANGLE"/>
             </require>
         </extension>
+        <extension name="GL_ANGLE_metal_schedule" supported="gles2">
+            <require>
+                <command name="glScheduleANGLE"/>
+            </require>
+        </extension>
     </extensions>
 
     <!-- SECTION: GL enumerant (token) definitions. -->
diff --git a/scripts/registry_xml.py b/scripts/registry_xml.py
index 87b125b3e93693e0da8ae56bf079f652622f89d8..1a5d2f277aeea90a1db771067243f7804bae64cb 100644
--- a/scripts/registry_xml.py
+++ b/scripts/registry_xml.py
@@ -58,6 +58,7 @@ angle_requestable_extensions = [
     "GL_ANGLE_memory_object_flags",
     "GL_ANGLE_memory_object_fuchsia",
     "GL_ANGLE_memory_size",
+    "GL_ANGLE_metal_schedule",
     "GL_ANGLE_multi_draw",
     "GL_ANGLE_multiview_multisample",
     "GL_ANGLE_provoking_vertex",
diff --git a/src/angle_commit.h.TEMP b/src/angle_commit.h.TEMP
new file mode 100644
index 0000000000000000000000000000000000000000..41ab97a66a558a75c3f0b961703c62084c0fa76e
--- /dev/null
+++ b/src/angle_commit.h.TEMP
@@ -0,0 +1,4 @@
+#define ANGLE_COMMIT_HASH "389b86e7d76c"
+#define ANGLE_COMMIT_HASH_SIZE 12
+#define ANGLE_COMMIT_DATE "2023-02-23 09:47:51 +0000"
+#define ANGLE_COMMIT_POSITION 20574
diff --git a/src/common/ANGLEShaderProgramVersion.h b/src/common/ANGLEShaderProgramVersion.h
new file mode 100644
index 0000000000000000000000000000000000000000..56af66411529bea41fe1837a6b5b2a414774068a
--- /dev/null
+++ b/src/common/ANGLEShaderProgramVersion.h
@@ -0,0 +1,2 @@
+#define ANGLE_PROGRAM_VERSION "04aaab59a833345418c7917ae2c77abc"
+#define ANGLE_PROGRAM_VERSION_HASH_SIZE 16
diff --git a/src/common/entry_points_enum_autogen.cpp b/src/common/entry_points_enum_autogen.cpp
index 282b5d63a2ca99a6c0884e6d190793b38ba737aa..08e1791c620dfa91c8ac80a1682d45df5db68d16 100644
--- a/src/common/entry_points_enum_autogen.cpp
+++ b/src/common/entry_points_enum_autogen.cpp
@@ -2642,6 +2642,8 @@ const char *GetEntryPointName(EntryPoint ep)
             return "glScalef";
         case EntryPoint::GLScalex:
             return "glScalex";
+        case EntryPoint::GLScheduleANGLE:
+            return "glScheduleANGLE";
         case EntryPoint::GLScissor:
             return "glScissor";
         case EntryPoint::GLScissorArrayv:
diff --git a/src/common/entry_points_enum_autogen.h b/src/common/entry_points_enum_autogen.h
index a2343870a09d228cf5aaa55694a3e946e838982b..e2032a05e012e3be062a5a43f4a0d3ba98eaf00e 100644
--- a/src/common/entry_points_enum_autogen.h
+++ b/src/common/entry_points_enum_autogen.h
@@ -1327,6 +1327,7 @@ enum class EntryPoint
     GLScaled,
     GLScalef,
     GLScalex,
+    GLScheduleANGLE,
     GLScissor,
     GLScissorArrayv,
     GLScissorIndexed,
diff --git a/src/common/utilities.cpp b/src/common/utilities.cpp
index 7a0a706519887e596a18e2dbd3489051c78c7ba0..f11469503fd488b856e448c8ed8385d01cc522f1 100644
--- a/src/common/utilities.cpp
+++ b/src/common/utilities.cpp
@@ -6,6 +6,12 @@
 
 // utilities.cpp: Conversion functions and other utility routines.
 
+// Older clang versions have a false positive on this warning here.
+// TODO(dino): Is this still necessary?
+#if defined(__clang__)
+#    pragma clang diagnostic ignored "-Wglobal-constructors"
+#endif
+
 #include "common/utilities.h"
 #include "GLES3/gl3.h"
 #include "common/mathutil.h"
diff --git a/src/compiler/preprocessor/preprocessor_tab_autogen.cpp b/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
index a7607c9e529ce7a57bdc6c3c82134b144eb67130..c9ec1adec020589bd4fcfe226721042a8f2c6cf5 100644
--- a/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
+++ b/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.8.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
diff --git a/src/compiler/translator/glslang_tab_autogen.cpp b/src/compiler/translator/glslang_tab_autogen.cpp
index 233b571b7985ba9d33b245f495725851a12be569..6bd263e0b1ec4137e5b8bb1a6269ce07cc8a6b32 100644
--- a/src/compiler/translator/glslang_tab_autogen.cpp
+++ b/src/compiler/translator/glslang_tab_autogen.cpp
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.8.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
diff --git a/src/compiler/translator/glslang_tab_autogen.h b/src/compiler/translator/glslang_tab_autogen.h
index d5a48edd40f382359db76acf1a1ce75b6a6dc6d5..907c62e0bb659292b3912707904981863429478a 100644
--- a/src/compiler/translator/glslang_tab_autogen.h
+++ b/src/compiler/translator/glslang_tab_autogen.h
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.8.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison interface for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
diff --git a/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.cpp b/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.cpp
index 55e2f8b9717ec73d2d52607d400352f5f4c0c191..4237558526274ea3e643d45ccf574b6b10eac785 100644
--- a/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.cpp
+++ b/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.cpp
@@ -10,6 +10,7 @@
 #include "compiler/translator/tree_util/IntermNode_util.h"
 #include "compiler/translator/tree_util/IntermTraverse.h"
 
+#if defined(ANGLE_ENABLE_GLSL) && defined(ANGLE_ENABLE_APPLE_WORKAROUNDS)
 namespace sh
 {
 
@@ -70,5 +71,5 @@ bool UnfoldShortCircuitAST(TCompiler *compiler, TIntermBlock *root)
     root->traverse(&traverser);
     return traverser.updateTree(compiler, root);
 }
-
+#endif
 }  // namespace sh
diff --git a/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.h b/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.h
index 101e04ccdc4a7217be38960dd372878ad4c15472..9ddc681d320550b171a2916cac8e9a4b1c3b7fab 100644
--- a/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.h
+++ b/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.h
@@ -12,7 +12,6 @@
 
 #include "common/angleutils.h"
 #include "common/debug.h"
-
 namespace sh
 {
 
diff --git a/src/libANGLE/Context.cpp b/src/libANGLE/Context.cpp
index 5f6fece19342054aff074c72b5f6eed5782f237a..26d01f548900879ca90fa82177937fd2a680fbbf 100644
--- a/src/libANGLE/Context.cpp
+++ b/src/libANGLE/Context.cpp
@@ -2814,6 +2814,11 @@ void Context::finish()
     ANGLE_CONTEXT_TRY(mImplementation->finish(this));
 }
 
+void Context::schedule()
+{
+    ANGLE_CONTEXT_TRY(mImplementation->schedule(this));
+}
+
 void Context::insertEventMarker(GLsizei length, const char *marker)
 {
     ASSERT(mImplementation);
diff --git a/src/libANGLE/Context_gles_ext_autogen.h b/src/libANGLE/Context_gles_ext_autogen.h
index 1dc2322ed5b39aca04e8d13b6e0b226002850b69..610fcef9c90b5a1cf81d31c904c769c0de47fb3a 100644
--- a/src/libANGLE/Context_gles_ext_autogen.h
+++ b/src/libANGLE/Context_gles_ext_autogen.h
@@ -407,6 +407,8 @@
     void importMemoryZirconHandle(MemoryObjectID memoryPacked, GLuint64 size,                      \
                                   HandleType handleTypePacked, GLuint handle);                     \
     /* GL_ANGLE_memory_size */                                                                     \
+    /* GL_ANGLE_metal_schedule */                                                                  \
+    void schedule();                                                                               \
     /* GL_ANGLE_multi_draw */                                                                      \
     void multiDrawArrays(PrimitiveMode modePacked, const GLint *firsts, const GLsizei *counts,     \
                          GLsizei drawcount);                                                       \
diff --git a/src/libANGLE/State.cpp b/src/libANGLE/State.cpp
index 46987ac1bb7ecad90214c33195c3a8f6bd0b59de..a14357ee88fa76f4d675d5463210cb8b17db65b4 100644
--- a/src/libANGLE/State.cpp
+++ b/src/libANGLE/State.cpp
@@ -6,6 +6,9 @@
 
 // State.cpp: Implements the State class, encapsulating raw GL state.
 
+// Older clang versions have a false positive on this warning here.
+#pragma clang diagnostic ignored "-Wglobal-constructors"
+
 #include "libANGLE/State.h"
 
 #include <string.h>
diff --git a/src/libANGLE/capture/capture_gles_ext_autogen.cpp b/src/libANGLE/capture/capture_gles_ext_autogen.cpp
index 54ddc8e4863e40b8851cc7967ff6f3cc52217840..91f3fda79c0bb73f93d9ac3245cc601aaefe1739 100644
--- a/src/libANGLE/capture/capture_gles_ext_autogen.cpp
+++ b/src/libANGLE/capture/capture_gles_ext_autogen.cpp
@@ -1260,6 +1260,13 @@ CallCapture CaptureImportMemoryZirconHandleANGLE(const State &glState,
     return CallCapture(angle::EntryPoint::GLImportMemoryZirconHandleANGLE, std::move(paramBuffer));
 }
 
+CallCapture CaptureScheduleANGLE(const State &glState, bool isCallValid)
+{
+    ParamBuffer paramBuffer;
+
+    return CallCapture(angle::EntryPoint::GLScheduleANGLE, std::move(paramBuffer));
+}
+
 CallCapture CaptureMultiDrawArraysANGLE(const State &glState,
                                         bool isCallValid,
                                         PrimitiveMode modePacked,
diff --git a/src/libANGLE/capture/capture_gles_ext_autogen.h b/src/libANGLE/capture/capture_gles_ext_autogen.h
index b2b0e9e7402adf5a2c5f405afcc49ebf20901f31..63f7a2f0c357cf485b67115629d5964af5ed9d9a 100644
--- a/src/libANGLE/capture/capture_gles_ext_autogen.h
+++ b/src/libANGLE/capture/capture_gles_ext_autogen.h
@@ -298,6 +298,9 @@ angle::CallCapture CaptureImportMemoryZirconHandleANGLE(const State &glState,
                                                         HandleType handleTypePacked,
                                                         GLuint handle);
 
+// GL_ANGLE_metal_schedule
+angle::CallCapture CaptureScheduleANGLE(const State &glState, bool isCallValid);
+
 // GL_ANGLE_multi_draw
 angle::CallCapture CaptureMultiDrawArraysANGLE(const State &glState,
                                                bool isCallValid,
diff --git a/src/libANGLE/gles_extensions_autogen.cpp b/src/libANGLE/gles_extensions_autogen.cpp
index 746ed9e9b18ff17bd15177d92a867ffbbae9b1d5..f12be9e3d3fab4449ce2cfd228afa300a34ac659 100644
--- a/src/libANGLE/gles_extensions_autogen.cpp
+++ b/src/libANGLE/gles_extensions_autogen.cpp
@@ -233,6 +233,7 @@ const ExtensionInfoMap &GetExtensionInfoMap()
         map["GL_ANGLE_memory_object_flags"] = enableableExtension(&Extensions::memoryObjectFlagsANGLE);
         map["GL_ANGLE_memory_object_fuchsia"] = enableableExtension(&Extensions::memoryObjectFuchsiaANGLE);
         map["GL_ANGLE_memory_size"] = enableableExtension(&Extensions::memorySizeANGLE);
+        map["GL_ANGLE_metal_schedule"] = enableableExtension(&Extensions::metalScheduleANGLE);
         map["GL_ANGLE_multi_draw"] = enableableExtension(&Extensions::multiDrawANGLE);
         map["GL_ANGLE_multiview_multisample"] = enableableExtension(&Extensions::multiviewMultisampleANGLE);
         map["GL_ANGLE_program_binary"] = esOnlyExtension(&Extensions::programBinaryANGLE);
diff --git a/src/libANGLE/gles_extensions_autogen.h b/src/libANGLE/gles_extensions_autogen.h
index 3f5163057f757775fa7b57b2167c10665fb0b821..5d82fbb4ffa8914f1f07e9a1003919155f20d9ca 100644
--- a/src/libANGLE/gles_extensions_autogen.h
+++ b/src/libANGLE/gles_extensions_autogen.h
@@ -655,6 +655,9 @@ struct Extensions
     // GL_ANGLE_memory_size
     bool memorySizeANGLE = false;
 
+    // GL_ANGLE_metal_schedule
+    bool metalScheduleANGLE = false;
+
     // GL_ANGLE_multi_draw
     bool multiDrawANGLE = false;
 
diff --git a/src/libANGLE/renderer/ContextImpl.cpp b/src/libANGLE/renderer/ContextImpl.cpp
index a05a86d6bf8a670350dd6cef91c8f2def648c49f..f4d447868e92b083c7773f0a3e7c30ebdb31f1c4 100644
--- a/src/libANGLE/renderer/ContextImpl.cpp
+++ b/src/libANGLE/renderer/ContextImpl.cpp
@@ -106,4 +106,11 @@ angle::Result ContextImpl::drawPixelLocalStorageEXTDisable(gl::Context *,
     UNREACHABLE();
     return angle::Result::Stop;
 }
+
+angle::Result ContextImpl::schedule(const gl::Context *)
+{
+    UNREACHABLE();
+    return angle::Result::Stop;
+}
+
 }  // namespace rx
diff --git a/src/libANGLE/renderer/ContextImpl.h b/src/libANGLE/renderer/ContextImpl.h
index 825ea294e758b9ca1e907800fccd0b4109b66024..54f9c8e5fccb1292f2adb517ca025295c8455c6d 100644
--- a/src/libANGLE/renderer/ContextImpl.h
+++ b/src/libANGLE/renderer/ContextImpl.h
@@ -281,6 +281,9 @@ class ContextImpl : public GLImplFactory
                                                           const gl::PixelLocalStoragePlane[],
                                                           const GLenum storeops[]);
 
+    // GL_ANGLE_metal_schedule
+    virtual angle::Result schedule(const gl::Context *);
+
   protected:
     const gl::State &mState;
     gl::MemoryProgramCache *mMemoryProgramCache;
diff --git a/src/libANGLE/renderer/metal/BufferMtl.mm b/src/libANGLE/renderer/metal/BufferMtl.mm
index e261e90255c6de20704e79b01a6575fc120e6f84..dc5a3613d1532a9c6e3162c9fdce996378927a9e 100644
--- a/src/libANGLE/renderer/metal/BufferMtl.mm
+++ b/src/libANGLE/renderer/metal/BufferMtl.mm
@@ -372,7 +372,7 @@ ConversionBufferMtl *BufferMtl::getUniformConversionBuffer(ContextMtl *context,
         {
             if (buffer.offset.second <= offset.second &&
                 (offset.second - buffer.offset.second) % buffer.uniformBufferBlockSize == 0)
-                return &buffer;
+                return static_cast<ConversionBufferMtl *>(&buffer);
         }
     }
 
diff --git a/src/libANGLE/renderer/metal/ContextMtl.h b/src/libANGLE/renderer/metal/ContextMtl.h
index 73addd6bcfca5b628df96feffca7617876f5e78b..5ddc2e1ea04c2b69a69f2e26c40227a73b1ba120 100644
--- a/src/libANGLE/renderer/metal/ContextMtl.h
+++ b/src/libANGLE/renderer/metal/ContextMtl.h
@@ -50,6 +50,7 @@ class ContextMtl : public ContextImpl, public mtl::Context
     // Flush and finish.
     angle::Result flush(const gl::Context *context) override;
     angle::Result finish(const gl::Context *context) override;
+    angle::Result schedule(const gl::Context *context) override;
 
     // Drawing methods.
     angle::Result drawArrays(const gl::Context *context,
diff --git a/src/libANGLE/renderer/metal/ContextMtl.mm b/src/libANGLE/renderer/metal/ContextMtl.mm
index df9dadabc57d29d0ee96617827f5f6e837578af2..b9d6730bb7c717d4e4c247954c2b1f4b819f31f8 100644
--- a/src/libANGLE/renderer/metal/ContextMtl.mm
+++ b/src/libANGLE/renderer/metal/ContextMtl.mm
@@ -309,12 +309,19 @@ angle::Result ContextMtl::flush(const gl::Context *context)
     }
     return angle::Result::Continue;
 }
+
 angle::Result ContextMtl::finish(const gl::Context *context)
 {
     ANGLE_TRY(finishCommandBuffer());
     return angle::Result::Continue;
 }
 
+angle::Result ContextMtl::schedule(const gl::Context *context)
+{
+    flushCommandBuffer(mtl::WaitUntilScheduled);
+    return angle::Result::Continue;
+}
+
 // Drawing methods.
 angle::Result ContextMtl::drawTriFanArraysWithBaseVertex(const gl::Context *context,
                                                          GLint first,
@@ -2439,8 +2446,21 @@ angle::Result ContextMtl::setupDraw(const gl::Context *context,
             return angle::Result::Continue;
         }
         // Setup with flushed state should either produce a working encoder or fail with an error
-        // result.
-        ASSERT(mRenderEncoder.valid());
+        // result. if that's not the case, something's gone seriously wrong. Try to
+        // recover from the error by bailing out of the draw call, and finishing the command buffer. This will result in an unfinished / corrupted draw,
+        // but will avoid a browser/GPU process crash.
+        if(ANGLE_UNLIKELY(!mRenderEncoder.valid() || !mRenderEncoder.hasPipelineState()))
+        {
+            // Completely flush the command buffer, waiting synchronously.
+            flushCommandBuffer(mtl::WaitUntilFinished);
+            // Invalidate all state
+            invalidateState(context);
+            // Return fail, and drop the draw call. This is
+            // a worst case scenario. If in a debug roots situation,
+            // we should try to catch the call stack.
+            ERR() << "Draw call is unusable - please report a bug on bugs.webkit.org";
+            return angle::Result::Stop;
+        }
     }
     return angle::Result::Continue;
 }
diff --git a/src/libANGLE/renderer/metal/DisplayMtl.mm b/src/libANGLE/renderer/metal/DisplayMtl.mm
index ea9a09f233bd2fd3ff2531600a4796c6ade8b2f7..35e9b788ef2662e5a0549efa022c38f96fcc88ac 100644
--- a/src/libANGLE/renderer/metal/DisplayMtl.mm
+++ b/src/libANGLE/renderer/metal/DisplayMtl.mm
@@ -1359,8 +1359,7 @@ bool DisplayMtl::supportsEitherGPUFamily(uint8_t iOSFamily, uint8_t macFamily) c
 bool DisplayMtl::supports32BitFloatFiltering() const
 {
 #if (defined(__MAC_11_0) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_11_0) ||        \
-    (defined(__IPHONE_14_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_14_0) || \
-    (defined(__TVOS_14_0) && __TV_OS_VERSION_MIN_REQUIRED >= __TVOS_14_0)
+    (defined(__IPHONE_14_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_14_0)
     if (@available(ios 14.0, macOS 11.0, *))
     {
         return [mMetalDevice supports32BitFloatFiltering];
diff --git a/src/libANGLE/renderer/metal/FrameBufferMtl.mm b/src/libANGLE/renderer/metal/FrameBufferMtl.mm
index a74c4e6d9a0b930dd0f8c3c10f5e417f9d033f30..746dd53eee510da93f4498bb301f71e8b401582f 100644
--- a/src/libANGLE/renderer/metal/FrameBufferMtl.mm
+++ b/src/libANGLE/renderer/metal/FrameBufferMtl.mm
@@ -1666,8 +1666,10 @@ angle::Result FramebufferMtl::readPixelsToPBO(const gl::Context *context,
 
     ContextMtl *contextMtl = mtl::GetImpl(context);
 
-    ANGLE_MTL_CHECK(contextMtl, packPixelsParams.offset <= std::numeric_limits<uint32_t>::max(),
+    if constexpr (sizeof(packPixelsParams.offset) > sizeof(uint32_t)) {
+        ANGLE_MTL_CHECK(contextMtl, static_cast<std::make_unsigned_t<decltype(packPixelsParams.offset)>>(packPixelsParams.offset) <= std::numeric_limits<uint32_t>::max(),
                         GL_INVALID_OPERATION);
+    }
     uint32_t offset = static_cast<uint32_t>(packPixelsParams.offset);
 
     BufferMtl *packBufferMtl = mtl::GetImpl(packPixelsParams.packBuffer);
diff --git a/src/libANGLE/renderer/metal/ProgramMtl.mm b/src/libANGLE/renderer/metal/ProgramMtl.mm
index 2855cbfc1adf69c01b70278e454b68dfdcfca4ae..9d731ac417dc6b7d7adbff8f938c6ee6d448c44c 100644
--- a/src/libANGLE/renderer/metal/ProgramMtl.mm
+++ b/src/libANGLE/renderer/metal/ProgramMtl.mm
@@ -1540,7 +1540,7 @@ angle::Result ProgramMtl::setupDraw(const gl::Context *glContext,
                                     bool uniformBuffersDirty)
 {
     ContextMtl *context = mtl::GetImpl(glContext);
-    if (pipelineDescChanged)
+    if (pipelineDescChanged || !cmdEncoder->hasPipelineState())
     {
         // Render pipeline state needs to be changed
         id<MTLRenderPipelineState> pipelineState =
diff --git a/src/libANGLE/renderer/metal/VertexArrayMtl.mm b/src/libANGLE/renderer/metal/VertexArrayMtl.mm
index 30f2faac716e9ac4e1a2005cccdaff61faa06233..f66c831fc00fe645206fb0b9b5341abd2927867a 100644
--- a/src/libANGLE/renderer/metal/VertexArrayMtl.mm
+++ b/src/libANGLE/renderer/metal/VertexArrayMtl.mm
@@ -1092,16 +1092,21 @@ angle::Result VertexArrayMtl::convertVertexBufferGPU(const gl::Context *glContex
     ANGLE_TRY(conversion->data.allocate(contextMtl, numVertices * targetStride, nullptr, &newBuffer,
                                         &newBufferOffset));
 
-    ANGLE_CHECK_GL_MATH(contextMtl, binding.getOffset() <= std::numeric_limits<uint32_t>::max());
+    GLintptr bindingOffset = binding.getOffset();
+
+    if constexpr (sizeof(bindingOffset) > sizeof(uint32_t))
+        ANGLE_CHECK_GL_MATH(contextMtl, static_cast<std::make_unsigned_t<decltype(bindingOffset)>>(bindingOffset) <= std::numeric_limits<uint32_t>::max());
     ANGLE_CHECK_GL_MATH(contextMtl, newBufferOffset <= std::numeric_limits<uint32_t>::max());
     ANGLE_CHECK_GL_MATH(contextMtl, numVertices <= std::numeric_limits<uint32_t>::max());
 
     mtl::VertexFormatConvertParams params;
     VertexConversionBufferMtl *vertexConversion =
         static_cast<VertexConversionBufferMtl *>(conversion);
+    if constexpr (sizeof(vertexConversion->offset) > sizeof(uint32_t))
+        ANGLE_CHECK_GL_MATH(contextMtl, vertexConversion->offset <= std::numeric_limits<uint32_t>::max());
     params.srcBuffer            = srcBuffer->getCurrentBuffer();
-    params.srcBufferStartOffset = static_cast<uint32_t>(
-        MIN(static_cast<GLintptr>(vertexConversion->offset), binding.getOffset()));
+    params.srcBufferStartOffset = std::min(
+        static_cast<uint32_t>(vertexConversion->offset), static_cast<uint32_t>(bindingOffset));
     params.srcStride           = binding.getStride();
     params.srcDefaultAlphaData = convertedFormat.defaultAlpha;
 
diff --git a/src/libANGLE/renderer/metal/mtl_command_buffer.h b/src/libANGLE/renderer/metal/mtl_command_buffer.h
index aa42b9fe58729ab74699e0e638b94d577b8cc3e6..c7df3484536d9656e6f8aa7c0914a4cc3ef3d7c6 100644
--- a/src/libANGLE/renderer/metal/mtl_command_buffer.h
+++ b/src/libANGLE/renderer/metal/mtl_command_buffer.h
@@ -533,6 +533,7 @@ class RenderCommandEncoder final : public CommandEncoder
 
     const RenderPassDesc &renderPassDesc() const { return mRenderPassDesc; }
     bool hasDrawCalls() const { return mHasDrawCalls; }
+    bool hasPipelineState() const { return mPipelineStateSet; }
 
   private:
     // Override CommandEncoder
diff --git a/src/libANGLE/renderer/metal/mtl_command_buffer.mm b/src/libANGLE/renderer/metal/mtl_command_buffer.mm
index bcbe2a6303d2eda2ff7550da0b274b725ff32c6e..ffefdf656c8ce494629319804b17526b9dc56179 100644
--- a/src/libANGLE/renderer/metal/mtl_command_buffer.mm
+++ b/src/libANGLE/renderer/metal/mtl_command_buffer.mm
@@ -364,24 +364,38 @@ inline void SetVisibilityResultModeCmd(id<MTLRenderCommandEncoder> encoder,
     [encoder setVisibilityResultMode:mode offset:offset];
 }
 
+#if (defined(__MAC_10_15) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_15) || \
+    (defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_13_0)
+#   define ANGLE_MTL_USE_RESOURCE_USAGE_STAGES_AVAILABLE 1
+#endif
+
+#if (defined(__MAC_13_0) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_13_0) || \
+    (defined(__IPHONE_16_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_16_0)
+#   define ANGLE_MTL_USE_RESOURCE_USAGE_DEPRECATED 1
+#endif
+
 inline void UseResourceCmd(id<MTLRenderCommandEncoder> encoder, IntermediateCommandStream *stream)
 {
     id<MTLResource> resource = stream->fetch<id<MTLResource>>();
     MTLResourceUsage usage   = stream->fetch<MTLResourceUsage>();
     mtl::RenderStages stages = stream->fetch<mtl::RenderStages>();
     ANGLE_UNUSED_VARIABLE(stages);
-#if defined(__IPHONE_13_0) || defined(__MAC_10_15)
+#if ANGLE_MTL_USE_RESOURCE_USAGE_DEPRECATED
+    [encoder useResource:resource usage:usage stages:stages];
+#else
+#   if ANGLE_MTL_USE_RESOURCE_USAGE_STAGES_AVAILABLE
     if (ANGLE_APPLE_AVAILABLE_XCI(10.15, 13.0, 13.0))
     {
         [encoder useResource:resource usage:usage stages:stages];
     }
     else
-#endif
+#   endif
     {
         ANGLE_APPLE_ALLOW_DEPRECATED_BEGIN
         [encoder useResource:resource usage:usage];
         ANGLE_APPLE_ALLOW_DEPRECATED_END
     }
+#endif
     [resource ANGLE_MTL_RELEASE];
 }
 
diff --git a/src/libANGLE/renderer/metal/mtl_render_utils.mm b/src/libANGLE/renderer/metal/mtl_render_utils.mm
index 4b854d589c5c7042ba8ab2e32960425c4070eb2a..1e2b6888ef205c355b2220fb36d3b889a614fa25 100644
--- a/src/libANGLE/renderer/metal/mtl_render_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_render_utils.mm
@@ -2540,45 +2540,13 @@ angle::Result MipmapUtils::generateMipmapCS(ContextMtl *contextMtl,
                                             bool sRGBMipmap,
                                             NativeTexLevelArray *mipmapOutputViews)
 {
-    // Only support 3D texture for now.
-    ASSERT(srcTexture->textureType() == MTLTextureType3D);
-
     MTLSize threadGroupSize;
     uint32_t slices                             = 1;
     id<MTLComputePipelineState> computePipeline = nil;
-
-    ensure3DMipGeneratorPipelineInitialized(contextMtl);
-    computePipeline = m3DMipGeneratorPipeline;
-    threadGroupSize =
-        MTLSizeMake(kGenerateMipThreadGroupSizePerDim, kGenerateMipThreadGroupSizePerDim,
-                    kGenerateMipThreadGroupSizePerDim);
-
     // The compute shader supports up to 4 mipmaps generated per pass.
     // See shaders/gen_mipmap.metal
     uint32_t maxMipsPerBatch = 4;
 
-    if (threadGroupSize.width * threadGroupSize.height * threadGroupSize.depth >
-            computePipeline.maxTotalThreadsPerThreadgroup ||
-        ANGLE_UNLIKELY(
-            !contextMtl->getDisplay()->getFeatures().allowGenMultipleMipsPerPass.enabled))
-    {
-        // Multiple mipmaps generation is not supported due to hardware's thread group size limits.
-        // Fallback to generate one mip per pass and reduce thread group size.
-        if (ANGLE_UNLIKELY(threadGroupSize.width * threadGroupSize.height >
-                           computePipeline.maxTotalThreadsPerThreadgroup))
-        {
-            // Even with reduced thread group size, we cannot proceed.
-            // HACK: use blit command encoder to generate mipmaps if it is not possible
-            // to use compute shader due to hardware limits.
-            BlitCommandEncoder *blitEncoder = contextMtl->getBlitCommandEncoder();
-            blitEncoder->generateMipmapsForTexture(srcTexture);
-            return angle::Result::Continue;
-        }
-
-        threadGroupSize.depth = 1;
-        maxMipsPerBatch       = 1;
-    }
-
     ComputeCommandEncoder *cmdEncoder = contextMtl->getComputeCommandEncoder();
     ASSERT(cmdEncoder);
 
@@ -2615,8 +2583,29 @@ angle::Result MipmapUtils::generateMipmapCS(ContextMtl *contextMtl,
             UNREACHABLE();
     }
 
-    Generate3DMipmapUniform options;
+    if (threadGroupSize.width * threadGroupSize.height * threadGroupSize.depth >
+            computePipeline.maxTotalThreadsPerThreadgroup ||
+        ANGLE_UNLIKELY(
+            !contextMtl->getDisplay()->getFeatures().allowGenMultipleMipsPerPass.enabled))
+    {
+        // Multiple mipmaps generation is not supported due to hardware's thread group size limits.
+        // Fallback to generate one mip per pass and reduce thread group size.
+        if (ANGLE_UNLIKELY(threadGroupSize.width * threadGroupSize.height >
+                           computePipeline.maxTotalThreadsPerThreadgroup))
+        {
+            // Even with reduced thread group size, we cannot proceed.
+            // HACK: use blit command encoder to generate mipmaps if it is not possible
+            // to use compute shader due to hardware limits.
+            BlitCommandEncoder *blitEncoder = contextMtl->getBlitCommandEncoder();
+            blitEncoder->generateMipmapsForTexture(srcTexture);
+            return angle::Result::Continue;
+        }
+
+        threadGroupSize.depth = 1;
+        maxMipsPerBatch       = 1;
+    }
 
+    Generate3DMipmapUniform options;
     uint32_t remainMips             = srcTexture->mipmapLevels() - 1;
     MipmapNativeLevel batchSrcLevel = kZeroNativeMipLevel;
     options.srcLevel                = batchSrcLevel.get();
diff --git a/src/libANGLE/renderer/metal/mtl_resource_spi.h b/src/libANGLE/renderer/metal/mtl_resource_spi.h
index 3eaa9a64e79af26faa786102ece3f0bdea84d090..2ecf7b40bd5a2edc3fd9d69841e266b6c3cee685 100644
--- a/src/libANGLE/renderer/metal/mtl_resource_spi.h
+++ b/src/libANGLE/renderer/metal/mtl_resource_spi.h
@@ -1,9 +1,63 @@
-//
-// Copyright 2021 The ANGLE Project Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (C) 2021 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 //
 // mtl_resource_spi.h:
-//    Used to set Metal resource ownership identity with SPI.
-//    Purposefully empty header file. Actual implementation will be hosted in WebKit.
+//    Used to set Metal resource ownership identity with SPI
 //
+
+#ifndef LIBANGLE_RENDERER_METAL_RESOURCE_SPI_H_
+#define LIBANGLE_RENDERER_METAL_RESOURCE_SPI_H_
+
+#import "common/apple/apple_platform.h"
+
+#if ANGLE_USE_METAL_OWNERSHIP_IDENTITY
+
+#    import <Metal/MTLResource_Private.h>
+#    import <Metal/Metal.h>
+#    import <mach/mach_types.h>
+
+namespace rx
+{
+namespace mtl
+{
+inline void setOwnerWithIdentity(id<MTLResource> resource, task_id_token_t identityToken)
+{
+    if (identityToken != TASK_ID_TOKEN_NULL)
+    {
+        kern_return_t kr = [(id<MTLResourceSPI>)resource setOwnerWithIdentity:identityToken];
+        if (ANGLE_UNLIKELY(kr != KERN_SUCCESS))
+        {
+            ERR() << "setOwnerWithIdentity failed with: %s (%x)" << mach_error_string(kr) << kr;
+            ASSERT(false);
+        }
+    }
+    return;
+}
+}
+}
+#endif
+
+#endif /* LIBANGLE_RENDERER_METAL_RESOURCE_SPI_H_ */
diff --git a/src/libANGLE/renderer/metal/mtl_state_cache.mm b/src/libANGLE/renderer/metal/mtl_state_cache.mm
index 558075b21cdcdcac0b9cd4ab8fc915bc032f57f7..b3990a828944bab60e692cdd16019ac26c5d99b3 100644
--- a/src/libANGLE/renderer/metal/mtl_state_cache.mm
+++ b/src/libANGLE/renderer/metal/mtl_state_cache.mm
@@ -21,9 +21,16 @@
 
 #define ANGLE_OBJC_CP_PROPERTY(DST, SRC, PROPERTY) \
     (DST).PROPERTY = static_cast<__typeof__((DST).PROPERTY)>(ToObjC((SRC).PROPERTY))
+#define ANGLE_OBJC_CP_PROPERTY2(DST, SRC, PROPERTY, DST_PROPERTY)  \
+    (DST).DST_PROPERTY = static_cast<__typeof__((DST).DST_PROPERTY)>(ToObjC((SRC).PROPERTY))
 
 #define ANGLE_PROP_EQ(LHS, RHS, PROP) ((LHS).PROP == (RHS).PROP)
 
+#if (defined(__MAC_13_0) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_13_0) || \
+    (defined(__IPHONE_16_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_16_0)
+#   define ANGLE_MTL_RENDER_PIPELINE_DESC_RASTER_SAMPLE_COUNT_AVAILABLE 1
+#endif
+
 namespace rx
 {
 namespace mtl
@@ -1069,23 +1076,10 @@ AutoObjCPtr<id<MTLRenderPipelineState>> RenderPipelineCache::createRenderPipelin
 
         auto objCDesc = CreateMTLRenderPipelineDescriptor(vertShader, fragShader, desc);
 
-        // Validate Render Pipeline State:
-        if (DeviceHasMaximumRenderTargetSize(metalDevice))
-        {
-            // TODO: Is the use of NSUInteger in 32 bit systems ok without any overflow checking?
-            NSUInteger maxSize = GetMaxRenderTargetSizeForDeviceInBytes(metalDevice);
-            NSUInteger renderTargetSize =
-                ComputeTotalSizeUsedForMTLRenderPipelineDescriptor(objCDesc, context, metalDevice);
-            if (renderTargetSize > maxSize)
+        if (!ValidateRenderPipelineState(objCDesc, context, metalDevice))
         {
-                std::stringstream errorStream;
-                errorStream << "This set of render targets requires " << renderTargetSize
-                            << " bytes of pixel storage. This device supports " << maxSize
-                            << " bytes.";
-                ANGLE_MTL_HANDLE_ERROR(context, errorStream.str().c_str(), GL_INVALID_OPERATION);
             return nil;
         }
-        }
 
         if (!ValidateRenderPipelineState(objCDesc, context, metalDevice))
         {
diff --git a/src/libANGLE/renderer/metal/mtl_utils.mm b/src/libANGLE/renderer/metal/mtl_utils.mm
index 169b89dd2922f559a4f1831086fbe3a2bfb4030e..a0396f8c88e6502c4df0c8f13384c86d9168394c 100644
--- a/src/libANGLE/renderer/metal/mtl_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_utils.mm
@@ -1355,6 +1355,24 @@ bool SupportsAppleGPUFamily(id<MTLDevice> device, uint8_t appleFamily)
 #endif      // TARGET_OS_IOS || TARGET_OS_TV
 }
 
+#if (defined(__MAC_13_0) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_13_0) || \
+    (defined(__IPHONE_16_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_16_0) || \
+    (defined(__TVOS_16_0) && __TV_OS_VERSION_MIN_REQUIRED >= __TVOS_16_0)
+#   define ANGLE_MTL_FEATURE_SET_DEPRECATED 1
+#   define ANGLE_MTL_GPU_FAMILY_MAC1_DEPRECATED 1
+#endif
+
+#if ANGLE_MTL_GPU_FAMILY_MAC1_DEPRECATED
+#   define ANGLE_MTL_GPU_FAMILY_MAC1 MTLGPUFamilyMac2
+#   define ANGLE_MTL_GPU_FAMILY_MAC2 MTLGPUFamilyMac2
+#elif TARGET_OS_MACCATALYST
+#   define ANGLE_MTL_GPU_FAMILY_MAC1 MTLGPUFamilyMacCatalyst1
+#   define ANGLE_MTL_GPU_FAMILY_MAC2 MTLGPUFamilyMacCatalyst2
+#else // !ANGLE_MTL_GPU_FAMILY_MAC1_DEPRECATED && !TARGET_OS_MACCATALYST
+#   define ANGLE_MTL_GPU_FAMILY_MAC1 MTLGPUFamilyMac1
+#   define ANGLE_MTL_GPU_FAMILY_MAC2 MTLGPUFamilyMac2
+#endif
+
 bool SupportsMacGPUFamily(id<MTLDevice> device, uint8_t macFamily)
 {
 #if TARGET_OS_OSX || TARGET_OS_MACCATALYST
@@ -1369,10 +1387,10 @@ bool SupportsMacGPUFamily(id<MTLDevice> device, uint8_t macFamily)
 #        if TARGET_OS_MACCATALYST
             ANGLE_APPLE_ALLOW_DEPRECATED_BEGIN
             case 1:
-                family = MTLGPUFamilyMacCatalyst1;
+                family = ANGLE_MTL_GPU_FAMILY_MAC1;
                 break;
             case 2:
-                family = MTLGPUFamilyMacCatalyst2;
+                family = ANGLE_MTL_GPU_FAMILY_MAC2;
                 break;
                 ANGLE_APPLE_ALLOW_DEPRECATED_END
 #        else   // TARGET_OS_MACCATALYST
@@ -1395,7 +1413,7 @@ bool SupportsMacGPUFamily(id<MTLDevice> device, uint8_t macFamily)
 
     // If device doesn't support [MTLDevice supportsFamily:], then use
     // [MTLDevice supportsFeatureSet:].
-#    if TARGET_OS_MACCATALYST
+#    if TARGET_OS_MACCATALYST || ANGLE_MTL_FEATURE_SET_DEPRECATED
     UNREACHABLE();
     return false;
 #    else
diff --git a/src/libANGLE/validationES2.cpp b/src/libANGLE/validationES2.cpp
index c6f9fc097e627750b4927d52c6270e3ef46d36d8..66f31ea92de7e872cf8ce61634de47581cdd453b 100644
--- a/src/libANGLE/validationES2.cpp
+++ b/src/libANGLE/validationES2.cpp
@@ -4830,6 +4830,11 @@ bool ValidateSampleCoverage(const Context *context,
     return true;
 }
 
+bool ValidateScheduleANGLE(const Context *context, angle::EntryPoint entryPoint)
+{
+    return true;
+}
+
 bool ValidateScissor(const Context *context,
                      angle::EntryPoint entryPoint,
                      GLint x,
diff --git a/src/libANGLE/validationESEXT_autogen.h b/src/libANGLE/validationESEXT_autogen.h
index 70f7614e433aba86663f3cfa70fa58e6ca315281..38627a950e05ca5c030c3e38e00b00e6850ab863 100644
--- a/src/libANGLE/validationESEXT_autogen.h
+++ b/src/libANGLE/validationESEXT_autogen.h
@@ -297,6 +297,9 @@ bool ValidateImportMemoryZirconHandleANGLE(const Context *context,
                                            HandleType handleTypePacked,
                                            GLuint handle);
 
+// GL_ANGLE_metal_schedule
+bool ValidateScheduleANGLE(const Context *context, angle::EntryPoint entryPoint);
+
 // GL_ANGLE_multi_draw
 bool ValidateMultiDrawArraysANGLE(const Context *context,
                                   angle::EntryPoint entryPoint,
diff --git a/src/libGLESv2/entry_points_gles_ext_autogen.cpp b/src/libGLESv2/entry_points_gles_ext_autogen.cpp
index 15828e0d6bc5836b7b32995972e9345a62ee5df7..44b225b0d64fa8c3904bc0fe6edadb3cd2a541bb 100644
--- a/src/libGLESv2/entry_points_gles_ext_autogen.cpp
+++ b/src/libGLESv2/entry_points_gles_ext_autogen.cpp
@@ -1249,6 +1249,31 @@ void GL_APIENTRY GL_ImportMemoryZirconHandleANGLE(GLuint memory,
     }
 }
 
+// GL_ANGLE_metal_schedule
+void GL_APIENTRY GL_ScheduleANGLE()
+{
+    Context *context = GetValidGlobalContext();
+    EVENT(context, GLScheduleANGLE, "context = %d", CID(context));
+
+    if (context)
+    {
+        SCOPED_SHARE_CONTEXT_LOCK(context);
+        bool isCallValid =
+            (context->skipValidation() ||
+             (ValidatePixelLocalStorageInactive(context, angle::EntryPoint::GLScheduleANGLE) &&
+              ValidateScheduleANGLE(context, angle::EntryPoint::GLScheduleANGLE)));
+        if (isCallValid)
+        {
+            context->schedule();
+        }
+        ANGLE_CAPTURE_GL(ScheduleANGLE, isCallValid, context);
+    }
+    else
+    {
+        GenerateContextLostErrorOnCurrentGlobalContext();
+    }
+}
+
 // GL_ANGLE_multi_draw
 void GL_APIENTRY GL_MultiDrawArraysANGLE(GLenum mode,
                                          const GLint *firsts,
diff --git a/src/libGLESv2/entry_points_gles_ext_autogen.h b/src/libGLESv2/entry_points_gles_ext_autogen.h
index 4a4afb0521acb94139d224804af0868206a3da70..5bcf9fe7a5288691ae9f67901aece50e9d5cac8b 100644
--- a/src/libGLESv2/entry_points_gles_ext_autogen.h
+++ b/src/libGLESv2/entry_points_gles_ext_autogen.h
@@ -232,6 +232,9 @@ ANGLE_EXPORT void GL_APIENTRY GL_ImportMemoryZirconHandleANGLE(GLuint memory,
                                                                GLenum handleType,
                                                                GLuint handle);
 
+// GL_ANGLE_metal_schedule
+ANGLE_EXPORT void GL_APIENTRY GL_ScheduleANGLE();
+
 // GL_ANGLE_multi_draw
 ANGLE_EXPORT void GL_APIENTRY GL_MultiDrawArraysANGLE(GLenum mode,
                                                       const GLint *firsts,
diff --git a/src/libGLESv2/libGLESv2_autogen.cpp b/src/libGLESv2/libGLESv2_autogen.cpp
index 089e7b62c1584dab2e5a7c04d9c3f54d5e67ecfc..8e35b2474972001b4cf224f0fd4494dfa5796a2b 100644
--- a/src/libGLESv2/libGLESv2_autogen.cpp
+++ b/src/libGLESv2/libGLESv2_autogen.cpp
@@ -3061,6 +3061,12 @@ void GL_APIENTRY glImportMemoryZirconHandleANGLE(GLuint memory,
     return GL_ImportMemoryZirconHandleANGLE(memory, size, handleType, handle);
 }
 
+// GL_ANGLE_metal_schedule
+void GL_APIENTRY glScheduleANGLE()
+{
+    return GL_ScheduleANGLE();
+}
+
 // GL_ANGLE_multi_draw
 void GL_APIENTRY glMultiDrawArraysANGLE(GLenum mode,
                                         const GLint *firsts,
diff --git a/src/libGLESv2/libGLESv2_autogen.def b/src/libGLESv2/libGLESv2_autogen.def
index 78d981b5d2de7b86aff66c17f702e0b2bc0412d0..05a6ab1b2ce0606bbfcd6f5059f9593f1b1c00b4 100644
--- a/src/libGLESv2/libGLESv2_autogen.def
+++ b/src/libGLESv2/libGLESv2_autogen.def
@@ -521,6 +521,9 @@ EXPORTS
     ; GL_ANGLE_memory_object_fuchsia
     glImportMemoryZirconHandleANGLE
 
+    ; GL_ANGLE_metal_schedule
+    glScheduleANGLE
+
     ; GL_ANGLE_multi_draw
     glMultiDrawArraysANGLE
     glMultiDrawArraysInstancedANGLE
diff --git a/src/libGLESv2/libGLESv2_no_capture_autogen.def b/src/libGLESv2/libGLESv2_no_capture_autogen.def
index 0ea1bbb4387124663a9c7d36b4630a1ce3615a68..59085b320ff579813ccb579183a29bf4fe64c0a7 100644
--- a/src/libGLESv2/libGLESv2_no_capture_autogen.def
+++ b/src/libGLESv2/libGLESv2_no_capture_autogen.def
@@ -521,6 +521,9 @@ EXPORTS
     ; GL_ANGLE_memory_object_fuchsia
     glImportMemoryZirconHandleANGLE
 
+    ; GL_ANGLE_metal_schedule
+    glScheduleANGLE
+
     ; GL_ANGLE_multi_draw
     glMultiDrawArraysANGLE
     glMultiDrawArraysInstancedANGLE
diff --git a/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def b/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def
index faf3b9ca3c89404e5c6423a7822debb41f5e7006..ae3130bc42d79e1646d38f9afead07957c39142d 100644
--- a/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def
+++ b/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def
@@ -521,6 +521,9 @@ EXPORTS
     ; GL_ANGLE_memory_object_fuchsia
     glImportMemoryZirconHandleANGLE
 
+    ; GL_ANGLE_metal_schedule
+    glScheduleANGLE
+
     ; GL_ANGLE_multi_draw
     glMultiDrawArraysANGLE
     glMultiDrawArraysInstancedANGLE
diff --git a/src/libGLESv2/libGLESv2_with_capture_autogen.def b/src/libGLESv2/libGLESv2_with_capture_autogen.def
index 4f570808978c349300183bdc15b67ae035b4a536..5ca09d7fc4e832360b0d2ed6428e21d874764b8e 100644
--- a/src/libGLESv2/libGLESv2_with_capture_autogen.def
+++ b/src/libGLESv2/libGLESv2_with_capture_autogen.def
@@ -521,6 +521,9 @@ EXPORTS
     ; GL_ANGLE_memory_object_fuchsia
     glImportMemoryZirconHandleANGLE
 
+    ; GL_ANGLE_metal_schedule
+    glScheduleANGLE
+
     ; GL_ANGLE_multi_draw
     glMultiDrawArraysANGLE
     glMultiDrawArraysInstancedANGLE
diff --git a/src/libGLESv2/opengl32_autogen.def b/src/libGLESv2/opengl32_autogen.def
index 33b44aa5402b7a9d14ef1113554679c24cfcde9f..3e03b565054423697e53d3344b6b91caba9906bc 100644
--- a/src/libGLESv2/opengl32_autogen.def
+++ b/src/libGLESv2/opengl32_autogen.def
@@ -521,6 +521,9 @@ EXPORTS
     ; GL_ANGLE_memory_object_fuchsia
     glImportMemoryZirconHandleANGLE
 
+    ; GL_ANGLE_metal_schedule
+    glScheduleANGLE
+
     ; GL_ANGLE_multi_draw
     glMultiDrawArraysANGLE
     glMultiDrawArraysInstancedANGLE
diff --git a/src/libGLESv2/opengl32_with_wgl_autogen.def b/src/libGLESv2/opengl32_with_wgl_autogen.def
index 4da9d2305d221588e156443921f103d7bdd34960..5b8eaa88697a408e7f2df37ad886c2a67556f873 100644
--- a/src/libGLESv2/opengl32_with_wgl_autogen.def
+++ b/src/libGLESv2/opengl32_with_wgl_autogen.def
@@ -521,6 +521,9 @@ EXPORTS
     ; GL_ANGLE_memory_object_fuchsia
     glImportMemoryZirconHandleANGLE
 
+    ; GL_ANGLE_metal_schedule
+    glScheduleANGLE
+
     ; GL_ANGLE_multi_draw
     glMultiDrawArraysANGLE
     glMultiDrawArraysInstancedANGLE
diff --git a/src/libGLESv2/proc_table_egl_autogen.cpp b/src/libGLESv2/proc_table_egl_autogen.cpp
index d8165c24019f9e2fc619fe3255e48e849487d2eb..6a382cbf3699f3b862df3f1d532c4959c8f66bd8 100644
--- a/src/libGLESv2/proc_table_egl_autogen.cpp
+++ b/src/libGLESv2/proc_table_egl_autogen.cpp
@@ -1241,6 +1241,7 @@ const ProcEntry g_procTable[] = {
     DESKTOP_ONLY("glScaled", GL_Scaled)
     {"glScalef", P(GL_Scalef)},
     {"glScalex", P(GL_Scalex)},
+    {"glScheduleANGLE", P(GL_ScheduleANGLE)},
     {"glScissor", P(GL_Scissor)},
     DESKTOP_ONLY("glScissorArrayv", GL_ScissorArrayv)
     DESKTOP_ONLY("glScissorIndexed", GL_ScissorIndexed)
diff --git a/src/libGLESv2/proc_table_glx_autogen.cpp b/src/libGLESv2/proc_table_glx_autogen.cpp
index 76d6c25c180b08804403b907d3ea73182fe7fae1..fa826e4e3b3f399899001513b2281889c399d019 100644
--- a/src/libGLESv2/proc_table_glx_autogen.cpp
+++ b/src/libGLESv2/proc_table_glx_autogen.cpp
@@ -1121,6 +1121,7 @@ const ProcEntry g_procTable[] = {
     {"glScaled", P(GL_Scaled)},
     {"glScalef", P(GL_Scalef)},
     {"glScalex", P(GL_Scalex)},
+    {"glScheduleANGLE", P(GL_ScheduleANGLE)},
     {"glScissor", P(GL_Scissor)},
     {"glScissorArrayv", P(GL_ScissorArrayv)},
     {"glScissorIndexed", P(GL_ScissorIndexed)},
diff --git a/src/libGLESv2/proc_table_wgl_autogen.cpp b/src/libGLESv2/proc_table_wgl_autogen.cpp
index 436e49a8c0e26de9b92f8c65b8027203b4a545bc..d35c3a186798dab5446cb0c09b8ca9b918088d59 100644
--- a/src/libGLESv2/proc_table_wgl_autogen.cpp
+++ b/src/libGLESv2/proc_table_wgl_autogen.cpp
@@ -1121,6 +1121,7 @@ const ProcEntry g_procTable[] = {
     {"glScaled", P(GL_Scaled)},
     {"glScalef", P(GL_Scalef)},
     {"glScalex", P(GL_Scalex)},
+    {"glScheduleANGLE", P(GL_ScheduleANGLE)},
     {"glScissor", P(GL_Scissor)},
     {"glScissorArrayv", P(GL_ScissorArrayv)},
     {"glScissorIndexed", P(GL_ScissorIndexed)},
diff --git a/util/capture/frame_capture_replay_autogen.cpp b/util/capture/frame_capture_replay_autogen.cpp
index d90ca17376e49e963a4a2b5c821d88f43b8a07e7..4611848e6a3f2d6590cede2ed12114570c18bb93 100644
--- a/util/capture/frame_capture_replay_autogen.cpp
+++ b/util/capture/frame_capture_replay_autogen.cpp
@@ -3101,6 +3101,9 @@ void ReplayTraceFunctionCall(const CallCapture &call, const TraceFunctionMap &cu
             glScalex(captures[0].value.GLfixedVal, captures[1].value.GLfixedVal,
                      captures[2].value.GLfixedVal);
             break;
+        case angle::EntryPoint::GLScheduleANGLE:
+            glScheduleANGLE();
+            break;
         case angle::EntryPoint::GLScissor:
             glScissor(captures[0].value.GLintVal, captures[1].value.GLintVal,
                       captures[2].value.GLsizeiVal, captures[3].value.GLsizeiVal);
diff --git a/util/capture/trace_gles_loader_autogen.cpp b/util/capture/trace_gles_loader_autogen.cpp
index 8339c7435464408ca9d40b5219ac93a21582dd6f..fd4478c2c2bcce09326e827fe1439c51b120597e 100644
--- a/util/capture/trace_gles_loader_autogen.cpp
+++ b/util/capture/trace_gles_loader_autogen.cpp
@@ -498,6 +498,7 @@ ANGLE_TRACE_LOADER_EXPORT PFNGLTEXSTORAGEMEMFLAGS3DANGLEPROC t_glTexStorageMemFl
 ANGLE_TRACE_LOADER_EXPORT PFNGLTEXSTORAGEMEMFLAGS3DMULTISAMPLEANGLEPROC
     t_glTexStorageMemFlags3DMultisampleANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLIMPORTMEMORYZIRCONHANDLEANGLEPROC t_glImportMemoryZirconHandleANGLE;
+ANGLE_TRACE_LOADER_EXPORT PFNGLSCHEDULEANGLEPROC t_glScheduleANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLMULTIDRAWARRAYSANGLEPROC t_glMultiDrawArraysANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLMULTIDRAWARRAYSINSTANCEDANGLEPROC t_glMultiDrawArraysInstancedANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLMULTIDRAWELEMENTSANGLEPROC t_glMultiDrawElementsANGLE;
@@ -1604,6 +1605,7 @@ void LoadTraceGLES(LoadProc loadProc)
             loadProc("glTexStorageMemFlags3DMultisampleANGLE"));
     t_glImportMemoryZirconHandleANGLE = reinterpret_cast<PFNGLIMPORTMEMORYZIRCONHANDLEANGLEPROC>(
         loadProc("glImportMemoryZirconHandleANGLE"));
+    t_glScheduleANGLE = reinterpret_cast<PFNGLSCHEDULEANGLEPROC>(loadProc("glScheduleANGLE"));
     t_glMultiDrawArraysANGLE =
         reinterpret_cast<PFNGLMULTIDRAWARRAYSANGLEPROC>(loadProc("glMultiDrawArraysANGLE"));
     t_glMultiDrawArraysInstancedANGLE = reinterpret_cast<PFNGLMULTIDRAWARRAYSINSTANCEDANGLEPROC>(
diff --git a/util/capture/trace_gles_loader_autogen.h b/util/capture/trace_gles_loader_autogen.h
index 35543acacd3259e08e133023ccb845940e2cfe40..223846731e55b202f6ef653b0549e7a6d223cfaf 100644
--- a/util/capture/trace_gles_loader_autogen.h
+++ b/util/capture/trace_gles_loader_autogen.h
@@ -496,6 +496,7 @@
 #define glTexStorageMemFlags3DANGLE t_glTexStorageMemFlags3DANGLE
 #define glTexStorageMemFlags3DMultisampleANGLE t_glTexStorageMemFlags3DMultisampleANGLE
 #define glImportMemoryZirconHandleANGLE t_glImportMemoryZirconHandleANGLE
+#define glScheduleANGLE t_glScheduleANGLE
 #define glMultiDrawArraysANGLE t_glMultiDrawArraysANGLE
 #define glMultiDrawArraysInstancedANGLE t_glMultiDrawArraysInstancedANGLE
 #define glMultiDrawElementsANGLE t_glMultiDrawElementsANGLE
@@ -1348,6 +1349,7 @@ ANGLE_TRACE_LOADER_EXPORT extern PFNGLTEXSTORAGEMEMFLAGS3DMULTISAMPLEANGLEPROC
     t_glTexStorageMemFlags3DMultisampleANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLIMPORTMEMORYZIRCONHANDLEANGLEPROC
     t_glImportMemoryZirconHandleANGLE;
+ANGLE_TRACE_LOADER_EXPORT extern PFNGLSCHEDULEANGLEPROC t_glScheduleANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLMULTIDRAWARRAYSANGLEPROC t_glMultiDrawArraysANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLMULTIDRAWARRAYSINSTANCEDANGLEPROC
     t_glMultiDrawArraysInstancedANGLE;
diff --git a/util/capture/trace_interpreter_autogen.cpp b/util/capture/trace_interpreter_autogen.cpp
index 953c72d57c5b130bb204c0f398a9262bf01c339b..288e9af827ff60df485f758a7871f365952d5c8f 100644
--- a/util/capture/trace_interpreter_autogen.cpp
+++ b/util/capture/trace_interpreter_autogen.cpp
@@ -5140,6 +5140,12 @@ CallCapture ParseCallCapture(const Token &nameToken,
             ParseParameters<std::remove_pointer<PFNGLSCALEXPROC>::type>(paramTokens, strings);
         return CallCapture(EntryPoint::GLScalex, std::move(params));
     }
+    if (strcmp(nameToken, "glScheduleANGLE") == 0)
+    {
+        ParamBuffer params = ParseParameters<std::remove_pointer<PFNGLSCHEDULEANGLEPROC>::type>(
+            paramTokens, strings);
+        return CallCapture(EntryPoint::GLScheduleANGLE, std::move(params));
+    }
     if (strcmp(nameToken, "glScissor") == 0)
     {
         ParamBuffer params =
diff --git a/util/gles_loader_autogen.cpp b/util/gles_loader_autogen.cpp
index 9711aa9b83808fa04187dd4d6cf99928c0442f83..2edeec0eb1e3695fa3bf411edf5a15355f3f522e 100644
--- a/util/gles_loader_autogen.cpp
+++ b/util/gles_loader_autogen.cpp
@@ -495,6 +495,7 @@ ANGLE_UTIL_EXPORT PFNGLTEXSTORAGEMEMFLAGS3DANGLEPROC l_glTexStorageMemFlags3DANG
 ANGLE_UTIL_EXPORT PFNGLTEXSTORAGEMEMFLAGS3DMULTISAMPLEANGLEPROC
     l_glTexStorageMemFlags3DMultisampleANGLE;
 ANGLE_UTIL_EXPORT PFNGLIMPORTMEMORYZIRCONHANDLEANGLEPROC l_glImportMemoryZirconHandleANGLE;
+ANGLE_UTIL_EXPORT PFNGLSCHEDULEANGLEPROC l_glScheduleANGLE;
 ANGLE_UTIL_EXPORT PFNGLMULTIDRAWARRAYSANGLEPROC l_glMultiDrawArraysANGLE;
 ANGLE_UTIL_EXPORT PFNGLMULTIDRAWARRAYSINSTANCEDANGLEPROC l_glMultiDrawArraysInstancedANGLE;
 ANGLE_UTIL_EXPORT PFNGLMULTIDRAWELEMENTSANGLEPROC l_glMultiDrawElementsANGLE;
@@ -1573,6 +1574,7 @@ void LoadUtilGLES(LoadProc loadProc)
             loadProc("glTexStorageMemFlags3DMultisampleANGLE"));
     l_glImportMemoryZirconHandleANGLE = reinterpret_cast<PFNGLIMPORTMEMORYZIRCONHANDLEANGLEPROC>(
         loadProc("glImportMemoryZirconHandleANGLE"));
+    l_glScheduleANGLE = reinterpret_cast<PFNGLSCHEDULEANGLEPROC>(loadProc("glScheduleANGLE"));
     l_glMultiDrawArraysANGLE =
         reinterpret_cast<PFNGLMULTIDRAWARRAYSANGLEPROC>(loadProc("glMultiDrawArraysANGLE"));
     l_glMultiDrawArraysInstancedANGLE = reinterpret_cast<PFNGLMULTIDRAWARRAYSINSTANCEDANGLEPROC>(
diff --git a/util/gles_loader_autogen.h b/util/gles_loader_autogen.h
index 05ba33654cf09cbae426b10cbb238e10c17e24af..ba9941a748edd2064ad9c491c9ee4132b9faf91a 100644
--- a/util/gles_loader_autogen.h
+++ b/util/gles_loader_autogen.h
@@ -496,6 +496,7 @@
 #define glTexStorageMemFlags3DANGLE l_glTexStorageMemFlags3DANGLE
 #define glTexStorageMemFlags3DMultisampleANGLE l_glTexStorageMemFlags3DMultisampleANGLE
 #define glImportMemoryZirconHandleANGLE l_glImportMemoryZirconHandleANGLE
+#define glScheduleANGLE l_glScheduleANGLE
 #define glMultiDrawArraysANGLE l_glMultiDrawArraysANGLE
 #define glMultiDrawArraysInstancedANGLE l_glMultiDrawArraysInstancedANGLE
 #define glMultiDrawElementsANGLE l_glMultiDrawElementsANGLE
@@ -1337,6 +1338,7 @@ ANGLE_UTIL_EXPORT extern PFNGLTEXSTORAGEMEMFLAGS3DANGLEPROC l_glTexStorageMemFla
 ANGLE_UTIL_EXPORT extern PFNGLTEXSTORAGEMEMFLAGS3DMULTISAMPLEANGLEPROC
     l_glTexStorageMemFlags3DMultisampleANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLIMPORTMEMORYZIRCONHANDLEANGLEPROC l_glImportMemoryZirconHandleANGLE;
+ANGLE_UTIL_EXPORT extern PFNGLSCHEDULEANGLEPROC l_glScheduleANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLMULTIDRAWARRAYSANGLEPROC l_glMultiDrawArraysANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLMULTIDRAWARRAYSINSTANCEDANGLEPROC l_glMultiDrawArraysInstancedANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLMULTIDRAWELEMENTSANGLEPROC l_glMultiDrawElementsANGLE;
