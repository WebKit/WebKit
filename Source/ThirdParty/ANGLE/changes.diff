diff --git a/BUILD.gn b/BUILD.gn
index 61f96e6929959919046b2317da331bff27a816b7..4cd1b692803427057b5cdd4563d20212950e1bce 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -1753,7 +1753,8 @@ if (angle_enable_cgl) {
   }
 }
 
-if (is_android && symbol_level != 0) {
+if (is_android && symbol_level != 0 &&
+    (angle_standalone || build_with_chromium)) {
   action_foreach("compressed_symbols") {
     sources = []
     foreach(_library, angle_libraries) {
diff --git a/DEPS b/DEPS
index fd101525656c59e004ef50fb79a72457ea9e32e9..57bf10484c0189f224cbe55e84725652393b6052 100644
--- a/DEPS
+++ b/DEPS
@@ -43,7 +43,7 @@ vars = {
   'checkout_angle_mesa': False,
 
   # Version of Chromium our Chromium-based DEPS are mirrored from.
-  'chromium_revision': 'df8999228884974b1d9795896a83a61ad9b61f60',
+  'chromium_revision': '26ff6a05368337c32f0494b34bcfa2e016f1bbeb',
   # We never want to checkout chromium,
   # but need a dummy DEPS entry for the autoroller
   'dummy_checkout_chromium': False,
@@ -88,7 +88,7 @@ vars = {
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling catapult
   # and whatever else without interference from each other.
-  'catapult_revision': '1c61efe64fd31f3cc991a762e74663c4244deca9',
+  'catapult_revision': '2feeb46c600d86a89b31b6f03050b205f0d4c32a',
 
   # the commit queue can handle CLs rolling Fuchsia sdk
   # and whatever else without interference from each other.
@@ -97,7 +97,7 @@ vars = {
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling luci-go
   # and whatever else without interference from each other.
-  'luci_go': 'git_revision:771ea9a614a104c71655f699ef82219a2a474817',
+  'luci_go': 'git_revision:be41b8d978e22d396ecb4aa9f50ddc3f25977359',
 
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling android_sdk_build-tools_version
@@ -118,7 +118,7 @@ vars = {
 
   # ninja CIPD package version.
   # https://chrome-infra-packages.appspot.com/p/infra/3pp/tools/ninja
-  'ninja_version': 'version:2@1.11.1.chromium.2',
+  'ninja_version': 'version:2@1.12.1.chromium.4',
 
   # Fetch configuration files required for the 'use_remoteexec' gn arg
   'download_remoteexec_cfg': False,
@@ -130,10 +130,10 @@ vars = {
   # reclient CIPD package
   'reclient_package': 'infra/rbe/client/',
   # reclient CIPD package version
-  'reclient_version': 're_client_version:0.150.2.a829188f-gomaip',
+  'reclient_version': 're_client_version:0.155.0.f89f6fe3-gomaip',
 
   # siso CIPD package version.
-  'siso_version': 'git_revision:57e2ea7758b03901b7f3d4da57e673dff55690ba',
+  'siso_version': 'git_revision:54a843e6d76610b340d62437aca89653a9a9e18f',
 
   # 'magic' text to tell depot_tools that git submodules should be accepted but
   # but parity with DEPS file is expected.
@@ -422,12 +422,12 @@ vars = {
 deps = {
 
   'build': {
-    'url': Var('chromium_git') + '/chromium/src/build.git@1233783ad7668f446c77c1669231c0f12b4c87d2',
+    'url': Var('chromium_git') + '/chromium/src/build.git@a0e5713502d43369d238f110f789c190e5e3c022',
     'condition': 'not build_with_chromium',
   },
 
   'buildtools': {
-    'url': Var('chromium_git') + '/chromium/src/buildtools.git@4eb7a10ce6e60cfd8dc9e17a17591816d7607437',
+    'url': Var('chromium_git') + '/chromium/src/buildtools.git@19268125543e152a215808913dacafe77ecae63f',
     'condition': 'not build_with_chromium',
   },
 
@@ -440,7 +440,7 @@ deps = {
     'packages': [
       {
         'package': 'gn/gn/linux-${{arch}}',
-        'version': 'git_revision:1b41f0502f87b2056cee5cc9b48f9242693d497b',
+        'version': 'git_revision:05eed8f6252e2dd6b555e0b65192ef03e2c4a276',
       }
     ],
     'dep_type': 'cipd',
@@ -451,7 +451,7 @@ deps = {
     'packages': [
       {
         'package': 'gn/gn/mac-${{arch}}',
-        'version': 'git_revision:1b41f0502f87b2056cee5cc9b48f9242693d497b',
+        'version': 'git_revision:05eed8f6252e2dd6b555e0b65192ef03e2c4a276',
       }
     ],
     'dep_type': 'cipd',
@@ -473,7 +473,7 @@ deps = {
     'packages': [
       {
         'package': 'gn/gn/windows-amd64',
-        'version': 'git_revision:1b41f0502f87b2056cee5cc9b48f9242693d497b',
+        'version': 'git_revision:05eed8f6252e2dd6b555e0b65192ef03e2c4a276',
       }
     ],
     'dep_type': 'cipd',
@@ -481,17 +481,17 @@ deps = {
   },
 
   'testing': {
-    'url': '{chromium_git}/chromium/src/testing@b201b0824864f33ebd5e06fd17a2bc467124061f',
+    'url': '{chromium_git}/chromium/src/testing@7605e1a3e36ad115dbf98ea87f84ca19a30ad5f6',
     'condition': 'not build_with_chromium',
   },
 
   'third_party/abseil-cpp': {
-    'url': Var('chromium_git') + '/chromium/src/third_party/abseil-cpp@4c87034dc5580b2457b523eb4068613ac72d8665',
+    'url': Var('chromium_git') + '/chromium/src/third_party/abseil-cpp@0b4fc47c61258a1ac696a8a495e1f79c69b00266',
     'condition': 'not build_with_chromium',
   },
 
   'third_party/android_build_tools': {
-    'url': Var('chromium_git') + '/chromium/src/third_party/android_build_tools@240e20ff7f30e63dca36a0f1ff5dac7e97777591',
+    'url': Var('chromium_git') + '/chromium/src/third_party/android_build_tools@f7c885fa9e8c47dccb648ddb4d5c4e2faac91cbb',
     'condition': 'checkout_android and not build_with_chromium',
   },
 
@@ -532,7 +532,7 @@ deps = {
       'packages': [
           {
                'package': 'chromium/third_party/android_build_tools/lint',
-               'version': 'uG3kHGeJabRNjw9Eky3VXo5ykOVG8GddMkhJtB377hcC',
+               'version': 'VSZsvsCZqxvPmRURoEXm6_9prLL38jGMQKXQNZUHmkcC',
           },
       ],
       'condition': 'checkout_android and not build_with_chromium',
@@ -543,7 +543,7 @@ deps = {
       'packages': [
           {
                'package': 'chromium/third_party/android_build_tools/manifest_merger',
-               'version': 'nVcR6k4nXavEey7s0fJVOqBkkBgtRQbAOdltDmvVJHUC',
+               'version': 'xoWqP0Bmz9ReU5nL9ems2x3Ir4Ir3PMTLyba0Ibs824C',
           },
       ],
       'condition': 'checkout_android and not build_with_chromium',
@@ -551,7 +551,7 @@ deps = {
   },
 
   'third_party/android_deps': {
-    'url': Var('chromium_git') + '/chromium/src/third_party/android_deps@b4abde9e3728c5d7eacf1422bf779096fd3ca42c',
+    'url': Var('chromium_git') + '/chromium/src/third_party/android_deps@5e53b74c00950fdee57e7daa9d4922a194ec0eed',
     'condition': 'checkout_android and not build_with_chromium',
   },
 
@@ -596,7 +596,7 @@ deps = {
           },
           {
               'package': 'chromium/third_party/android_sdk/public/cmdline-tools',
-              'version': 'mU9jm4LkManzjSzRquV1UIA7fHBZ2pK7NtbCXxoVnVUC',
+              'version': 'fv6JzkTqfxfIbmsRC8u1b2y0EQO7yQDMDzY3-g0NVu4C',
           },
       ],
       'condition': 'checkout_android_native_support and not build_with_chromium',
@@ -663,7 +663,7 @@ deps = {
   },
 
   'third_party/depot_tools': {
-    'url': Var('chromium_git') + '/chromium/tools/depot_tools.git@7815620b1fc90605b76dacbd2d128460d3743184',
+    'url': Var('chromium_git') + '/chromium/tools/depot_tools.git@75932421da2cd8b5807a4ac52ed2a6f46d7c2120',
     'condition': 'not build_with_chromium',
   },
 
@@ -720,7 +720,7 @@ deps = {
       'packages': [
           {
               'package': 'chromium/third_party/kotlin_stdlib',
-              'version': '7D39_IeRRmlY63nkWblJaEJhtjQwqEk5oTqT9hoZxKsC',
+              'version': 'qtDQdcYfgSh4FeSY3TnkSjnZ5FqCbP1kjk1Zj1m6Jd4C',
           },
       ],
       'condition': 'checkout_android and not build_with_chromium',
@@ -782,17 +782,17 @@ deps = {
    },
 
   'third_party/libc++/src': {
-    'url': Var('chromium_git') + '/external/github.com/llvm/llvm-project/libcxx.git@116395a11e064f22bd143f709d6811b4827c11b6',
+    'url': Var('chromium_git') + '/external/github.com/llvm/llvm-project/libcxx.git@7993b2fda28215023f8e0a1f6d0adc48812dc9f0',
     'condition': 'not build_with_chromium',
   },
 
   'third_party/libc++abi/src': {
-    'url': Var('chromium_git') + '/external/github.com/llvm/llvm-project/libcxxabi.git@a3c7d3e2f3e1e724b4651891b1a71257cbd88acc',
+    'url': Var('chromium_git') + '/external/github.com/llvm/llvm-project/libcxxabi.git@eb6567388e89d9730c76dee71d68ac82e4a1abf6',
     'condition': 'not build_with_chromium',
   },
 
   'third_party/libunwind/src': {
-    'url': Var('chromium_git') + '/external/github.com/llvm/llvm-project/libunwind.git@9f0b3768de4494225fee07ca810782b8fa0c897a',
+    'url': Var('chromium_git') + '/external/github.com/llvm/llvm-project/libunwind.git@6db1ccfa71064a8129710fc77a567160fdfba7fd',
     'condition': 'not build_with_chromium',
   },
 
@@ -821,7 +821,7 @@ deps = {
   'third_party/ninja': {
     'packages': [
       {
-        'package': 'infra/3pp/build_support/ninja-1_11_1/${{platform}}',
+        'package': 'infra/3pp/tools/ninja/${{platform}}',
         'version': Var('ninja_version'),
       }
     ],
@@ -879,7 +879,7 @@ deps = {
       'packages': [
           {
               'package': 'chromium/third_party/r8',
-              'version': 'ILFR2kx4djOku2KBB58TOiYl20p0BacrbuKnvdrKlOYC',
+              'version': 'PXH37yAaLUOxMKapVN58gGbrt4ncdU0of7PVnU1hqlAC',
           },
       ],
       'condition': 'checkout_android and not build_with_chromium',
@@ -926,7 +926,7 @@ deps = {
   },
 
   'third_party/SwiftShader': {
-    'url': Var('swiftshader_git') + '/SwiftShader@f72761e8676601271ae282f9581cde771db57a5b',
+    'url': Var('swiftshader_git') + '/SwiftShader@65157d32945d9a75fc9a657e878a1b2f61342f03',
     'condition': 'not build_with_chromium',
   },
 
@@ -934,7 +934,7 @@ deps = {
       'packages': [
           {
               'package': 'chromium/third_party/turbine',
-              'version': 'EICM7eVhYRyG5-glA6v4B4llD23SycxxXp3bjd_pke8C',
+              'version': 'HLBr7iWMO2VeD_WbrAA1eq33jZZCVxvA3noE3LNzSlQC',
           },
       ],
       'condition': 'checkout_android and not build_with_chromium',
@@ -946,17 +946,17 @@ deps = {
   },
 
   'third_party/vulkan-deps': {
-    'url': Var('chromium_git') + '/vulkan-deps@068847956e41da25de7a5e1076ef603db1738c28',
+    'url': Var('chromium_git') + '/vulkan-deps@236cdecbee13fdf18b5a7f501d696700e6c0ef62',
     'condition': 'not build_with_chromium',
   },
 
   'third_party/glslang/src': {
-    'url': '{chromium_git}/external/github.com/KhronosGroup/glslang@3c7b12c643437061aec00a813a7f7ae578ba813f',
+    'url': '{chromium_git}/external/github.com/KhronosGroup/glslang@7c4d91e7819a1d27213aa3499953d54ae1a00e8f',
     'condition': 'not build_with_chromium',
   },
 
   'third_party/lunarg-vulkantools/src': {
-    'url': '{chromium_git}/external/github.com/LunarG/VulkanTools@9bd6f95db3076517205b01300c8d37043c5b2dd3',
+    'url': '{chromium_git}/external/github.com/LunarG/VulkanTools@a12be94856baf210bb7ae9457dbdf907148caa0a',
     'condition': 'not build_with_chromium',
   },
 
@@ -966,37 +966,37 @@ deps = {
   },
 
   'third_party/spirv-headers/src': {
-    'url': '{chromium_git}/external/github.com/KhronosGroup/SPIRV-Headers@db5a00f8cebe81146cafabf89019674a3c4bf03d',
+    'url': '{chromium_git}/external/github.com/KhronosGroup/SPIRV-Headers@f013f08e4455bcc1f0eed8e3dd5e2009682656d9',
     'condition': 'not build_with_chromium',
   },
 
   'third_party/spirv-tools/src': {
-    'url': '{chromium_git}/external/github.com/KhronosGroup/SPIRV-Tools@e7216170d02921ce8acd49aebed0098adc050d23',
+    'url': '{chromium_git}/external/github.com/KhronosGroup/SPIRV-Tools@b64a423b44f448df5464978173e28be12069b73c',
     'condition': 'not build_with_chromium',
   },
 
   'third_party/vulkan-headers/src': {
-    'url': '{chromium_git}/external/github.com/KhronosGroup/Vulkan-Headers@fabe9e2672334fdb9a622d42a2e8f94578952082',
+    'url': '{chromium_git}/external/github.com/KhronosGroup/Vulkan-Headers@595c8d4794410a4e64b98dc58d27c0310d7ea2fd',
     'condition': 'not build_with_chromium',
   },
 
   'third_party/vulkan-loader/src': {
-    'url': '{chromium_git}/external/github.com/KhronosGroup/Vulkan-Loader@be0e1c3683a39a26b4f1a3859226b07a482d030e',
+    'url': '{chromium_git}/external/github.com/KhronosGroup/Vulkan-Loader@faeb5882c7faf3e683ebb1d9d7dbf9bc337b8fa6',
     'condition': 'not build_with_chromium',
   },
 
   'third_party/vulkan-tools/src': {
-    'url': '{chromium_git}/external/github.com/KhronosGroup/Vulkan-Tools@46df205dcad665b652f57ee580d78051925b296a',
+    'url': '{chromium_git}/external/github.com/KhronosGroup/Vulkan-Tools@7d5cdf62e4f2935425faab1270fe1c9a401fa664',
     'condition': 'not build_with_chromium',
   },
 
   'third_party/vulkan-utility-libraries/src': {
-    'url': '{chromium_git}/external/github.com/KhronosGroup/Vulkan-Utility-Libraries@67522b34edde86dbb97e164280291f387ade55fc',
+    'url': '{chromium_git}/external/github.com/KhronosGroup/Vulkan-Utility-Libraries@45b881573538f8e481cb6e1d811a9076be6920c1',
     'condition': 'not build_with_chromium',
   },
 
   'third_party/vulkan-validation-layers/src': {
-    'url': '{chromium_git}/external/github.com/KhronosGroup/Vulkan-ValidationLayers@1582614bd3ad31463710af6365a56f04d6788ce6',
+    'url': '{chromium_git}/external/github.com/KhronosGroup/Vulkan-ValidationLayers@3131e4be90985c9f3c063d1527f0368a98166765',
     'condition': 'not build_with_chromium',
   },
 
@@ -1016,12 +1016,12 @@ deps = {
   },
 
   'tools/android': {
-    'url': Var('chromium_git') + '/chromium/src/tools/android@023f8c071bf891263804cd3bec5b6ce8aadd2558',
+    'url': Var('chromium_git') + '/chromium/src/tools/android@324faa7115a61d34322d57fc929f17879d6ccf6f',
     'condition': 'checkout_android and not build_with_chromium',
   },
 
   'tools/clang': {
-    'url': Var('chromium_git') + '/chromium/src/tools/clang.git@51579c516e100d8e173fc2b80407b41c98afdadc',
+    'url': Var('chromium_git') + '/chromium/src/tools/clang.git@bd2518c73b763cb742dadb6049d78c65e7a3610a',
     'condition': 'not build_with_chromium',
   },
 
@@ -1062,12 +1062,12 @@ deps = {
   },
 
   'tools/memory': {
-    'url': Var('chromium_git') + '/chromium/src/tools/memory@5a2fc6d03abe14d800811f42578872992c37c0dd',
+    'url': Var('chromium_git') + '/chromium/src/tools/memory@d7a1bee91c1e4927b0f4d35f26aecb4cafa7df8c',
     'condition': 'not build_with_chromium',
   },
 
   'tools/perf': {
-    'url': Var('chromium_git') + '/chromium/src/tools/perf@dfd08b107f4a7a2456bdbd9646ef5e6e749d9157',
+    'url': Var('chromium_git') + '/chromium/src/tools/perf@647af9c63d15b9eff470d2beb282efd82a2346bf',
     'condition': 'not build_with_chromium',
   },
 
@@ -1082,7 +1082,7 @@ deps = {
   },
 
   'tools/rust': {
-    'url': Var('chromium_git') + '/chromium/src/tools/rust.git@26be847460d2b395ebde4947eb002bf286498a9a',
+    'url': Var('chromium_git') + '/chromium/src/tools/rust.git@e27ef2019ac1dcd87d15640aa1ba5ca662e44158',
     'condition': 'not build_with_chromium',
   },
 
@@ -1090,7 +1090,7 @@ deps = {
       'packages': [
         {
           'package': 'skia/tools/goldctl/linux-amd64',
-          'version': 'dPSh2hSFImVtYVOiMVjHTBEre0Asyy65tgiDL8miZbgC',
+          'version': 'HBWTb3YUFBBjYkOtjhxS1wlkmEml8L10JqtlnSdhw-UC',
         },
       ],
       'dep_type': 'cipd',
@@ -1101,7 +1101,7 @@ deps = {
       'packages': [
         {
           'package': 'skia/tools/goldctl/windows-amd64',
-          'version': 'DJGQjlpG-s27CzX1oKqNQtH9fBh6kgVemcGds9How_4C',
+          'version': 'zOnwb1fg3Utxextms-shBCXVqq3TZ4q-P-8Yh4Uv7uwC',
         },
       ],
       'dep_type': 'cipd',
@@ -1112,7 +1112,7 @@ deps = {
       'packages': [
         {
           'package': 'skia/tools/goldctl/mac-amd64',
-          'version': 'qtaQhHygWRQcSDpg6ZVJNUfceR2EZH3rto0pOFEebzkC',
+          'version': 'W-fY5DncMFHUQVRKwZ-6a1bTL3Q0Cb0nqA5Kn8m2cZ4C',
         },
       ],
       'dep_type': 'cipd',
@@ -1123,7 +1123,7 @@ deps = {
       'packages': [
         {
           'package': 'skia/tools/goldctl/mac-arm64',
-          'version': 'VRxzxVSfFBWl3AlTnrcO-4gQY5i6AYveLfh2Eop5-UIC',
+          'version': '0-qMzZ4dqMlt0A1qSjLar6NlcpAkZNqG3wxM17cGS4AC',
         },
       ],
       'dep_type': 'cipd',
@@ -4151,7 +4151,7 @@ deps = {
       'packages': [
           {
               'package': 'chromium/third_party/android_deps/libs/com_google_android_gms_play_services_base',
-              'version': 'version:2@18.1.0.cr1',
+              'version': 'version:2@18.5.0.cr1',
           },
       ],
       'condition': 'checkout_android and not build_with_chromium and non_git_source',
@@ -4162,7 +4162,7 @@ deps = {
       'packages': [
           {
               'package': 'chromium/third_party/android_deps/libs/com_google_android_gms_play_services_basement',
-              'version': 'version:2@18.1.0.cr1',
+              'version': 'version:2@18.4.0.cr1',
           },
       ],
       'condition': 'checkout_android and not build_with_chromium and non_git_source',
@@ -4235,6 +4235,17 @@ deps = {
       'dep_type': 'cipd',
   },
 
+  'third_party/android_deps/cipd/libs/com_google_android_gms_play_services_identity_credentials': {
+      'packages': [
+          {
+              'package': 'chromium/third_party/android_deps/libs/com_google_android_gms_play_services_identity_credentials',
+              'version': 'version:2@16.0.0-alpha02.cr1',
+          },
+      ],
+      'condition': 'checkout_android and not build_with_chromium and non_git_source',
+      'dep_type': 'cipd',
+  },
+
   'third_party/android_deps/cipd/libs/com_google_android_gms_play_services_iid': {
       'packages': [
           {
@@ -4294,7 +4305,7 @@ deps = {
       'packages': [
           {
               'package': 'chromium/third_party/android_deps/libs/com_google_android_gms_play_services_tasks',
-              'version': 'version:2@18.0.2.cr1',
+              'version': 'version:2@18.2.0.cr1',
           },
       ],
       'condition': 'checkout_android and not build_with_chromium and non_git_source',
diff --git a/README.md b/README.md
index 9e00445f7a50d61a16220cb6f6ef0c3e95998c1f..d29313db09c0519c83561bb86e216f9e0789283b 100644
--- a/README.md
+++ b/README.md
@@ -123,14 +123,16 @@ View the [Dev setup instructions](doc/DevSetup.md).
 * Use ANGLE's [coding standard](doc/CodingStandard.md).
 * Learn how to [build ANGLE for Chromium development](doc/BuildingAngleForChromiumDevelopment.md).
 * Get help on [debugging ANGLE](doc/DebuggingTips.md).
-* Go through [ANGLE's orientation](doc/Orientation.md) and sift through [starter projects](https://bugs.chromium.org/p/angleproject/issues/list?q=Hotlist%3DStarterBug). If you decide to take on any task, write a comment so you can get in touch with us, and more importantly, set yourself as the "owner" of the bug. This avoids having multiple people accidentally working on the same issue.
+* Go through [ANGLE's orientation](doc/Orientation.md) and sift through [issues](https://issues.angleproject.org/). If you decide to take on any task, write a comment so you can get in touch with us, and more importantly, set yourself as the "owner" of the bug. This avoids having multiple people accidentally working on the same issue.
 
 
 * Read about WebGL on the [Khronos WebGL Wiki](http://khronos.org/webgl/wiki/Main_Page).
-* Learn about the initial ANGLE implementation details in the [OpenGL Insights chapter on ANGLE](http://www.seas.upenn.edu/~pcozzi/OpenGLInsights/OpenGLInsights-ANGLE.pdf) (this is not the most up-to-date ANGLE implementation details, it is listed here for historical reference only) and this [ANGLE presentation](https://drive.google.com/file/d/0Bw29oYeC09QbbHoxNE5EUFh0RGs/view?usp=sharing&resourcekey=0-CNvGnQGgFSvbXgX--Y_Iyg).
-* Learn about the past, present, and future of the ANGLE implementation in [this presentation](https://docs.google.com/presentation/d/1CucIsdGVDmdTWRUbg68IxLE5jXwCb2y1E9YVhQo0thg/pub?start=false&loop=false).
-* Watch a [short presentation](https://youtu.be/QrIKdjmpmaA) on the Vulkan back-end.
-* Track the [dEQP test conformance](doc/dEQP-Charts.md)
+* Learn about the internals of ANGLE:
+  * [Overview](https://docs.google.com/presentation/d/1qal4GgddwlUw-TPaXRYeTWLXUoaemgggBuTfg6_rwjU) with a focus on the Vulkan backend (2022)
+  * A [short presentation](https://youtu.be/QrIKdjmpmaA) on the Vulkan back-end (2018).
+  * Historical [presentation](https://docs.google.com/presentation/d/1CucIsdGVDmdTWRUbg68IxLE5jXwCb2y1E9YVhQo0thg/pub?start=false&loop=false) on the evolution of ANGLE and its use in Chromium
+  * Historical [presentation](https://drive.google.com/file/d/0Bw29oYeC09QbbHoxNE5EUFh0RGs/view?usp=sharing&resourcekey=0-CNvGnQGgFSvbXgX--Y_Iyg) with a focus on D3D
+  * The details of the initial implementation of ANGLE in the [OpenGL Insights chapter on ANGLE](http://www.seas.upenn.edu/~pcozzi/OpenGLInsights/OpenGLInsights-ANGLE.pdf) (these details are severely out-of-date, and this reference is listed here for historical reference only)
 * Read design docs on the [Vulkan back-end](src/libANGLE/renderer/vulkan/README.md)
 * Read about ANGLE's [testing infrastructure](infra/README.md)
 * View information on ANGLE's [supported extensions](doc/ExtensionSupport.md)
diff --git a/doc/ExtensionSupport.md b/doc/ExtensionSupport.md
index bb7e1359c7a48a1cd1001515eb046e5c33e922d7..dff8988c34fa21b0ebf378392ff3297e4cbf8467 100644
--- a/doc/ExtensionSupport.md
+++ b/doc/ExtensionSupport.md
@@ -221,6 +221,7 @@ using data from registry_xml.py and gl.xml.
 | [GL_CHROMIUM_copy_compressed_texture](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/CHROMIUM_copy_compressed_texture.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
 | [GL_CHROMIUM_copy_texture](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/CHROMIUM_copy_texture.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
 | [GL_ANGLE_copy_texture_3d](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_copy_texture_3d.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
+| [GL_WEBKIT_explicit_resolve_target](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/WEBKIT_explicit_resolve_target.txt) |  |  |  |  |  |  |  |
 | [GL_CHROMIUM_framebuffer_mixed_samples](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/CHROMIUM_framebuffer_mixed_samples.txt) |  |  |  |  |  |  |  |
 | [GL_ANGLE_framebuffer_multisample](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_framebuffer_multisample.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
 | [GL_ANGLE_get_image](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_get_image.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
@@ -258,6 +259,7 @@ using data from registry_xml.py and gl.xml.
 | [GL_ANGLE_texture_external_update](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_texture_external_update.txt) |  |  |  |  |  |  |  |
 | [GL_ANGLE_texture_multisample](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_texture_multisample.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
 | [GL_ANGLE_texture_rectangle](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_texture_rectangle.txt) |  |  |  |  |  |  |  |
+| [GL_ANGLE_variable_rasterization_rate_metal](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_variable_rasterization_rate_metal.txt) |  |  |  |  |  |  |  |
 | [GL_ANGLE_vulkan_image](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_vulkan_image.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
 | [GL_ANGLE_webgl_compatibility](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_webgl_compatibility.txt) |  |  |  |  |  |  |  |
 | [GL_ANGLE_yuv_internal_format](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_yuv_internal_format.txt) | &#x2714; |  | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
diff --git a/doc/dEQP-Charts.md b/doc/dEQP-Charts.md
deleted file mode 100644
index 4a504579b77ec3f86122a956ff733134b7d982d0..0000000000000000000000000000000000000000
--- a/doc/dEQP-Charts.md
+++ /dev/null
@@ -1,124 +0,0 @@
-# Charts
-
-These charts are generated nightly from the [chrome GPU waterfall bots](https://ci.chromium.org/p/chromium/g/chromium.gpu.fyi/console?limit=200). The output of dEQP tests are parsed by [generate_stats.py](https://chromium.googlesource.com/angle/angle/+/HEAD/scripts/generate_stats.py) and collected into a Sheet here: https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek
-
-Warning: the charts below that are wrapped by iframe tags may not display
-properly on GitHub Markdown. The charts can be viewed best on the
-[Chromium repo page](https://chromium.googlesource.com/angle/angle/+/HEAD/doc/dEQP-Charts.md).
-
-[TOC]
-
-## Win Desktop OpenGL Charts
-
-[https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek/edit#gid=2131794282](https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek/edit#gid=2131794282)
-
-<iframe id="GLES 2.0 Desktop OpenGL Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=2017908944&format=interactive"></iframe>
-
-<iframe id="GLES 3.0 Desktop OpenGL Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=1311087567&format=interactive"></iframe>
-
-<iframe id="GLES 3.1 Desktop OpenGL Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=786488695&format=interactive"></iframe>
-
-<iframe id="EGL Desktop OpenGL Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=485763259&format=interactive"></iframe>
-
-## Win Vulkan Charts
-
-[https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek/edit#gid=88272764](https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek/edit#gid=88272764)
-
-<iframe id="GLES 2.0 Vulkan Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=1224536816&format=interactive"></iframe>
-
-<iframe id="GLES 3.0 Vulkan Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=470578632&format=interactive"></iframe>
-
-<iframe id="GLES 3.1 Vulkan Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=304442659&format=interactive"></iframe>
-
-<iframe id="EGL Vulkan Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=907538347&format=interactive"></iframe>
-
-### KHR
-
-<iframe id="GLES 2.0 Vulkan khr Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=1264555977&format=interactive"></iframe>
-
-<iframe id="GLES 3.0 Vulkan khr Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=884611147&format=interactive"></iframe>
-
-<iframe id="GLES 3.1 Vulkan khr Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=441071086&format=interactive"></iframe>
-
-## Win D3D11 Charts
-
-[https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek/edit#gid=1236517289](https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek/edit#gid=1236517289)
-
-<iframe id="GLES 2.0 D3D11 Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=2018286499&format=interactive"></iframe>
-
-<iframe id="GLES 3.0 D3D11 Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=725892266&format=interactive"></iframe>
-
-<iframe id="GLES 3.1 D3D11 Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=415437873&format=interactive"></iframe>
-
-<iframe id="EGL D3D11 Win10 NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=1558331750&format=interactive"></iframe>
-
-## Mac Desktop Open GL Charts
-
-[https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek/edit#gid=745187740](https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek/edit#gid=745187740)
-
-<iframe id="GLES 2.0 Desktop OpenGL Mac AMD" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=405516565&format=interactive"></iframe>
-
-<iframe id="GLES 3.0 Desktop OpenGL Mac AMD" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=1993001882&format=interactive"></iframe>
-
-<iframe id="EGL Desktop OpenGL Mac AMD" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=718088219&format=interactive"></iframe>
-
-## Linux Desktop Open GL Charts
-
-[https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek/edit#gid=518000832](https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek/edit#gid=518000832)
-
-<iframe id="GLES 2.0 Desktop OpenGL Linux NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=1000752961&format=interactive"></iframe>
-
-<iframe id="GLES 3.0 Desktop OpenGL Linux NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=658136720&format=interactive"></iframe>
-
-<iframe id="GLES 3.1 Desktop OpenGL Linux NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=637777434&format=interactive"></iframe>
-
-<iframe id="EGL Desktop OpenGL Linux NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=1262725407&format=interactive"></iframe>
-
-## Linux Vulkan Charts
-
-[https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek/edit#gid=1271046732](https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek/edit#gid=1271046732)
-
-<iframe id="GLES 2.0 Vulkan Linux NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=2098104121&format=interactive"></iframe>
-
-<iframe id="GLES 3.0 Vulkan Linux NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=1985365791&format=interactive"></iframe>
-
-<iframe id="GLES 3.1 Vulkan Linux NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=288024561&format=interactive"></iframe>
-
-<iframe id="EGL Vulkan Linux NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=1792478091&format=interactive"></iframe>
-
-### KHR
-
-<iframe id="GLES 2.0 Vulkan khr Linux NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=1734147637&format=interactive"></iframe>
-
-<iframe id="GLES 3.0 Vulkan khr Linux NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=1396798929&format=interactive"></iframe>
-
-<iframe id="GLES 3.1 Vulkan khr Linux NVIDIA" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=383448866&format=interactive"></iframe>
-
-## Android Vulkan Charts
-
-[https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek/edit#gid=703637628](https://docs.google.com/spreadsheets/d/1uttk1z8lJ4ZsUY7wMdFauMzUxb048nh5l52zdrAznek/edit#gid=703637628)
-
-<iframe id="GLES 2.0 Vulkan Android 64 Pixel 2" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=1563521823&format=interactive"></iframe>
-
-<iframe id="GLES 3.0 Vulkan Android 64 Pixel 2" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=330631789&format=interactive"></iframe>
-
-<iframe id="GLES 3.1 Vulkan Android 64 Pixel 2" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=1089048598&format=interactive"></iframe>
-
-<iframe id="EGL Vulkan Android 64 Pixel 2" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=345901518&format=interactive"></iframe>
-
-### KHR
-
-<iframe id="GLES 2.0 Vulkan khr Android 64 Pixel 2" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=1369552559&format=interactive"></iframe>
-
-<iframe id="GLES 3.0 Vulkan khr Android 64 Pixel 2" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=211294637&format=interactive"></iframe>
-
-<iframe id="GLES 3.1 Vulkan khr Android 64 Pixel 2" width="1200px" height="371px" class="noborder" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubchart?oid=679956702&format=interactive"></iframe>
-
-## Unexpected Passes/Failures
-
-The latest list of unexpected passed/failed tests on HEAD.
-Each test is followed by a list of links to any builds on which they passed/failed unexpectedly.
-
-<iframe id="Unexpected Passed Tests" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubhtml?gid=227024905&single=true&widget=true&headers=false" width="100%" height="600px"></iframe>
-
-<iframe id="Unexpected Failed Tests" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQKyd5j9B0BOl-SuEYeJfIdhYF8EZzASSA7M3nZeLL54i-7iAfEMx0kX7SF_CiwU7DrX8THgn6VKX8a/pubhtml?gid=101098052&single=true&widget=true&headers=false" width="100%" height="600px"></iframe>
\ No newline at end of file
diff --git a/doc/dEQP.md b/doc/dEQP.md
index e3620df737265f1eff2cb39921ca0762b2e1e21d..076d9b55eb693d927cb3c36ef8fbcb005b1eed13 100644
--- a/doc/dEQP.md
+++ b/doc/dEQP.md
@@ -31,7 +31,7 @@ a better sense of total passing rate.
 
 ### Choosing a Renderer
 
-By default ANGLE tests with D3D11 on Windows, GLES on mobile and Desktop GL otherwise.
+By default ANGLE tests with Vulkan, except on Apple platforms where OpenGL is used.
 To specify the exact platform for ANGLE + dEQP, use the arguments:
 
   * `--deqp-egl-display-type=angle-d3d11` for D3D11 (highest available feature level)
diff --git a/include/GLES2/gl2ext_angle.h b/include/GLES2/gl2ext_angle.h
index 7952b50a5b8637eaf53d7d9611225a12c80cdcdd..24f072e9eddcb3c7ce480a4f83558d4a24e1740d 100644
--- a/include/GLES2/gl2ext_angle.h
+++ b/include/GLES2/gl2ext_angle.h
@@ -736,4 +736,23 @@ GL_APICALL void GL_APIENTRY glLogicOpANGLE (GLenum);
 #define GL_PROGRAM_BINARY_READY_ANGLE    0x96BE
 #endif /* GL_ANGLE_program_binary_readiness_query */
 
+#ifndef GL_WEBKIT_explicit_resolve_target
+typedef void (GL_APIENTRYP PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC) (GLenum, GLenum, GLenum, GLuint);
+#ifdef GL_GLEXT_PROTOTYPES
+GL_APICALL void GL_APIENTRY glFramebufferResolveRenderbufferWEBKIT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
+#endif
+#endif /* GL_WEBKIT_explicit_resolve_target */
+
+#ifndef GL_ANGLE_variable_rasterization_rate_metal
+#define GL_ANGLE_variable_rasterization_rate_metal 1
+
+#define GL_VARIABLE_RASTERIZATION_RATE_ANGLE            0x96BC
+#define GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE   0x96BD
+typedef void *GLMTLRasterizationRateMapANGLE;
+typedef void (GL_APIENTRYP PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC) (GLuint, GLMTLRasterizationRateMapANGLE);
+#ifdef GL_GLEXT_PROTOTYPES
+GL_APICALL void GL_APIENTRY glBindMetalRasterizationRateMapANGLE(GLuint framebuffer, GLMTLRasterizationRateMapANGLE map);
+#endif
+#endif /* GL_ANGLE_variable_rasterization_rate_metal */
+
 #endif  // INCLUDE_GLES2_GL2EXT_ANGLE_H_
diff --git a/include/GLSLANG/ShaderLang.h b/include/GLSLANG/ShaderLang.h
index 64cdfa3cc149fbf30dda39d53804e900936f3494..eb62fb0b171efc04fbba72ab3e52883b2e746aec 100644
--- a/include/GLSLANG/ShaderLang.h
+++ b/include/GLSLANG/ShaderLang.h
@@ -26,7 +26,7 @@
 
 // Version number for shader translation API.
 // It is incremented every time the API changes.
-#define ANGLE_SH_VERSION 357
+#define ANGLE_SH_VERSION 358
 
 enum ShShaderSpec
 {
@@ -449,6 +449,12 @@ struct ShCompileOptions
     // Whether SPIR-V 1.4 can be emitted.  If not set, SPIR-V 1.3 is emitted.
     uint64_t emitSPIRV14 : 1;
 
+    // Reject shaders with obvious undefined behavior:
+    //
+    // - Shader contains easy-to-detect infinite loops
+    //
+    uint64_t rejectWebglShadersWithUndefinedBehavior : 1;
+
     ShCompileOptionsMetal metal;
     ShPixelLocalStorageOptions pls;
 };
diff --git a/include/platform/autogen/FeaturesMtl_autogen.h b/include/platform/autogen/FeaturesMtl_autogen.h
index 28e27213619de12f342cdced7abe175d5a82555a..d79889bcfa9ad58b608ae07cb85845ca885c136f 100644
--- a/include/platform/autogen/FeaturesMtl_autogen.h
+++ b/include/platform/autogen/FeaturesMtl_autogen.h
@@ -83,6 +83,13 @@ struct FeaturesMtl : FeatureSetBase
         &members,
     };
 
+    FeatureInfo hasVariableRasterizationRate = {
+        "hasVariableRasterizationRate",
+        FeatureCategory::MetalFeatures,
+        "The renderer supports variable rasterization rate",
+        &members,
+    };
+
     FeatureInfo allowInlineConstVertexData = {
         "allowInlineConstVertexData",
         FeatureCategory::MetalFeatures,
@@ -421,11 +428,11 @@ struct FeaturesMtl : FeatureSetBase
         &members, "http://anglebug.com/42266744"
     };
 
-    FeatureInfo alwaysResolveMultisampleRenderBuffers = {
-        "alwaysResolveMultisampleRenderBuffers",
+    FeatureInfo enableMultisampledRenderToTextureOnNonTilers = {
+        "enableMultisampledRenderToTextureOnNonTilers",
         FeatureCategory::MetalFeatures,
-        "Always automatically resolve MSAA render buffers to single sampled texture.",
-        &members, "http://crbug.com/1486094"
+        "Enable EXT_multisampled_render_to_texture on non tiled GPUs.",
+        &members, "http://anglebug.com/42261786"
     };
 
     FeatureInfo injectAsmStatementIntoLoopBodies = {
diff --git a/include/platform/autogen/FrontendFeatures_autogen.h b/include/platform/autogen/FrontendFeatures_autogen.h
index d5a19406ac298f99fe8b0357e227f5d63e74193a..a05639c6a0bb8c85dcaa97886279ffdf8032d837 100644
--- a/include/platform/autogen/FrontendFeatures_autogen.h
+++ b/include/platform/autogen/FrontendFeatures_autogen.h
@@ -203,6 +203,13 @@ struct FrontendFeatures : FeatureSetBase
         &members, "https://issuetracker.google.com/349489248"
     };
 
+    FeatureInfo rejectWebglShadersWithUndefinedBehavior = {
+        "rejectWebglShadersWithUndefinedBehavior",
+        FeatureCategory::FrontendWorkarounds,
+        "Attempts to detect undefined behavior when in WebGL mode and reject shaders if any detected.",
+        &members, "http://crbug.com/350528343"
+    };
+
 };
 
 inline FrontendFeatures::FrontendFeatures()  = default;
diff --git a/include/platform/frontend_features.json b/include/platform/frontend_features.json
index d7d81a2ff783c49eed7cb0ad561941213194955d..f430f1a735b25e4a1da3b44a417f6e3d64d48205 100644
--- a/include/platform/frontend_features.json
+++ b/include/platform/frontend_features.json
@@ -209,6 +209,14 @@
                 "Force flush after drawcall use shadow map for intel device."
             ],
             "issue": "https://issuetracker.google.com/349489248"
+        },
+        {
+            "name": "reject_webgl_shaders_with_undefined_behavior",
+            "category": "Workarounds",
+            "description": [
+                "Attempts to detect undefined behavior when in WebGL mode and reject shaders if any detected."
+            ],
+            "issue": "http://crbug.com/350528343"
         }
     ]
 }
diff --git a/include/platform/mtl_features.json b/include/platform/mtl_features.json
index 8aabccca1e1edee5fae5e28ff6bf9ab6f8967f73..2c33cbabf896877cb301acae5889e405f751dd27 100644
--- a/include/platform/mtl_features.json
+++ b/include/platform/mtl_features.json
@@ -70,6 +70,13 @@
                 "The renderer supports MTL(Shared)Event"
             ]
         },
+        {
+            "name": "has_variable_rasterization_rate",
+            "category": "Features",
+            "description": [
+                "The renderer supports variable rasterization rate"
+            ]
+        },
         {
             "name": "allow_inline_const_vertex_data",
             "category": "Features",
@@ -436,12 +443,12 @@
             "issue": "http://anglebug.com/42266744"
         },
         {
-            "name": "always_resolve_multisample_render_buffers",
+            "name": "enable_multisampled_render_to_texture_on_non_tilers",
             "category": "Features",
             "description": [
-                "Always automatically resolve MSAA render buffers to single sampled texture."
+                "Enable EXT_multisampled_render_to_texture on non tiled GPUs."
             ],
-            "issue": "http://crbug.com/1486094"
+            "issue": "http://anglebug.com/42261786"
         },
         {
             "name": "inject_asm_statement_into_loop_bodies",
diff --git a/infra/specs/angle.json b/infra/specs/angle.json
index dd1f1e8077024c7bc4aa8f07da2ad3110d6df844..e0c9dafe51d72f3fcce051daf5eae0cc3c55fefe 100644
--- a/infra/specs/angle.json
+++ b/infra/specs/angle.json
@@ -5919,7 +5919,7 @@
             "cpu": "x86-64",
             "display_attached": "1",
             "gpu": "8086:3e9b",
-            "os": "Mac-14.6-23G5075b"
+            "os": "Mac-14.6-23G80"
           },
           "service_account": "chromium-tester@chops-service-accounts.iam.gserviceaccount.com"
         },
@@ -5941,7 +5941,7 @@
             "cpu": "x86-64",
             "display_attached": "1",
             "gpu": "8086:3e9b",
-            "os": "Mac-14.6-23G5075b"
+            "os": "Mac-14.6-23G80"
           },
           "service_account": "chromium-tester@chops-service-accounts.iam.gserviceaccount.com"
         },
@@ -5964,7 +5964,7 @@
             "cpu": "x86-64",
             "display_attached": "1",
             "gpu": "8086:3e9b",
-            "os": "Mac-14.6-23G5075b"
+            "os": "Mac-14.6-23G80"
           },
           "service_account": "chromium-tester@chops-service-accounts.iam.gserviceaccount.com"
         },
@@ -5987,7 +5987,7 @@
             "cpu": "x86-64",
             "display_attached": "1",
             "gpu": "8086:3e9b",
-            "os": "Mac-14.6-23G5075b"
+            "os": "Mac-14.6-23G80"
           },
           "service_account": "chromium-tester@chops-service-accounts.iam.gserviceaccount.com"
         },
@@ -6009,7 +6009,7 @@
             "cpu": "x86-64",
             "display_attached": "1",
             "gpu": "8086:3e9b",
-            "os": "Mac-14.6-23G5075b"
+            "os": "Mac-14.6-23G80"
           },
           "service_account": "chromium-tester@chops-service-accounts.iam.gserviceaccount.com"
         },
@@ -6032,7 +6032,7 @@
             "cpu": "x86-64",
             "display_attached": "1",
             "gpu": "8086:3e9b",
-            "os": "Mac-14.6-23G5075b"
+            "os": "Mac-14.6-23G80"
           },
           "service_account": "chromium-tester@chops-service-accounts.iam.gserviceaccount.com",
           "shards": 2
@@ -6056,7 +6056,7 @@
             "cpu": "x86-64",
             "display_attached": "1",
             "gpu": "8086:3e9b",
-            "os": "Mac-14.6-23G5075b"
+            "os": "Mac-14.6-23G80"
           },
           "service_account": "chromium-tester@chops-service-accounts.iam.gserviceaccount.com",
           "shards": 2
@@ -6080,7 +6080,7 @@
             "cpu": "x86-64",
             "display_attached": "1",
             "gpu": "8086:3e9b",
-            "os": "Mac-14.6-23G5075b"
+            "os": "Mac-14.6-23G80"
           },
           "service_account": "chromium-tester@chops-service-accounts.iam.gserviceaccount.com",
           "shards": 2
@@ -6100,7 +6100,7 @@
             "cpu": "x86-64",
             "display_attached": "1",
             "gpu": "8086:3e9b",
-            "os": "Mac-14.6-23G5075b"
+            "os": "Mac-14.6-23G80"
           },
           "service_account": "chromium-tester@chops-service-accounts.iam.gserviceaccount.com"
         },
diff --git a/infra/specs/mixins.pyl b/infra/specs/mixins.pyl
index 6dca5a9514b6fe7d22fba5059f4dd87609b781fd..ccd48f5816503df86c78ed07acce3d583d4a4c7b 100644
--- a/infra/specs/mixins.pyl
+++ b/infra/specs/mixins.pyl
@@ -54,7 +54,7 @@
   'mac_mini_intel_gpu_experimental': { 'swarming': { 'dimensions': { 'cpu': 'x86-64',
                                                                      'display_attached': '1',
                                                                      'gpu': '8086:3e9b',
-                                                                     'os': 'Mac-14.6-23G5075b'}}},
+                                                                     'os': 'Mac-14.6-23G80'}}},
   'mac_mini_intel_gpu_stable': { 'swarming': { 'dimensions': { 'cpu': 'x86-64',
                                                                'display_attached': '1',
                                                                'gpu': '8086:3e9b',
diff --git a/scripts/code_generation_hashes/SPIR-V_helpers.json b/scripts/code_generation_hashes/SPIR-V_helpers.json
index 7a5dfd0cec8b13a5487723c04dbc716f25517255..e20744392da592d3df950b28d76b713a96ea3bb1 100644
--- a/scripts/code_generation_hashes/SPIR-V_helpers.json
+++ b/scripts/code_generation_hashes/SPIR-V_helpers.json
@@ -10,5 +10,5 @@
   "src/common/spirv/spirv_instruction_parser_autogen.h":
     "06672c12d63e6a8a489dd8d2ee7204ce",
   "third_party/spirv-headers/src/include/spirv/unified1/spirv.core.grammar.json":
-    "6a657b301421cff0bad32fb3c970b432"
+    "7b869bd8919b2c7a9d0dccc6d3d27f39"
 }
diff --git a/scripts/code_generation_hashes/Vulkan_mandatory_format_support_table.json b/scripts/code_generation_hashes/Vulkan_mandatory_format_support_table.json
index a560c0c474e4b5f866a5db9e753811c3285872f1..de428ff9b5b43f6147e2360ffd8ce9dd6a85ad34 100644
--- a/scripts/code_generation_hashes/Vulkan_mandatory_format_support_table.json
+++ b/scripts/code_generation_hashes/Vulkan_mandatory_format_support_table.json
@@ -10,5 +10,5 @@
   "src/libANGLE/renderer/vulkan/vk_mandatory_format_support_table_autogen.cpp":
     "96ac9e08704b7a086f7c8db5d213de2b",
   "third_party/vulkan-headers/src/registry/vk.xml":
-    "236e6388241ac472f4d8f29430a860de"
+    "1ba52b9c48a5b8ecef08157b751a9a47"
 }
diff --git a/scripts/entry_point_packed_gl_enums.json b/scripts/entry_point_packed_gl_enums.json
index b258660ba4367032e592ab8d6397ee5edca0a661..fe961d3125259b015d3d005a6d45443ede3131bc 100644
--- a/scripts/entry_point_packed_gl_enums.json
+++ b/scripts/entry_point_packed_gl_enums.json
@@ -440,6 +440,9 @@
     "glFramebufferFoveationParameters": {
         "framebuffer": "FramebufferID"
     },
+    "glFramebufferResolveRenderbufferWEBKIT": {
+        "renderbuffer": "RenderbufferID"
+    },
     "glFramebufferRenderbuffer": {
         "renderbuffer": "RenderbufferID"
     },
diff --git a/scripts/export_targets.py b/scripts/export_targets.py
index a423e42e877234b3c127c14d1457877378e6e92d..e64a1ba92713fde54db0fa9e0bd4d3ccce724441 100755
--- a/scripts/export_targets.py
+++ b/scripts/export_targets.py
@@ -264,6 +264,8 @@ IGNORED_INCLUDES = {
     b'spirv/unified1/spirv.hpp11',
     # Behind #if defined(QAT_COMPRESSION_ENABLED) in third_party/zlib/deflate.c
     b'contrib/qat/deflate_qat.h',
+    # Behind #if defined(TRACY_ENABLE) in third_party/vulkan-validation-layers/src/layers/vulkan/generated/chassis.cpp
+    b'profiling/profiling.h',
 }
 
 IGNORED_INCLUDE_PREFIXES = {
diff --git a/scripts/generate_entry_points.py b/scripts/generate_entry_points.py
index a4dd512e5e4b864018737215e13d622deda4bbd8..79853e9acef6f523356a226432f77065467f4982 100755
--- a/scripts/generate_entry_points.py
+++ b/scripts/generate_entry_points.py
@@ -1010,6 +1010,7 @@ FORMAT_DICT = {
     "GLfloat": "%f",
     "GLint": "%d",
     "GLintptr": UNSIGNED_LONG_LONG_FORMAT,
+    "GLMTLRasterizationRateMapANGLE": POINTER_FORMAT,
     "GLshort": "%d",
     "GLsizei": "%d",
     "GLsizeiptr": UNSIGNED_LONG_LONG_FORMAT,
diff --git a/scripts/gl_angle_ext.xml b/scripts/gl_angle_ext.xml
index 466387f2a92f2bda5884e6cde7910678690fe58d..6bd47c33dee536bdefad6aa8ca602ec41577089b 100644
--- a/scripts/gl_angle_ext.xml
+++ b/scripts/gl_angle_ext.xml
@@ -9,6 +9,11 @@
         Includes data used to auto-generate ANGLE classes.
     </comment>
 
+    <!-- SECTION: GL type definitions. -->
+    <types>
+        <type>typedef void *<name>GLMTLRasterizationRateMapANGLE</name>;</type>
+    </types>
+
     <!-- SECTION: GL parameter class type definitions. -->
     <groups>
         <group name="CreateFlagMask">
@@ -1048,6 +1053,18 @@
             <param group="LogicOp"><ptype>GLenum</ptype> <name>opcode</name></param>
             <alias name="glLogicOp"/>
         </command>
+        <command>
+            <proto>void <name>glBindMetalRasterizationRateMapANGLE</name></proto>
+            <param><ptype>GLuint</ptype> <name>framebuffer</name></param>
+            <param><ptype>GLMTLRasterizationRateMapANGLE</ptype> <name>map</name></param>
+        </command>
+        <command>
+            <proto>void <name>glFramebufferResolveRenderbufferWEBKIT</name></proto>
+            <param><ptype>GLenum</ptype> <name>target</name></param>
+            <param><ptype>GLenum</ptype> <name>attachment</name></param>
+            <param><ptype>GLenum</ptype> <name>renderbuffertarget</name></param>
+            <param><ptype>GLuint</ptype> <name>renderbuffer</name></param>
+        </command>
     </commands>
 
     <!-- SECTION: ANGLE extension interface definitions -->
@@ -1449,6 +1466,16 @@
         <extension name="GL_ANGLE_shader_binary" supported='gles2'>
             <require>
                 <enum name="GL_SHADER_BINARY_ANGLE"/>
+        <extension name="GL_ANGLE_variable_rasterization_rate_metal" supported="gles2">
+            <require>
+                <enum name="GL_VARIABLE_RASTERIZATION_RATE_ANGLE"/>
+                <enum name="GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE"/>
+                <command name="glBindMetalRasterizationRateMapANGLE"/>
+            </require>
+        </extension>
+        <extension name="GL_WEBKIT_explicit_resolve_target" supported='gles2'>
+            <require>
+                <command name="glFramebufferResolveRenderbufferWEBKIT"/>
             </require>
         </extension>
     </extensions>
@@ -1630,4 +1657,9 @@
     <enums namespace="GL" start="0x0BF2" end="0x0BF2" vendor="ANGLE">
         <enum value="0x0BF2" name="GL_COLOR_LOGIC_OP_ANGLE"/>
     </enums>
+
+    <enums namespace="GL" start="0x96BC" end="0x96BD" vendor="ANGLE">
+        <enum value="0x96BC" name="GL_VARIABLE_RASTERIZATION_RATE_ANGLE"/>
+        <enum value="0x96BD" name="GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE"/>
+    </enums>
 </registry>
diff --git a/scripts/registry_xml.py b/scripts/registry_xml.py
index 4e428eac9e30e27598fcd2c3bf9d1b0a3a7fc6d0..438bf3b75cd41f83920f2227338443c2cdc2aba2 100644
--- a/scripts/registry_xml.py
+++ b/scripts/registry_xml.py
@@ -73,12 +73,14 @@ angle_requestable_extensions = [
     "GL_ANGLE_texture_compression_dxt5",
     "GL_ANGLE_texture_external_update",
     "GL_ANGLE_texture_multisample",
+    "GL_ANGLE_variable_rasterization_rate_metal",
     "GL_ANGLE_vulkan_image",
     "GL_ANGLE_yuv_internal_format",
     "GL_CHROMIUM_color_buffer_float_rgb",
     "GL_CHROMIUM_color_buffer_float_rgba",
     "GL_CHROMIUM_lose_context",
     "GL_CHROMIUM_sync_query",
+    "GL_WEBKIT_explicit_resolve_target",
 ]
 
 gles_requestable_extensions = [
diff --git a/scripts/roll_aosp.sh b/scripts/roll_aosp.sh
index b8d8a0cbcc80f71d2331da917b2a9e204c41c55e..35a03e3177c03c769ba5a07487a8ceac76481c03 100755
--- a/scripts/roll_aosp.sh
+++ b/scripts/roll_aosp.sh
@@ -101,12 +101,15 @@ function generate_Android_bp_file() {
 }
 
 function generate_angle_commit_file() {
-    # output ANGLE git hash during ANGLE to Android roll into
-    # {AndroidANGLERoot}/angle_commmit.h. Files include angle_commit.h will use
-    # this version of angle_commit.h, instead of the one generated by build
-    # target angle_commit_id during compile time, because in Android repos,
-    # access to .git is not guaranteed, and ANGLE git hash generated during
-    # compile time in Android will end with up "unknown hash".
+    # Output chromium ANGLE git hash during ANGLE to Android roll into
+    # {AndroidANGLERoot}/angle_commit.h.
+    # In Android repos, we stop generating the angle_commit.h at compile time,
+    # because in Android repos, access to .git is not guaranteed, running
+    # commit_id.py at compile time will generate "unknown hash" for ANGLE_COMMIT_HASH.
+    # Instead, we generate angle_commit.h during ANGLE to Android roll time.
+    # Before roll_aosp.sh is called during the roll, ANGLE_UPSTREAM_HASH environment
+    # variable is set to {rolling_to} git hash, and that can be used by below
+    # script commit_id.py as the ANGLE_COMMIT_HASH written to the angle_commit.h.
     # See b/348044346.
     python3 src/commit_id.py \
         gen \
diff --git a/src/commit_id.py b/src/commit_id.py
index 0adec614810c38df429e4d1d9b3352964b75d2d6..6fa4d2630e269bda54f59c2b043f8e0cd14f3820 100755
--- a/src/commit_id.py
+++ b/src/commit_id.py
@@ -109,13 +109,18 @@ if len(sys.argv) < 3 or operation != 'gen':
 
 output_file = sys.argv[2]
 commit_id_size = 12
-commit_id = 'unknown hash'
 commit_date = 'unknown date'
 commit_position = '0'
 
-if git_dir_exists:
+# If the ANGLE_UPSTREAM_HASH environment variable is set, use it as
+# commit_id. commit_date will be 'unknown date' and commit_position will be 0
+# in this case. See details in roll_aosp.sh where commit_id.py is invoked.
+commit_id = os.environ.get('ANGLE_UPSTREAM_HASH')
+# If ANGLE_UPSTREAM_HASH environment variable is not set, use the git command
+# to get the git hash, when .git is available
+if git_dir_exists and not commit_id:
     try:
-        commit_id = grab_output('git rev-parse --short=%d HEAD' % commit_id_size, cwd) or commit_id
+        commit_id = grab_output('git rev-parse --short=%d HEAD' % commit_id_size, cwd)
         commit_date = grab_output('git show -s --format=%ci HEAD', cwd) or commit_date
         commit_position = get_commit_position(cwd) or commit_position
     except:
@@ -123,7 +128,7 @@ if git_dir_exists:
 
 hfile = open(output_file, 'w')
 
-hfile.write('#define ANGLE_COMMIT_HASH "%s"\n' % commit_id)
+hfile.write('#define ANGLE_COMMIT_HASH "%s"\n' % (commit_id or "unknown hash"))
 hfile.write('#define ANGLE_COMMIT_HASH_SIZE %d\n' % commit_id_size)
 hfile.write('#define ANGLE_COMMIT_DATE "%s"\n' % commit_date)
 hfile.write('#define ANGLE_COMMIT_POSITION %s\n' % commit_position)
diff --git a/src/common/angle_version.h b/src/common/angle_version.h
index 488c65dfe7abc88493226fa8206d4fa52de5d85b..ca395f8911b960593a272550ea96cd8a9148d38c 100644
--- a/src/common/angle_version.h
+++ b/src/common/angle_version.h
@@ -21,9 +21,15 @@
 #define ANGLE_STRINGIFY(x) #x
 #define ANGLE_MACRO_STRINGIFY(x) ANGLE_STRINGIFY(x)
 
+#if (ANGLE_REVISION != 0)
+#    define ANGLE_REVISION_SUFFIX "." ANGLE_MACRO_STRINGIFY(ANGLE_REVISION)
+#else
+#    define ANGLE_REVISION_SUFFIX ""
+#endif
+
 #define ANGLE_VERSION_STRING                                             \
     ANGLE_MACRO_STRINGIFY(ANGLE_MAJOR_VERSION)                           \
-    "." ANGLE_MACRO_STRINGIFY(ANGLE_MINOR_VERSION) "." ANGLE_MACRO_STRINGIFY( \
-        ANGLE_REVISION) " git hash: " ANGLE_COMMIT_HASH
+    "." ANGLE_MACRO_STRINGIFY(ANGLE_MINOR_VERSION) ANGLE_REVISION_SUFFIX \
+        " git hash: " ANGLE_COMMIT_HASH
 
 #endif  // COMMON_ANGLE_VERSION_H_
diff --git a/src/common/entry_points_enum_autogen.cpp b/src/common/entry_points_enum_autogen.cpp
index 8266c3561d4af4f06a2dab192500026802ab5e9c..7e3f74ef36e2faa66caaf55a32ef936019a1e689 100644
--- a/src/common/entry_points_enum_autogen.cpp
+++ b/src/common/entry_points_enum_autogen.cpp
@@ -540,6 +540,8 @@ const char *GetEntryPointName(EntryPoint ep)
             return "glBindImageTexture";
         case EntryPoint::GLBindImageTextures:
             return "glBindImageTextures";
+        case EntryPoint::GLBindMetalRasterizationRateMapANGLE:
+            return "glBindMetalRasterizationRateMapANGLE";
         case EntryPoint::GLBindProgramPipeline:
             return "glBindProgramPipeline";
         case EntryPoint::GLBindProgramPipelineEXT:
@@ -1216,6 +1218,8 @@ const char *GetEntryPointName(EntryPoint ep)
             return "glFramebufferRenderbuffer";
         case EntryPoint::GLFramebufferRenderbufferOES:
             return "glFramebufferRenderbufferOES";
+        case EntryPoint::GLFramebufferResolveRenderbufferWEBKIT:
+            return "glFramebufferResolveRenderbufferWEBKIT";
         case EntryPoint::GLFramebufferTexture:
             return "glFramebufferTexture";
         case EntryPoint::GLFramebufferTexture1D:
diff --git a/src/common/entry_points_enum_autogen.h b/src/common/entry_points_enum_autogen.h
index e45604ba4ee4eb8ebffbd506dc34c71f635f3618..b7dc04efab8abb5bcd354aada4229d4487b21c88 100644
--- a/src/common/entry_points_enum_autogen.h
+++ b/src/common/entry_points_enum_autogen.h
@@ -276,6 +276,7 @@ enum class EntryPoint
     GLBindFramebufferOES,
     GLBindImageTexture,
     GLBindImageTextures,
+    GLBindMetalRasterizationRateMapANGLE,
     GLBindProgramPipeline,
     GLBindProgramPipelineEXT,
     GLBindRenderbuffer,
@@ -614,6 +615,7 @@ enum class EntryPoint
     GLFramebufferPixelLocalStorageRestoreANGLE,
     GLFramebufferRenderbuffer,
     GLFramebufferRenderbufferOES,
+    GLFramebufferResolveRenderbufferWEBKIT,
     GLFramebufferTexture,
     GLFramebufferTexture1D,
     GLFramebufferTexture2D,
diff --git a/src/common/frame_capture_utils_autogen.cpp b/src/common/frame_capture_utils_autogen.cpp
index f356982285bc9bed6469571d6c2f0ef9ea7cc940..9f601fc824eae7e78da8e8f9b3fe6576b0d7e76c 100644
--- a/src/common/frame_capture_utils_autogen.cpp
+++ b/src/common/frame_capture_utils_autogen.cpp
@@ -222,6 +222,10 @@ void WriteParamCaptureReplay(std::ostream &os, const CallCapture &call, const Pa
             WriteParamValueReplay<ParamType::TGLDEBUGPROCKHR>(os, call,
                                                               param.value.GLDEBUGPROCKHRVal);
             break;
+        case ParamType::TGLMTLRasterizationRateMapANGLE:
+            WriteParamValueReplay<ParamType::TGLMTLRasterizationRateMapANGLE>(
+                os, call, param.value.GLMTLRasterizationRateMapANGLEVal);
+            break;
         case ParamType::TGLbitfield:
             WriteParamValueReplay<ParamType::TGLbitfield>(os, call, param.value.GLbitfieldVal);
             break;
@@ -768,6 +772,8 @@ const char *ParamTypeToString(ParamType paramType)
             return "GLDEBUGPROC";
         case ParamType::TGLDEBUGPROCKHR:
             return "GLDEBUGPROCKHR";
+        case ParamType::TGLMTLRasterizationRateMapANGLE:
+            return "GLMTLRasterizationRateMapANGLE";
         case ParamType::TGLbitfield:
             return "GLbitfield";
         case ParamType::TGLboolean:
diff --git a/src/common/frame_capture_utils_autogen.h b/src/common/frame_capture_utils_autogen.h
index e68affb0e0773ce2c83439ca9c188066cc225d34..88a18830e8037a5cf2c23d60b94f2910c6edf136 100644
--- a/src/common/frame_capture_utils_autogen.h
+++ b/src/common/frame_capture_utils_autogen.h
@@ -74,6 +74,7 @@ enum class ParamType
     TFramebufferIDPointer,
     TGLDEBUGPROC,
     TGLDEBUGPROCKHR,
+    TGLMTLRasterizationRateMapANGLE,
     TGLbitfield,
     TGLboolean,
     TGLbooleanConstPointer,
@@ -191,7 +192,7 @@ enum class ParamType
     TvoidPointerPointer,
 };
 
-constexpr uint32_t kParamTypeCount = 172;
+constexpr uint32_t kParamTypeCount = 173;
 
 union ParamValue
 {
@@ -252,6 +253,7 @@ union ParamValue
     gl::FramebufferID *FramebufferIDPointerVal;
     GLDEBUGPROC GLDEBUGPROCVal;
     GLDEBUGPROCKHR GLDEBUGPROCKHRVal;
+    GLMTLRasterizationRateMapANGLE GLMTLRasterizationRateMapANGLEVal;
     GLbitfield GLbitfieldVal;
     GLboolean GLbooleanVal;
     const GLboolean *GLbooleanConstPointerVal;
@@ -745,6 +747,14 @@ inline GLDEBUGPROCKHR GetParamVal<ParamType::TGLDEBUGPROCKHR, GLDEBUGPROCKHR>(
     return value.GLDEBUGPROCKHRVal;
 }
 
+template <>
+inline GLMTLRasterizationRateMapANGLE
+GetParamVal<ParamType::TGLMTLRasterizationRateMapANGLE, GLMTLRasterizationRateMapANGLE>(
+    const ParamValue &value)
+{
+    return value.GLMTLRasterizationRateMapANGLEVal;
+}
+
 template <>
 inline GLbitfield GetParamVal<ParamType::TGLbitfield, GLbitfield>(const ParamValue &value)
 {
@@ -1629,6 +1639,8 @@ T AccessParamValue(ParamType paramType, const ParamValue &value)
             return GetParamVal<ParamType::TGLDEBUGPROC, T>(value);
         case ParamType::TGLDEBUGPROCKHR:
             return GetParamVal<ParamType::TGLDEBUGPROCKHR, T>(value);
+        case ParamType::TGLMTLRasterizationRateMapANGLE:
+            return GetParamVal<ParamType::TGLMTLRasterizationRateMapANGLE, T>(value);
         case ParamType::TGLbitfield:
             return GetParamVal<ParamType::TGLbitfield, T>(value);
         case ParamType::TGLboolean:
@@ -2227,6 +2239,14 @@ inline void SetParamVal<ParamType::TGLDEBUGPROCKHR>(GLDEBUGPROCKHR valueIn, Para
     valueOut->GLDEBUGPROCKHRVal = valueIn;
 }
 
+template <>
+inline void SetParamVal<ParamType::TGLMTLRasterizationRateMapANGLE>(
+    GLMTLRasterizationRateMapANGLE valueIn,
+    ParamValue *valueOut)
+{
+    valueOut->GLMTLRasterizationRateMapANGLEVal = valueIn;
+}
+
 template <>
 inline void SetParamVal<ParamType::TGLbitfield>(GLbitfield valueIn, ParamValue *valueOut)
 {
@@ -3149,6 +3169,9 @@ void InitParamValue(ParamType paramType, T valueIn, ParamValue *valueOut)
         case ParamType::TGLDEBUGPROCKHR:
             SetParamVal<ParamType::TGLDEBUGPROCKHR>(valueIn, valueOut);
             break;
+        case ParamType::TGLMTLRasterizationRateMapANGLE:
+            SetParamVal<ParamType::TGLMTLRasterizationRateMapANGLE>(valueIn, valueOut);
+            break;
         case ParamType::TGLbitfield:
             SetParamVal<ParamType::TGLbitfield>(valueIn, valueOut);
             break;
diff --git a/src/common/gl_enum_utils_autogen.cpp b/src/common/gl_enum_utils_autogen.cpp
index 40f19699fbf375c7531b7da2e020dde7003f7ace..af39593acdc3dcbd39043ad1bfcbcbceb0e487b6 100644
--- a/src/common/gl_enum_utils_autogen.cpp
+++ b/src/common/gl_enum_utils_autogen.cpp
@@ -2814,6 +2814,10 @@ const char *GLenumToString(GLESEnum enumGroup, unsigned int value)
                     return "GL_RGBX8_ANGLE";
                 case 0x96BB:
                     return "GL_SHADER_BINARY_ANGLE";
+                case 0x96BC:
+                    return "GL_VARIABLE_RASTERIZATION_RATE_ANGLE";
+                case 0x96BD:
+                    return "GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE";
                 case 0x96BE:
                     return "GL_PROGRAM_BINARY_READY_ANGLE";
                 case 0x96E0:
@@ -22190,6 +22194,7 @@ static StringEnumEntry g_stringEnumTable[] = {
     {"GL_MESH_SUBROUTINE_UNIFORM_NV", 0x957E},
     {"GL_MESH_VERTICES_OUT_NV", 0x9579},
     {"GL_MESH_WORK_GROUP_SIZE_NV", 0x953E},
+    {"GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE", 0x96BD},
     {"GL_MIN", 0x8007},
     {"GL_MINMAX", 0x802E},
     {"GL_MINMAX_EXT", 0x802E},
@@ -24841,6 +24846,7 @@ static StringEnumEntry g_stringEnumTable[] = {
     {"GL_VARIABLE_E_NV", 0x8527},
     {"GL_VARIABLE_F_NV", 0x8528},
     {"GL_VARIABLE_G_NV", 0x8529},
+    {"GL_VARIABLE_RASTERIZATION_RATE_ANGLE", 0x96BC},
     {"GL_VARIANT_ARRAY_EXT", 0x87E8},
     {"GL_VARIANT_ARRAY_POINTER_EXT", 0x87E9},
     {"GL_VARIANT_ARRAY_STRIDE_EXT", 0x87E6},
diff --git a/src/common/utilities.cpp b/src/common/utilities.cpp
index 34826b47554d0d89e8b9619d46828177b2c1b873..2e03a110de26a7cb888d8e9a5997deaf3745c12c 100644
--- a/src/common/utilities.cpp
+++ b/src/common/utilities.cpp
@@ -6,6 +6,12 @@
 
 // utilities.cpp: Conversion functions and other utility routines.
 
+// Older clang versions have a false positive on this warning here.
+// TODO(dino): Is this still necessary?
+#if defined(__clang__)
+#    pragma clang diagnostic ignored "-Wglobal-constructors"
+#endif
+
 #include "common/utilities.h"
 #include "GLES3/gl3.h"
 #include "common/mathutil.h"
diff --git a/src/compiler/fuzz/translator_fuzzer.cpp b/src/compiler/fuzz/translator_fuzzer.cpp
index 5b4b726798eb3ed29415dd103366c6206981517a..b258a88908e4893ef0a5a108c724220fb5ba4841 100644
--- a/src/compiler/fuzz/translator_fuzzer.cpp
+++ b/src/compiler/fuzz/translator_fuzzer.cpp
@@ -140,6 +140,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
         static_cast<uint32_t>(ShFragmentSynchronizationType::InvalidEnum));
 
     std::vector<uint32_t> validOutputs;
+#ifndef ANGLE_TRANSLATOR_FUZZER_METAL_ONLY
     validOutputs.push_back(SH_ESSL_OUTPUT);
     validOutputs.push_back(SH_GLSL_COMPATIBILITY_OUTPUT);
     validOutputs.push_back(SH_GLSL_130_OUTPUT);
@@ -156,6 +157,10 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
     validOutputs.push_back(SH_HLSL_3_0_OUTPUT);
     validOutputs.push_back(SH_HLSL_4_1_OUTPUT);
     validOutputs.push_back(SH_HLSL_4_0_FL9_3_OUTPUT);
+#endif
+#ifdef ANGLE_ENABLE_METAL
+    validOutputs.push_back(SH_MSL_METAL_OUTPUT);
+#endif
     bool found = false;
     for (auto valid : validOutputs)
     {
@@ -187,6 +192,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 
         if (translator == nullptr)
         {
+            sh::Finalize();
             return 0;
         }
 
@@ -220,6 +226,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 
         if (!translator->Init(resources))
         {
+            sh::Finalize();
             return 0;
         }
 
@@ -232,5 +239,6 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
     const char *shaderStrings[]       = {reinterpret_cast<const char *>(data)};
     translator->compile(shaderStrings, 1, options);
 
+    sh::Finalize();
     return 0;
 }
diff --git a/src/compiler/preprocessor/preprocessor_tab_autogen.cpp b/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
index a7607c9e529ce7a57bdc6c3c82134b144eb67130..c9ec1adec020589bd4fcfe226721042a8f2c6cf5 100644
--- a/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
+++ b/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.8.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
diff --git a/src/compiler/translator/Compiler.cpp b/src/compiler/translator/Compiler.cpp
index 4f30968dbed22cccdcdb143bff8aa4bc3327a5df..b60842eedab0f3dd9f00b15a5cbb36198e5a9253 100644
--- a/src/compiler/translator/Compiler.cpp
+++ b/src/compiler/translator/Compiler.cpp
@@ -1046,13 +1046,22 @@ bool TCompiler::checkAndSimplifyAST(TIntermBlock *root,
         return false;
     }
 
-    // Attempt to reject shaders with infinite loops in WebGL contexts.
     if (IsWebGLBasedSpec(mShaderSpec))
     {
-        if (!PruneInfiniteLoops(this, root, &mSymbolTable))
+        // Remove infinite loops, they are not supposed to exist in shaders.
+        bool anyInfiniteLoops = false;
+        if (!PruneInfiniteLoops(this, root, &mSymbolTable, &anyInfiniteLoops))
         {
             return false;
         }
+
+        // If requested, reject shaders with infinite loops.  If not requested, the same loops are
+        // removed from the shader as a fallback.
+        if (anyInfiniteLoops && mCompileOptions.rejectWebglShadersWithUndefinedBehavior)
+        {
+            mDiagnostics.globalError("Infinite loop detected in the shader");
+            return false;
+        }
     }
 
     if (compileOptions.rescopeGlobalVariables)
diff --git a/src/compiler/translator/glslang_tab_autogen.cpp b/src/compiler/translator/glslang_tab_autogen.cpp
index 8fdf47f2df99d27c74009feaca91a7366c2ffa7e..876840f7c6be65fda7260182c3dc9ca38b79ac88 100644
--- a/src/compiler/translator/glslang_tab_autogen.cpp
+++ b/src/compiler/translator/glslang_tab_autogen.cpp
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.8.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
diff --git a/src/compiler/translator/glslang_tab_autogen.h b/src/compiler/translator/glslang_tab_autogen.h
index d5a48edd40f382359db76acf1a1ce75b6a6dc6d5..907c62e0bb659292b3912707904981863429478a 100644
--- a/src/compiler/translator/glslang_tab_autogen.h
+++ b/src/compiler/translator/glslang_tab_autogen.h
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.8.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison interface for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
diff --git a/src/compiler/translator/tree_ops/PruneInfiniteLoops.cpp b/src/compiler/translator/tree_ops/PruneInfiniteLoops.cpp
index 1037df6c80f5d19a6963766ce7f1261808253a6c..79a3f72f97135936ca31837dddc986f14f5bd540 100644
--- a/src/compiler/translator/tree_ops/PruneInfiniteLoops.cpp
+++ b/src/compiler/translator/tree_ops/PruneInfiniteLoops.cpp
@@ -113,9 +113,13 @@ class PruneInfiniteLoopsTraverser : public TIntermTraverser
 {
   public:
     PruneInfiniteLoopsTraverser(TSymbolTable *symbolTable, const VariableSet &constVariables)
-        : TIntermTraverser(true, false, false, symbolTable), mConstVariables(constVariables)
+        : TIntermTraverser(true, false, false, symbolTable),
+          mConstVariables(constVariables),
+          mAnyLoopsPruned(false)
     {}
 
+    bool anyLoopsPruned() const { return mAnyLoopsPruned; }
+
   private:
     bool visitLoop(Visit visit, TIntermLoop *loop) override;
     bool visitSwitch(Visit visit, TIntermSwitch *node) override;
@@ -144,6 +148,7 @@ class PruneInfiniteLoopsTraverser : public TIntermTraverser
 
     const VariableSet &mConstVariables;
     std::stack<LoopStats> mLoopStats;
+    bool mAnyLoopsPruned;
 };
 
 bool PruneInfiniteLoopsTraverser::visitLoop(Visit visit, TIntermLoop *loop)
@@ -168,6 +173,7 @@ bool PruneInfiniteLoopsTraverser::visitLoop(Visit visit, TIntermLoop *loop)
     if (isConditionConstant && loop->getType() != ELoopDoWhile && !hasLoopEscape())
     {
         mMultiReplacements.emplace_back(getParentNode()->getAsBlock(), loop, TIntermSequence{});
+        mAnyLoopsPruned = true;
     }
 
     onScopeEnd();
@@ -215,14 +221,20 @@ bool PruneInfiniteLoopsTraverser::visitBranch(Visit visit, TIntermBranch *node)
 }
 }  // namespace
 
-bool PruneInfiniteLoops(TCompiler *compiler, TIntermBlock *root, TSymbolTable *symbolTable)
+bool PruneInfiniteLoops(TCompiler *compiler,
+                        TIntermBlock *root,
+                        TSymbolTable *symbolTable,
+                        bool *anyLoopsPruned)
 {
+    *anyLoopsPruned = false;
+
     FindConstantVariablesTraverser constVarTransverser(symbolTable);
     root->traverse(&constVarTransverser);
 
     PruneInfiniteLoopsTraverser pruneTraverser(symbolTable,
                                                constVarTransverser.getConstVariables());
     root->traverse(&pruneTraverser);
+    *anyLoopsPruned = pruneTraverser.anyLoopsPruned();
     return pruneTraverser.updateTree(compiler, root);
 }
 
diff --git a/src/compiler/translator/tree_ops/PruneInfiniteLoops.h b/src/compiler/translator/tree_ops/PruneInfiniteLoops.h
index 4e4fec0371b757b8556d902e11a2db146416f758..0aae9e59dbd0adffe4c7344c4047f82505ae3f0e 100644
--- a/src/compiler/translator/tree_ops/PruneInfiniteLoops.h
+++ b/src/compiler/translator/tree_ops/PruneInfiniteLoops.h
@@ -18,7 +18,8 @@ class TSymbolTable;
 
 [[nodiscard]] bool PruneInfiniteLoops(TCompiler *compiler,
                                       TIntermBlock *root,
-                                      TSymbolTable *symbolTable);
+                                      TSymbolTable *symbolTable,
+                                      bool *anyLoopsPruned);
 }  // namespace sh
 
 #endif  // COMPILER_TRANSLATOR_TREEOPS_PRUNEINFINITELOOPS_H_
diff --git a/src/compiler/translator/tree_ops/msl/SeparateCompoundExpressions.cpp b/src/compiler/translator/tree_ops/msl/SeparateCompoundExpressions.cpp
index 49eaec47c303c5d7ef368f330ec3009bd8bf8c9f..db8035477778364f59d8f18c138a8de8094fcd0d 100644
--- a/src/compiler/translator/tree_ops/msl/SeparateCompoundExpressions.cpp
+++ b/src/compiler/translator/tree_ops/msl/SeparateCompoundExpressions.cpp
@@ -262,8 +262,10 @@ class Separator : public TIntermRebuild
         }
         auto &bindingMap = getCurrBindingMap();
         const Name name  = mIdGen.createNewName();
-        auto *var =
-            new TVariable(&mSymbolTable, name.rawName(), &newExpr.getType(), name.symbolType());
+        TType *newType   = new TType(newExpr.getType());
+        newType->setQualifier(EvqTemporary);
+        newType->setInterfaceBlock(nullptr);
+        auto *var  = new TVariable(&mSymbolTable, name.rawName(), newType, name.symbolType());
         auto *decl = new TIntermDeclaration(var, &newExpr);
         pushStmt(*decl);
         mExprMap[&oldExpr] = new TIntermSymbol(var);
diff --git a/src/libANGLE/CLCommandQueue.cpp b/src/libANGLE/CLCommandQueue.cpp
index f6ebe98ed5b03a117fbc27f011f999bc4ee86748..66dc0e89d1a59a6a24ac63410c18039f1964fd8f 100644
--- a/src/libANGLE/CLCommandQueue.cpp
+++ b/src/libANGLE/CLCommandQueue.cpp
@@ -23,6 +23,14 @@ namespace cl
 namespace
 {
 
+void InitializeOutputEvent(cl_event *event)
+{
+    if (event != nullptr)
+    {
+        *event = nullptr;
+    }
+}
+
 void CheckCreateEvent(CommandQueue &queue,
                       cl_command_type commandType,
                       const rx::CLEventImpl::CreateFunc &createFunc,
@@ -145,6 +153,7 @@ angle::Result CommandQueue::enqueueReadBuffer(cl_mem buffer,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(
         mImpl->enqueueReadBuffer(buf, blocking, offset, size, ptr, waitEvents, eventCreateFuncPtr));
@@ -168,6 +177,7 @@ angle::Result CommandQueue::enqueueWriteBuffer(cl_mem buffer,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueWriteBuffer(buf, blocking, offset, size, ptr, waitEvents,
                                         eventCreateFuncPtr));
@@ -196,6 +206,7 @@ angle::Result CommandQueue::enqueueReadBufferRect(cl_mem buffer,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueReadBufferRect(buf, blocking, bufferOrigin, hostOrigin, region,
                                            bufferRowPitch, bufferSlicePitch, hostRowPitch,
@@ -225,6 +236,7 @@ angle::Result CommandQueue::enqueueWriteBufferRect(cl_mem buffer,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueWriteBufferRect(buf, blocking, bufferOrigin, hostOrigin, region,
                                             bufferRowPitch, bufferSlicePitch, hostRowPitch,
@@ -249,6 +261,7 @@ angle::Result CommandQueue::enqueueCopyBuffer(cl_mem srcBuffer,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueCopyBuffer(src, dst, srcOffset, dstOffset, size, waitEvents,
                                        eventCreateFuncPtr));
@@ -276,6 +289,7 @@ angle::Result CommandQueue::enqueueCopyBufferRect(cl_mem srcBuffer,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueCopyBufferRect(src, dst, srcOrigin, dstOrigin, region, srcRowPitch,
                                            srcSlicePitch, dstRowPitch, dstSlicePitch, waitEvents,
@@ -299,6 +313,7 @@ angle::Result CommandQueue::enqueueFillBuffer(cl_mem buffer,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueFillBuffer(buf, pattern, patternSize, offset, size, waitEvents,
                                        eventCreateFuncPtr));
@@ -323,6 +338,7 @@ angle::Result CommandQueue::enqueueMapBuffer(cl_mem buffer,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueMapBuffer(buf, blocking, mapFlags, offset, size, waitEvents,
                                       eventCreateFuncPtr, mapPtr));
@@ -348,6 +364,7 @@ angle::Result CommandQueue::enqueueReadImage(cl_mem image,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueReadImage(img, blocking, origin, region, rowPitch, slicePitch, ptr,
                                       waitEvents, eventCreateFuncPtr));
@@ -373,6 +390,7 @@ angle::Result CommandQueue::enqueueWriteImage(cl_mem image,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueWriteImage(img, blocking, origin, region, inputRowPitch,
                                        inputSlicePitch, ptr, waitEvents, eventCreateFuncPtr));
@@ -396,6 +414,7 @@ angle::Result CommandQueue::enqueueCopyImage(cl_mem srcImage,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueCopyImage(src, dst, srcOrigin, dstOrigin, region, waitEvents,
                                       eventCreateFuncPtr));
@@ -417,6 +436,7 @@ angle::Result CommandQueue::enqueueFillImage(cl_mem image,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(
         mImpl->enqueueFillImage(img, fillColor, origin, region, waitEvents, eventCreateFuncPtr));
@@ -440,6 +460,7 @@ angle::Result CommandQueue::enqueueCopyImageToBuffer(cl_mem srcImage,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueCopyImageToBuffer(src, dst, srcOrigin, region, dstOffset, waitEvents,
                                               eventCreateFuncPtr));
@@ -463,6 +484,7 @@ angle::Result CommandQueue::enqueueCopyBufferToImage(cl_mem srcBuffer,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueCopyBufferToImage(src, dst, srcOffset, dstOrigin, region, waitEvents,
                                               eventCreateFuncPtr));
@@ -489,6 +511,7 @@ angle::Result CommandQueue::enqueueMapImage(cl_mem image,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueMapImage(img, blocking, mapFlags, origin, region, imageRowPitch,
                                      imageSlicePitch, waitEvents, eventCreateFuncPtr, mapPtr));
@@ -508,6 +531,7 @@ angle::Result CommandQueue::enqueueUnmapMemObject(cl_mem memobj,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueUnmapMemObject(memory, mappedPtr, waitEvents, eventCreateFuncPtr));
 
@@ -532,6 +556,7 @@ angle::Result CommandQueue::enqueueMigrateMemObjects(cl_uint numMemObjects,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueMigrateMemObjects(memories, flags, waitEvents, eventCreateFuncPtr));
 
@@ -550,6 +575,7 @@ angle::Result CommandQueue::enqueueNDRangeKernel(cl_kernel kernel,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueNDRangeKernel(krnl, ndrange, waitEvents, eventCreateFuncPtr));
 
@@ -567,6 +593,7 @@ angle::Result CommandQueue::enqueueTask(cl_kernel kernel,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueTask(krnl, waitEvents, eventCreateFuncPtr));
 
@@ -618,6 +645,7 @@ angle::Result CommandQueue::enqueueNativeKernel(UserFunc userFunc,
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueNativeKernel(userFunc, args, cbArgs, buffers, offsets, waitEvents,
                                          eventCreateFuncPtr));
@@ -634,6 +662,7 @@ angle::Result CommandQueue::enqueueMarkerWithWaitList(cl_uint numEventsInWaitLis
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueMarkerWithWaitList(waitEvents, eventCreateFuncPtr));
 
@@ -644,6 +673,7 @@ angle::Result CommandQueue::enqueueMarkerWithWaitList(cl_uint numEventsInWaitLis
 angle::Result CommandQueue::enqueueMarker(cl_event *event)
 {
     rx::CLEventImpl::CreateFunc eventCreateFunc;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueMarker(eventCreateFunc));
 
@@ -664,6 +694,7 @@ angle::Result CommandQueue::enqueueBarrierWithWaitList(cl_uint numEventsInWaitLi
     rx::CLEventImpl::CreateFunc eventCreateFunc;
     rx::CLEventImpl::CreateFunc *const eventCreateFuncPtr =
         event != nullptr ? &eventCreateFunc : nullptr;
+    InitializeOutputEvent(event);
 
     ANGLE_TRY(mImpl->enqueueBarrierWithWaitList(waitEvents, eventCreateFuncPtr));
 
diff --git a/src/libANGLE/Context.cpp b/src/libANGLE/Context.cpp
index 3ec9be59df1847a4b9e5eef6cbf41f2414fb154a..e3bf9da1bde6124c3aed59de644e6ccca24ca31d 100644
--- a/src/libANGLE/Context.cpp
+++ b/src/libANGLE/Context.cpp
@@ -9959,6 +9959,33 @@ void Context::textureFoveationParameters(TextureID texturePacked,
     texture->setFocalPoint(layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);
 }
 
+void Context::framebufferResolveRenderbufferWEBKIT(GLenum target,
+                                                   GLenum attachment,
+                                                   GLenum renderbuffertarget,
+                                                   RenderbufferID renderbuffer)
+{
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    Framebuffer *framebuffer = mState.getTargetFramebuffer(target);
+    ASSERT(framebuffer);
+
+    if (renderbuffer.value != 0)
+    {
+        Renderbuffer *renderbufferObject = getRenderbuffer(renderbuffer);
+
+        framebuffer->setAttachmentResolve(this, GL_RENDERBUFFER, attachment, gl::ImageIndex(),
+                                          renderbufferObject);
+    }
+    else
+    {
+        framebuffer->resetAttachmentResolve(this, attachment);
+    }
+
+    mState.setObjectDirty(target);
+#else
+    UNIMPLEMENTED();
+#endif
+}
+
 void Context::endTiling(GLbitfield preserveMask)
 {
     ANGLE_CONTEXT_TRY(mImplementation->endTiling(this, preserveMask));
@@ -10019,6 +10046,14 @@ void Context::clearTexSubImage(TextureID texturePacked,
                                              static_cast<const uint8_t *>(data)));
 }
 
+void Context::bindMetalRasterizationRateMap(GLuint renderbufferHandle, GLMTLRasterizationRateMapANGLE map)
+{
+    Renderbuffer *renderbuffer = getRenderbuffer({renderbufferHandle});
+    rx::RenderbufferImpl *renderbufferImpl = renderbuffer ? renderbuffer->getImplementation() : nullptr;
+    ANGLE_CONTEXT_TRY(mImplementation->bindMetalRasterizationRateMap(this, renderbufferImpl, map));
+    getMutablePrivateState()->setVariableRasterizationRateMap(map);
+}
+
 // ErrorSet implementation.
 ErrorSet::ErrorSet(Debug *debug,
                    const angle::FrontendFeatures &frontendFeatures,
diff --git a/src/libANGLE/Context_gles_ext_autogen.h b/src/libANGLE/Context_gles_ext_autogen.h
index 364ea21366fc5a76de2b3e596b7039370e911bde..05d8ca360ef3df12b82fcdf07d2d53e2ed58f7c1 100644
--- a/src/libANGLE/Context_gles_ext_autogen.h
+++ b/src/libANGLE/Context_gles_ext_autogen.h
@@ -631,6 +631,8 @@
     void invalidateTexture(TextureType targetPacked);                                              \
     /* GL_ANGLE_texture_multisample */                                                             \
     /* GL_ANGLE_texture_rectangle */                                                               \
+    /* GL_ANGLE_variable_rasterization_rate_metal */                                               \
+    void bindMetalRasterizationRateMap(GLuint renderbuffer, GLMTLRasterizationRateMapANGLE map);   \
     /* GL_ANGLE_vulkan_image */                                                                    \
     void acquireTextures(GLuint numTextures, const TextureID *texturesPacked,                      \
                          const GLenum *layouts);                                                   \
@@ -658,6 +660,10 @@
     /* GL_CHROMIUM_framebuffer_mixed_samples */                                                    \
     /* GL_CHROMIUM_lose_context */                                                                 \
     void loseContext(GraphicsResetStatus currentPacked, GraphicsResetStatus otherPacked);          \
-    /* GL_CHROMIUM_sync_query */
+    /* GL_CHROMIUM_sync_query */                                                                   \
+    /* GL_WEBKIT_explicit_resolve_target */                                                        \
+    void framebufferResolveRenderbufferWEBKIT(GLenum target, GLenum attachment,                    \
+                                              GLenum renderbuffertarget,                           \
+                                              RenderbufferID renderbufferPacked);
 
 #endif  // ANGLE_CONTEXT_API_EXT_AUTOGEN_H_
diff --git a/src/libANGLE/Display.cpp b/src/libANGLE/Display.cpp
index 0d19af39384a89eb0eddacacf6feef0c31b06cdc..a939e41542b1434d5fc4ee1a2e739ee8326fd0bc 100644
--- a/src/libANGLE/Display.cpp
+++ b/src/libANGLE/Display.cpp
@@ -2357,6 +2357,9 @@ void Display::initializeFrontendFeatures()
 
     ANGLE_FEATURE_CONDITION(&mFrontendFeatures, forceMinimumMaxVertexAttributes, false);
 
+    // Reject shaders with undefined behavior.  In the compiler, this only applies to WebGL.
+    ANGLE_FEATURE_CONDITION(&mFrontendFeatures, rejectWebglShadersWithUndefinedBehavior, true);
+
     mImplementation->initializeFrontendFeatures(&mFrontendFeatures);
 }
 
diff --git a/src/libANGLE/Framebuffer.cpp b/src/libANGLE/Framebuffer.cpp
index a7a1cc00168789858d23f9799317c293bda6b077..a276a6c5f5244cb72fbc3c750dd2dcd439039d53 100644
--- a/src/libANGLE/Framebuffer.cpp
+++ b/src/libANGLE/Framebuffer.cpp
@@ -164,6 +164,47 @@ FramebufferStatus CheckAttachmentCompleteness(const Context *context,
     return FramebufferStatus::Complete();
 }
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+// Check the |checkAttachment| in reference to |firstAttachment| for the sake of explicit resolve
+// target framebuffer completeness.
+FramebufferStatus CheckResolveTargetMatchesForCompleteness(
+    const Context *context,
+    const FramebufferAttachment &firstAttachment,
+    const FramebufferAttachment &checkAttachment)
+{
+    ASSERT(firstAttachment.isAttached() && checkAttachment.isAttached());
+
+    FramebufferStatus attachmentCompleteness =
+        CheckAttachmentCompleteness(context, checkAttachment);
+    if (!attachmentCompleteness.isComplete())
+    {
+        return attachmentCompleteness;
+    }
+
+    if (checkAttachment.getSamples() != 0)
+    {
+        return FramebufferStatus::Incomplete(GL_FRAMEBUFFER_UNSUPPORTED,
+            "Framebuffer is incomplete: Resolve attachments have multiple samples.");
+    }
+
+    if (firstAttachment.getSize() != checkAttachment.getSize())
+    {
+        return gl::FramebufferStatus::Incomplete(
+            GL_FRAMEBUFFER_UNSUPPORTED,
+            gl::err::kFramebufferIncompleteUnsupportedMissmatchedDimensions);
+    }
+
+    if (!Format::EquivalentForBlit(firstAttachment.getFormat(), checkAttachment.getFormat()))
+    {
+        return gl::FramebufferStatus::Incomplete(GL_FRAMEBUFFER_UNSUPPORTED,
+                                                 "Framebuffer is incomplete: Attempting to resolve "
+                                                 "to target with non-equivalent format for blit");
+    }
+
+    return FramebufferStatus::Complete();
+}
+#endif
+
 FramebufferStatus CheckAttachmentSampleCounts(const Context *context,
                                               GLsizei currAttachmentSamples,
                                               GLsizei samples,
@@ -369,6 +410,9 @@ FramebufferState::FramebufferState(rx::UniqueSerial serial)
       mFramebufferSerial(serial),
       mLabel(),
       mColorAttachments(1),
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+      mColorResolveAttachments(1),
+#endif
       mColorAttachmentsMask(0),
       mDrawBufferStates(1, GL_BACK),
       mReadBufferState(GL_BACK),
@@ -392,6 +436,9 @@ FramebufferState::FramebufferState(const Caps &caps, FramebufferID id, rx::Uniqu
       mFramebufferSerial(serial),
       mLabel(),
       mColorAttachments(caps.maxColorAttachments),
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+      mColorResolveAttachments(caps.maxColorAttachments),
+#endif
       mColorAttachmentsMask(0),
       mDrawBufferStates(caps.maxDrawBuffers, GL_NONE),
       mReadBufferState(GL_COLOR_ATTACHMENT0_EXT),
@@ -598,6 +645,27 @@ const FramebufferAttachment *FramebufferState::getDepthStencilAttachment() const
     return nullptr;
 }
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+const FramebufferAttachment *FramebufferState::getColorResolveAttachment(
+    size_t colorAttachment) const
+{
+    ASSERT(colorAttachment < mColorResolveAttachments.size());
+    return mColorResolveAttachments[colorAttachment].isAttached()
+               ? &mColorResolveAttachments[colorAttachment]
+               : nullptr;
+}
+
+const FramebufferAttachment *FramebufferState::getDepthResolveAttachment() const
+{
+    return mDepthResolveAttachment.isAttached() ? &mDepthResolveAttachment : nullptr;
+}
+
+const FramebufferAttachment *FramebufferState::getStencilResolveAttachment() const
+{
+    return mStencilResolveAttachment.isAttached() ? &mStencilResolveAttachment : nullptr;
+}
+#endif
+
 const Extents FramebufferState::getAttachmentExtentsIntersection() const
 {
     int32_t width  = std::numeric_limits<int32_t>::max();
@@ -828,6 +896,10 @@ Framebuffer::Framebuffer(const Context *context, rx::GLImplFactory *factory, Fra
     ASSERT(mImpl != nullptr);
     ASSERT(mState.mColorAttachments.size() ==
            static_cast<size_t>(context->getCaps().maxColorAttachments));
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    ASSERT(mState.mColorResolveAttachments.size() ==
+           static_cast<size_t>(context->getCaps().maxColorAttachments));
+#endif
 
     for (uint32_t colorIndex = 0;
          colorIndex < static_cast<uint32_t>(mState.mColorAttachments.size()); ++colorIndex)
@@ -862,6 +934,15 @@ void Framebuffer::onDestroy(const Context *context)
     mState.mWebGLStencilAttachment.detach(context, mState.mFramebufferSerial);
     mState.mWebGLDepthStencilAttachment.detach(context, mState.mFramebufferSerial);
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    for (auto &attachment : mState.mColorResolveAttachments)
+    {
+        attachment.detach(context, mState.mFramebufferSerial);
+    }
+    mState.mDepthResolveAttachment.detach(context, mState.mFramebufferSerial);
+    mState.mStencilResolveAttachment.detach(context, mState.mFramebufferSerial);
+#endif
+
     if (mPixelLocalStorage)
     {
         mPixelLocalStorage->onFramebufferDestroyed(context);
@@ -1151,6 +1232,23 @@ size_t Framebuffer::getDrawbufferStateCount() const
     return mState.mDrawBufferStates.size();
 }
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+const FramebufferAttachment *Framebuffer::getColorResolveAttachment(size_t colorAttachment) const
+{
+    return mState.getColorResolveAttachment(colorAttachment);
+}
+
+const FramebufferAttachment *Framebuffer::getDepthResolveAttachment() const
+{
+    return mState.getDepthResolveAttachment();
+}
+
+const FramebufferAttachment *Framebuffer::getStencilResolveAttachment() const
+{
+    return mState.getStencilResolveAttachment();
+}
+#endif
+
 GLenum Framebuffer::getDrawBufferState(size_t drawBuffer) const
 {
     ASSERT(drawBuffer < mState.mDrawBufferStates.size());
@@ -1445,6 +1543,25 @@ FramebufferStatus Framebuffer::checkStatusWithGLFrontEnd(const Context *context)
         }
     }
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    for (size_t index = 0; index < mState.mColorAttachments.size(); ++index)
+    {
+        const FramebufferAttachment &colorAttachment = mState.mColorAttachments[index];
+        const FramebufferAttachment &colorResolveAttachment =
+            mState.mColorResolveAttachments[index];
+        if (colorResolveAttachment.isAttached() && colorAttachment.isAttached())
+        {
+            FramebufferStatus resolveAttachmentCompleteness =
+                CheckResolveTargetMatchesForCompleteness(context, colorAttachment,
+                                                         colorResolveAttachment);
+            if (!resolveAttachmentCompleteness.isComplete())
+            {
+                return resolveAttachmentCompleteness;
+            }
+        }
+    }
+#endif
+
     const FramebufferAttachment &depthAttachment = mState.mDepthAttachment;
     if (depthAttachment.isAttached())
     {
@@ -1498,6 +1615,20 @@ FramebufferStatus Framebuffer::checkStatusWithGLFrontEnd(const Context *context)
                     err::kFramebufferIncompleteMismatchedLayeredAttachments);
             }
         }
+
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+        const FramebufferAttachment &depthResolveAttachment = mState.mDepthResolveAttachment;
+        if (depthResolveAttachment.isAttached())
+        {
+            FramebufferStatus resolveAttachmentCompleteness =
+                CheckResolveTargetMatchesForCompleteness(context, depthAttachment,
+                                                         depthResolveAttachment);
+            if (!resolveAttachmentCompleteness.isComplete())
+            {
+                return resolveAttachmentCompleteness;
+            }
+        }
+#endif
     }
 
     const FramebufferAttachment &stencilAttachment = mState.mStencilAttachment;
@@ -1553,6 +1684,20 @@ FramebufferStatus Framebuffer::checkStatusWithGLFrontEnd(const Context *context)
                     err::kFramebufferIncompleteMismatchedLayeredAttachments);
             }
         }
+
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+        const FramebufferAttachment &stencilResolveAttachment = mState.mStencilResolveAttachment;
+        if (stencilResolveAttachment.isAttached())
+        {
+            FramebufferStatus resolveAttachmentCompleteness =
+                CheckResolveTargetMatchesForCompleteness(context, stencilAttachment,
+                                                         stencilResolveAttachment);
+            if (!resolveAttachmentCompleteness.isComplete())
+            {
+                return resolveAttachmentCompleteness;
+            }
+        }
+#endif
     }
 
     // Starting from ES 3.0 stencil and depth, if present, should be the same image
@@ -1680,6 +1825,8 @@ angle::Result Framebuffer::discard(const Context *context, size_t count, const G
     // Back-ends might make the contents of the FBO undefined. In WebGL 2.0, invalidate operations
     // can be no-ops, so we should probably do that to ensure consistency.
     // TODO(jmadill): WebGL behaviour, and robust resource init behaviour without WebGL.
+    if (context->isRobustResourceInitEnabled())
+        markDrawAttachmentsNeedInit(count, attachments);
 
     return mImpl->discard(context, count, attachments);
 }
@@ -1691,6 +1838,8 @@ angle::Result Framebuffer::invalidate(const Context *context,
     // Back-ends might make the contents of the FBO undefined. In WebGL 2.0, invalidate operations
     // can be no-ops, so we should probably do that to ensure consistency.
     // TODO(jmadill): WebGL behaviour, and robust resource init behaviour without WebGL.
+    if (context->isRobustResourceInitEnabled())
+        markDrawAttachmentsNeedInit(count, attachments);
 
     return mImpl->invalidate(context, count, attachments);
 }
@@ -1726,9 +1875,20 @@ bool Framebuffer::partialClearNeedsInit(const Context *context,
         return true;
     }
 
+    const Framebuffer *drawFramebuffer = glState.getDrawFramebuffer();
+    const FramebufferAttachment *stencilAttachment =
+        drawFramebuffer ? drawFramebuffer->getStencilOrDepthStencilAttachment() : nullptr;
+    const GLuint stencilBits    = stencilAttachment ? stencilAttachment->getStencilSize() : 0;
+    const GLuint maxStencilMask = (1 << stencilBits) - 1;
+
+    // The least significant |stencilBits| of stencil mask state specify a
+    // mask. Compare the masks for differences only in those bits, ignoring any
+    // difference in the high bits.
     const auto &depthStencil       = glState.getDepthStencilState();
-    if (stencil && (depthStencil.stencilMask != depthStencil.stencilWritemask ||
-                    depthStencil.stencilBackMask != depthStencil.stencilBackWritemask))
+    const GLuint differentFwdMasks = depthStencil.stencilMask ^ depthStencil.stencilWritemask;
+    const GLuint differentBackMasks =
+        depthStencil.stencilBackMask ^ depthStencil.stencilBackWritemask;
+    if (stencil && ((differentFwdMasks | differentBackMasks) & maxStencilMask) != 0)
     {
         return true;
     }
@@ -2012,6 +2172,66 @@ void Framebuffer::setAttachmentMultiview(const Context *context,
                   FramebufferAttachment::kDefaultRenderToTextureSamples);
 }
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+void Framebuffer::setAttachmentResolve(const Context *context,
+                                       GLenum type,
+                                       GLenum binding,
+                                       const ImageIndex &textureIndex,
+                                       FramebufferAttachmentObject *resource)
+{
+    switch (binding)
+    {
+        case GL_DEPTH_STENCIL:
+        case GL_DEPTH_STENCIL_ATTACHMENT:
+            updateAttachmentResolve(context, &mState.mDepthResolveAttachment,
+                                    DIRTY_BIT_DEPTH_ATTACHMENT, &mDirtyDepthAttachmentBinding, type,
+                                    binding, textureIndex, resource);
+            updateAttachmentResolve(context, &mState.mStencilResolveAttachment,
+                                    DIRTY_BIT_STENCIL_ATTACHMENT, &mDirtyStencilAttachmentBinding,
+                                    type, binding, textureIndex, resource);
+            break;
+        case GL_DEPTH:
+        case GL_DEPTH_ATTACHMENT:
+            updateAttachmentResolve(context, &mState.mDepthResolveAttachment,
+                                    DIRTY_BIT_DEPTH_ATTACHMENT, &mDirtyDepthAttachmentBinding, type,
+                                    binding, textureIndex, resource);
+            if (context->isWebGL1())
+            {
+                updateAttachmentResolve(context, &mState.mStencilResolveAttachment,
+                                        DIRTY_BIT_STENCIL_ATTACHMENT,
+                                        &mDirtyStencilAttachmentBinding, GL_NONE,
+                                        GL_STENCIL_ATTACHMENT, ImageIndex(), nullptr);
+            }
+            break;
+
+        case GL_STENCIL:
+        case GL_STENCIL_ATTACHMENT:
+            updateAttachmentResolve(context, &mState.mStencilResolveAttachment,
+                                    DIRTY_BIT_STENCIL_ATTACHMENT, &mDirtyStencilAttachmentBinding,
+                                    type, binding, textureIndex, resource);
+            if (context->isWebGL1())
+            {
+                updateAttachmentResolve(context, &mState.mDepthResolveAttachment,
+                                        DIRTY_BIT_DEPTH_ATTACHMENT, &mDirtyDepthAttachmentBinding,
+                                        GL_NONE, GL_DEPTH_ATTACHMENT, ImageIndex(), nullptr);
+            }
+            break;
+
+        default:
+        {
+            const size_t colorIndex = binding - GL_COLOR_ATTACHMENT0;
+            ASSERT(colorIndex < mState.mColorResolveAttachments.size());
+
+            const size_t dirtyBit = DIRTY_BIT_COLOR_ATTACHMENT_0 + colorIndex;
+            updateAttachmentResolve(context, &mState.mColorResolveAttachments[colorIndex], dirtyBit,
+                                    &mDirtyColorAttachmentBindings[colorIndex], type, binding,
+                                    textureIndex, resource);
+        }
+        break;
+    }
+}
+#endif
+
 void Framebuffer::commitWebGL1DepthStencilIfConsistent(const Context *context,
                                                        GLsizei numViews,
                                                        GLuint baseViewIndex,
@@ -2189,11 +2409,40 @@ void Framebuffer::updateAttachment(const Context *context,
     invalidateCompletenessCache();
 }
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+void Framebuffer::updateAttachmentResolve(const Context *context,
+                                          FramebufferAttachment *attachment,
+                                          size_t dirtyBit,
+                                          angle::ObserverBinding *onDirtyBinding,
+                                          GLenum type,
+                                          GLenum binding,
+                                          const ImageIndex &textureIndex,
+                                          FramebufferAttachmentObject *resource)
+{
+    attachment->attach(
+        context, type, binding, textureIndex, resource, FramebufferAttachment::kDefaultNumViews,
+        FramebufferAttachment::kDefaultBaseViewIndex, false,
+        FramebufferAttachment::kDefaultRenderToTextureSamples, mState.mFramebufferSerial);
+    mDirtyBits.set(dirtyBit);
+    onDirtyBinding->bind(resource);
+    mAttachmentChangedAfterEnablingFoveation = isFoveationEnabled();
+
+    invalidateCompletenessCache();
+}
+#endif
+
 void Framebuffer::resetAttachment(const Context *context, GLenum binding)
 {
     setAttachment(context, GL_NONE, binding, ImageIndex(), nullptr);
 }
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+void Framebuffer::resetAttachmentResolve(const Context *context, GLenum binding)
+{
+    setAttachmentResolve(context, GL_NONE, binding, ImageIndex(), nullptr);
+}
+#endif
+
 void Framebuffer::setWriteControlMode(SrgbWriteControlMode srgbWriteControlMode)
 {
     if (srgbWriteControlMode != mState.getWriteControlMode())
@@ -2839,4 +3088,56 @@ angle::Result Framebuffer::syncAttachmentState(const Context *context,
 
     return angle::Result::Continue;
 }
+
+void Framebuffer::markDrawAttachmentsNeedInit(size_t count, const GLenum *attachments)
+{
+    bool stateChanged = false;
+    for (size_t attachmentIdx = 0; attachmentIdx < count; attachmentIdx++)
+    {
+        GLenum attachmentBindPoint = attachments[attachmentIdx];
+        switch (attachmentBindPoint)
+        {
+            case GL_DEPTH_ATTACHMENT:
+            case GL_DEPTH_EXT:
+                if (mState.mDepthAttachment.isAttached())
+                {
+                    mDirtyBits.set(DIRTY_BIT_DEPTH_ATTACHMENT);
+                    mState.mResourceNeedsInit.set(DIRTY_BIT_DEPTH_ATTACHMENT);
+                    mState.mDepthAttachment.setInitState(InitState::MayNeedInit);
+                    stateChanged = true;
+                }
+                break;
+            case GL_STENCIL_ATTACHMENT:
+            case GL_STENCIL_EXT:
+                if (mState.mStencilAttachment.isAttached())
+                {
+                    mDirtyBits.set(DIRTY_BIT_STENCIL_ATTACHMENT);
+                    mState.mResourceNeedsInit.set(DIRTY_BIT_STENCIL_ATTACHMENT);
+                    mState.mStencilAttachment.setInitState(InitState::MayNeedInit);
+                    stateChanged = true;
+                }
+                break;
+            default:
+                if (attachmentBindPoint == GL_COLOR_EXT)
+                {
+                    attachmentBindPoint = GL_COLOR_ATTACHMENT0;
+                }
+                int colorDirtyBit = attachmentBindPoint - GL_COLOR_ATTACHMENT0;
+                if (colorDirtyBit >= 0 && colorDirtyBit < IMPLEMENTATION_MAX_DRAW_BUFFERS &&
+                    mState.mColorAttachments[colorDirtyBit].isAttached())
+                {
+                    mDirtyBits.set(colorDirtyBit);
+                    mState.mResourceNeedsInit.set(colorDirtyBit);
+                    mState.mColorAttachments[colorDirtyBit].setInitState(InitState::MayNeedInit);
+                    stateChanged = true;
+                }
+                break;
+        }
+    }
+
+    if (stateChanged)
+    {
+        onStateChange(angle::SubjectMessage::DirtyBitsFlagged);
+    }
+}
 }  // namespace gl
diff --git a/src/libANGLE/Framebuffer.h b/src/libANGLE/Framebuffer.h
index f690cf4932b165ff099b1ea1c80002023f559dd5..4d633b3d7722e72d14aa645cba2498d465b88212 100644
--- a/src/libANGLE/Framebuffer.h
+++ b/src/libANGLE/Framebuffer.h
@@ -82,6 +82,13 @@ class FramebufferState final : angle::NonCopyable
     const FramebufferAttachment *getDepthStencilAttachment() const;
     const FramebufferAttachment *getReadPixelsAttachment(GLenum readFormat) const;
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    // GL_WEBKIT_explicit_resolve_target
+    const FramebufferAttachment *getColorResolveAttachment(size_t colorAttachment) const;
+    const FramebufferAttachment *getDepthResolveAttachment() const;
+    const FramebufferAttachment *getStencilResolveAttachment() const;
+#endif
+
     const DrawBuffersVector<GLenum> &getDrawBufferStates() const { return mDrawBufferStates; }
     DrawBufferMask getEnabledDrawBuffers() const { return mEnabledDrawBuffers; }
     GLenum getReadBufferState() const { return mReadBufferState; }
@@ -162,6 +169,13 @@ class FramebufferState final : angle::NonCopyable
     FramebufferAttachment mDepthAttachment;
     FramebufferAttachment mStencilAttachment;
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    // GL_WEBKIT_explicit_resolve_target;
+    DrawBuffersVector<FramebufferAttachment> mColorResolveAttachments;
+    FramebufferAttachment mDepthResolveAttachment;
+    FramebufferAttachment mStencilResolveAttachment;
+#endif
+
     // Tracks all the color buffers attached to this FramebufferDesc
     DrawBufferMask mColorAttachmentsMask;
 
@@ -244,6 +258,16 @@ class Framebuffer final : public angle::ObserverInterface,
                                 GLint baseViewIndex);
     void resetAttachment(const Context *context, GLenum binding);
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    // GL_WEBKIT_explicit_resolve_target
+    void setAttachmentResolve(const Context *context,
+                              GLenum type,
+                              GLenum binding,
+                              const ImageIndex &textureIndex,
+                              FramebufferAttachmentObject *resource);
+    void resetAttachmentResolve(const Context *context, GLenum binding);
+#endif
+
     bool detachTexture(Context *context, TextureID texture);
     bool detachRenderbuffer(Context *context, RenderbufferID renderbuffer);
 
@@ -258,9 +282,16 @@ class Framebuffer final : public angle::ObserverInterface,
     const FramebufferAttachment *getFirstColorAttachment() const;
     const FramebufferAttachment *getFirstNonNullAttachment() const;
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    // GL_WEBKIT_explicit_resolve_target
+    const FramebufferAttachment *getColorResolveAttachment(size_t colorAttachment) const;
+    const FramebufferAttachment *getDepthResolveAttachment() const;
+    const FramebufferAttachment *getStencilResolveAttachment() const;
+#endif
+
     const DrawBuffersVector<FramebufferAttachment> &getColorAttachments() const
     {
-        return mState.mColorAttachments;
+        return mState.getColorAttachments();
     }
 
     const FramebufferState &getState() const { return mState; }
@@ -521,6 +552,18 @@ class Framebuffer final : public angle::ObserverInterface,
                           bool isMultiview,
                           GLsizei samples);
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    // GL_WEBKIT_explicit_resolve_target
+    void updateAttachmentResolve(const Context *context,
+                                 FramebufferAttachment *attachment,
+                                 size_t dirtyBit,
+                                 angle::ObserverBinding *onDirtyBinding,
+                                 GLenum type,
+                                 GLenum binding,
+                                 const ImageIndex &textureIndex,
+                                 FramebufferAttachmentObject *resource);
+#endif
+
     void markAttachmentsInitialized(const DrawBufferMask &color, bool depth, bool stencil);
 
     // Checks that we have a partially masked clear:
@@ -545,6 +588,8 @@ class Framebuffer final : public angle::ObserverInterface,
                                       Command command,
                                       const FramebufferAttachment *attachment) const;
 
+    void markDrawAttachmentsNeedInit(size_t count, const GLenum *attachments);
+
     FramebufferState mState;
     rx::FramebufferImpl *mImpl;
 
diff --git a/src/libANGLE/Shader.cpp b/src/libANGLE/Shader.cpp
index 8816b487593c2c2a47b2c386cc063d9e96dd01af..4a04caa488f388b34bc2656694babe985d8c3f57 100644
--- a/src/libANGLE/Shader.cpp
+++ b/src/libANGLE/Shader.cpp
@@ -674,6 +674,11 @@ void Shader::compile(const Context *context, angle::JobResultExpectancy resultEx
         options.limitExpressionComplexity  = true;
         options.enforcePackingRestrictions = true;
         options.initSharedVariables        = true;
+
+        if (context->getFrontendFeatures().rejectWebglShadersWithUndefinedBehavior.enabled)
+        {
+            options.rejectWebglShadersWithUndefinedBehavior = true;
+        }
     }
     else
     {
diff --git a/src/libANGLE/State.cpp b/src/libANGLE/State.cpp
index 23adcd03b5744ff40dd030567174aef4abe4a599..cb546dcc6bc7f2d7ac8aeb8a6c052b532dd64782 100644
--- a/src/libANGLE/State.cpp
+++ b/src/libANGLE/State.cpp
@@ -6,6 +6,9 @@
 
 // State.cpp: Implements the State class, encapsulating raw GL state.
 
+// Older clang versions have a false positive on this warning here.
+#pragma clang diagnostic ignored "-Wglobal-constructors"
+
 #include "libANGLE/State.h"
 
 #include <string.h>
@@ -369,6 +372,8 @@ PrivateState::PrivateState(const EGLenum clientType,
       mLogicOp(LogicalOperation::Copy),
       mPatchVertices(3),
       mPixelLocalStorageActivePlanes(0),
+      mVariableRasterizationRateEnabled(false),
+      mVariableRasterizationRateMap(nullptr),
       mNoSimultaneousConstantColorAndAlphaBlendFunc(false),
       mSetBlendIndexedInvoked(false),
       mSetBlendFactorsIndexedInvoked(false),
@@ -1247,6 +1252,26 @@ void PrivateState::setLogicOp(LogicalOperation opcode)
     }
 }
 
+void PrivateState::setVariableRasterizationRateEnabled(bool enabled)
+{
+    if (mVariableRasterizationRateEnabled != enabled)
+    {
+        mVariableRasterizationRateEnabled = enabled;
+        mDirtyBits.set(state::DIRTY_BIT_EXTENDED);
+        mExtendedDirtyBits.set(state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE);
+    }
+}
+
+void PrivateState::setVariableRasterizationRateMap(GLMTLRasterizationRateMapANGLE map)
+{
+    if (mVariableRasterizationRateMap != map)
+    {
+        mVariableRasterizationRateMap = map;
+        mDirtyBits.set(state::DIRTY_BIT_EXTENDED);
+        mExtendedDirtyBits.set(state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE);
+    }
+}
+
 void PrivateState::setVertexAttribf(GLuint index, const GLfloat values[4])
 {
     ASSERT(static_cast<size_t>(index) < mVertexAttribCurrentValues.size());
@@ -1379,6 +1404,9 @@ void PrivateState::setEnableFeature(GLenum feature, bool enabled)
         case GL_FETCH_PER_SAMPLE_ARM:
             mFetchPerSample = enabled;
             return;
+        case GL_VARIABLE_RASTERIZATION_RATE_ANGLE:
+            setVariableRasterizationRateEnabled(enabled);
+            return;
         default:
             break;
     }
@@ -1545,6 +1573,8 @@ bool PrivateState::getEnableFeature(GLenum feature) const
             return mShadingRatePreserveAspectRatio;
         case GL_FETCH_PER_SAMPLE_ARM:
             return mFetchPerSample;
+        case GL_VARIABLE_RASTERIZATION_RATE_ANGLE:
+            return mVariableRasterizationRateEnabled;
     }
 
     ASSERT(mClientVersion.major == 1);
@@ -3426,6 +3456,9 @@ void State::getPointerv(const Context *context, GLenum pname, void **params) con
                                           context->vertexArrayIndex(ParamToVertexArrayType(pname))),
                                       GL_VERTEX_ATTRIB_ARRAY_POINTER, params);
             return;
+        case GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE:
+            *params = privateState().getVariableRasterizationRateMap();
+            break;
         default:
             UNREACHABLE();
             break;
diff --git a/src/libANGLE/State.h b/src/libANGLE/State.h
index a1ac0dd3075d43422336e74317c93c0106cb448f..f7bc28d978000abedfe9f71058dcc8d122d16106 100644
--- a/src/libANGLE/State.h
+++ b/src/libANGLE/State.h
@@ -180,6 +180,7 @@ enum ExtendedDirtyBitType
     EXTENDED_DIRTY_BIT_LOGIC_OP_ENABLED,              // ANGLE_logic_op
     EXTENDED_DIRTY_BIT_LOGIC_OP,                      // ANGLE_logic_op
     EXTENDED_DIRTY_BIT_BLEND_ADVANCED_COHERENT,       // KHR_blend_operation_advanced_coherent
+    EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE,   // ANGLE_variable_rasterization_rate_metal
 
     EXTENDED_DIRTY_BIT_INVALID,
     EXTENDED_DIRTY_BIT_MAX = EXTENDED_DIRTY_BIT_INVALID,
@@ -475,6 +476,15 @@ class PrivateState : angle::NonCopyable
     void setPixelLocalStorageActivePlanes(GLsizei n);
     GLsizei getPixelLocalStorageActivePlanes() const { return mPixelLocalStorageActivePlanes; }
 
+    // GL_ANGLE_variable_rasterization_rate_metal
+    void setVariableRasterizationRateEnabled(bool enabled);
+    bool isVariableRasterizationRateEnabled() const { return mVariableRasterizationRateEnabled; }
+    void setVariableRasterizationRateMap(GLMTLRasterizationRateMapANGLE map);
+    GLMTLRasterizationRateMapANGLE getVariableRasterizationRateMap() const
+    {
+        return mVariableRasterizationRateMap;
+    }
+
     // Line width state setter
     void setLineWidth(GLfloat width);
     float getLineWidth() const { return mLineWidth; }
@@ -702,6 +712,10 @@ class PrivateState : angle::NonCopyable
     // GL_ANGLE_shader_pixel_local_storage
     GLsizei mPixelLocalStorageActivePlanes;
 
+    // GL_ANGLE_variable_rasterization_rate_metal
+    bool mVariableRasterizationRateEnabled;
+    GLMTLRasterizationRateMapANGLE mVariableRasterizationRateMap;
+
     // GLES1 emulation: state specific to GLES1
     GLES1State mGLES1State;
 
diff --git a/src/libANGLE/VertexArray.cpp b/src/libANGLE/VertexArray.cpp
index d915347cd37bbe6f658f1b5db6e414c25d174479..36f15e6d28bfbb77d700741c79d546c42d41e66e 100644
--- a/src/libANGLE/VertexArray.cpp
+++ b/src/libANGLE/VertexArray.cpp
@@ -360,6 +360,8 @@ VertexArray::DirtyBindingBits VertexArray::bindVertexBufferImpl(const Context *c
         return dirtyBindingBits;
     }
 
+    if (boundBuffer != oldBuffer)
+    {
         angle::ObserverBinding *observer = &mArrayBufferObserverBindings[bindingIndex];
         observer->assignSubject(boundBuffer);
 
@@ -374,9 +376,6 @@ VertexArray::DirtyBindingBits VertexArray::bindVertexBufferImpl(const Context *c
         }
 
         binding->assignBuffer(boundBuffer);
-    binding->setOffset(offset);
-    binding->setStride(stride);
-    updateCachedBufferBindingSize(binding);
 
         // Update client memory attribute pointers. Affects all bound attributes.
         if (boundBuffer)
@@ -407,6 +406,11 @@ VertexArray::DirtyBindingBits VertexArray::bindVertexBufferImpl(const Context *c
             mState.mClientMemoryAttribsMask |= binding->getBoundAttributesMask();
             updateCachedArrayBuffersMasks(false, false, false, binding->getBoundAttributesMask());
         }
+    }
+
+    binding->setOffset(offset);
+    binding->setStride(stride);
+    updateCachedBufferBindingSize(binding);
 
     return dirtyBindingBits;
 }
@@ -883,7 +887,10 @@ void VertexArrayBufferContentsObservers::enableForBuffer(Buffer *buffer, uint32_
 
 void VertexArrayBufferContentsObservers::disableForBuffer(Buffer *buffer, uint32_t attribIndex)
 {
+    if (mBufferObserversBitMask.test(attribIndex))
+    {
         buffer->removeContentsObserver(mVertexArray, attribIndex);
         mBufferObserversBitMask.reset(attribIndex);
+    }
 }
 }  // namespace gl
diff --git a/src/libANGLE/angletypes.cpp b/src/libANGLE/angletypes.cpp
index 560a07e6ee51d57eeff0c7f85c1ce48afa6303a1..fc5369289e4e100df4b6cde03fdd90c0e9b6c9b1 100644
--- a/src/libANGLE/angletypes.cpp
+++ b/src/libANGLE/angletypes.cpp
@@ -1146,9 +1146,11 @@ bool DecompressBlob(const uint8_t *compressedData,
     return true;
 }
 
-uint32_t GenerateCrc(const uint8_t *data, size_t size)
+uint32_t GenerateCRC32(const uint8_t *data, size_t size)
 {
-    return static_cast<uint32_t>(crc32_z(0u, data, size));
+    // To get required initial value for the crc, need to pass nullptr into buf.
+    const uLong initialValue = crc32_z(0u, nullptr, 0u);
+    return static_cast<uint32_t>(crc32_z(initialValue, data, size));
 }
 
 UnlockedTailCall::UnlockedTailCall() = default;
diff --git a/src/libANGLE/angletypes.h b/src/libANGLE/angletypes.h
index 6095e331549ad26d3433d53c41d01e324b62354d..d1b87e7c87cd914b0f62030cefb4cf8825cc81b2 100644
--- a/src/libANGLE/angletypes.h
+++ b/src/libANGLE/angletypes.h
@@ -1279,7 +1279,7 @@ bool DecompressBlob(const uint8_t *compressedData,
                     const size_t compressedSize,
                     size_t maxUncompressedDataSize,
                     MemoryBuffer *uncompressedData);
-uint32_t GenerateCrc(const uint8_t *data, size_t size);
+uint32_t GenerateCRC32(const uint8_t *data, size_t size);
 }  // namespace angle
 
 namespace std
diff --git a/src/libANGLE/capture/capture_gles_ext_autogen.cpp b/src/libANGLE/capture/capture_gles_ext_autogen.cpp
index 8fd39cbd8e1e15cd8b7142bf31b64719d0079c7e..54fed047c7d7c01b96592cc535cfad4f1e6ab3c7 100644
--- a/src/libANGLE/capture/capture_gles_ext_autogen.cpp
+++ b/src/libANGLE/capture/capture_gles_ext_autogen.cpp
@@ -5164,6 +5164,18 @@ CallCapture CaptureGetTranslatedShaderSourceANGLE(const State &glState,
     return CallCapture(angle::EntryPoint::GLGetTranslatedShaderSourceANGLE, std::move(paramBuffer));
 }
 
+CallCapture CaptureBindMetalRasterizationRateMapANGLE(const State &glState,
+                                                      bool isCallValid,
+                                                      GLMTLRasterizationRateMapANGLE map)
+{
+    ParamBuffer paramBuffer;
+
+    paramBuffer.addValueParam("map", ParamType::TGLMTLRasterizationRateMapANGLE, map);
+
+    return CallCapture(angle::EntryPoint::GLBindMetalRasterizationRateMapANGLE,
+                       std::move(paramBuffer));
+}
+
 CallCapture CaptureAcquireTexturesANGLE(const State &glState,
                                         bool isCallValid,
                                         GLuint numTextures,
@@ -12236,4 +12248,23 @@ CallCapture CaptureStartTilingQCOM(const State &glState,
     return CallCapture(angle::EntryPoint::GLStartTilingQCOM, std::move(paramBuffer));
 }
 
+CallCapture CaptureFramebufferResolveRenderbufferWEBKIT(const State &glState,
+                                                        bool isCallValid,
+                                                        GLenum target,
+                                                        GLenum attachment,
+                                                        GLenum renderbuffertarget,
+                                                        RenderbufferID renderbufferPacked)
+{
+    ParamBuffer paramBuffer;
+
+    paramBuffer.addEnumParam("target", GLESEnum::AllEnums, ParamType::TGLenum, target);
+    paramBuffer.addEnumParam("attachment", GLESEnum::AllEnums, ParamType::TGLenum, attachment);
+    paramBuffer.addEnumParam("renderbuffertarget", GLESEnum::AllEnums, ParamType::TGLenum,
+                             renderbuffertarget);
+    paramBuffer.addValueParam("renderbufferPacked", ParamType::TRenderbufferID, renderbufferPacked);
+
+    return CallCapture(angle::EntryPoint::GLFramebufferResolveRenderbufferWEBKIT,
+                       std::move(paramBuffer));
+}
+
 }  // namespace gl
diff --git a/src/libANGLE/capture/capture_gles_ext_autogen.h b/src/libANGLE/capture/capture_gles_ext_autogen.h
index e06b394709e2e712312c3596cd51f1465f705c07..382a460d8cef36920770b9f79c945d4674de0806 100644
--- a/src/libANGLE/capture/capture_gles_ext_autogen.h
+++ b/src/libANGLE/capture/capture_gles_ext_autogen.h
@@ -993,6 +993,11 @@ angle::CallCapture CaptureGetTranslatedShaderSourceANGLE(const State &glState,
                                                          GLsizei *length,
                                                          GLchar *source);
 
+// GL_ANGLE_variable_rasterization_rate_metal
+angle::CallCapture CaptureBindMetalRasterizationRateMapANGLE(const State &glState,
+                                                             bool isCallValid,
+                                                             GLMTLRasterizationRateMapANGLE map);
+
 // GL_ANGLE_vulkan_image
 angle::CallCapture CaptureAcquireTexturesANGLE(const State &glState,
                                                bool isCallValid,
@@ -2881,6 +2886,14 @@ angle::CallCapture CaptureStartTilingQCOM(const State &glState,
                                           GLuint height,
                                           GLbitfield preserveMask);
 
+// GL_WEBKIT_explicit_resolve_target
+angle::CallCapture CaptureFramebufferResolveRenderbufferWEBKIT(const State &glState,
+                                                               bool isCallValid,
+                                                               GLenum target,
+                                                               GLenum attachment,
+                                                               GLenum renderbuffertarget,
+                                                               RenderbufferID renderbufferPacked);
+
 // Parameter Captures
 
 void CaptureDeletePerfMonitorsAMD_monitors(const State &glState,
diff --git a/src/libANGLE/features.h b/src/libANGLE/features.h
index a6fe076c72d043dba3fc347bf020ebf8ec895f51..add46e99c91d19bbd790d2de0d8768b8953d633e 100644
--- a/src/libANGLE/features.h
+++ b/src/libANGLE/features.h
@@ -44,4 +44,11 @@
 #    define ANGLE_PROGRAM_LINK_VALIDATE_UNIFORM_PRECISION 1
 #endif
 
+// Lose context on Metal command queue error
+// ENABLED check Metal command buffer status on completion for error and lose context on error.
+// DISABLED Metal backed contexts are never lost.
+#if !defined(ANGLE_METAL_LOSE_CONTEXT_ON_ERROR)
+#    define ANGLE_METAL_LOSE_CONTEXT_ON_ERROR ANGLE_ENABLED
+#endif
+
 #endif  // LIBANGLE_FEATURES_H_
diff --git a/src/libANGLE/formatutils.cpp b/src/libANGLE/formatutils.cpp
index 8068c7dd1fbc62d2177b771b583f24a3d81084b3..9de76b5ee42b6026cec4662daff6e35445477735 100644
--- a/src/libANGLE/formatutils.cpp
+++ b/src/libANGLE/formatutils.cpp
@@ -592,7 +592,8 @@ static GLenum EquivalentBlitInternalFormat(GLenum internalformat)
     // sized, even if there is a swizzle (for example, blitting from a
     // multisampled RGBA8 renderbuffer to a BGRA8 texture). This could
     // be expanded and/or autogenerated if that is found necessary.
-    if (internalformat == GL_BGRA8_EXT || internalformat == GL_BGRA8_SRGB_ANGLEX)
+    if (internalformat == GL_SRGB8_ALPHA8_EXT || internalformat == GL_BGRA8_EXT ||
+        internalformat == GL_BGRA8_SRGB_ANGLEX)
     {
         return GL_RGBA8;
     }
diff --git a/src/libANGLE/gles_extensions_autogen.cpp b/src/libANGLE/gles_extensions_autogen.cpp
index 08d6416ee0ff64ae1db4bd0b61df3fe48856df20..1d61477b65de7fe8f04759c42c6f95a862ee7c0d 100644
--- a/src/libANGLE/gles_extensions_autogen.cpp
+++ b/src/libANGLE/gles_extensions_autogen.cpp
@@ -233,6 +233,7 @@ const ExtensionInfoMap &GetExtensionInfoMap()
         map["GL_CHROMIUM_copy_compressed_texture"] = esOnlyExtension(&Extensions::copyCompressedTextureCHROMIUM);
         map["GL_CHROMIUM_copy_texture"] = esOnlyExtension(&Extensions::copyTextureCHROMIUM);
         map["GL_ANGLE_copy_texture_3d"] = enableableExtension(&Extensions::copyTexture3dANGLE);
+        map["GL_WEBKIT_explicit_resolve_target"] = enableableExtension(&Extensions::explicitResolveTargetWEBKIT);
         map["GL_CHROMIUM_framebuffer_mixed_samples"] = esOnlyExtension(&Extensions::framebufferMixedSamplesCHROMIUM);
         map["GL_ANGLE_framebuffer_multisample"] = enableableExtension(&Extensions::framebufferMultisampleANGLE);
         map["GL_ANGLE_get_image"] = enableableExtension(&Extensions::getImageANGLE);
@@ -270,6 +271,7 @@ const ExtensionInfoMap &GetExtensionInfoMap()
         map["GL_ANGLE_texture_external_update"] = enableableExtension(&Extensions::textureExternalUpdateANGLE);
         map["GL_ANGLE_texture_multisample"] = enableableExtension(&Extensions::textureMultisampleANGLE);
         map["GL_ANGLE_texture_rectangle"] = enableableDisablableExtension(&Extensions::textureRectangleANGLE);
+        map["GL_ANGLE_variable_rasterization_rate_metal"] = enableableExtension(&Extensions::variableRasterizationRateMetalANGLE);
         map["GL_ANGLE_vulkan_image"] = enableableExtension(&Extensions::vulkanImageANGLE);
         map["GL_ANGLE_webgl_compatibility"] = esOnlyExtension(&Extensions::webglCompatibilityANGLE);
         map["GL_ANGLE_yuv_internal_format"] = enableableExtension(&Extensions::yuvInternalFormatANGLE);
diff --git a/src/libANGLE/gles_extensions_autogen.h b/src/libANGLE/gles_extensions_autogen.h
index d3f6ae8aefceec8ff7db974ad0dbdb817bb8d8ed..6603729516e7caaaac3f851ab020d68d0b2203cf 100644
--- a/src/libANGLE/gles_extensions_autogen.h
+++ b/src/libANGLE/gles_extensions_autogen.h
@@ -659,6 +659,9 @@ struct Extensions
     // GL_ANGLE_copy_texture_3d
     bool copyTexture3dANGLE = false;
 
+    // GL_WEBKIT_explicit_resolve_target
+    bool explicitResolveTargetWEBKIT = false;
+
     // GL_CHROMIUM_framebuffer_mixed_samples
     bool framebufferMixedSamplesCHROMIUM = false;
 
@@ -770,6 +773,9 @@ struct Extensions
     // GL_ANGLE_texture_rectangle
     bool textureRectangleANGLE = false;
 
+    // GL_ANGLE_variable_rasterization_rate_metal
+    bool variableRasterizationRateMetalANGLE = false;
+
     // GL_ANGLE_vulkan_image
     bool vulkanImageANGLE = false;
 
diff --git a/src/libANGLE/renderer/ContextImpl.cpp b/src/libANGLE/renderer/ContextImpl.cpp
index dea6f2f500ee89410847e205d2b86eae4a5a2f1f..23d5d18b7c00186a7bf5a6a657c87f3494f3038a 100644
--- a/src/libANGLE/renderer/ContextImpl.cpp
+++ b/src/libANGLE/renderer/ContextImpl.cpp
@@ -124,4 +124,13 @@ angle::Result ContextImpl::drawPixelLocalStorageEXTDisable(gl::Context *,
     UNREACHABLE();
     return angle::Result::Stop;
 }
+
+angle::Result ContextImpl::bindMetalRasterizationRateMap(gl::Context *,
+                                                         RenderbufferImpl *renderbuffer,
+                                                         GLMTLRasterizationRateMapANGLE map)
+{
+    UNREACHABLE();
+    return angle::Result::Stop;
+}
+
 }  // namespace rx
diff --git a/src/libANGLE/renderer/ContextImpl.h b/src/libANGLE/renderer/ContextImpl.h
index ec84d044755d61e14353fb32735a7d13a60d19dd..c3f918bb49ca3d10bcd767079e8c6f7e77dbc042 100644
--- a/src/libANGLE/renderer/ContextImpl.h
+++ b/src/libANGLE/renderer/ContextImpl.h
@@ -298,6 +298,11 @@ class ContextImpl : public GLImplFactory
                                                           const gl::PixelLocalStoragePlane[],
                                                           const GLenum storeops[]);
 
+    // GL_ANGLE_variable_rasterization_rate_metal
+    virtual angle::Result bindMetalRasterizationRateMap(gl::Context *,
+                                                        RenderbufferImpl *renderbuffer,
+                                                        GLMTLRasterizationRateMapANGLE map);
+
   protected:
     const gl::State &mState;
     gl::MemoryProgramCache *mMemoryProgramCache;
diff --git a/src/libANGLE/renderer/gl/FunctionsGL.cpp b/src/libANGLE/renderer/gl/FunctionsGL.cpp
index 9d8c7a4f4be3f1afd54163e2aacb12b9a832664e..9c3661be5fb3f51c15404bad23a1942a9eb2a6a4 100644
--- a/src/libANGLE/renderer/gl/FunctionsGL.cpp
+++ b/src/libANGLE/renderer/gl/FunctionsGL.cpp
@@ -53,7 +53,8 @@ static std::vector<std::string> GetIndexedExtensions(PFNGLGETINTEGERVPROC getInt
 
     for (GLint i = 0; i < numExtensions; i++)
     {
-        result.push_back(reinterpret_cast<const char *>(getStringIFunction(GL_EXTENSIONS, i)));
+        if (const char* extensionString = reinterpret_cast<const char *>(getStringIFunction(GL_EXTENSIONS, i)))
+            result.push_back(extensionString);
     }
 
     return result;
diff --git a/src/libANGLE/renderer/gl/StateManagerGL.cpp b/src/libANGLE/renderer/gl/StateManagerGL.cpp
index f771c406453139ef34ece342e7b13c67fb59e715..45956cd9bc887099897b73a70231a5196d91e699 100644
--- a/src/libANGLE/renderer/gl/StateManagerGL.cpp
+++ b/src/libANGLE/renderer/gl/StateManagerGL.cpp
@@ -2512,6 +2512,8 @@ angle::Result StateManagerGL::syncState(const gl::Context *context,
                             break;
                         case gl::state::EXTENDED_DIRTY_BIT_BLEND_ADVANCED_COHERENT:
                             setBlendAdvancedCoherent(state.isBlendAdvancedCoherentEnabled());
+                        case gl::state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE:
+                            // Unimplemented extensions.
                             break;
                         default:
                             UNREACHABLE();
diff --git a/src/libANGLE/renderer/metal/BUILD.gn b/src/libANGLE/renderer/metal/BUILD.gn
index 96e9ee8420810f6a3ca9a0c290d4a654200eb7b9..8725219587ee8afc25e803bfd84f0fb117176372 100644
--- a/src/libANGLE/renderer/metal/BUILD.gn
+++ b/src/libANGLE/renderer/metal/BUILD.gn
@@ -15,7 +15,10 @@ assert(is_mac || is_ios)
 assert(angle_enable_metal)
 
 config("angle_metal_backend_config") {
-  defines = [ "ANGLE_ENABLE_METAL" ]
+  defines = [
+    "ANGLE_ENABLE_METAL",
+    "ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED=1",
+  ]
   ldflags = [
     "-weak_framework",
     "Metal",
diff --git a/src/libANGLE/renderer/metal/BufferMtl.mm b/src/libANGLE/renderer/metal/BufferMtl.mm
index 398e6d3e3809da8b0d7ed81458a8f5b752433b16..4689f7484593f8654680d2650d8903324771ecb3 100644
--- a/src/libANGLE/renderer/metal/BufferMtl.mm
+++ b/src/libANGLE/renderer/metal/BufferMtl.mm
@@ -390,7 +390,7 @@ bool isOffsetAndSizeMetalBlitCompatible(size_t offset, size_t size)
         {
             if (buffer.offset.second <= offset.second &&
                 (offset.second - buffer.offset.second) % buffer.uniformBufferBlockSize == 0)
-                return &buffer;
+                return static_cast<ConversionBufferMtl *>(&buffer);
         }
     }
 
diff --git a/src/libANGLE/renderer/metal/ContextMtl.h b/src/libANGLE/renderer/metal/ContextMtl.h
index acdd008c5424d3ab67df0ffe384bb459143348a1..7283095e00b5c260f276c497de5d53d1de27d2b9 100644
--- a/src/libANGLE/renderer/metal/ContextMtl.h
+++ b/src/libANGLE/renderer/metal/ContextMtl.h
@@ -272,6 +272,10 @@ class ContextMtl : public ContextImpl, public mtl::Context
     angle::Result memoryBarrier(const gl::Context *context, GLbitfield barriers) override;
     angle::Result memoryBarrierByRegion(const gl::Context *context, GLbitfield barriers) override;
 
+    angle::Result bindMetalRasterizationRateMap(gl::Context *context,
+                                                RenderbufferImpl *renderbuffer,
+                                                GLMTLRasterizationRateMapANGLE map) override;
+
     // override mtl::ErrorHandler
     void handleError(GLenum error,
                      const char *message,
@@ -555,6 +559,7 @@ class ContextMtl : public ContextImpl, public mtl::Context
         DIRTY_BIT_RENDER_PIPELINE,
         DIRTY_BIT_UNIFORM_BUFFERS_BINDING,
         DIRTY_BIT_RASTERIZER_DISCARD,
+        DIRTY_BIT_VARIABLE_RASTERIZATION_RATE,
 
         DIRTY_BIT_INVALID,
         DIRTY_BIT_MAX = DIRTY_BIT_INVALID,
@@ -649,6 +654,9 @@ class ContextMtl : public ContextImpl, public mtl::Context
     IncompleteTextureSet mIncompleteTextures;
     ProvokingVertexHelper mProvokingVertexHelper;
 
+    mtl::RasterizationRateMapRef mRasterizationRateMap;
+    id<MTLTexture> mRasterizationRateMapTexture;
+
     mtl::ContextDevice mContextDevice;
 };
 
diff --git a/src/libANGLE/renderer/metal/ContextMtl.mm b/src/libANGLE/renderer/metal/ContextMtl.mm
index 763f717c171f46212dd4c7de75718de9716f7c93..65721594d04c8bffad5088fc53ced3da36dc70c0 100644
--- a/src/libANGLE/renderer/metal/ContextMtl.mm
+++ b/src/libANGLE/renderer/metal/ContextMtl.mm
@@ -263,6 +263,8 @@ GLint GetOwnershipIdentity(const egl::AttributeMap &attribs)
     mIncompleteTextures.onDestroy(context);
     mProvokingVertexHelper.onDestroy(this);
     mDummyXFBRenderTexture = nullptr;
+    mRasterizationRateMap.reset();
+    mRasterizationRateMapTexture = nil;
 
     mContextDevice.reset();
 }
@@ -1084,6 +1086,13 @@ GLint GetOwnershipIdentity(const egl::AttributeMap &attribs)
 // Device loss
 gl::GraphicsResetStatus ContextMtl::getResetStatus()
 {
+#if ANGLE_METAL_LOSE_CONTEXT_ON_ERROR == ANGLE_ENABLED
+    if (cmdQueue().isDeviceLost())
+    {
+        return gl::GraphicsResetStatus::UnknownContextReset;
+    }
+#endif
+
     return gl::GraphicsResetStatus::NoError;
 }
 
@@ -1425,6 +1434,9 @@ GLint GetOwnershipIdentity(const egl::AttributeMap &attribs)
             case gl::state::EXTENDED_DIRTY_BIT_POLYGON_OFFSET_LINE_ENABLED:
                 mDirtyBits.set(DIRTY_BIT_DEPTH_BIAS);
                 break;
+            case gl::state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE:
+                mDirtyBits.set(DIRTY_BIT_VARIABLE_RASTERIZATION_RATE);
+                break;
             default:
                 break;
         }
@@ -1675,6 +1687,36 @@ GLint GetOwnershipIdentity(const egl::AttributeMap &attribs)
     return angle::Result::Stop;
 }
 
+angle::Result ContextMtl::bindMetalRasterizationRateMap(gl::Context *context,
+                                                        RenderbufferImpl *renderbuffer,
+                                                        GLMTLRasterizationRateMapANGLE map)
+{
+    id<MTLRasterizationRateMap> rateMap = (__bridge id<MTLRasterizationRateMap>)(map);
+    if (rateMap && rateMap.device != mContextDevice.get())
+    {
+        return angle::Result::Stop;
+    }
+
+    if (auto *metalRenderbuffer = static_cast<RenderbufferMtl*>(renderbuffer))
+    {
+        FramebufferAttachmentRenderTarget *rtOut = nullptr;
+        gl::ImageIndex index;
+        GLenum binding = 0;
+        if (angle::Result::Continue == metalRenderbuffer->getAttachmentRenderTarget(context, binding, index, 1, &rtOut))
+        {
+            if (auto *renderTargetMetal = static_cast<RenderTargetMtl*>(rtOut))
+            {
+                mtl::RenderPassAttachmentDesc desc;
+                renderTargetMetal->toRenderPassAttachmentDesc(&desc);
+                mRasterizationRateMapTexture = desc.texture.get()->get();
+            }
+        }
+    }
+
+    mRasterizationRateMap = std::move(rateMap);
+    return angle::Result::Continue;
+}
+
 // override mtl::ErrorHandler
 void ContextMtl::handleError(GLenum glErrorCode,
                              const char *message,
@@ -2531,8 +2573,22 @@ static bool isDrawNoOp(const mtl::RenderPipelineDesc &descriptor,
             return angle::Result::Continue;
         }
         // Setup with flushed state should either produce a working encoder or fail with an error
-        // result.
-        ASSERT(mRenderEncoder.valid());
+        // result. if that's not the case, something's gone seriously wrong. Try to
+        // recover from the error by bailing out of the draw call, and finishing the command buffer.
+        // This will result in an unfinished / corrupted draw, but will avoid a browser/GPU process
+        // crash.
+        if (ANGLE_UNLIKELY(!mRenderEncoder.valid() || !mRenderEncoder.hasPipelineState()))
+        {
+            // Completely flush the command buffer, waiting synchronously.
+            flushCommandBuffer(mtl::WaitUntilFinished);
+            // Invalidate all state
+            invalidateState(context);
+            // Return fail, and drop the draw call. This is
+            // a worst case scenario. If in a debug roots situation,
+            // we should try to catch the call stack.
+            ERR() << "Draw call is unusable - please report a bug on bugs.webkit.org";
+            return angle::Result::Stop;
+        }
     }
     return angle::Result::Continue;
 }
@@ -2641,10 +2697,10 @@ static bool isDrawNoOp(const mtl::RenderPipelineDesc &descriptor,
                     mState.getBlendColor().blue, mState.getBlendColor().alpha);
                 break;
             case DIRTY_BIT_VIEWPORT:
-                mRenderEncoder.setViewport(mViewport);
+                mRenderEncoder.setViewport(mViewport, mRenderEncoder.rasterizationRateMapForPass(mRasterizationRateMap, mRasterizationRateMapTexture));
                 break;
             case DIRTY_BIT_SCISSOR:
-                mRenderEncoder.setScissorRect(mScissorRect);
+                mRenderEncoder.setScissorRect(mScissorRect, mRenderEncoder.rasterizationRateMapForPass(mRasterizationRateMap, mRasterizationRateMapTexture));
                 break;
             case DIRTY_BIT_DRAW_FRAMEBUFFER:
                 // Already handled.
@@ -2669,6 +2725,12 @@ static bool isDrawNoOp(const mtl::RenderPipelineDesc &descriptor,
             case DIRTY_BIT_RASTERIZER_DISCARD:
                 // Already handled.
                 break;
+            case DIRTY_BIT_VARIABLE_RASTERIZATION_RATE:
+                if (getState().privateState().isVariableRasterizationRateEnabled() && mRasterizationRateMap)
+                {
+                    mRenderEncoder.setRasterizationRateMap(mRenderEncoder.rasterizationRateMapForPass(mRasterizationRateMap, mRasterizationRateMapTexture));
+                }
+                break;
             default:
                 UNREACHABLE();
                 break;
@@ -2723,7 +2785,8 @@ static bool isDrawNoOp(const mtl::RenderPipelineDesc &descriptor,
     if (!IsTransformFeedbackOnly(mState))
     {
         // Start new render command encoder
-        ANGLE_MTL_TRY(this, mDrawFramebuffer->ensureRenderPassStarted(context));
+        mtl::RenderCommandEncoder *encoder;
+        ANGLE_TRY(mDrawFramebuffer->ensureRenderPassStarted(context, &encoder));
     }
     else
     {
diff --git a/src/libANGLE/renderer/metal/DisplayMtl.h b/src/libANGLE/renderer/metal/DisplayMtl.h
index 16ae6340e37283bcd49e8ea926f75a1f6f17f1d6..8e632756bf2ad4b6478579baf3aa00bede009058 100644
--- a/src/libANGLE/renderer/metal/DisplayMtl.h
+++ b/src/libANGLE/renderer/metal/DisplayMtl.h
@@ -142,6 +142,8 @@ class DisplayMtl : public DisplayImpl
     bool supportsMetal2_2() const;
     bool supportsDepth24Stencil8PixelFormat() const;
     bool supports32BitFloatFiltering() const;
+    bool supportsBCTextureCompression() const;
+    bool supportsVariableRasterizationRate() const;
     bool isAMD() const;
     bool isAMDBronzeDriver() const;
     bool isAMDFireProDevice() const;
diff --git a/src/libANGLE/renderer/metal/DisplayMtl.mm b/src/libANGLE/renderer/metal/DisplayMtl.mm
index faf3ce89f10dba6d83dafe4460dda337afe980e9..86e178f8e6e5285603d5a6d1dceda977f677a87e 100644
--- a/src/libANGLE/renderer/metal/DisplayMtl.mm
+++ b/src/libANGLE/renderer/metal/DisplayMtl.mm
@@ -184,12 +184,22 @@ bool IsMetalDisplayAvailable()
 
 bool DisplayMtl::testDeviceLost()
 {
+#if ANGLE_METAL_LOSE_CONTEXT_ON_ERROR == ANGLE_ENABLED
+    return mCmdQueue.isDeviceLost();
+#else
      return false;
+#endif
 }
 
 egl::Error DisplayMtl::restoreLostDevice(const egl::Display *display)
 {
+#if ANGLE_METAL_LOSE_CONTEXT_ON_ERROR == ANGLE_ENABLED
+    // A Metal device cannot be restored, the entire context would have to be
+    // re-created along with any other EGL objects that reference it.
+    return egl::EglBadDisplay();
+#else
     return egl::NoError();
+#endif
 }
 
 std::string DisplayMtl::getRendererDescription()
@@ -983,19 +993,11 @@ bool IsMetalDisplayAvailable()
     // regular 2D textures with Metal, and causes other problems such as
     // breaking the SPIR-V Metal compiler.
 
-    // TODO(anglebug.com/42264909): figure out why WebGL drawing buffer
-    // creation fails on macOS when the Metal backend advertises the
-    // EXT_multisampled_render_to_texture extension.
-    // TODO(anglebug.com/42261786): Metal doesn't implement render to texture
-    // correctly. A texture (if used as a color attachment for a framebuffer)
-    // is always created with sample count == 1, which results in creation of a
-    // render pipeline with the same value. Moreover, if there is a more
-    // sophisticated case and a framebuffer also has a stencil/depth attachment,
-    // it will result in creation of a render pipeline with those attachment's
-    // sample count, but the texture that was used as a color attachment, will
-    // still remain with sample count 1. That results in Metal validation error
-    // if enabled.
-    mNativeExtensions.multisampledRenderToTextureEXT = false;
+    mNativeExtensions.multisampledRenderToTextureEXT =
+        (supportsAppleGPUFamily(1) ||
+         mFeatures.enableMultisampledRenderToTextureOnNonTilers.enabled) &&
+        mFeatures.hasShaderStencilOutput.enabled && mFeatures.hasDepthAutoResolve.enabled &&
+        mFeatures.hasStencilAutoResolve.enabled;
 
     // Enable EXT_blend_minmax
     mNativeExtensions.blendMinmaxEXT = true;
@@ -1176,6 +1178,14 @@ bool IsMetalDisplayAvailable()
             mNativeCaps.maxImageUnits = gl::IMPLEMENTATION_MAX_PIXEL_LOCAL_STORAGE_PLANES;
         }
     }
+
+    // GL_ANGLE_variable_rasterization_rate_metal
+    mNativeExtensions.variableRasterizationRateMetalANGLE = mFeatures.hasVariableRasterizationRate.enabled;
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    // GL_WEBKIT_explicit_resolve_target
+    mNativeExtensions.explicitResolveTargetWEBKIT = true;
+#endif
+
     // "The GPUs in Apple3 through Apple8 families only support memory barriers for compute command
     // encoders, and for vertex-to-vertex and vertex-to-fragment stages of render command encoders."
     mHasFragmentMemoryBarriers = !supportsAppleGPUFamily(3);
@@ -1248,6 +1258,8 @@ bool IsMetalDisplayAvailable()
                             supportsMetal2_1() && (isOSX || isCatalyst) && !isARM);
     ANGLE_FEATURE_CONDITION((&mFeatures), hasDepthAutoResolve, supportsEitherGPUFamily(3, 2));
     ANGLE_FEATURE_CONDITION((&mFeatures), hasStencilAutoResolve, supportsEitherGPUFamily(5, 2));
+    ANGLE_FEATURE_CONDITION((&mFeatures), hasVariableRasterizationRate,
+                            supportsVariableRasterizationRate());
     ANGLE_FEATURE_CONDITION((&mFeatures), allowMultisampleStoreAndResolve,
                             supportsEitherGPUFamily(3, 1));
 
@@ -1358,13 +1370,6 @@ bool IsMetalDisplayAvailable()
     ANGLE_FEATURE_CONDITION((&mFeatures), preTransformTextureCubeGradDerivatives,
                             supportsAppleGPUFamily(1));
 
-    // On tile-based GPUs, always resolving MSAA render buffers to single-sampled
-    // is preferred. Because it would save bandwidth by avoiding the cost of storing the MSAA
-    // textures to memory. Traditional desktop GPUs almost always store MSAA textures to memory
-    // anyway, so this feature would have no benefit besides adding additional resolve step and
-    // memory overhead of the hidden single-sampled textures.
-    ANGLE_FEATURE_CONDITION((&mFeatures), alwaysResolveMultisampleRenderBuffers, isARM);
-
     // Metal compiler optimizations may remove infinite loops causing crashes later in shader
     // execution. http://crbug.com/1513738
     // Disabled on Mac11 due to test failures. http://crbug.com/1522730
@@ -1437,18 +1442,36 @@ bool IsMetalDisplayAvailable()
 
 bool DisplayMtl::supports32BitFloatFiltering() const
 {
-#if (defined(__MAC_11_0) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_11_0) ||        \
-    (defined(__IPHONE_14_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_14_0) || \
-    (defined(__TVOS_14_0) && __TV_OS_VERSION_MIN_REQUIRED >= __TVOS_14_0)
-    if (@available(ios 14.0, macOS 11.0, *))
+#if ((TARGET_OS_OSX && __MAC_OS_X_VERSION_MAX_ALLOWED >= 110000) ||  \
+     (TARGET_OS_IOS && __IPHONE_OS_VERSION_MAX_ALLOWED >= 140000) || \
+     (TARGET_OS_TV && __TV_OS_VERSION_MAX_ALLOWED >= 160000) || TARGET_OS_VISION)
+    if (@available(macOS 11.0, macCatalyst 14.0, iOS 14.0, tvOS 16.0, *))
     {
         return [mMetalDevice supports32BitFloatFiltering];
     }
-    else
 #endif
+#if TARGET_OS_OSX || TARGET_OS_MACCATALYST
+    return true;  // Always true on old macOS
+#else
+    return false;  // Always false everywhere else
+#endif
+}
+
+bool DisplayMtl::supportsBCTextureCompression() const
+{
+#if ((TARGET_OS_OSX && __MAC_OS_X_VERSION_MAX_ALLOWED >= 110000) ||  \
+     (TARGET_OS_IOS && __IPHONE_OS_VERSION_MAX_ALLOWED >= 160400) || \
+     (TARGET_OS_TV && __TV_OS_VERSION_MAX_ALLOWED >= 160400) || TARGET_OS_VISION)
+    if (@available(macOS 11.0, macCatalyst 16.4, iOS 16.4, tvOS 16.4, *))
     {
-        return supportsMacGPUFamily(1);
+        return [mMetalDevice supportsBCTextureCompression];
     }
+#endif
+#if TARGET_OS_OSX || TARGET_OS_MACCATALYST
+    return true;  // Always true on old macOS
+#else
+    return false;  // Always false everywhere else
+#endif
 }
 
 bool DisplayMtl::supportsDepth24Stencil8PixelFormat() const
@@ -1459,6 +1482,17 @@ bool IsMetalDisplayAvailable()
     return false;
 #endif
 }
+
+bool DisplayMtl::supportsVariableRasterizationRate() const
+{
+    if (@available(ios 13.0, macOS 10.15.4, macCatalyst 13.4, tvOS 16.0, *))
+    {
+        return [mMetalDevice supportsRasterizationRateMapWithLayerCount:1];
+    }
+
+    return false;
+}
+
 bool DisplayMtl::isAMD() const
 {
     return angle::IsAMD(mMetalDeviceVendorId);
diff --git a/src/libANGLE/renderer/metal/FrameBufferMtl.h b/src/libANGLE/renderer/metal/FrameBufferMtl.h
index 51f2f2b96dddedf975ec17ec60e8eb8255592c25..ca845ad3e93985a6459773242ec0c83d9f3940e7 100644
--- a/src/libANGLE/renderer/metal/FrameBufferMtl.h
+++ b/src/libANGLE/renderer/metal/FrameBufferMtl.h
@@ -106,7 +106,8 @@ class FramebufferMtl : public FramebufferImpl
     {
         return mRenderPassDesc.defaultWidth > 0 || mRenderPassDesc.defaultHeight > 0;
     }
-    mtl::RenderCommandEncoder *ensureRenderPassStarted(const gl::Context *context);
+    angle::Result ensureRenderPassStarted(const gl::Context *context,
+                                          mtl::RenderCommandEncoder **encoderOut);
 
     // Call this to notify FramebufferMtl whenever its render pass has started.
     void onStartedDrawingToFrameBuffer(const gl::Context *context);
@@ -172,8 +173,9 @@ class FramebufferMtl : public FramebufferImpl
 
     // Check if a render pass specified by the given RenderPassDesc has started or not, if not this
     // method will start the render pass and return its render encoder.
-    mtl::RenderCommandEncoder *ensureRenderPassStarted(const gl::Context *context,
-                                                       const mtl::RenderPassDesc &desc);
+    angle::Result ensureRenderPassStarted(const gl::Context *context,
+                                          const mtl::RenderPassDesc &desc,
+                                          mtl::RenderCommandEncoder **encoderOut);
 
     angle::Result updateColorRenderTarget(const gl::Context *context, size_t colorIndexGL);
     angle::Result updateDepthRenderTarget(const gl::Context *context);
@@ -199,7 +201,10 @@ class FramebufferMtl : public FramebufferImpl
     bool totalBitsUsedIsLessThanOrEqualToMaxBitsSupported(const gl::Context *context) const;
 
     RenderTargetMtl *getColorReadRenderTargetNoCache(const gl::Context *context) const;
-    bool prepareForUse(const gl::Context *context) const;
+    angle::Result prepareForUse(const gl::Context *context) const;
+
+    // Perform unresolve step for loading into memoryless MS attachments.
+    angle::Result unresolveIfNeeded(const gl::Context *context, mtl::RenderCommandEncoder *encoder);
 
     // NOTE: we cannot use RenderTargetCache here because it doesn't support separate
     // depth & stencil attachments as of now. Separate depth & stencil could be useful to
@@ -207,6 +212,14 @@ class FramebufferMtl : public FramebufferImpl
     angle::FixedVector<RenderTargetMtl *, mtl::kMaxRenderTargets> mColorRenderTargets;
     RenderTargetMtl *mDepthRenderTarget   = nullptr;
     RenderTargetMtl *mStencilRenderTarget = nullptr;
+
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    // GL_WEBKIT_explicit_resolve_target
+    angle::FixedVector<RenderTargetMtl *, mtl::kMaxRenderTargets> mColorResolveRenderTargets;
+    RenderTargetMtl *mDepthResolveRenderTarget   = nullptr;
+    RenderTargetMtl *mStencilResolveRenderTarget = nullptr;
+#endif
+
     mtl::RenderPassDesc mRenderPassDesc;
 
     const mtl::Format *mRenderPassFirstColorAttachmentFormat = nullptr;
@@ -220,6 +233,8 @@ class FramebufferMtl : public FramebufferImpl
     bool mFlipY                   = false;
 
     mtl::BufferRef mReadPixelBuffer;
+
+    uint64_t mStartedRenderEncoderSerial = 0;
 };
 }  // namespace rx
 
diff --git a/src/libANGLE/renderer/metal/FrameBufferMtl.mm b/src/libANGLE/renderer/metal/FrameBufferMtl.mm
index d4650cb71be42d55b19bb57cb98c06437086dfb5..f4e01a06c2bf3d8faf279be5b9097862eb66062e 100644
--- a/src/libANGLE/renderer/metal/FrameBufferMtl.mm
+++ b/src/libANGLE/renderer/metal/FrameBufferMtl.mm
@@ -121,6 +121,9 @@ void OverrideMTLClearColor(const mtl::TextureRef &texture,
 FramebufferMtl::FramebufferMtl(const gl::FramebufferState &state, ContextMtl *context, bool flipY)
     : FramebufferImpl(state),
       mColorRenderTargets(context->getNativeCaps().maxColorAttachments, nullptr),
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+      mColorResolveRenderTargets(context->getNativeCaps().maxColorAttachments, nullptr),
+#endif
       mBackbuffer(nullptr),
       mFlipY(flipY)
 {
@@ -137,6 +140,14 @@ void OverrideMTLClearColor(const mtl::TextureRef &texture,
     }
     mDepthRenderTarget = mStencilRenderTarget = nullptr;
 
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    for (auto &rt : mColorResolveRenderTargets)
+    {
+        rt = nullptr;
+    }
+    mDepthResolveRenderTarget = mStencilResolveRenderTarget = nullptr;
+#endif
+
     mRenderPassFirstColorAttachmentFormat = nullptr;
 
     mReadPixelBuffer = nullptr;
@@ -601,13 +612,13 @@ void RoundValueAndAdjustCorrespondingValue(float a,
         }
 
         // The actual blitting of depth and/or stencil
-        renderEncoder = ensureRenderPassStarted(context);
+        ANGLE_TRY(ensureRenderPassStarted(context, &renderEncoder));
         ANGLE_TRY(contextMtl->getDisplay()->getUtils().blitDepthStencilWithDraw(
             context, renderEncoder, dsBlitParams));
     }  // if (blitDepthBuffer || blitStencilBuffer)
     else
     {
-        renderEncoder = ensureRenderPassStarted(context);
+        ANGLE_TRY(ensureRenderPassStarted(context, &renderEncoder));
     }
 
     // Blit color
@@ -824,28 +835,26 @@ void RoundValueAndAdjustCorrespondingValue(float a,
     return angle::Result::Stop;
 }
 
-bool FramebufferMtl::prepareForUse(const gl::Context *context) const
+angle::Result FramebufferMtl::prepareForUse(const gl::Context *context) const
 {
     if (mBackbuffer)
     {
         // Backbuffer might obtain new drawable, which means it might change the
         // the native texture used as the target of the render pass.
         // We need to call this before creating render encoder.
-        if (IsError(mBackbuffer->ensureCurrentDrawableObtained(context)))
-        {
-            return false;
-        }
+        ANGLE_TRY(mBackbuffer->ensureCurrentDrawableObtained(context));
 
         if (mBackbuffer->hasRobustResourceInit())
         {
-            (void)mBackbuffer->initializeContents(context, GL_BACK, gl::ImageIndex::Make2D(0));
+            ANGLE_TRY(mBackbuffer->initializeContents(context, GL_BACK, gl::ImageIndex::Make2D(0)));
             if (mBackbuffer->hasDepthStencil())
             {
-                (void)mBackbuffer->initializeContents(context, GL_DEPTH, gl::ImageIndex::Make2D(0));
+                ANGLE_TRY(
+                    mBackbuffer->initializeContents(context, GL_DEPTH, gl::ImageIndex::Make2D(0)));
             }
         }
     }
-    return true;
+    return angle::Result::Continue;
 }
 
 RenderTargetMtl *FramebufferMtl::getColorReadRenderTarget(const gl::Context *context) const
@@ -855,7 +864,7 @@ void RoundValueAndAdjustCorrespondingValue(float a,
         return nullptr;
     }
 
-    if (!prepareForUse(context))
+    if (IsError(prepareForUse(context)))
     {
         return nullptr;
     }
@@ -903,26 +912,36 @@ void RoundValueAndAdjustCorrespondingValue(float a,
     return contextMtl->hasStartedRenderPass(mRenderPassDesc);
 }
 
-mtl::RenderCommandEncoder *FramebufferMtl::ensureRenderPassStarted(const gl::Context *context)
+angle::Result FramebufferMtl::ensureRenderPassStarted(const gl::Context *context,
+                                                      mtl::RenderCommandEncoder **encoderOut)
 {
-    return ensureRenderPassStarted(context, mRenderPassDesc);
+    return ensureRenderPassStarted(context, mRenderPassDesc, encoderOut);
 }
 
-mtl::RenderCommandEncoder *FramebufferMtl::ensureRenderPassStarted(const gl::Context *context,
-                                                                   const mtl::RenderPassDesc &desc)
+angle::Result FramebufferMtl::ensureRenderPassStarted(const gl::Context *context,
+                                                      const mtl::RenderPassDesc &desc,
+                                                      mtl::RenderCommandEncoder **encoderOut)
 {
     ContextMtl *contextMtl = mtl::GetImpl(context);
 
-    if (!prepareForUse(context))
+    mtl::RenderCommandEncoder *encoder = contextMtl->getRenderCommandEncoder();
+    if (encoder && encoder->getSerial() == mStartedRenderEncoderSerial)
     {
-        return nullptr;
+        // Already started.
+        *encoderOut = encoder;
+        return angle::Result::Continue;
     }
 
+    ANGLE_TRY(prepareForUse(context));
+
     // Only support ensureRenderPassStarted() with different load & store options only. The
     // texture, level, slice must be the same.
     ASSERT(desc.equalIgnoreLoadStoreOptions(mRenderPassDesc));
 
-    mtl::RenderCommandEncoder *encoder = contextMtl->getRenderPassCommandEncoder(desc);
+    encoder                     = contextMtl->getRenderPassCommandEncoder(desc);
+    mStartedRenderEncoderSerial = encoder->getSerial();
+
+    ANGLE_TRY(unresolveIfNeeded(context, encoder));
 
     if (mRenderPassCleanStart)
     {
@@ -937,7 +956,9 @@ void RoundValueAndAdjustCorrespondingValue(float a,
         mRenderPassDesc.stencilAttachment.loadAction = MTLLoadActionLoad;
     }
 
-    return encoder;
+    *encoderOut = encoder;
+
+    return angle::Result::Continue;
 }
 
 void FramebufferMtl::setLoadStoreActionOnRenderPassFirstStart(
@@ -958,7 +979,7 @@ void RoundValueAndAdjustCorrespondingValue(float a,
         attachment.loadAction = MTLLoadActionLoad;
     }
 
-    if (attachment.hasImplicitMSTexture())
+    if (attachment.hasResolveTexture())
     {
         attachment.storeAction = MTLStoreActionStoreAndMultisampleResolve;
     }
@@ -1025,22 +1046,47 @@ void RoundValueAndAdjustCorrespondingValue(float a,
     ASSERT(colorIndexGL < mColorRenderTargets.size());
     // Reset load store action
     mRenderPassDesc.colorAttachments[colorIndexGL].reset();
-    return updateCachedRenderTarget(context, mState.getColorAttachment(colorIndexGL),
-                                    &mColorRenderTargets[colorIndexGL]);
+    ANGLE_TRY(updateCachedRenderTarget(context, mState.getColorAttachment(colorIndexGL),
+                                       &mColorRenderTargets[colorIndexGL]));
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    if (mState.getColorResolveAttachment(colorIndexGL))
+    {
+        ANGLE_TRY(updateCachedRenderTarget(context, mState.getColorResolveAttachment(colorIndexGL),
+                                           &mColorResolveRenderTargets[colorIndexGL]));
+    }
+#endif
+    return angle::Result::Continue;
 }
 
 angle::Result FramebufferMtl::updateDepthRenderTarget(const gl::Context *context)
 {
     // Reset load store action
     mRenderPassDesc.depthAttachment.reset();
-    return updateCachedRenderTarget(context, mState.getDepthAttachment(), &mDepthRenderTarget);
+    ANGLE_TRY(updateCachedRenderTarget(context, mState.getDepthAttachment(), &mDepthRenderTarget));
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    if (mState.getDepthResolveAttachment())
+    {
+        ANGLE_TRY(updateCachedRenderTarget(context, mState.getDepthResolveAttachment(),
+                                           &mDepthResolveRenderTarget));
+    }
+#endif
+    return angle::Result::Continue;
 }
 
 angle::Result FramebufferMtl::updateStencilRenderTarget(const gl::Context *context)
 {
     // Reset load store action
     mRenderPassDesc.stencilAttachment.reset();
-    return updateCachedRenderTarget(context, mState.getStencilAttachment(), &mStencilRenderTarget);
+    ANGLE_TRY(
+        updateCachedRenderTarget(context, mState.getStencilAttachment(), &mStencilRenderTarget));
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    if (mState.getStencilResolveAttachment())
+    {
+        ANGLE_TRY(updateCachedRenderTarget(context, mState.getStencilResolveAttachment(),
+                                           &mStencilResolveRenderTarget));
+    }
+#endif
+    return angle::Result::Continue;
 }
 
 angle::Result FramebufferMtl::updateCachedRenderTarget(const gl::Context *context,
@@ -1082,6 +1128,9 @@ void RoundValueAndAdjustCorrespondingValue(float a,
 
         mtl::RenderPassColorAttachmentDesc &colorAttachment = desc.colorAttachments[colorIndexGL];
         const RenderTargetMtl *colorRenderTarget            = mColorRenderTargets[colorIndexGL];
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+        const RenderTargetMtl *colorResolveRenderTarget = mColorResolveRenderTargets[colorIndexGL];
+#endif
 
         // GL allows data types of fragment shader color outputs to be incompatible with disabled
         // color attachments. To prevent various Metal validation issues, assign textures only to
@@ -1089,6 +1138,12 @@ void RoundValueAndAdjustCorrespondingValue(float a,
         if (colorRenderTarget && enabledDrawBuffers.test(colorIndexGL))
         {
             colorRenderTarget->toRenderPassAttachmentDesc(&colorAttachment);
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+            if (colorResolveRenderTarget)
+            {
+                colorResolveRenderTarget->toRenderPassResolveAttachmentDesc(&colorAttachment);
+            }
+#endif
 
             desc.numColorAttachments = std::max(desc.numColorAttachments, colorIndexGL + 1);
             desc.sampleCount = std::max(desc.sampleCount, colorRenderTarget->getRenderSamples());
@@ -1117,6 +1172,12 @@ void RoundValueAndAdjustCorrespondingValue(float a,
     if (mDepthRenderTarget)
     {
         mDepthRenderTarget->toRenderPassAttachmentDesc(&desc.depthAttachment);
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+        if (mDepthResolveRenderTarget)
+        {
+            mDepthResolveRenderTarget->toRenderPassResolveAttachmentDesc(&desc.depthAttachment);
+        }
+#endif
         desc.sampleCount = std::max(desc.sampleCount, mDepthRenderTarget->getRenderSamples());
     }
     else
@@ -1127,6 +1188,12 @@ void RoundValueAndAdjustCorrespondingValue(float a,
     if (mStencilRenderTarget)
     {
         mStencilRenderTarget->toRenderPassAttachmentDesc(&desc.stencilAttachment);
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+        if (mStencilResolveRenderTarget)
+        {
+            mStencilResolveRenderTarget->toRenderPassResolveAttachmentDesc(&desc.stencilAttachment);
+        }
+#endif
         desc.sampleCount = std::max(desc.sampleCount, mStencilRenderTarget->getRenderSamples());
     }
     else
@@ -1154,7 +1221,7 @@ void RoundValueAndAdjustCorrespondingValue(float a,
 
     if (startedRenderPass)
     {
-        encoder = ensureRenderPassStarted(context);
+        ANGLE_TRY(ensureRenderPassStarted(context, &encoder));
         if (encoder->hasDrawCalls())
         {
             // Render pass already has draw calls recorded, it is better to use clear with draw
@@ -1200,7 +1267,7 @@ void RoundValueAndAdjustCorrespondingValue(float a,
             colorAttachment.loadAction = MTLLoadActionLoad;
         }
 
-        if (colorAttachment.hasImplicitMSTexture())
+        if (colorAttachment.hasResolveTexture())
         {
             colorAttachment.storeAction = MTLStoreActionStoreAndMultisampleResolve;
         }
@@ -1220,7 +1287,7 @@ void RoundValueAndAdjustCorrespondingValue(float a,
         tempDesc.depthAttachment.loadAction = MTLLoadActionLoad;
     }
 
-    if (tempDesc.depthAttachment.hasImplicitMSTexture())
+    if (tempDesc.depthAttachment.hasResolveTexture())
     {
         tempDesc.depthAttachment.storeAction = MTLStoreActionStoreAndMultisampleResolve;
     }
@@ -1239,7 +1306,7 @@ void RoundValueAndAdjustCorrespondingValue(float a,
         tempDesc.stencilAttachment.loadAction = MTLLoadActionLoad;
     }
 
-    if (tempDesc.stencilAttachment.hasImplicitMSTexture())
+    if (tempDesc.stencilAttachment.hasResolveTexture())
     {
         tempDesc.stencilAttachment.storeAction = MTLStoreActionStoreAndMultisampleResolve;
     }
@@ -1249,9 +1316,8 @@ void RoundValueAndAdjustCorrespondingValue(float a,
     }
 
     // Start new render encoder with loadOp=Clear
-    ensureRenderPassStarted(context, tempDesc);
-
-    return angle::Result::Continue;
+    mtl::RenderCommandEncoder *encoder;
+    return ensureRenderPassStarted(context, tempDesc, &encoder);
 }
 
 angle::Result FramebufferMtl::clearWithLoadOpRenderPassStarted(
@@ -1303,7 +1369,8 @@ void RoundValueAndAdjustCorrespondingValue(float a,
     if (mRenderPassAttachmentsSameColorType)
     {
         // Start new render encoder if not already.
-        mtl::RenderCommandEncoder *encoder = ensureRenderPassStarted(context, mRenderPassDesc);
+        mtl::RenderCommandEncoder *encoder;
+        ANGLE_TRY(ensureRenderPassStarted(context, mRenderPassDesc, &encoder));
 
         return display->getUtils().clearWithDraw(context, encoder, clearOpts);
     }
@@ -1477,31 +1544,54 @@ void RoundValueAndAdjustCorrespondingValue(float a,
                 }
             }
 
-            mtl::RenderPassColorAttachmentDesc &colorAttachment =
-                mRenderPassDesc.colorAttachments[i];
+            // If the invalidated color buffer has an associated resolve target
+            // then resolve the MSAA samples, otherwise discard the data.
+            auto &colorAttachment = mRenderPassDesc.colorAttachments[i];
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+            auto *resolveRenderTarget = mColorResolveRenderTargets[i];
+            colorAttachment.storeAction =
+                resolveRenderTarget ? MTLStoreActionMultisampleResolve : MTLStoreActionDontCare;
+#else
             colorAttachment.storeAction = MTLStoreActionDontCare;
+#endif
             if (renderPassStarted)
             {
-                encoder->setColorStoreAction(MTLStoreActionDontCare, i);
+                encoder->setColorStoreAction(colorAttachment.storeAction, i);
             }
         }
     }
 
     if (invalidateDepthBuffer && mDepthRenderTarget)
     {
-        mRenderPassDesc.depthAttachment.storeAction = MTLStoreActionDontCare;
+        // If the invalidated depth buffer has an associated resolve target then
+        // resolve the MSAA samples, otherwise discard the data.
+        auto &depthAttachment = mRenderPassDesc.depthAttachment;
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+        depthAttachment.storeAction =
+            mDepthResolveRenderTarget ? MTLStoreActionMultisampleResolve : MTLStoreActionDontCare;
+#else
+        depthAttachment.storeAction = MTLStoreActionDontCare;
+#endif
         if (renderPassStarted)
         {
-            encoder->setDepthStoreAction(MTLStoreActionDontCare);
+            encoder->setDepthStoreAction(depthAttachment.storeAction);
         }
     }
 
     if (invalidateStencilBuffer && mStencilRenderTarget)
     {
-        mRenderPassDesc.stencilAttachment.storeAction = MTLStoreActionDontCare;
+        // If the invalidated stencil buffer has an associated resolve target
+        // then resolve the MSAA samples, otherwise discard the data.
+        auto &stencilAttachment = mRenderPassDesc.stencilAttachment;
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+        stencilAttachment.storeAction =
+            mStencilResolveRenderTarget ? MTLStoreActionMultisampleResolve : MTLStoreActionDontCare;
+#else
+        stencilAttachment.storeAction = MTLStoreActionDontCare;
+#endif
         if (renderPassStarted)
         {
-            encoder->setStencilStoreAction(MTLStoreActionDontCare);
+            encoder->setStencilStoreAction(stencilAttachment.storeAction);
         }
     }
 
@@ -1685,8 +1775,13 @@ void RoundValueAndAdjustCorrespondingValue(float a,
 
     ContextMtl *contextMtl = mtl::GetImpl(context);
 
-    ANGLE_MTL_CHECK(contextMtl, packPixelsParams.offset <= std::numeric_limits<uint32_t>::max(),
+    if constexpr (sizeof(packPixelsParams.offset) > sizeof(uint32_t))
+    {
+        ANGLE_MTL_CHECK(contextMtl,
+                        static_cast<std::make_unsigned_t<decltype(packPixelsParams.offset)>>(
+                            packPixelsParams.offset) <= std::numeric_limits<uint32_t>::max(),
                         GL_INVALID_OPERATION);
+    }
     uint32_t offset = static_cast<uint32_t>(packPixelsParams.offset);
 
     BufferMtl *packBufferMtl = mtl::GetImpl(packPixelsParams.packBuffer);
@@ -1802,4 +1897,98 @@ void RoundValueAndAdjustCorrespondingValue(float a,
     return angle::Result::Continue;
 }
 
+angle::Result FramebufferMtl::unresolveIfNeeded(const gl::Context *context,
+                                                mtl::RenderCommandEncoder *encoder)
+{
+    ContextMtl *contextMtl = mtl::GetImpl(context);
+    DisplayMtl *display    = contextMtl->getDisplay();
+
+    const mtl::RenderPassDesc &renderPassDesc = encoder->renderPassDesc();
+    const gl::Rectangle renderArea            = this->getCompleteRenderArea();
+
+    mtl::BlitParams baseParams;
+    baseParams.dstTextureSize = gl::Extents(renderArea.width, renderArea.height, 1);
+    baseParams.dstRect        = renderArea;
+    baseParams.dstScissorRect = renderArea;
+    baseParams.dstFlipY       = false;
+
+    baseParams.srcNormalizedCoords =
+        mtl::NormalizedCoords(0, 0, renderArea.width, renderArea.height, renderArea);
+
+    baseParams.srcYFlipped = false;
+    baseParams.unpackFlipX = false;
+    baseParams.unpackFlipY = false;
+
+    // Unresolve any color attachment if the intended loadAction = MTLLoadActionLoad and the
+    // respective MS texture is memoryless.
+    mtl::ColorBlitParams colorBlitParams;
+    colorBlitParams.BlitParams::operator=(baseParams);
+    for (uint32_t colorIndexGL = 0; colorIndexGL < renderPassDesc.numColorAttachments;
+         ++colorIndexGL)
+    {
+        const mtl::RenderPassColorAttachmentDesc &colorAttachment =
+            renderPassDesc.colorAttachments[colorIndexGL];
+
+        if (colorAttachment.loadAction != MTLLoadActionLoad ||
+            !colorAttachment.texture ||
+            !colorAttachment.texture->shouldNotLoadStore())
+        {
+            continue;
+        }
+        const RenderTargetMtl *colorRenderTarget = mColorRenderTargets[colorIndexGL];
+        const angle::Format &angleFormat = colorRenderTarget->getFormat().actualAngleFormat();
+
+        // Blit the resolve texture to the MS texture.
+        colorBlitParams.src      = colorAttachment.resolveTexture;
+        colorBlitParams.srcLevel = colorAttachment.resolveLevel;
+        colorBlitParams.srcLayer = colorAttachment.resolveSliceOrDepth;
+
+        colorBlitParams.enabledBuffers.reset();
+        colorBlitParams.enabledBuffers.set(colorIndexGL);
+        colorBlitParams.filter       = GL_NEAREST;
+        colorBlitParams.dstLuminance = angleFormat.isLUMA();
+
+        ANGLE_TRY(
+            display->getUtils().blitColorWithDraw(context, encoder, angleFormat, colorBlitParams));
+    }
+
+    // Similarly, unresolve depth/stencil attachments.
+    mtl::DepthStencilBlitParams dsBlitParams;
+    dsBlitParams.BlitParams::operator=(baseParams);
+    const mtl::RenderPassDepthAttachmentDesc &depthAttachment = renderPassDesc.depthAttachment;
+    if (depthAttachment.loadAction == MTLLoadActionLoad && depthAttachment.texture &&
+        depthAttachment.texture->shouldNotLoadStore())
+    {
+        dsBlitParams.src      = depthAttachment.resolveTexture;
+        dsBlitParams.srcLevel = depthAttachment.resolveLevel;
+        dsBlitParams.srcLayer = depthAttachment.resolveSliceOrDepth;
+    }
+
+    const mtl::RenderPassStencilAttachmentDesc &stencilAttachment =
+        renderPassDesc.stencilAttachment;
+    if (stencilAttachment.loadAction == MTLLoadActionLoad && stencilAttachment.texture &&
+        stencilAttachment.texture->shouldNotLoadStore())
+    {
+        if (mState.hasSeparateDepthAndStencilAttachments())
+        {
+            // Blit depth/stencil separately.
+            ANGLE_TRY(contextMtl->getDisplay()->getUtils().blitDepthStencilWithDraw(
+                context, encoder, dsBlitParams));
+            dsBlitParams.src = nullptr;
+        }
+
+        dsBlitParams.srcStencil = stencilAttachment.resolveTexture->getStencilView();
+        dsBlitParams.srcLevel   = stencilAttachment.resolveLevel;
+        dsBlitParams.srcLayer   = stencilAttachment.resolveSliceOrDepth;
+    }
+
+    if (dsBlitParams.src || dsBlitParams.srcStencil)
+    {
+        ANGLE_TRY(contextMtl->getDisplay()->getUtils().blitDepthStencilWithDraw(context, encoder,
+                                                                                dsBlitParams));
+    }
+
+    return angle::Result::Continue;
+}
+
 }  // namespace rx
diff --git a/src/libANGLE/renderer/metal/ImageMtl.mm b/src/libANGLE/renderer/metal/ImageMtl.mm
index a4a809fabe7572c1d212ff8fb4da35b1f67b6a01..eb2bd204b9edda65ba372b8fcb24f8092b9f4f65 100644
--- a/src/libANGLE/renderer/metal/ImageMtl.mm
+++ b/src/libANGLE/renderer/metal/ImageMtl.mm
@@ -86,7 +86,9 @@
         return egl::EglBadAttribute() << "Unrecognized format";
     }
 
-    if (format.metalFormat != texture.pixelFormat)
+    angle::FormatID srcAngleFormatId = mtl::Format::MetalToAngleFormatID(texture.pixelFormat);
+    const mtl::Format &srcFormat = display->getPixelFormat(srcAngleFormatId);
+    if (!format.isViewCompatible(srcFormat))
     {
         return egl::EglBadAttribute() << "Incompatible format";
     }
@@ -120,18 +122,21 @@
 {
     mNativeTexture = mtl::Texture::MakeFromMetal((__bridge id<MTLTexture>)(mBuffer));
 
-    if (mNativeTexture->textureType() == MTLTextureType2DArray)
+    angle::FormatID angleFormatId = intendedFormatForMTLTexture(mNativeTexture->get(), mAttribs);
+    mFormat                       = displayMtl->getPixelFormat(angleFormatId);
+
+    if (mNativeTexture->textureType() == MTLTextureType2DArray ||
+        mNativeTexture->pixelFormat() != mFormat.metalFormat)
     {
         mtl::TextureRef baseTexture = std::move(mNativeTexture);
         unsigned textureArraySlice =
             static_cast<unsigned>(mAttribs.getAsInt(EGL_METAL_TEXTURE_ARRAY_SLICE_ANGLE, 0));
         mNativeTexture =
-            baseTexture->createSliceMipView(textureArraySlice, mtl::kZeroNativeMipLevel);
+        baseTexture->createSliceMipViewWithCompatibleFormat(textureArraySlice,
+                                                            mtl::kZeroNativeMipLevel,
+                                                            mFormat.metalFormat);
     }
 
-    angle::FormatID angleFormatId = intendedFormatForMTLTexture(mNativeTexture->get(), mAttribs);
-    mFormat                       = displayMtl->getPixelFormat(angleFormatId);
-
     if (mNativeTexture)
     {
         size_t resourceSize = EstimateTextureSizeInBytes(
diff --git a/src/libANGLE/renderer/metal/ProgramExecutableMtl.mm b/src/libANGLE/renderer/metal/ProgramExecutableMtl.mm
index 2b12574f70492d26ca793c57b1c21569d50ef468..45446b2b041fad4f756e1587eecd4d0995c0a8bd 100644
--- a/src/libANGLE/renderer/metal/ProgramExecutableMtl.mm
+++ b/src/libANGLE/renderer/metal/ProgramExecutableMtl.mm
@@ -889,7 +889,7 @@ void ReadFromDefaultUniformBlockWithElementSize(int componentCount,
 {
     ContextMtl *context = mtl::GetImpl(glContext);
 
-    if (pipelineDescChanged)
+    if (pipelineDescChanged || !cmdEncoder->hasPipelineState())
     {
         id<MTLFunction> vertexShader = nil;
         ANGLE_TRY(
diff --git a/src/libANGLE/renderer/metal/RenderBufferMtl.h b/src/libANGLE/renderer/metal/RenderBufferMtl.h
index 7e0267ffb77a0bbf6e811333a9e566d132221423..8fb794aa1daa901b2e6a9ab48c946aa166617333 100644
--- a/src/libANGLE/renderer/metal/RenderBufferMtl.h
+++ b/src/libANGLE/renderer/metal/RenderBufferMtl.h
@@ -52,7 +52,8 @@ class RenderbufferMtl : public RenderbufferImpl
                                  GLsizei samples,
                                  GLenum internalformat,
                                  GLsizei width,
-                                 GLsizei height);
+                                 GLsizei height,
+                                 gl::MultisamplingMode mode);
 
     void releaseTexture();
 
diff --git a/src/libANGLE/renderer/metal/RenderBufferMtl.mm b/src/libANGLE/renderer/metal/RenderBufferMtl.mm
index 913f4904f8c256e7ce8fd681aedb529f335b74c3..96f373bfff80e1d3174eb71f15abf27496924668 100644
--- a/src/libANGLE/renderer/metal/RenderBufferMtl.mm
+++ b/src/libANGLE/renderer/metal/RenderBufferMtl.mm
@@ -36,7 +36,8 @@
                                               GLsizei samples,
                                               GLenum internalformat,
                                               GLsizei width,
-                                              GLsizei height)
+                                              GLsizei height,
+                                              gl::MultisamplingMode mode)
 {
     ContextMtl *contextMtl = mtl::GetImpl(context);
 
@@ -56,9 +57,6 @@
         angle::Format::InternalFormatToID(internalFormat.sizedInternalFormat);
     mFormat = contextMtl->getPixelFormat(angleFormatId);
 
-    bool useImplicitResolve =
-        contextMtl->getDisplay()->getFeatures().alwaysResolveMultisampleRenderBuffers.enabled;
-
     uint32_t actualSamples;
     if (samples == 0)
     {
@@ -77,26 +75,21 @@
 
     if ((mTexture == nullptr || !mTexture->valid()) && (width != 0 && height != 0))
     {
-        if (actualSamples == 1 || (useImplicitResolve && mFormat.getCaps().resolve))
+        if (actualSamples == 1 || mode == gl::MultisamplingMode::MultisampledRenderToTexture)
         {
             ANGLE_TRY(mtl::Texture::Make2DTexture(
                 contextMtl, mFormat, static_cast<uint32_t>(width), static_cast<uint32_t>(height), 1,
                 /* renderTargetOnly */ false,
                 /* allowFormatView */ mFormat.hasDepthAndStencilBits(), &mTexture));
 
-            // Use implicit resolve if alwaysResolveMultisampleRenderBuffers feature is enabled. At
-            // the end of every render pass, the MSAA render buffer will be automatically resolved
-            // to a single sampled texture.
-            if (actualSamples > 1)
+            if (mode == gl::MultisamplingMode::MultisampledRenderToTexture)
             {
                 // This format must supports implicit resolve
                 ASSERT(mFormat.getCaps().resolve);
 
-                ANGLE_TRY(mtl::Texture::Make2DMSTexture(
+                ANGLE_TRY(mtl::Texture::MakeMemoryLess2DMSTexture(
                     contextMtl, mFormat, static_cast<uint32_t>(width),
-                    static_cast<uint32_t>(height), actualSamples,
-                    /* renderTargetOnly */ true,
-                    /* allowFormatView */ mFormat.hasDepthAndStencilBits(), &mImplicitMSTexture));
+                    static_cast<uint32_t>(height), actualSamples, &mImplicitMSTexture));
             }
         }
         else
@@ -118,7 +111,7 @@
         {
             gl::ImageIndex index;
 
-            if (actualSamples > 1)
+            if (mTexture->samples() > 1)
             {
                 index = gl::ImageIndex::Make2DMultisample();
             }
@@ -129,18 +122,12 @@
 
             ANGLE_TRY(mtl::InitializeTextureContents(context, mTexture, mFormat,
                                                      mtl::ImageNativeIndex(index, 0)));
-            if (mImplicitMSTexture)
-            {
-                ANGLE_TRY(mtl::InitializeTextureContents(
-                    context, mImplicitMSTexture, mFormat,
-                    mtl::ImageNativeIndex(gl::ImageIndex::Make2DMultisample(), 0)));
-            }
         }  // if (emulatedChannels)
         bool isDepthStencil = mFormat.hasDepthOrStencilBits();
         if (isDepthStencil)
         {
             gl::ImageIndex index;
-            if (actualSamples > 1)
+            if (mTexture->samples() > 1)
             {
                 index = gl::ImageIndex::Make2DMultisample();
             }
@@ -150,12 +137,6 @@
             }
             ANGLE_TRY(mtl::InitializeDepthStencilTextureContentsGPU(
                 context, mTexture, mFormat, mtl::ImageNativeIndex(index, 0)));
-            if (mImplicitMSTexture)
-            {
-                ANGLE_TRY(mtl::InitializeDepthStencilTextureContentsGPU(
-                    context, mImplicitMSTexture, mFormat,
-                    mtl::ImageNativeIndex(gl::ImageIndex::Make2DMultisample(), 0)));
-            }
         }
     }
 
@@ -167,7 +148,8 @@
                                           GLsizei width,
                                           GLsizei height)
 {
-    return setStorageImpl(context, 0, internalformat, width, height);
+    return setStorageImpl(context, 0, internalformat, width, height,
+                          gl::MultisamplingMode::Regular);
 }
 
 angle::Result RenderbufferMtl::setStorageMultisample(const gl::Context *context,
@@ -177,7 +159,7 @@
                                                      GLsizei height,
                                                      gl::MultisamplingMode mode)
 {
-    return setStorageImpl(context, samples, internalformat, width, height);
+    return setStorageImpl(context, samples, internalformat, width, height, mode);
 }
 
 angle::Result RenderbufferMtl::setStorageEGLImageTarget(const gl::Context *context,
diff --git a/src/libANGLE/renderer/metal/RenderTargetMtl.h b/src/libANGLE/renderer/metal/RenderTargetMtl.h
index 281085bbc46eb7d96dabf73b9c75ee0a61125bab..a07218bc78473252b0b2b9e561ec74799959177e 100644
--- a/src/libANGLE/renderer/metal/RenderTargetMtl.h
+++ b/src/libANGLE/renderer/metal/RenderTargetMtl.h
@@ -51,6 +51,9 @@ class RenderTargetMtl final : public FramebufferAttachmentRenderTarget
     const mtl::Format &getFormat() const { return mFormat; }
 
     void toRenderPassAttachmentDesc(mtl::RenderPassAttachmentDesc *rpaDescOut) const;
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    void toRenderPassResolveAttachmentDesc(mtl::RenderPassAttachmentDesc *rpaDescOut) const;
+#endif
 
   private:
     mtl::TextureWeakRef mTexture;
diff --git a/src/libANGLE/renderer/metal/RenderTargetMtl.mm b/src/libANGLE/renderer/metal/RenderTargetMtl.mm
index 18e62da867b2916085794ba3b68ee4a3812d3929..6cbf2a58812184edb425d11689bdbce5574917f0 100644
--- a/src/libANGLE/renderer/metal/RenderTargetMtl.mm
+++ b/src/libANGLE/renderer/metal/RenderTargetMtl.mm
@@ -73,10 +73,33 @@
 
 void RenderTargetMtl::toRenderPassAttachmentDesc(mtl::RenderPassAttachmentDesc *rpaDescOut) const
 {
-    rpaDescOut->texture           = mTexture.lock();
-    rpaDescOut->implicitMSTexture = mImplicitMSTexture.lock();
+    mtl::TextureRef implicitMSTex = getImplicitMSTexture();
+    mtl::TextureRef tex           = getTexture();
+    if (implicitMSTex)
+    {
+        rpaDescOut->texture             = implicitMSTex;
+        rpaDescOut->resolveTexture      = tex;
+        rpaDescOut->resolveLevel        = mLevelIndex;
+        rpaDescOut->resolveSliceOrDepth = mLayerIndex;
+    }
+    else
+    {
+        rpaDescOut->texture      = tex;
         rpaDescOut->level        = mLevelIndex;
         rpaDescOut->sliceOrDepth = mLayerIndex;
+    }
     rpaDescOut->blendable = mFormat.getCaps().blendable;
 }
+
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+void RenderTargetMtl::toRenderPassResolveAttachmentDesc(
+    mtl::RenderPassAttachmentDesc *rpaDescOut) const
+{
+    ASSERT(!getImplicitMSTexture());
+    ASSERT(getRenderSamples() == 1);
+    rpaDescOut->resolveTexture      = getTexture();
+    rpaDescOut->resolveLevel        = mLevelIndex;
+    rpaDescOut->resolveSliceOrDepth = mLayerIndex;
+}
+#endif
 }  // namespace rx
diff --git a/src/libANGLE/renderer/metal/SurfaceMtl.mm b/src/libANGLE/renderer/metal/SurfaceMtl.mm
index 1089fb59517f0c50d055275a66992dda7f380e5f..1c1e2b823d9a4c1340fabb9dff87e8b60993e015 100644
--- a/src/libANGLE/renderer/metal/SurfaceMtl.mm
+++ b/src/libANGLE/renderer/metal/SurfaceMtl.mm
@@ -686,8 +686,7 @@
             mColorTexture->set(mCurrentDrawable.get().texture);
         }
 
-        ANGLE_MTL_LOG("Current metal drawable size=%d,%d", mColorTexture->width(),
-                      mColorTexture->height());
+        ANGLE_MTL_LOG("Current metal drawable size=%d,%d", mColorTexture->width(mtl::MipmapNativeLevel(0)),  mColorTexture->height(mtl::MipmapNativeLevel(0)));
 
         // Now we have to resize depth stencil buffers if required.
         ANGLE_TRY(ensureCompanionTexturesSizeCorrect(context));
diff --git a/src/libANGLE/renderer/metal/TextureMtl.h b/src/libANGLE/renderer/metal/TextureMtl.h
index 3406174e2a17cac6ad814b9dab62655460f74231..8787ad79e429203d150ed20c01d5eb5257650b5d 100644
--- a/src/libANGLE/renderer/metal/TextureMtl.h
+++ b/src/libANGLE/renderer/metal/TextureMtl.h
@@ -204,7 +204,10 @@ class TextureMtl : public TextureImpl
                                            const mtl::TextureRef &texture);
     mtl::TextureRef &getImage(const gl::ImageIndex &imageIndex);
     ImageDefinitionMtl &getImageDefinition(const gl::ImageIndex &imageIndex);
-    RenderTargetMtl &getRenderTarget(const gl::ImageIndex &imageIndex);
+    angle::Result getRenderTarget(ContextMtl *context,
+                                  const gl::ImageIndex &imageIndex,
+                                  GLsizei implicitSamples,
+                                  RenderTargetMtl **renderTargetOut);
     mtl::TextureRef &getImplicitMSTexture(const gl::ImageIndex &imageIndex);
 
     // If levels = 0, this function will create full mipmaps texture.
@@ -346,15 +349,15 @@ class TextureMtl : public TextureImpl
     // Stored images array defined by glTexImage/glCopy*.
     // Once the images array is complete, they will be transferred to real texture object.
     // NOTE:
-    //  - The second dimension is indexed by configured base level + actual native level
     //  - For Cube map, there will be at most 6 entries in the map table, one for each face. This is
     //  because the Cube map's image is defined per face & per level.
     //  - For other texture types, there will be only one entry in the map table. All other textures
     //  except Cube map has texture image defined per level (all slices included).
-    //  - These three variables' second dimension are indexed by image index (base level included).
+    //  - The second dimension is indexed by GL level.
     std::map<int, gl::TexLevelArray<ImageDefinitionMtl>> mTexImageDefs;
-    std::map<int, gl::TexLevelArray<RenderTargetMtl>> mPerLayerRenderTargets;
-    std::map<int, gl::TexLevelArray<mtl::TextureRef>> mImplicitMSTextures;
+    // 1st index = image index, 2nd index = samples count.
+    std::map<gl::ImageIndex, gl::RenderToTextureImageMap<RenderTargetMtl>> mRenderTargets;
+    std::map<gl::ImageIndex, gl::RenderToTextureImageMap<mtl::TextureRef>> mImplicitMSTextures;
 
     // Lazily populated 2D views for shader storage images.
     // May have different formats than the original texture.
diff --git a/src/libANGLE/renderer/metal/TextureMtl.mm b/src/libANGLE/renderer/metal/TextureMtl.mm
index 7c0e45c810fa9b56f9fe89563ccf7538956386c1..1229ee47cea6bbcce2164ff7c69630bd07d81dd2 100644
--- a/src/libANGLE/renderer/metal/TextureMtl.mm
+++ b/src/libANGLE/renderer/metal/TextureMtl.mm
@@ -924,11 +924,19 @@ uint32_t height(GLuint glLevel) const
 
     // Clear render target cache for each texture's image. We don't erase them because they
     // might still be referenced by a framebuffer.
-    for (auto &sliceRenderTargets : mPerLayerRenderTargets)
+    for (auto &samplesMapRenderTargets : mRenderTargets)
     {
-        for (RenderTargetMtl &mipRenderTarget : sliceRenderTargets.second)
+        for (RenderTargetMtl &perSampleCountRenderTarget : samplesMapRenderTargets.second)
         {
-            mipRenderTarget.reset();
+            perSampleCountRenderTarget.reset();
+        }
+    }
+
+    for (auto &samplesMapMSTextures : mImplicitMSTextures)
+    {
+        for (mtl::TextureRef &perSampleCountMSTexture : samplesMapMSTextures.second)
+        {
+            perSampleCountMSTexture.reset();
         }
     }
 
@@ -1325,13 +1333,22 @@ uint32_t height(GLuint glLevel) const
 
     return imageDef;
 }
-RenderTargetMtl &TextureMtl::getRenderTarget(const gl::ImageIndex &imageIndex)
+angle::Result TextureMtl::getRenderTarget(ContextMtl *context,
+                                          const gl::ImageIndex &imageIndex,
+                                          GLsizei implicitSamples,
+                                          RenderTargetMtl **renderTargetOut)
 {
     ASSERT(imageIndex.getType() == gl::TextureType::_2D ||
            imageIndex.getType() == gl::TextureType::Rectangle ||
            imageIndex.getType() == gl::TextureType::_2DMultisample || imageIndex.hasLayer());
+
+    const gl::RenderToTextureImageIndex renderToTextureIndex =
+        implicitSamples <= 1
+            ? gl::RenderToTextureImageIndex::Default
+            : static_cast<gl::RenderToTextureImageIndex>(PackSampleCount(implicitSamples));
+
     GLuint layer         = GetImageLayerIndexFrom(imageIndex);
-    RenderTargetMtl &rtt = mPerLayerRenderTargets[layer][imageIndex.getLevelIndex()];
+    RenderTargetMtl &rtt = mRenderTargets[imageIndex][renderToTextureIndex];
     if (!rtt.getTexture())
     {
         // Lazy initialization of render target:
@@ -1349,7 +1366,24 @@ uint32_t height(GLuint glLevel) const
             }
         }
     }
-    return rtt;
+
+    if (implicitSamples > 1 && !rtt.getImplicitMSTexture())
+    {
+        // This format must supports implicit resolve
+        ANGLE_MTL_CHECK(context, mFormat.getCaps().resolve, GL_INVALID_VALUE);
+        mtl::TextureRef &msTexture = mImplicitMSTextures[imageIndex][renderToTextureIndex];
+        if (!msTexture)
+        {
+            const gl::ImageDesc &desc = mState.getImageDesc(imageIndex);
+            ANGLE_TRY(mtl::Texture::MakeMemoryLess2DMSTexture(
+                context, mFormat, desc.size.width, desc.size.height, implicitSamples, &msTexture));
+        }
+        rtt.setImplicitMSTexture(msTexture);
+    }
+
+    *renderTargetOut = &rtt;
+
+    return angle::Result::Continue;
 }
 
 angle::Result TextureMtl::setImage(const gl::Context *context,
@@ -1790,7 +1824,10 @@ uint32_t height(GLuint glLevel) const
     ContextMtl *contextMtl = mtl::GetImpl(context);
     ANGLE_MTL_TRY(contextMtl, mNativeTextureStorage);
 
-    *rtOut = &getRenderTarget(imageIndex);
+    RenderTargetMtl *rtt;
+    ANGLE_TRY(getRenderTarget(contextMtl, imageIndex, samples, &rtt));
+
+    *rtOut = rtt;
 
     return angle::Result::Continue;
 }
@@ -2611,12 +2648,13 @@ uint32_t height(GLuint glLevel) const
     ContextMtl *contextMtl = mtl::GetImpl(context);
     DisplayMtl *displayMtl = contextMtl->getDisplay();
 
-    const RenderTargetMtl &imageRtt = getRenderTarget(index);
+    RenderTargetMtl *imageRtt;
+    ANGLE_TRY(getRenderTarget(contextMtl, index, /*implicitSamples=*/0, &imageRtt));
 
-    mtl::RenderCommandEncoder *cmdEncoder = contextMtl->getRenderTargetCommandEncoder(imageRtt);
+    mtl::RenderCommandEncoder *cmdEncoder = contextMtl->getRenderTargetCommandEncoder(*imageRtt);
     mtl::ColorBlitParams blitParams;
 
-    blitParams.dstTextureSize = imageRtt.getTexture()->size(imageRtt.getLevelIndex());
+    blitParams.dstTextureSize = imageRtt->getTexture()->size(imageRtt->getLevelIndex());
     blitParams.dstRect        = gl::Rectangle(modifiedDestOffset.x, modifiedDestOffset.y,
                                               clippedSourceArea.width, clippedSourceArea.height);
     blitParams.dstScissorRect = blitParams.dstRect;
diff --git a/src/libANGLE/renderer/metal/VertexArrayMtl.mm b/src/libANGLE/renderer/metal/VertexArrayMtl.mm
index d93f10afc07d12b88cd234e569fa658a1fbf6ad2..24fc07ff9b0e8294d972e7623173b9d47ff49679 100644
--- a/src/libANGLE/renderer/metal/VertexArrayMtl.mm
+++ b/src/libANGLE/renderer/metal/VertexArrayMtl.mm
@@ -1084,16 +1084,23 @@ inline MTLVertexFormat GetCurrentAttribFormat(GLenum type)
     ANGLE_TRY(conversion->data.allocate(contextMtl, numVertices * targetStride, nullptr, &newBuffer,
                                         &newBufferOffset));
 
-    ANGLE_CHECK_GL_MATH(contextMtl, binding.getOffset() <= std::numeric_limits<uint32_t>::max());
+    GLintptr bindingOffset = binding.getOffset();
+
+    if constexpr (sizeof(bindingOffset) > sizeof(uint32_t))
+        ANGLE_CHECK_GL_MATH(contextMtl, static_cast<std::make_unsigned_t<decltype(bindingOffset)>>(
+                                            bindingOffset) <= std::numeric_limits<uint32_t>::max());
     ANGLE_CHECK_GL_MATH(contextMtl, newBufferOffset <= std::numeric_limits<uint32_t>::max());
     ANGLE_CHECK_GL_MATH(contextMtl, numVertices <= std::numeric_limits<uint32_t>::max());
 
     mtl::VertexFormatConvertParams params;
     VertexConversionBufferMtl *vertexConversion =
         static_cast<VertexConversionBufferMtl *>(conversion);
+    if constexpr (sizeof(vertexConversion->offset) > sizeof(uint32_t))
+        ANGLE_CHECK_GL_MATH(contextMtl,
+                            vertexConversion->offset <= std::numeric_limits<uint32_t>::max());
     params.srcBuffer            = srcBuffer->getCurrentBuffer();
-    params.srcBufferStartOffset = static_cast<uint32_t>(
-        MIN(static_cast<GLintptr>(vertexConversion->offset), binding.getOffset()));
+    params.srcBufferStartOffset = std::min(static_cast<uint32_t>(vertexConversion->offset),
+                                           static_cast<uint32_t>(bindingOffset));
     params.srcStride            = binding.getStride();
     params.srcDefaultAlphaData  = convertedFormat.defaultAlpha;
 
diff --git a/src/libANGLE/renderer/metal/gen_mtl_format_table.py b/src/libANGLE/renderer/metal/gen_mtl_format_table.py
index 07eb14aef818ebcdbfed46f68fb969d5a7363885..b7b7c27b7267763698af4b737a912efad141435f 100644
--- a/src/libANGLE/renderer/metal/gen_mtl_format_table.py
+++ b/src/libANGLE/renderer/metal/gen_mtl_format_table.py
@@ -143,7 +143,6 @@ case_image_format_template1 = """        case angle::FormatID::{angle_format}:
 """
 
 case_image_format_template2 = """        case angle::FormatID::{angle_format}:
-#if defined(__IPHONE_13_0) || defined(__MAC_10_15)
             if (display->getFeatures().hasTextureSwizzle.enabled)
             {{
                 {image_format_assign_swizzled}
@@ -151,7 +150,6 @@ case_image_format_template2 = """        case angle::FormatID::{angle_format}:
                 this->swizzle  = {mtl_swizzle};
             }}
             else
-#endif  // #if defined(__IPHONE_13_0) || defined(__MAC_10_15)
             {{
                 {image_format_assign_default}
             }}
@@ -412,17 +410,19 @@ def gen_image_map_switch_string(image_table, angle_to_gl):
     angle_override = image_table["override"]
     mac_override = image_table["override_mac"]
     mac_override_es3 = image_table["override_mac_es3"]
-    mac_override_bc1 = image_table["override_mac_bc1"]
+    override_bc1 = image_table["override_bc1"]
     ios_override = image_table["override_ios"]
     mac_depth_fallbacks = image_table["depth_fallbacks_mac"]
     angle_to_mtl = image_table["map"]
-    mac_specific_map = image_table["map_mac"]
+    mac_specific_map = image_table["map_mac"].copy()
+    bc = image_table["map_bc"]
     ios_specific_map = image_table["map_ios"]
     astc_tpl_map = image_table["map_astc_tpl"]
     sim_specific_map = image_table["map_sim"]
     sim_override = image_table["override_sim"]
 
     # mac_specific_map + angle_to_mtl:
+    mac_specific_map.update(bc)
     mac_angle_to_mtl = mac_specific_map.copy()
     mac_angle_to_mtl.update(angle_to_mtl)
     # ios_specific_map + angle_to_mtl
@@ -451,9 +451,8 @@ def gen_image_map_switch_string(image_table, angle_to_gl):
     for angle_format in sorted(mac_override.keys()):
         switch_data += gen_image_map_switch_simple_case(angle_format, mac_override[angle_format],
                                                         angle_to_gl, mac_angle_to_mtl)
-    for angle_format in sorted(mac_override_bc1.keys()):
-        switch_data += gen_image_map_switch_simple_case(angle_format,
-                                                        mac_override_bc1[angle_format],
+    for angle_format in sorted(override_bc1.keys()):
+        switch_data += gen_image_map_switch_simple_case(angle_format, override_bc1[angle_format],
                                                         angle_to_gl, mac_angle_to_mtl)
     switch_data += "#endif\n"
 
@@ -473,7 +472,7 @@ def gen_image_map_switch_string(image_table, angle_to_gl):
     for angle_format in sorted(sim_override.keys()):
         switch_data += gen_image_map_switch_simple_case(angle_format, sim_override[angle_format],
                                                         angle_to_gl, sim_angle_to_mtl)
-    switch_data += "#if TARGET_OS_IOS\n"
+    switch_data += "#if TARGET_OS_IOS || TARGET_OS_VISION\n"
     for angle_format in sorted(astc_tpl_map.keys()):
         switch_data += gen_image_map_switch_astc_case_iosmac(angle_format, angle_to_gl,
                                                              astc_tpl_map)
@@ -482,7 +481,19 @@ def gen_image_map_switch_string(image_table, angle_to_gl):
     for angle_format in sorted(astc_tpl_map.keys()):
         switch_data += gen_image_map_switch_astc_case_tv_watchos(angle_format, angle_to_gl,
                                                                  astc_tpl_map)
-    switch_data += "#endif // TARGET_OS_IOS\n "
+    switch_data += "#endif // ASTC formats\n"
+
+    # BC formats
+    switch_data += "#if (TARGET_OS_IOS && __IPHONE_OS_VERSION_MAX_ALLOWED >= 160400) || \\\n"
+    switch_data += "    (TARGET_OS_TV && __TV_OS_VERSION_MAX_ALLOWED >= 160400) || TARGET_OS_VISION\n"
+    for angle_format in sorted(bc.keys()):
+        switch_data += gen_image_map_switch_simple_case(angle_format, angle_format, angle_to_gl,
+                                                        bc)
+    for angle_format in sorted(override_bc1.keys()):
+        switch_data += gen_image_map_switch_simple_case(angle_format, override_bc1[angle_format],
+                                                        angle_to_gl, bc)
+    switch_data += "#endif // BC formats on iOS/tvOS/visionOS \n"
+
     # iOS specific
     switch_data += "#elif TARGET_OS_IPHONE && !TARGET_OS_MACCATALYST\n"
     for angle_format in sorted(ios_specific_map.keys()):
@@ -491,7 +502,7 @@ def gen_image_map_switch_string(image_table, angle_to_gl):
     for angle_format in sorted(ios_override.keys()):
         switch_data += gen_image_map_switch_simple_case(angle_format, ios_override[angle_format],
                                                         angle_to_gl, ios_angle_to_mtl)
-    switch_data += "#if TARGET_OS_IOS\n"
+    switch_data += "#if TARGET_OS_IOS || TARGET_OS_VISION\n"
     for angle_format in sorted(astc_tpl_map.keys()):
         switch_data += gen_image_map_switch_astc_case_iosmac(angle_format, angle_to_gl,
                                                              astc_tpl_map)
@@ -501,7 +512,19 @@ def gen_image_map_switch_string(image_table, angle_to_gl):
     for angle_format in sorted(astc_tpl_map.keys()):
         switch_data += gen_image_map_switch_astc_case_tv_watchos(angle_format, angle_to_gl,
                                                                  astc_tpl_map)
-    switch_data += "#endif // TARGET_OS_IOS || TARGET_OS_TV\n"
+    switch_data += "#endif // ASTC formats\n"
+
+    # BC formats
+    switch_data += "#if (TARGET_OS_IOS && __IPHONE_OS_VERSION_MAX_ALLOWED >= 160400) || \\\n"
+    switch_data += "    (TARGET_OS_TV && __TV_OS_VERSION_MAX_ALLOWED >= 160400) || TARGET_OS_VISION\n"
+    for angle_format in sorted(bc.keys()):
+        switch_data += gen_image_map_switch_simple_case(angle_format, angle_format, angle_to_gl,
+                                                        bc)
+    for angle_format in sorted(override_bc1.keys()):
+        switch_data += gen_image_map_switch_simple_case(angle_format, override_bc1[angle_format],
+                                                        angle_to_gl, bc)
+    switch_data += "#endif // BC formats on iOS/tvOS/visionOS \n"
+
     switch_data += "#endif // TARGET_OS_IPHONE\n"
 
     # Try to support all iOS formats on newer macOS with Apple GPU.
@@ -532,6 +555,7 @@ def gen_image_map_switch_string(image_table, angle_to_gl):
 
 def gen_image_mtl_to_angle_switch_string(image_table):
     angle_to_mtl = image_table["map"]
+    bc_map = image_table["map_bc"]
     mac_specific_map = image_table["map_mac"]
     ios_specific_map = image_table["map_ios"]
     astc_tpl_map = image_table["map_astc_tpl"]
@@ -543,6 +567,15 @@ def gen_image_mtl_to_angle_switch_string(image_table):
         switch_data += case_image_mtl_to_angle_template.format(
             mtl_format=angle_to_mtl[angle_format], angle_format=angle_format)
 
+    # BC formats
+    switch_data += "#if TARGET_OS_OSX || TARGET_OS_MACCATALYST ||\\\n"
+    switch_data += "    (TARGET_OS_IOS && __IPHONE_OS_VERSION_MAX_ALLOWED >= 160400) ||\\\n"
+    switch_data += "    (TARGET_OS_TV && __TV_OS_VERSION_MAX_ALLOWED >= 160400) || TARGET_OS_VISION\n"
+    for angle_format in sorted(bc_map.keys()):
+        switch_data += case_image_mtl_to_angle_template.format(
+            mtl_format=bc_map[angle_format], angle_format=angle_format)
+    switch_data += "#endif  // BC formats\n"
+
     # Mac specific
     switch_data += "#if TARGET_OS_OSX || TARGET_OS_MACCATALYST\n"
     for angle_format in sorted(mac_specific_map.keys()):
@@ -564,11 +597,11 @@ def gen_image_mtl_to_angle_switch_string(image_table):
     for angle_format in sorted(astc_tpl_map.keys()):
         switch_data += case_image_mtl_to_angle_template.format(
             mtl_format=astc_tpl_map[angle_format] + "LDR", angle_format=angle_format)
-    switch_data += "#if TARGET_OS_IOS || TARGET_OS_OSX \n"
+    switch_data += "#if TARGET_OS_IOS || TARGET_OS_OSX || TARGET_OS_VISION\n"
     for angle_format in sorted(astc_tpl_map.keys()):
         switch_data += case_image_mtl_to_angle_template.format(
             mtl_format=astc_tpl_map[angle_format] + "HDR", angle_format=angle_format)
-    switch_data += "#endif // TARGET_OS_IOS || TARGET_OS_OSX\n"
+    switch_data += "#endif // TARGET_OS_IOS || TARGET_OS_OSX || TARGET_OS_VISION\n"
     switch_data += "#endif  // TARGET_OS_IPHONE || mac 11.0+\n"
 
     switch_data += "        default:\n"
@@ -637,6 +670,7 @@ def gen_vertex_map_switch_string(vertex_table):
 
 def gen_mtl_format_caps_init_string(map_image):
     caps = map_image['caps']
+    bc_caps = map_image['caps_bc']
     mac_caps = map_image['caps_mac']
     ios_platform_caps = map_image['caps_ios_platform']
     ios_specific_caps = map_image['caps_ios_specific']
@@ -665,6 +699,12 @@ def gen_mtl_format_caps_init_string(map_image):
 
     caps_init_str += caps_to_cpp(caps)
 
+    caps_init_str += "#if TARGET_OS_OSX || TARGET_OS_MACCATALYST ||\\\n"
+    caps_init_str += "    (TARGET_OS_IOS && __IPHONE_OS_VERSION_MAX_ALLOWED >= 160400) ||\\\n"
+    caps_init_str += "    (TARGET_OS_TV && __TV_OS_VERSION_MAX_ALLOWED >= 160400) || TARGET_OS_VISION\n"
+    caps_init_str += caps_to_cpp(bc_caps)
+    caps_init_str += "#endif  // BC formats\n"
+
     caps_init_str += "#if TARGET_OS_OSX || TARGET_OS_MACCATALYST\n"
     caps_init_str += caps_to_cpp(mac_caps)
     caps_init_str += "#endif  // TARGET_OS_OSX || TARGET_OS_MACCATALYST\n"
@@ -674,9 +714,9 @@ def gen_mtl_format_caps_init_string(map_image):
 
     caps_init_str += caps_to_cpp(ios_platform_caps)
 
-    caps_init_str += "#if TARGET_OS_IOS || TARGET_OS_OSX\n"
+    caps_init_str += "#if TARGET_OS_IOS || TARGET_OS_OSX || TARGET_OS_VISION\n"
     caps_init_str += caps_to_cpp(ios_specific_caps)
-    caps_init_str += "#endif // TARGET_OS_IOS || mac 11.0+ \n"
+    caps_init_str += "#endif // TARGET_OS_IOS || mac 11.0+ || TARGET_OS_VISION\n"
     caps_init_str += "#endif // TARGET_OS_IPHONE && !TARGET_OS_MACCATALYST || mac 11.0+ \n"
 
     return caps_init_str
diff --git a/src/libANGLE/renderer/metal/mtl_command_buffer.h b/src/libANGLE/renderer/metal/mtl_command_buffer.h
index d8abf0f1ba04749840bb993a650febf766a471d0..2856bdf4e1f16dcec8d95543e5d2478d46f9b33e 100644
--- a/src/libANGLE/renderer/metal/mtl_command_buffer.h
+++ b/src/libANGLE/renderer/metal/mtl_command_buffer.h
@@ -104,6 +104,8 @@ class CommandQueue final : public WrappedObject<id<MTLCommandQueue>>, angle::Non
     bool isTimeElapsedEntryComplete(uint64_t id);
     double getTimeElapsedEntryInSeconds(uint64_t id);
 
+    bool isDeviceLost() const { return mIsDeviceLost; }
+
   private:
     void onCommandBufferCompleted(id<MTLCommandBuffer> buf,
                                   uint64_t serial,
@@ -146,6 +148,8 @@ class CommandQueue final : public WrappedObject<id<MTLCommandQueue>>, angle::Non
     void recordCommandBufferTimeElapsed(std::lock_guard<std::mutex> &lg,
                                         uint64_t id,
                                         double seconds);
+
+    std::atomic_bool mIsDeviceLost = false;
 };
 
 class CommandBuffer final : public WrappedObject<id<MTLCommandBuffer>>, angle::NonCopyable
@@ -426,8 +430,10 @@ class RenderCommandEncoder final : public CommandEncoder
     RenderCommandEncoder &setStencilRefVals(uint32_t frontRef, uint32_t backRef);
     RenderCommandEncoder &setStencilRefVal(uint32_t ref);
 
-    RenderCommandEncoder &setViewport(const MTLViewport &viewport);
-    RenderCommandEncoder &setScissorRect(const MTLScissorRect &rect);
+    RenderCommandEncoder &setViewport(const MTLViewport &viewport,
+                                      id<MTLRasterizationRateMap> map);
+    RenderCommandEncoder &setScissorRect(const MTLScissorRect &rect,
+                                         id<MTLRasterizationRateMap> map);
 
     RenderCommandEncoder &setBlendColor(float r, float g, float b, float a);
 
@@ -576,6 +582,8 @@ class RenderCommandEncoder final : public CommandEncoder
     RenderCommandEncoder &setDepthLoadAction(MTLLoadAction action, double clearValue);
     RenderCommandEncoder &setStencilLoadAction(MTLLoadAction action, uint32_t clearValue);
 
+    RenderCommandEncoder &setRasterizationRateMap(id<MTLRasterizationRateMap> map);
+
     void setLabel(NSString *label);
 
     void pushDebugGroup(NSString *label) override;
@@ -583,8 +591,11 @@ class RenderCommandEncoder final : public CommandEncoder
 
     const RenderPassDesc &renderPassDesc() const { return mRenderPassDesc; }
     bool hasDrawCalls() const { return mHasDrawCalls; }
+    bool hasPipelineState() const { return mPipelineStateSet; }
 
     uint64_t getSerial() const { return mSerial; }
+    id<MTLRasterizationRateMap> rasterizationRateMapForPass(id<MTLRasterizationRateMap> map,
+                                                            id<MTLTexture> colorTexture) const;
 
   private:
     // Override CommandEncoder
@@ -597,7 +608,8 @@ class RenderCommandEncoder final : public CommandEncoder
     void initAttachmentWriteDependencyAndScissorRect(const RenderPassAttachmentDesc &attachment);
     void initWriteDependency(const TextureRef &texture);
 
-    bool finalizeLoadStoreAction(MTLRenderPassAttachmentDescriptor *objCRenderPassAttachment);
+    bool finalizeLoadStoreAction(const RenderPassAttachmentDesc &cppRenderPassAttachment,
+                                 MTLRenderPassAttachmentDescriptor *objCRenderPassAttachment);
 
     void encodeMetalEncoder();
     void simulateDiscardFramebuffer();
diff --git a/src/libANGLE/renderer/metal/mtl_command_buffer.mm b/src/libANGLE/renderer/metal/mtl_command_buffer.mm
index 6ec5b329019ff4e7e2f459a0c72b71871d696732..55dfff675e2368f5d7f2a512fb79f5ad5d5986da 100644
--- a/src/libANGLE/renderer/metal/mtl_command_buffer.mm
+++ b/src/libANGLE/renderer/metal/mtl_command_buffer.mm
@@ -373,12 +373,20 @@ inline void SetVisibilityResultModeCmd(id<MTLRenderCommandEncoder> encoder,
     [encoder setVisibilityResultMode:mode offset:offset];
 }
 
+#if (defined(__MAC_13_0) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_13_0) || \
+    (defined(__IPHONE_16_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_16_0)
+#    define ANGLE_MTL_USE_RESOURCE_USAGE_DEPRECATED 1
+#endif
+
 inline void UseResourceCmd(id<MTLRenderCommandEncoder> encoder, IntermediateCommandStream *stream)
 {
     id<MTLResource> resource = stream->fetch<id<MTLResource>>();
     MTLResourceUsage usage   = stream->fetch<MTLResourceUsage>();
     mtl::RenderStages stages = stream->fetch<mtl::RenderStages>();
     ANGLE_UNUSED_VARIABLE(stages);
+#if ANGLE_MTL_USE_RESOURCE_USAGE_DEPRECATED
+    [encoder useResource:resource usage:usage stages:stages];
+#else
 #if defined(__IPHONE_13_0) || defined(__MAC_10_15)
     if (ANGLE_APPLE_AVAILABLE_XCI(10.15, 13.1, 13.0))
     {
@@ -391,6 +399,7 @@ inline void UseResourceCmd(id<MTLRenderCommandEncoder> encoder, IntermediateComm
         [encoder useResource:resource usage:usage];
         ANGLE_APPLE_ALLOW_DEPRECATED_END
     }
+#endif
     [resource ANGLE_MTL_RELEASE];
 }
 
@@ -644,6 +653,20 @@ inline void CheckPrimitiveType(MTLPrimitiveType primitiveType)
 
     ANGLE_MTL_LOG("Completed MTLCommandBuffer %llu:%p", serial, buf);
 
+    MTLCommandBufferStatus status = buf.status;
+    if (status != MTLCommandBufferStatusCompleted)
+    {
+        NSError *error = buf.error;
+        // MTLCommandBufferErrorNotPermitted is non-fatal, all other errors
+        // result in device lost.
+        // TODO(djg): Should this also check error.domain for MTLCommandBufferErrorDomain?
+        mIsDeviceLost  = !error || error.code != MTLCommandBufferErrorNotPermitted;
+        if (mIsDeviceLost)
+        {
+            return;
+        }
+    }
+
     if (timeElapsedEntry != 0)
     {
         // Record this command buffer's elapsed time.
@@ -1360,10 +1383,12 @@ inline void CheckPrimitiveType(MTLPrimitiveType primitiveType)
     CommandEncoder::reset();
     mRecording        = false;
     mPipelineStateSet = false;
+    setRasterizationRateMap(nil);
     mCommands.clear();
 }
 
 bool RenderCommandEncoder::finalizeLoadStoreAction(
+    const RenderPassAttachmentDesc &cppRenderPassAttachment,
     MTLRenderPassAttachmentDescriptor *objCRenderPassAttachment)
 {
     if (!objCRenderPassAttachment.texture)
@@ -1378,12 +1403,11 @@ inline void CheckPrimitiveType(MTLPrimitiveType primitiveType)
     {
         if (objCRenderPassAttachment.storeAction == MTLStoreActionStore)
         {
-            // NOTE(hqle): Currently if the store action with implicit MS texture is MTLStoreAction,
-            // it is automatically convert to store and resolve action. It might introduce
-            // unnecessary overhead.
-            // Consider an improvement such as only store the MS texture, and resolve only at
-            // the end of real render pass (not render pass the was interrupted by compute pass)
-            // or before glBlitFramebuffer operation starts.
+            // NOTE(hqle): Currently if the store action with implicit MS texture is
+            // MTLStoreAction, it is automatically converted to store and resolve action. It might
+            // introduce unnecessary overhead. Consider an improvement such as only store the MS
+            // texture, and resolve only at the end of real render pass (not render pass that was
+            // interrupted by compute pass) or before glBlitFramebuffer operation starts.
             objCRenderPassAttachment.storeAction = MTLStoreActionStoreAndMultisampleResolve;
         }
         else if (objCRenderPassAttachment.storeAction == MTLStoreActionDontCare)
@@ -1393,6 +1417,26 @@ inline void CheckPrimitiveType(MTLPrimitiveType primitiveType)
         }
     }
 
+    // Check if we need to disable MTLLoadActionLoad & MTLStoreActionStore
+    if (cppRenderPassAttachment.texture->shouldNotLoadStore())
+    {
+        // Disable Load.
+        if (objCRenderPassAttachment.loadAction == MTLLoadActionLoad)
+        {
+            objCRenderPassAttachment.loadAction = MTLLoadActionDontCare;
+        }
+
+        // Disable Store.
+        if (objCRenderPassAttachment.storeAction == MTLStoreActionStore)
+        {
+            objCRenderPassAttachment.storeAction = MTLStoreActionDontCare;
+        }
+        else if (objCRenderPassAttachment.storeAction == MTLStoreActionStoreAndMultisampleResolve)
+        {
+            objCRenderPassAttachment.storeAction = MTLStoreActionMultisampleResolve;
+        }
+    }
+
     if (objCRenderPassAttachment.storeAction == MTLStoreActionUnknown)
     {
         // If storeAction hasn't been set for this attachment, we set to dontcare.
@@ -1421,19 +1465,22 @@ inline void CheckPrimitiveType(MTLPrimitiveType primitiveType)
         // Update store action set between restart() and endEncoding()
         objCRenderPassDesc.colorAttachments[i].storeAction =
             mRenderPassDesc.colorAttachments[i].storeAction;
-        if (finalizeLoadStoreAction(objCRenderPassDesc.colorAttachments[i]))
+        if (finalizeLoadStoreAction(mRenderPassDesc.colorAttachments[i],
+                                    objCRenderPassDesc.colorAttachments[i]))
             hasAttachment = true;
     }
 
     // Update store action set between restart() and endEncoding()
     objCRenderPassDesc.depthAttachment.storeAction = mRenderPassDesc.depthAttachment.storeAction;
-    if (finalizeLoadStoreAction(objCRenderPassDesc.depthAttachment))
+    if (finalizeLoadStoreAction(mRenderPassDesc.depthAttachment,
+                                objCRenderPassDesc.depthAttachment))
         hasAttachment = true;
 
     // Update store action set between restart() and endEncoding()
     objCRenderPassDesc.stencilAttachment.storeAction =
         mRenderPassDesc.stencilAttachment.storeAction;
-    if (finalizeLoadStoreAction(objCRenderPassDesc.stencilAttachment))
+    if (finalizeLoadStoreAction(mRenderPassDesc.stencilAttachment,
+                                objCRenderPassDesc.stencilAttachment))
         hasAttachment = true;
 
     // Set visibility result buffer
@@ -1491,13 +1538,13 @@ inline void CheckPrimitiveType(MTLPrimitiveType primitiveType)
 inline void RenderCommandEncoder::initAttachmentWriteDependencyAndScissorRect(
     const RenderPassAttachmentDesc &attachment)
 {
-    TextureRef texture = attachment.texture;
+    auto texture = attachment.hasResolveTexture() ? attachment.resolveTexture : attachment.texture;
+    auto &mipLevel = attachment.hasResolveTexture() ? attachment.resolveLevel : attachment.level;
+
     if (texture)
     {
         cmdBuffer().setWriteDependency(texture, /*isRenderCommand=*/true);
 
-        const MipmapNativeLevel &mipLevel = attachment.level;
-
         mRenderPassMaxScissorRect.width =
             std::min<NSUInteger>(mRenderPassMaxScissorRect.width, texture->width(mipLevel));
         mRenderPassMaxScissorRect.height =
@@ -1775,7 +1822,8 @@ inline void CheckPrimitiveType(MTLPrimitiveType primitiveType)
     return setStencilRefVals(ref, ref);
 }
 
-RenderCommandEncoder &RenderCommandEncoder::setViewport(const MTLViewport &viewport)
+RenderCommandEncoder &RenderCommandEncoder::setViewport(const MTLViewport &viewport,
+                                                        id<MTLRasterizationRateMap> map)
 {
     if (mStateCache.viewport.valid() && mStateCache.viewport.value() == viewport)
     {
@@ -1788,12 +1836,22 @@ inline void CheckPrimitiveType(MTLPrimitiveType primitiveType)
     return *this;
 }
 
-RenderCommandEncoder &RenderCommandEncoder::setScissorRect(const MTLScissorRect &rect)
+RenderCommandEncoder &RenderCommandEncoder::setScissorRect(const MTLScissorRect &rect, id<MTLRasterizationRateMap> map)
 {
+    auto maxScissorRect =
+        MTLCoordinate2DMake(mRenderPassMaxScissorRect.width, mRenderPassMaxScissorRect.height);
+
+    if (map)
+    {
+        maxScissorRect = [map mapPhysicalToScreenCoordinates:maxScissorRect forLayer:0];
+        if (!(rect.width * rect.height))
+            return *this;
+    }
+
     NSUInteger clampedWidth =
-        rect.x > mRenderPassMaxScissorRect.width ? 0 : mRenderPassMaxScissorRect.width - rect.x;
+        rect.x > maxScissorRect.x ? 0 : (NSUInteger)ceilf(maxScissorRect.x) - rect.x;
     NSUInteger clampedHeight =
-        rect.y > mRenderPassMaxScissorRect.height ? 0 : mRenderPassMaxScissorRect.height - rect.y;
+        rect.y > maxScissorRect.y ? 0 : (NSUInteger)ceilf(maxScissorRect.y) - rect.y;
 
     MTLScissorRect clampedRect = {rect.x, rect.y, std::min(rect.width, clampedWidth),
                                   std::min(rect.height, clampedHeight)};
@@ -1805,6 +1863,23 @@ inline void CheckPrimitiveType(MTLPrimitiveType primitiveType)
 
     mStateCache.scissorRect = clampedRect;
 
+    if (map)
+    {
+        auto adjustedOrigin =
+            [map mapPhysicalToScreenCoordinates:MTLCoordinate2DMake(clampedRect.x, clampedRect.y)
+                                       forLayer:0];
+        auto adjustedSize =
+            [map mapPhysicalToScreenCoordinates:MTLCoordinate2DMake(clampedRect.width,
+                                                                    clampedRect.height)
+                                       forLayer:0];
+
+        clampedRect.x      = (NSUInteger)roundf(adjustedOrigin.x);
+        clampedRect.y      = (NSUInteger)roundf(adjustedOrigin.y);
+        MTLSize screenSize = [map screenSize];
+        clampedRect.width  = std::min<NSUInteger>(screenSize.width, roundf(adjustedSize.x));
+        clampedRect.height = std::min<NSUInteger>(screenSize.height, roundf(adjustedSize.y));
+    }
+
     mCommands.push(CmdType::SetScissorRect).push(clampedRect);
 
     return *this;
@@ -2210,6 +2285,17 @@ inline void CheckPrimitiveType(MTLPrimitiveType primitiveType)
     mCommands.push(CmdType::PopDebugGroup);
 }
 
+id<MTLRasterizationRateMap> RenderCommandEncoder::rasterizationRateMapForPass(id<MTLRasterizationRateMap> map,
+                                                                              id<MTLTexture> texture) const
+{
+    if (!mCachedRenderPassDescObjC.get())
+        return nil;
+
+    MTLSize size = [map physicalSizeForLayer:0];
+    id<MTLTexture> t = mCachedRenderPassDescObjC.get().colorAttachments[0].texture;
+    return t.width == size.width && t.height == size.height ? map : nil;
+}
+
 RenderCommandEncoder &RenderCommandEncoder::setColorStoreAction(MTLStoreAction action,
                                                                 uint32_t colorAttachmentIndex)
 {
@@ -2305,6 +2391,16 @@ inline void CheckPrimitiveType(MTLPrimitiveType primitiveType)
     return *this;
 }
 
+RenderCommandEncoder &RenderCommandEncoder::setRasterizationRateMap(id<MTLRasterizationRateMap> map)
+{
+    if (map != mCachedRenderPassDescObjC.get().rasterizationRateMap)
+    {
+        mCachedRenderPassDescObjC.get().rasterizationRateMap = map;
+    }
+
+    return *this;
+}
+
 void RenderCommandEncoder::setLabel(NSString *label)
 {
     mLabel.retainAssign(label);
diff --git a/src/libANGLE/renderer/metal/mtl_common.h b/src/libANGLE/renderer/metal/mtl_common.h
index b430aa0263545ce6d35ae410e62b035cd41b6c23..96438f09f8b4f576ee2280206b3bdbf461c7618e 100644
--- a/src/libANGLE/renderer/metal/mtl_common.h
+++ b/src/libANGLE/renderer/metal/mtl_common.h
@@ -407,6 +407,8 @@ inline AutoObjCObj<U> adoptObjCObj(U *NS_RELEASES_ARGUMENT src)
 #    define ANGLE_MTL_EVENT_AVAILABLE 0
 #endif
 
+using RasterizationRateMapRef = AutoObjCPtr<id<MTLRasterizationRateMap>>;
+
 // The native image index used by Metal back-end,  the image index uses native mipmap level instead
 // of "virtual" level modified by OpenGL's base level.
 using MipmapNativeLevel = gl::LevelIndexWrapper<uint32_t>;
diff --git a/src/libANGLE/renderer/metal/mtl_format_map.json b/src/libANGLE/renderer/metal/mtl_format_map.json
index 006c24939afa184ae924d2b925993b4b21c02d60..a6f817addb40a750f0f497e4e2b7d2d0764b2cd0 100644
--- a/src/libANGLE/renderer/metal/mtl_format_map.json
+++ b/src/libANGLE/renderer/metal/mtl_format_map.json
@@ -166,7 +166,9 @@
         },
         "map_mac": {
             "D16_UNORM": "MTLPixelFormatDepth16Unorm",
-            "D24_UNORM_S8_UINT": "MTLPixelFormatDepth24Unorm_Stencil8",
+            "D24_UNORM_S8_UINT": "MTLPixelFormatDepth24Unorm_Stencil8"
+        },
+        "map_bc": {
             "BC1_RGBA_UNORM_BLOCK": "MTLPixelFormatBC1_RGBA",
             "BC1_RGBA_UNORM_SRGB_BLOCK": "MTLPixelFormatBC1_RGBA_sRGB",
             "BC2_RGBA_UNORM_BLOCK": "MTLPixelFormatBC2_RGBA",
@@ -220,7 +222,7 @@
             "R4G4B4A4_UNORM": "R8G8B8A8_UNORM",
             "D16_UNORM": "D32_FLOAT"
         },
-        "override_mac_bc1": {
+        "override_bc1": {
             "BC1_RGB_UNORM_BLOCK": {
                 "default": "BC1_RGBA_UNORM_BLOCK",
                 "swizzle": ["RGB1", "BC1_RGBA_UNORM_BLOCK"]
@@ -631,7 +633,7 @@
                 "writable": "false",
                 "blendable": "false",
                 "multisample": "true",
-                "resolve": "false",
+                "resolve": "supportStencilAutoResolve",
                 "colorRenderable": "false",
                 "depthRenderable": "true"
             },
@@ -663,48 +665,50 @@
                 "resolve": "supportDepthStencilAutoResolve",
                 "colorRenderable": "false",
                 "depthRenderable": "display->supportsMacGPUFamily(1) && display->supportsDepth24Stencil8PixelFormat()"
+            }
         },
+        "caps_bc": {
             "MTLPixelFormatBC1_RGBA":{
-                "filterable": "true"
+                "filterable": "display->supportsBCTextureCompression()"
             },
             "MTLPixelFormatBC1_RGBA_sRGB":{
-                "filterable": "true"
+                "filterable": "display->supportsBCTextureCompression()"
             },
             "MTLPixelFormatBC2_RGBA":{
-                "filterable": "true"
+                "filterable": "display->supportsBCTextureCompression()"
             },
             "MTLPixelFormatBC2_RGBA_sRGB":{
-                "filterable": "true"
+                "filterable": "display->supportsBCTextureCompression()"
             },
             "MTLPixelFormatBC3_RGBA":{
-                "filterable": "true"
+                "filterable": "display->supportsBCTextureCompression()"
             },
             "MTLPixelFormatBC3_RGBA_sRGB":{
-                "filterable": "true"
+                "filterable": "display->supportsBCTextureCompression()"
             },
             "MTLPixelFormatBC4_RUnorm":{
-                "filterable": "true"
+                "filterable": "display->supportsBCTextureCompression()"
             },
             "MTLPixelFormatBC4_RSnorm":{
-                "filterable": "true"
+                "filterable": "display->supportsBCTextureCompression()"
             },
             "MTLPixelFormatBC5_RGUnorm":{
-                "filterable": "true"
+                "filterable": "display->supportsBCTextureCompression()"
             },
             "MTLPixelFormatBC5_RGSnorm":{
-                "filterable": "true"
+                "filterable": "display->supportsBCTextureCompression()"
             },
             "MTLPixelFormatBC6H_RGBUfloat":{
-                "filterable": "true"
+                "filterable": "display->supportsBCTextureCompression()"
             },
             "MTLPixelFormatBC6H_RGBFloat":{
-                "filterable": "true"
+                "filterable": "display->supportsBCTextureCompression()"
             },
             "MTLPixelFormatBC7_RGBAUnorm":{
-                "filterable": "true"
+                "filterable": "display->supportsBCTextureCompression()"
             },
             "MTLPixelFormatBC7_RGBAUnorm_sRGB":{
-                "filterable": "true"
+                "filterable": "display->supportsBCTextureCompression()"
             }
         },
         "caps_ios_platform": {
diff --git a/src/libANGLE/renderer/metal/mtl_format_table_autogen.mm b/src/libANGLE/renderer/metal/mtl_format_table_autogen.mm
index da0421a68a5d28327b633f64f913d976e00d3723..7c8b1014a617c3a0196f762a1030fe1eacf6ab62 100644
--- a/src/libANGLE/renderer/metal/mtl_format_table_autogen.mm
+++ b/src/libANGLE/renderer/metal/mtl_format_table_autogen.mm
@@ -129,7 +129,9 @@
             return angle::FormatID::R9G9B9E5_SHAREDEXP;
         case MTLPixelFormatStencil8:
             return angle::FormatID::S8_UINT;
-#if TARGET_OS_OSX || TARGET_OS_MACCATALYST
+#if TARGET_OS_OSX || TARGET_OS_MACCATALYST ||                       \
+    (TARGET_OS_IOS && __IPHONE_OS_VERSION_MAX_ALLOWED >= 160400) || \
+    (TARGET_OS_TV && __TV_OS_VERSION_MAX_ALLOWED >= 160400) || TARGET_OS_VISION
         case MTLPixelFormatBC1_RGBA:
             return angle::FormatID::BC1_RGBA_UNORM_BLOCK;
         case MTLPixelFormatBC1_RGBA_sRGB:
@@ -158,6 +160,8 @@
             return angle::FormatID::BC7_RGBA_UNORM_BLOCK;
         case MTLPixelFormatBC7_RGBAUnorm_sRGB:
             return angle::FormatID::BC7_RGBA_UNORM_SRGB_BLOCK;
+#endif  // BC formats
+#if TARGET_OS_OSX || TARGET_OS_MACCATALYST
         case MTLPixelFormatDepth16Unorm:
             return angle::FormatID::D16_UNORM;
         case MTLPixelFormatDepth24Unorm_Stencil8:
@@ -266,7 +270,7 @@
             return angle::FormatID::ASTC_8x6_UNORM_BLOCK;
         case MTLPixelFormatASTC_8x8_LDR:
             return angle::FormatID::ASTC_8x8_UNORM_BLOCK;
-#    if TARGET_OS_IOS || TARGET_OS_OSX
+#    if TARGET_OS_IOS || TARGET_OS_OSX || TARGET_OS_VISION
         case MTLPixelFormatASTC_10x10_HDR:
             return angle::FormatID::ASTC_10x10_UNORM_BLOCK;
         case MTLPixelFormatASTC_10x5_HDR:
@@ -295,7 +299,7 @@
             return angle::FormatID::ASTC_8x6_UNORM_BLOCK;
         case MTLPixelFormatASTC_8x8_HDR:
             return angle::FormatID::ASTC_8x8_UNORM_BLOCK;
-#    endif  // TARGET_OS_IOS || TARGET_OS_OSX
+#    endif  // TARGET_OS_IOS || TARGET_OS_OSX || TARGET_OS_VISION
 #endif      // TARGET_OS_IPHONE || mac 11.0+
         default:
             return angle::FormatID::NONE;
@@ -887,7 +891,6 @@
             break;
 
         case angle::FormatID::BC1_RGB_UNORM_BLOCK:
-#    if defined(__IPHONE_13_0) || defined(__MAC_10_15)
             if (display->getFeatures().hasTextureSwizzle.enabled)
             {
 
@@ -897,7 +900,6 @@
                 this->swizzle        = {GL_RED, GL_GREEN, GL_BLUE, GL_ONE};
             }
             else
-#    endif  // #if defined(__IPHONE_13_0) || defined(__MAC_10_15)
             {
 
                 this->metalFormat    = MTLPixelFormatBC1_RGBA;
@@ -906,7 +908,6 @@
             break;
 
         case angle::FormatID::BC1_RGB_UNORM_SRGB_BLOCK:
-#    if defined(__IPHONE_13_0) || defined(__MAC_10_15)
             if (display->getFeatures().hasTextureSwizzle.enabled)
             {
 
@@ -916,7 +917,6 @@
                 this->swizzle        = {GL_RED, GL_GREEN, GL_BLUE, GL_ONE};
             }
             else
-#    endif  // #if defined(__IPHONE_13_0) || defined(__MAC_10_15)
             {
 
                 this->metalFormat    = MTLPixelFormatBC1_RGBA_sRGB;
@@ -1199,7 +1199,7 @@
             this->initFunction   = Initialize4ComponentData<GLubyte, 0x00, 0x00, 0x00, 0xFF>;
             break;
 
-#    if TARGET_OS_IOS
+#    if TARGET_OS_IOS || TARGET_OS_VISION
         case angle::FormatID::ASTC_10x10_UNORM_BLOCK:
 
             if (display->supportsAppleGPUFamily(6))
@@ -1481,7 +1481,128 @@
             this->actualFormatId = angle::FormatID::ASTC_8x8_UNORM_BLOCK;
             break;
 
-#    endif  // TARGET_OS_IOS
+#    endif  // ASTC formats
+#    if (TARGET_OS_IOS && __IPHONE_OS_VERSION_MAX_ALLOWED >= 160400) || \
+        (TARGET_OS_TV && __TV_OS_VERSION_MAX_ALLOWED >= 160400) || TARGET_OS_VISION
+        case angle::FormatID::BC1_RGBA_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC1_RGBA;
+            this->actualFormatId = angle::FormatID::BC1_RGBA_UNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC1_RGBA_UNORM_SRGB_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC1_RGBA_sRGB;
+            this->actualFormatId = angle::FormatID::BC1_RGBA_UNORM_SRGB_BLOCK;
+            break;
+
+        case angle::FormatID::BC2_RGBA_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC2_RGBA;
+            this->actualFormatId = angle::FormatID::BC2_RGBA_UNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC2_RGBA_UNORM_SRGB_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC2_RGBA_sRGB;
+            this->actualFormatId = angle::FormatID::BC2_RGBA_UNORM_SRGB_BLOCK;
+            break;
+
+        case angle::FormatID::BC3_RGBA_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC3_RGBA;
+            this->actualFormatId = angle::FormatID::BC3_RGBA_UNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC3_RGBA_UNORM_SRGB_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC3_RGBA_sRGB;
+            this->actualFormatId = angle::FormatID::BC3_RGBA_UNORM_SRGB_BLOCK;
+            break;
+
+        case angle::FormatID::BC4_RED_SNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC4_RSnorm;
+            this->actualFormatId = angle::FormatID::BC4_RED_SNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC4_RED_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC4_RUnorm;
+            this->actualFormatId = angle::FormatID::BC4_RED_UNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC5_RG_SNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC5_RGSnorm;
+            this->actualFormatId = angle::FormatID::BC5_RG_SNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC5_RG_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC5_RGUnorm;
+            this->actualFormatId = angle::FormatID::BC5_RG_UNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC6H_RGB_SFLOAT_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC6H_RGBFloat;
+            this->actualFormatId = angle::FormatID::BC6H_RGB_SFLOAT_BLOCK;
+            break;
+
+        case angle::FormatID::BC6H_RGB_UFLOAT_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC6H_RGBUfloat;
+            this->actualFormatId = angle::FormatID::BC6H_RGB_UFLOAT_BLOCK;
+            break;
+
+        case angle::FormatID::BC7_RGBA_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC7_RGBAUnorm;
+            this->actualFormatId = angle::FormatID::BC7_RGBA_UNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC7_RGBA_UNORM_SRGB_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC7_RGBAUnorm_sRGB;
+            this->actualFormatId = angle::FormatID::BC7_RGBA_UNORM_SRGB_BLOCK;
+            break;
+
+        case angle::FormatID::BC1_RGB_UNORM_BLOCK:
+            if (display->getFeatures().hasTextureSwizzle.enabled)
+            {
+
+                this->metalFormat    = MTLPixelFormatBC1_RGBA;
+                this->actualFormatId = angle::FormatID::BC1_RGBA_UNORM_BLOCK;
+                this->swizzled       = true;
+                this->swizzle        = {GL_RED, GL_GREEN, GL_BLUE, GL_ONE};
+            }
+            else
+            {
+
+                this->metalFormat    = MTLPixelFormatBC1_RGBA;
+                this->actualFormatId = angle::FormatID::BC1_RGBA_UNORM_BLOCK;
+            }
+            break;
+
+        case angle::FormatID::BC1_RGB_UNORM_SRGB_BLOCK:
+            if (display->getFeatures().hasTextureSwizzle.enabled)
+            {
+
+                this->metalFormat    = MTLPixelFormatBC1_RGBA_sRGB;
+                this->actualFormatId = angle::FormatID::BC1_RGBA_UNORM_SRGB_BLOCK;
+                this->swizzled       = true;
+                this->swizzle        = {GL_RED, GL_GREEN, GL_BLUE, GL_ONE};
+            }
+            else
+            {
+
+                this->metalFormat    = MTLPixelFormatBC1_RGBA_sRGB;
+                this->actualFormatId = angle::FormatID::BC1_RGBA_UNORM_SRGB_BLOCK;
+            }
+            break;
+
+#    endif  // BC formats on iOS/tvOS/visionOS
 #elif TARGET_OS_IPHONE && !TARGET_OS_MACCATALYST
         case angle::FormatID::ASTC_10x10_SRGB_BLOCK:
 
@@ -1723,7 +1844,7 @@
             this->actualFormatId = angle::FormatID::D32_FLOAT_S8X24_UINT;
             break;
 
-#    if TARGET_OS_IOS
+#    if TARGET_OS_IOS || TARGET_OS_VISION
         case angle::FormatID::ASTC_10x10_UNORM_BLOCK:
 
             if (display->supportsAppleGPUFamily(6))
@@ -2005,7 +2126,128 @@
             this->actualFormatId = angle::FormatID::ASTC_8x8_UNORM_BLOCK;
             break;
 
-#    endif  // TARGET_OS_IOS || TARGET_OS_TV
+#    endif  // ASTC formats
+#    if (TARGET_OS_IOS && __IPHONE_OS_VERSION_MAX_ALLOWED >= 160400) || \
+        (TARGET_OS_TV && __TV_OS_VERSION_MAX_ALLOWED >= 160400) || TARGET_OS_VISION
+        case angle::FormatID::BC1_RGBA_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC1_RGBA;
+            this->actualFormatId = angle::FormatID::BC1_RGBA_UNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC1_RGBA_UNORM_SRGB_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC1_RGBA_sRGB;
+            this->actualFormatId = angle::FormatID::BC1_RGBA_UNORM_SRGB_BLOCK;
+            break;
+
+        case angle::FormatID::BC2_RGBA_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC2_RGBA;
+            this->actualFormatId = angle::FormatID::BC2_RGBA_UNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC2_RGBA_UNORM_SRGB_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC2_RGBA_sRGB;
+            this->actualFormatId = angle::FormatID::BC2_RGBA_UNORM_SRGB_BLOCK;
+            break;
+
+        case angle::FormatID::BC3_RGBA_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC3_RGBA;
+            this->actualFormatId = angle::FormatID::BC3_RGBA_UNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC3_RGBA_UNORM_SRGB_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC3_RGBA_sRGB;
+            this->actualFormatId = angle::FormatID::BC3_RGBA_UNORM_SRGB_BLOCK;
+            break;
+
+        case angle::FormatID::BC4_RED_SNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC4_RSnorm;
+            this->actualFormatId = angle::FormatID::BC4_RED_SNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC4_RED_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC4_RUnorm;
+            this->actualFormatId = angle::FormatID::BC4_RED_UNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC5_RG_SNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC5_RGSnorm;
+            this->actualFormatId = angle::FormatID::BC5_RG_SNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC5_RG_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC5_RGUnorm;
+            this->actualFormatId = angle::FormatID::BC5_RG_UNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC6H_RGB_SFLOAT_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC6H_RGBFloat;
+            this->actualFormatId = angle::FormatID::BC6H_RGB_SFLOAT_BLOCK;
+            break;
+
+        case angle::FormatID::BC6H_RGB_UFLOAT_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC6H_RGBUfloat;
+            this->actualFormatId = angle::FormatID::BC6H_RGB_UFLOAT_BLOCK;
+            break;
+
+        case angle::FormatID::BC7_RGBA_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC7_RGBAUnorm;
+            this->actualFormatId = angle::FormatID::BC7_RGBA_UNORM_BLOCK;
+            break;
+
+        case angle::FormatID::BC7_RGBA_UNORM_SRGB_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatBC7_RGBAUnorm_sRGB;
+            this->actualFormatId = angle::FormatID::BC7_RGBA_UNORM_SRGB_BLOCK;
+            break;
+
+        case angle::FormatID::BC1_RGB_UNORM_BLOCK:
+            if (display->getFeatures().hasTextureSwizzle.enabled)
+            {
+
+                this->metalFormat    = MTLPixelFormatBC1_RGBA;
+                this->actualFormatId = angle::FormatID::BC1_RGBA_UNORM_BLOCK;
+                this->swizzled       = true;
+                this->swizzle        = {GL_RED, GL_GREEN, GL_BLUE, GL_ONE};
+            }
+            else
+            {
+
+                this->metalFormat    = MTLPixelFormatBC1_RGBA;
+                this->actualFormatId = angle::FormatID::BC1_RGBA_UNORM_BLOCK;
+            }
+            break;
+
+        case angle::FormatID::BC1_RGB_UNORM_SRGB_BLOCK:
+            if (display->getFeatures().hasTextureSwizzle.enabled)
+            {
+
+                this->metalFormat    = MTLPixelFormatBC1_RGBA_sRGB;
+                this->actualFormatId = angle::FormatID::BC1_RGBA_UNORM_SRGB_BLOCK;
+                this->swizzled       = true;
+                this->swizzle        = {GL_RED, GL_GREEN, GL_BLUE, GL_ONE};
+            }
+            else
+            {
+
+                this->metalFormat    = MTLPixelFormatBC1_RGBA_sRGB;
+                this->actualFormatId = angle::FormatID::BC1_RGBA_UNORM_SRGB_BLOCK;
+            }
+            break;
+
+#    endif  // BC formats on iOS/tvOS/visionOS
 #endif      // TARGET_OS_IPHONE
 #if (TARGET_OS_OSX && (__MAC_OS_X_VERSION_MAX_ALLOWED >= 110000))
         case angle::FormatID::ASTC_10x10_SRGB_BLOCK:
@@ -3807,66 +4049,82 @@
                   /** colorRenderable*/ true, /** depthRenderable*/ false);
 
     setFormatCaps(MTLPixelFormatStencil8, /** filterable*/ false, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ true, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ true);
+                  /** blendable*/ false, /** multisample*/ true,
+                  /** resolve*/ supportStencilAutoResolve, /** colorRenderable*/ false,
+                  /** depthRenderable*/ true);
 
-#if TARGET_OS_OSX || TARGET_OS_MACCATALYST
-    setFormatCaps(MTLPixelFormatBC1_RGBA, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+#if TARGET_OS_OSX || TARGET_OS_MACCATALYST ||                       \
+    (TARGET_OS_IOS && __IPHONE_OS_VERSION_MAX_ALLOWED >= 160400) || \
+    (TARGET_OS_TV && __TV_OS_VERSION_MAX_ALLOWED >= 160400) || TARGET_OS_VISION
+    setFormatCaps(MTLPixelFormatBC1_RGBA, /** filterable*/ display->supportsBCTextureCompression(),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC1_RGBA_sRGB, /** filterable*/ true, /** writable*/ false,
+    setFormatCaps(MTLPixelFormatBC1_RGBA_sRGB,
+                  /** filterable*/ display->supportsBCTextureCompression(), /** writable*/ false,
                   /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
                   /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC2_RGBA, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC2_RGBA, /** filterable*/ display->supportsBCTextureCompression(),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC2_RGBA_sRGB, /** filterable*/ true, /** writable*/ false,
+    setFormatCaps(MTLPixelFormatBC2_RGBA_sRGB,
+                  /** filterable*/ display->supportsBCTextureCompression(), /** writable*/ false,
                   /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
                   /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC3_RGBA, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC3_RGBA, /** filterable*/ display->supportsBCTextureCompression(),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC3_RGBA_sRGB, /** filterable*/ true, /** writable*/ false,
+    setFormatCaps(MTLPixelFormatBC3_RGBA_sRGB,
+                  /** filterable*/ display->supportsBCTextureCompression(), /** writable*/ false,
                   /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
                   /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC4_RSnorm, /** filterable*/ true, /** writable*/ false,
+    setFormatCaps(MTLPixelFormatBC4_RSnorm,
+                  /** filterable*/ display->supportsBCTextureCompression(), /** writable*/ false,
                   /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
                   /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC4_RUnorm, /** filterable*/ true, /** writable*/ false,
+    setFormatCaps(MTLPixelFormatBC4_RUnorm,
+                  /** filterable*/ display->supportsBCTextureCompression(), /** writable*/ false,
                   /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
                   /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC5_RGSnorm, /** filterable*/ true, /** writable*/ false,
+    setFormatCaps(MTLPixelFormatBC5_RGSnorm,
+                  /** filterable*/ display->supportsBCTextureCompression(), /** writable*/ false,
                   /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
                   /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC5_RGUnorm, /** filterable*/ true, /** writable*/ false,
+    setFormatCaps(MTLPixelFormatBC5_RGUnorm,
+                  /** filterable*/ display->supportsBCTextureCompression(), /** writable*/ false,
                   /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
                   /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC6H_RGBFloat, /** filterable*/ true, /** writable*/ false,
+    setFormatCaps(MTLPixelFormatBC6H_RGBFloat,
+                  /** filterable*/ display->supportsBCTextureCompression(), /** writable*/ false,
                   /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
                   /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC6H_RGBUfloat, /** filterable*/ true, /** writable*/ false,
+    setFormatCaps(MTLPixelFormatBC6H_RGBUfloat,
+                  /** filterable*/ display->supportsBCTextureCompression(), /** writable*/ false,
                   /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
                   /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC7_RGBAUnorm, /** filterable*/ true, /** writable*/ false,
+    setFormatCaps(MTLPixelFormatBC7_RGBAUnorm,
+                  /** filterable*/ display->supportsBCTextureCompression(), /** writable*/ false,
                   /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
                   /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC7_RGBAUnorm_sRGB, /** filterable*/ true, /** writable*/ false,
+    setFormatCaps(MTLPixelFormatBC7_RGBAUnorm_sRGB,
+                  /** filterable*/ display->supportsBCTextureCompression(), /** writable*/ false,
                   /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
                   /** colorRenderable*/ false, /** depthRenderable*/ false);
 
+#endif  // BC formats
+#if TARGET_OS_OSX || TARGET_OS_MACCATALYST
     setFormatCaps(MTLPixelFormatDepth16Unorm, /** filterable*/ true, /** writable*/ false,
                   /** blendable*/ false, /** multisample*/ true,
                   /** resolve*/ supportDepthAutoResolve, /** colorRenderable*/ false,
@@ -4126,7 +4384,7 @@
                   /** colorRenderable*/ display->supportsAppleGPUFamily(1),
                   /** depthRenderable*/ false);
 
-#    if TARGET_OS_IOS || TARGET_OS_OSX
+#    if TARGET_OS_IOS || TARGET_OS_OSX || TARGET_OS_VISION
     setFormatCaps(MTLPixelFormatASTC_10x10_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4183,7 +4441,7 @@
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-#    endif  // TARGET_OS_IOS || mac 11.0+
+#    endif  // TARGET_OS_IOS || mac 11.0+ || TARGET_OS_VISION
 #endif      // TARGET_OS_IPHONE && !TARGET_OS_MACCATALYST || mac 11.0+
 }
 
diff --git a/src/libANGLE/renderer/metal/mtl_format_utils.h b/src/libANGLE/renderer/metal/mtl_format_utils.h
index db95298598177500cebd0eb81cfcb845656031b2..8cbd1014b7dd9c2886272df3ae0923ccec49b512 100644
--- a/src/libANGLE/renderer/metal/mtl_format_utils.h
+++ b/src/libANGLE/renderer/metal/mtl_format_utils.h
@@ -89,6 +89,10 @@ struct Format : public FormatBase
     // Need conversion between source format and this format?
     bool needConversion(angle::FormatID srcFormatId) const;
 
+    // Are the formats view compatible without requiring
+    // MTLTextureUsagePixelFormatView?
+    bool isViewCompatible(const Format &srcFormat) const;
+
     MTLPixelFormat metalFormat = MTLPixelFormatInvalid;
 
     LoadFunctionMap textureLoadFunctions       = nullptr;
diff --git a/src/libANGLE/renderer/metal/mtl_format_utils.mm b/src/libANGLE/renderer/metal/mtl_format_utils.mm
index 42ea015fdd35d71234acd7b64db032ba2831fb9b..047c119251175ca9a3b5bbafb84d6f686b0b22dd 100644
--- a/src/libANGLE/renderer/metal/mtl_format_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_format_utils.mm
@@ -161,6 +161,26 @@ void GenerateTextureCapsMap(const FormatTable &formatTable,
     return srcFormatId != actualFormatId;
 }
 
+bool Format::isViewCompatible(const Format &srcFormat) const
+{
+    if (srcFormat.metalFormat == metalFormat)
+        return true;
+
+    // The pixel layout is considered different if the number of components differs,
+    if (srcFormat.caps.channels != caps.channels)
+        return false;
+
+    // ... or if their size or order is different from the components in the original pixel format.
+    if (srcFormat.caps.pixelBytes != caps.pixelBytes)
+        return false;
+
+    // This is overly conservative but reject compressed formats
+    if (srcFormat.caps.compressed || caps.compressed)
+        return false;
+
+    return true;
+}
+
 bool Format::isPVRTC() const
 {
     switch (metalFormat)
diff --git a/src/libANGLE/renderer/metal/mtl_render_utils.mm b/src/libANGLE/renderer/metal/mtl_render_utils.mm
index 9e5487d393a0a2bd64106fc70e7b3f73626e2490..956808f2cd03665bd09d95cf4af90e2eeacdd0ef 100644
--- a/src/libANGLE/renderer/metal/mtl_render_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_render_utils.mm
@@ -607,7 +607,8 @@ void DispatchCompute(ContextMtl *contextMtl,
                      id<MTLComputePipelineState> pipelineState,
                      size_t numThreads)
 {
-    NSUInteger w = std::min<NSUInteger>(pipelineState.threadExecutionWidth, numThreads);
+    ASSERT(numThreads != 0);
+    NSUInteger w = std::clamp<NSUInteger>(numThreads, 1u, pipelineState.threadExecutionWidth);
     MTLSize threadsPerThreadgroup = MTLSizeMake(w, 1, 1);
 
     if (contextMtl->getDisplay()->getFeatures().hasNonUniformDispatch.enabled)
@@ -687,8 +688,9 @@ void SetupCommonBlitWithDrawStates(const gl::Context *context,
         GetViewport(params.dstRect, params.dstTextureSize.height, params.dstFlipY);
     MTLScissorRect scissorRectMtl =
         GetScissorRect(params.dstScissorRect, params.dstTextureSize.height, params.dstFlipY);
-    cmdEncoder->setViewport(viewportMtl);
-    cmdEncoder->setScissorRect(scissorRectMtl);
+
+    cmdEncoder->setViewport(viewportMtl, nil);
+    cmdEncoder->setScissorRect(scissorRectMtl, nil);
 
     if (params.src)
     {
@@ -1222,8 +1224,8 @@ ANGLE_INLINE void SetPipelineState(ComputeCommandEncoder *encoder,
 
     scissorRect = GetScissorRect(params.clearArea, params.dstTextureSize.height, params.flipY);
 
-    cmdEncoder->setViewport(viewport);
-    cmdEncoder->setScissorRect(scissorRect);
+    cmdEncoder->setViewport(viewport, nil);
+    cmdEncoder->setScissorRect(scissorRect, nil);
 
     // uniform
     ClearParamsUniform uniformParams;
diff --git a/src/libANGLE/renderer/metal/mtl_resource_spi.h b/src/libANGLE/renderer/metal/mtl_resource_spi.h
index 3eaa9a64e79af26faa786102ece3f0bdea84d090..7ecb6db9d993df8985fcb6f701dfe7ca75857cae 100644
--- a/src/libANGLE/renderer/metal/mtl_resource_spi.h
+++ b/src/libANGLE/renderer/metal/mtl_resource_spi.h
@@ -1,9 +1,63 @@
-//
-// Copyright 2021 The ANGLE Project Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (C) 2021 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 //
 // mtl_resource_spi.h:
-//    Used to set Metal resource ownership identity with SPI.
-//    Purposefully empty header file. Actual implementation will be hosted in WebKit.
+//    Used to set Metal resource ownership identity with SPI
 //
+
+#ifndef LIBANGLE_RENDERER_METAL_RESOURCE_SPI_H_
+#define LIBANGLE_RENDERER_METAL_RESOURCE_SPI_H_
+
+#import "common/apple/apple_platform.h"
+
+#if ANGLE_USE_METAL_OWNERSHIP_IDENTITY
+
+#    import <Metal/MTLResource_Private.h>
+#    import <Metal/Metal.h>
+#    import <mach/mach_types.h>
+
+namespace rx
+{
+namespace mtl
+{
+inline void setOwnerWithIdentity(id<MTLResource> resource, task_id_token_t identityToken)
+{
+    if (identityToken != TASK_ID_TOKEN_NULL)
+    {
+        kern_return_t kr = [(id<MTLResourceSPI>)resource setOwnerWithIdentity:identityToken];
+        if (ANGLE_UNLIKELY(kr != KERN_SUCCESS))
+        {
+            ERR() << "setOwnerWithIdentity failed with: %s (%x)" << mach_error_string(kr) << kr;
+            ASSERT(false);
+        }
+    }
+    return;
+}
+}  // namespace mtl
+}  // namespace rx
+#endif
+
+#endif /* LIBANGLE_RENDERER_METAL_RESOURCE_SPI_H_ */
diff --git a/src/libANGLE/renderer/metal/mtl_resources.h b/src/libANGLE/renderer/metal/mtl_resources.h
index 081c46ef66b3e24f228cd8ee4db46f68abfbcd35..d6c26bd72ca672f5ad3deaeb657af0723377c410 100644
--- a/src/libANGLE/renderer/metal/mtl_resources.h
+++ b/src/libANGLE/renderer/metal/mtl_resources.h
@@ -146,10 +146,11 @@ class Texture final : public Resource,
                                        TextureRef *refOut);
 
     // On macOS, memory will still be allocated for this texture.
-    static angle::Result MakeMemoryLess2DTexture(ContextMtl *context,
+    static angle::Result MakeMemoryLess2DMSTexture(ContextMtl *context,
                                                    const Format &format,
                                                    uint32_t width,
                                                    uint32_t height,
+                                                   uint32_t samples,
                                                    TextureRef *refOut);
 
     static angle::Result MakeCubeTexture(ContextMtl *context,
@@ -227,6 +228,11 @@ class Texture final : public Resource,
     TextureRef createCubeFaceView(uint32_t face);
     // Create a view of one slice at a level.
     TextureRef createSliceMipView(uint32_t slice, const MipmapNativeLevel &level);
+    // Same as createSliceMipView but the target format must be compatible, for example sRGB to linear. In this
+    // case texture doesn't need format view usage flag.
+    TextureRef createSliceMipViewWithCompatibleFormat(uint32_t slice,
+                                                      const MipmapNativeLevel &level,
+                                                      MTLPixelFormat format);
     // Create a levels range view
     TextureRef createMipsView(const MipmapNativeLevel &baseLevel, uint32_t levels);
     // Create a view of a level.
@@ -309,6 +315,11 @@ class Texture final : public Resource,
     size_t estimatedByteSize() const override { return mEstimatedByteSize; }
     id getID() const override { return get(); }
 
+    // Should we disable MTLLoadActionLoad & MTLStoreActionStore when using this texture
+    // as render pass' attachment. This is usually used for memoryless textures and
+    // EXT_multisampled_render_to_texture.
+    bool shouldNotLoadStore() const { return mShouldNotLoadStore; }
+
   private:
     using ParentClass = WrappedObject<id<MTLTexture>>;
 
@@ -394,6 +405,8 @@ class Texture final : public Resource,
     TextureRef mParentTexture;
 
     size_t mEstimatedByteSize = 0;
+
+    bool mShouldNotLoadStore = false;
 };
 
 class Buffer final : public Resource, public WrappedObject<id<MTLBuffer>>
diff --git a/src/libANGLE/renderer/metal/mtl_resources.mm b/src/libANGLE/renderer/metal/mtl_resources.mm
index 50873854b075ce7327e2ecff25a2c37ba707eb88..e0c4c7789813160815a4bf5341175f8b1f634634 100644
--- a/src/libANGLE/renderer/metal/mtl_resources.mm
+++ b/src/libANGLE/renderer/metal/mtl_resources.mm
@@ -78,12 +78,10 @@ MTLResourceOptions resourceOptionsForStorageMode(MTLStorageMode storageMode)
             return MTLResourceStorageModePrivate;
         case MTLStorageModeMemoryless:
             return MTLResourceStorageModeMemoryless;
-#if TARGET_OS_SIMULATOR
         default:
             // TODO(http://anglebug.com/42266474): Remove me once hacked SDKs are fixed.
             UNREACHABLE();
             return MTLResourceStorageModeShared;
-#endif
     }
 }
 
@@ -170,10 +168,11 @@ MTLResourceOptions resourceOptionsForStorageMode(MTLStorageMode storageMode)
 }
 
 /** static */
-angle::Result Texture::MakeMemoryLess2DTexture(ContextMtl *context,
+angle::Result Texture::MakeMemoryLess2DMSTexture(ContextMtl *context,
                                                  const Format &format,
                                                  uint32_t width,
                                                  uint32_t height,
+                                                 uint32_t samples,
                                                  TextureRef *refOut)
 {
     ANGLE_MTL_OBJC_SCOPE
@@ -183,8 +182,11 @@ MTLResourceOptions resourceOptionsForStorageMode(MTLStorageMode storageMode)
                                                                width:width
                                                               height:height
                                                            mipmapped:NO];
+        desc.textureType = MTLTextureType2DMultisample;
+        desc.sampleCount = samples;
 
-        return MakeTexture(context, format, desc, 1, true, false, true, refOut);
+        return MakeTexture(context, format, desc, 1, /*renderTargetOnly=*/true,
+                           /*allowFormatView=*/false, /*memoryLess=*/true, refOut);
     }  // ANGLE_MTL_OBJC_SCOPE
 }
 /** static */
@@ -428,11 +430,27 @@ bool needMultisampleColorFormatShaderReadWorkaround(ContextMtl *context, MTLText
 
         if (memoryLess)
         {
+            bool supportsMemoryless = false;
 #if (TARGET_OS_IOS || TARGET_OS_TV) && !TARGET_OS_MACCATALYST
-            desc.resourceOptions = MTLResourceStorageModeMemoryless;
+            supportsMemoryless = true;
 #else
-            desc.resourceOptions = MTLResourceStorageModePrivate;
+            if (ANGLE_APPLE_AVAILABLE_XC(11.0, 14.1))
+            {
+                supportsMemoryless = context->getDisplay()->supportsAppleGPUFamily(1);
+            }
 #endif
+            if (supportsMemoryless)
+            {
+                desc.resourceOptions = MTLResourceStorageModeMemoryless;
+            }
+            else
+            {
+                desc.resourceOptions = MTLResourceStorageModePrivate;
+            }
+
+            // Regardless of whether MTLResourceStorageModeMemoryless is used or not, we disable
+            // Load/Store on this texture.
+            mShouldNotLoadStore = true;
         }
         else if (context->getNativeFormatCaps(desc.pixelFormat).depthRenderable ||
                  desc.textureType == MTLTextureType2DMultisample)
@@ -451,12 +469,12 @@ bool needMultisampleColorFormatShaderReadWorkaround(ContextMtl *context, MTLText
         }
         if (desc.pixelFormat == MTLPixelFormatDepth32Float_Stencil8)
         {
-            ASSERT(allowFormatView);
+            ASSERT(allowFormatView || memoryLess);
         }
 #if TARGET_OS_OSX || TARGET_OS_MACCATALYST
         if (desc.pixelFormat == MTLPixelFormatDepth24Unorm_Stencil8)
         {
-            ASSERT(allowFormatView);
+            ASSERT(allowFormatView || memoryLess);
         }
 #endif
 
@@ -704,7 +722,9 @@ bool needMultisampleColorFormatShaderReadWorkaround(ContextMtl *context, MTLText
     }
 }
 
-TextureRef Texture::createSliceMipView(uint32_t slice, const MipmapNativeLevel &level)
+TextureRef Texture::createSliceMipViewWithCompatibleFormat(uint32_t slice,
+                                                           const MipmapNativeLevel &level,
+                                                           MTLPixelFormat format)
 {
     ANGLE_MTL_OBJC_SCOPE
     {
@@ -713,7 +733,7 @@ bool needMultisampleColorFormatShaderReadWorkaround(ContextMtl *context, MTLText
             case MTLTextureTypeCube:
             case MTLTextureType2D:
             case MTLTextureType2DArray:
-                return TextureRef(new Texture(this, pixelFormat(), MTLTextureType2D,
+                return TextureRef(new Texture(this, format, MTLTextureType2D,
                                               NSMakeRange(level.get(), 1), NSMakeRange(slice, 1)));
             default:
                 UNREACHABLE();
@@ -722,6 +742,11 @@ bool needMultisampleColorFormatShaderReadWorkaround(ContextMtl *context, MTLText
     }
 }
 
+TextureRef Texture::createSliceMipView(uint32_t slice, const MipmapNativeLevel &level)
+{
+    return createSliceMipViewWithCompatibleFormat(slice, level, pixelFormat());
+}
+
 TextureRef Texture::createMipView(const MipmapNativeLevel &level)
 {
     ANGLE_MTL_OBJC_SCOPE
diff --git a/src/libANGLE/renderer/metal/mtl_state_cache.h b/src/libANGLE/renderer/metal/mtl_state_cache.h
index 79afa2a499e6a508246edac7dd986b2eabf21a65..5aa69c7b4e7b7dd2fa7318d4bbf027073ba776ba 100644
--- a/src/libANGLE/renderer/metal/mtl_state_cache.h
+++ b/src/libANGLE/renderer/metal/mtl_state_cache.h
@@ -319,15 +319,21 @@ struct RenderPassAttachmentDesc
     bool equalIgnoreLoadStoreOptions(const RenderPassAttachmentDesc &other) const;
     bool operator==(const RenderPassAttachmentDesc &other) const;
 
-    ANGLE_INLINE bool hasImplicitMSTexture() const { return implicitMSTexture.get(); }
+    ANGLE_INLINE bool hasResolveTexture() const { return resolveTexture.get(); }
  
+    // When rendering with implicit multisample, |texture| is the texture that
+    // will be rendered into and discarded at the end of a render pass. Its
+    // result will be automatically resolved into |resolveTexture|.
     TextureRef texture;
     // Implicit multisample texture that will be rendered into and discarded at the end of
     // a render pass. Its result will be resolved into normal texture above.
-    TextureRef implicitMSTexture;
+    TextureRef resolveTexture;
     MipmapNativeLevel level;
     uint32_t sliceOrDepth;
 
+    MipmapNativeLevel resolveLevel;
+    uint32_t resolveSliceOrDepth;
+
     // This attachment is blendable or not.
     bool blendable;
     MTLLoadAction loadAction;
diff --git a/src/libANGLE/renderer/metal/mtl_state_cache.mm b/src/libANGLE/renderer/metal/mtl_state_cache.mm
index 8534c5c32fbc218da6c00ed95804026ccab508ef..ef3cb4944f9f588f4ddbf92529c5b999f0cc5f26 100644
--- a/src/libANGLE/renderer/metal/mtl_state_cache.mm
+++ b/src/libANGLE/renderer/metal/mtl_state_cache.mm
@@ -142,44 +142,29 @@ inline T ToObjC(const T p)
 void BaseRenderPassAttachmentDescToObjC(const RenderPassAttachmentDesc &src,
                                         MTLRenderPassAttachmentDescriptor *dst)
 {
-    const TextureRef &implicitMsTexture = src.implicitMSTexture;
-
-    if (implicitMsTexture)
-    {
-        dst.texture        = ToObjC(implicitMsTexture);
-        dst.level          = 0;
-        dst.slice          = 0;
-        dst.depthPlane     = 0;
-        dst.resolveTexture = ToObjC(src.texture);
-        dst.resolveLevel   = src.level.get();
-        if (dst.resolveTexture.textureType == MTLTextureType3D)
-        {
-            dst.resolveDepthPlane = src.sliceOrDepth;
-            dst.resolveSlice      = 0;
-        }
-        else
-        {
-            dst.resolveSlice      = src.sliceOrDepth;
-            dst.resolveDepthPlane = 0;
-        }
-    }
-    else
-    {
     dst.texture = ToObjC(src.texture);
     dst.level   = src.level.get();
     if (dst.texture.textureType == MTLTextureType3D)
     {
-            dst.depthPlane = src.sliceOrDepth;
         dst.slice      = 0;
+        dst.depthPlane = src.sliceOrDepth;
     }
     else
     {
         dst.slice      = src.sliceOrDepth;
         dst.depthPlane = 0;
     }
-        dst.resolveTexture    = nil;
-        dst.resolveLevel      = 0;
+
+    dst.resolveTexture = ToObjC(src.resolveTexture);
+    dst.resolveLevel   = src.resolveLevel.get();
+    if (dst.resolveTexture.textureType == MTLTextureType3D)
+    {
         dst.resolveSlice      = 0;
+        dst.resolveDepthPlane = src.resolveSliceOrDepth;
+    }
+    else
+    {
+        dst.resolveSlice      = src.resolveSliceOrDepth;
         dst.resolveDepthPlane = 0;
     }
 
@@ -692,9 +677,11 @@ MTLColorWriteMask AdjustColorWriteMaskForSharedExponent(MTLColorWriteMask mask)
 void RenderPassAttachmentDesc::reset()
 {
     texture.reset();
-    implicitMSTexture.reset();
+    resolveTexture.reset();
     level               = mtl::kZeroNativeMipLevel;
     sliceOrDepth        = 0;
+    resolveLevel        = mtl::kZeroNativeMipLevel;
+    resolveSliceOrDepth = 0;
     blendable           = false;
     loadAction          = MTLLoadActionLoad;
     storeAction         = MTLStoreActionStore;
@@ -704,7 +691,7 @@ MTLColorWriteMask AdjustColorWriteMaskForSharedExponent(MTLColorWriteMask mask)
 bool RenderPassAttachmentDesc::equalIgnoreLoadStoreOptions(
     const RenderPassAttachmentDesc &other) const
 {
-    return texture == other.texture && implicitMSTexture == other.implicitMSTexture &&
+    return texture == other.texture && resolveTexture == other.resolveTexture &&
            level == other.level && sliceOrDepth == other.sliceOrDepth &&
            blendable == other.blendable;
 }
diff --git a/src/libANGLE/renderer/metal/mtl_utils.mm b/src/libANGLE/renderer/metal/mtl_utils.mm
index b16fdeab51f65588f18e9ae7c19140474fd36eb2..13446940c9c0c06dcac73e4f6e72531abebc5334 100644
--- a/src/libANGLE/renderer/metal/mtl_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_utils.mm
@@ -105,9 +105,62 @@ bool FrameCaptureDeviceScope()
 #endif
 }
 
+// Ensure that .gputrace files have RW permissions for the user or, if a
+// directory, RWX permissions for the user.
+ANGLE_APPLE_UNUSED
+static inline void FixGPUTracePathPermissions(NSString *path, bool isDir)
+{
+    // Ensure we're only change permissions on files in a gputrace bundle.
+    if (![path containsString:@".gputrace"])
+    {
+        return;
+    }
+
+    NSError *error = nil;
+    NSDictionary<NSFileAttributeKey, id> *attributes =
+        [NSFileManager.defaultManager attributesOfItemAtPath:path error:&error];
+    NSNumber *oldPerms = static_cast<NSNumber *>(attributes[NSFilePosixPermissions]);
+    if (!oldPerms)
+    {
+        NSString *msg =
+            attributes ? @"NSFilePosixPermissions unavailable" : error.localizedDescription;
+        NSLog(@"Unable to read permissions for %@ (%@)", path, msg);
+        return;
+    }
+
+    NSUInteger newPerms = oldPerms.unsignedIntegerValue | S_IRUSR | S_IWUSR;
+    if (isDir)
+    {
+        newPerms |= S_IXUSR;
+    }
+
+    if (![NSFileManager.defaultManager setAttributes:@{
+            NSFilePosixPermissions : @(newPerms)
+        }
+                                        ofItemAtPath:path
+                                               error:&error])
+    {
+        NSLog(@"Unable to set permissions=%3lo for %@ (%@)", static_cast<unsigned long>(newPerms),
+              path, error.localizedDescription);
+    }
+}
+
+ANGLE_APPLE_UNUSED
+static inline void FixGPUTraceBundlePermissions(NSString *bundlePath)
+{
+    FixGPUTracePathPermissions(bundlePath, true);
+    for (NSString *file in [NSFileManager.defaultManager enumeratorAtPath:bundlePath])
+    {
+        FixGPUTracePathPermissions([NSString pathWithComponents:@[ bundlePath, file ]], false);
+    }
+}
+
 ANGLE_APPLE_UNUSED
 std::atomic<size_t> gFrameCaptured(0);
 
+ANGLE_APPLE_UNUSED
+NSString *gFrameCapturePath;
+
 ANGLE_APPLE_UNUSED
 void StartFrameCapture(id<MTLDevice> metalDevice, id<MTLCommandQueue> metalCmdQueue)
 {
@@ -141,13 +194,13 @@ void StartFrameCapture(id<MTLDevice> metalDevice, id<MTLCommandQueue> metalCmdQu
         auto captureDescriptor = mtl::adoptObjCObj([[MTLCaptureDescriptor alloc] init]);
         captureDescriptor.get().captureObject = metalDevice;
         const std::string filePath            = GetMetalCaptureFile();
+        NSString *frameCapturePath            = nil;
         if (filePath != "")
         {
-            const std::string numberedPath =
-                filePath + std::to_string(gFrameCaptured - 1) + ".gputrace";
+            frameCapturePath =
+                [NSString stringWithFormat:@"%s%zu.gputrace", filePath.c_str(), gFrameCaptured - 1];
             captureDescriptor.get().destination = MTLCaptureDestinationGPUTraceDocument;
-            captureDescriptor.get().outputURL =
-                [NSURL fileURLWithPath:[NSString stringWithUTF8String:numberedPath.c_str()]
+            captureDescriptor.get().outputURL   = [NSURL fileURLWithPath:frameCapturePath
                                                            isDirectory:false];
         }
         else
@@ -157,7 +210,12 @@ void StartFrameCapture(id<MTLDevice> metalDevice, id<MTLCommandQueue> metalCmdQu
         }
 
         NSError *error;
-        if (![captureManager startCaptureWithDescriptor:captureDescriptor.get() error:&error])
+        if ([captureManager startCaptureWithDescriptor:captureDescriptor.get() error:&error])
+        {
+            ASSERT(!gFrameCapturePath);
+            gFrameCapturePath = frameCapturePath;
+        }
+        else
         {
             NSLog(@"Failed to start capture, error %@", error);
         }
@@ -194,6 +252,12 @@ void StopFrameCapture()
     if (captureManager.isCapturing)
     {
         [captureManager stopCapture];
+        if (gFrameCapturePath)
+        {
+            FixGPUTraceBundlePermissions(gFrameCapturePath);
+            [gFrameCapturePath ANGLE_MTL_RELEASE];
+            gFrameCapturePath = nil;
+        }
     }
 #endif
 }
@@ -1484,9 +1548,10 @@ bool DeviceHasMaximumRenderTargetSize(id<MTLDevice> device)
 
 bool SupportsAppleGPUFamily(id<MTLDevice> device, uint8_t appleFamily)
 {
-#if (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101500 || __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000) || \
-    (__TV_OS_VERSION_MAX_ALLOWED >= 130000)
     // If device supports [MTLDevice supportsFamily:], then use it.
+#if (TARGET_OS_OSX && __MAC_OS_X_VERSION_MAX_ALLOWED >= 101500) ||  \
+    (TARGET_OS_IOS && __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000) || \
+    (TARGET_OS_TV && __TV_OS_VERSION_MAX_ALLOWED >= 130000) || TARGET_OS_WATCH || TARGET_OS_VISION
     if (ANGLE_APPLE_AVAILABLE_XCI(10.15, 13.1, 13))
     {
         MTLGPUFamily family;
@@ -1507,72 +1572,81 @@ bool SupportsAppleGPUFamily(id<MTLDevice> device, uint8_t appleFamily)
             case 5:
                 family = MTLGPUFamilyApple5;
                 break;
-#    if TARGET_OS_IOS || (TARGET_OS_OSX && __MAC_OS_X_VERSION_MAX_ALLOWED >= 110000)
+#    if !TARGET_OS_OSX || __MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
             case 6:
                 family = MTLGPUFamilyApple6;
                 break;
+#        if (TARGET_OS_IOS && __IPHONE_OS_VERSION_MAX_ALLOWED >= 140000) || \
+            (TARGET_OS_TV && __TV_OS_VERSION_MAX_ALLOWED >= 140000) ||      \
+            (!TARGET_OS_IOS && !TARGET_OS_TV)
             case 7:
                 family = MTLGPUFamilyApple7;
                 break;
-#        if __MAC_OS_X_VERSION_MAX_ALLOWED >= 130000 || __IPHONE_OS_VERSION_MAX_ALLOWED >= 150000
-            case 8:
-                family = MTLGPUFamilyApple8;
-                break;
-#        endif
-#        if __MAC_OS_X_VERSION_MAX_ALLOWED >= 140000 || __IPHONE_OS_VERSION_MAX_ALLOWED >= 170000
-            case 9:
-                family = MTLGPUFamilyApple9;
-                break;
 #        endif
 #    endif
             default:
                 return false;
         }
         return [device supportsFamily:family];
-    }   // Metal 2.2
-#endif  // __IPHONE_OS_VERSION_MAX_ALLOWED
+    }
+#endif
 
-#if (!TARGET_OS_IOS && !TARGET_OS_TV) || TARGET_OS_MACCATALYST || \
-    (TARGET_OS_IOS && defined(__IPHONE_16_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_16_0)
-    return false;
-#else
     // If device doesn't support [MTLDevice supportsFamily:], then use
-    // [MTLDevice supportsFeatureSet:].
-    MTLFeatureSet featureSet;
+    // [MTLDevice supportsFeatureSet:]. Only compiled for deployment targets
+    // that need support for older devices.
+#if TARGET_OS_IOS && __IPHONE_OS_VERSION_MIN_REQUIRED < 130000
     switch (appleFamily)
     {
-#    if TARGET_OS_IOS
         case 1:
-            featureSet = MTLFeatureSet_iOS_GPUFamily1_v1;
-            break;
+            return [device supportsFeatureSet:MTLFeatureSet_iOS_GPUFamily1_v1];
         case 2:
-            featureSet = MTLFeatureSet_iOS_GPUFamily2_v1;
-            break;
+            return [device supportsFeatureSet:MTLFeatureSet_iOS_GPUFamily2_v1];
         case 3:
-            featureSet = MTLFeatureSet_iOS_GPUFamily3_v1;
-            break;
+            return [device supportsFeatureSet:MTLFeatureSet_iOS_GPUFamily3_v1];
         case 4:
-            featureSet = MTLFeatureSet_iOS_GPUFamily4_v1;
-            break;
+            return [device supportsFeatureSet:MTLFeatureSet_iOS_GPUFamily4_v1];
 #    if __IPHONE_OS_VERSION_MAX_ALLOWED >= 120000
         case 5:
-            featureSet = MTLFeatureSet_iOS_GPUFamily5_v1;
+            return [device supportsFeatureSet:MTLFeatureSet_iOS_GPUFamily5_v1];
+#    endif
+        default:
             break;
-#        endif  // __IPHONE_OS_VERSION_MAX_ALLOWED
-#    elif TARGET_OS_TV
+    }
+#elif TARGET_OS_TV && __TV_OS_VERSION_MIN_REQUIRED < 130000
+    switch (appleFamily)
+    {
         case 1:
         case 2:
-            featureSet = MTLFeatureSet_tvOS_GPUFamily1_v1;
-            break;
-#    endif  // TARGET_OS_IOS
+            return [device supportsFeatureSet:MTLFeatureSet_tvOS_GPUFamily1_v1];
+#    if __TV_OS_VERSION_MAX_ALLOWED >= 120000
+        case 3:
+            return [device supportsFeatureSet:MTLFeatureSet_tvOS_GPUFamily2_v1];
+#    endif
         default:
-            return false;
+            break;
     }
-
-    return [device supportsFeatureSet:featureSet];
-#endif      // TARGET_OS_IOS || TARGET_OS_TV
+#endif
+    return false;
 }
 
+#if (defined(__MAC_13_0) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_13_0) ||        \
+    (defined(__IPHONE_16_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_16_0) || \
+    (defined(__TVOS_16_0) && __TV_OS_VERSION_MIN_REQUIRED >= __TVOS_16_0)
+#    define ANGLE_MTL_FEATURE_SET_DEPRECATED 1
+#    define ANGLE_MTL_GPU_FAMILY_MAC1_DEPRECATED 1
+#endif
+
+#if ANGLE_MTL_GPU_FAMILY_MAC1_DEPRECATED
+#    define ANGLE_MTL_GPU_FAMILY_MAC1 MTLGPUFamilyMac2
+#    define ANGLE_MTL_GPU_FAMILY_MAC2 MTLGPUFamilyMac2
+#elif TARGET_OS_MACCATALYST
+#    define ANGLE_MTL_GPU_FAMILY_MAC1 MTLGPUFamilyMacCatalyst1
+#    define ANGLE_MTL_GPU_FAMILY_MAC2 MTLGPUFamilyMacCatalyst2
+#else  // !ANGLE_MTL_GPU_FAMILY_MAC1_DEPRECATED && !TARGET_OS_MACCATALYST
+#    define ANGLE_MTL_GPU_FAMILY_MAC1 MTLGPUFamilyMac1
+#    define ANGLE_MTL_GPU_FAMILY_MAC2 MTLGPUFamilyMac2
+#endif
+
 bool SupportsMacGPUFamily(id<MTLDevice> device, uint8_t macFamily)
 {
 #if TARGET_OS_OSX || TARGET_OS_MACCATALYST
@@ -1587,10 +1661,10 @@ bool SupportsMacGPUFamily(id<MTLDevice> device, uint8_t macFamily)
 #        if TARGET_OS_MACCATALYST
             ANGLE_APPLE_ALLOW_DEPRECATED_BEGIN
             case 1:
-                family = MTLGPUFamilyMacCatalyst1;
+                family = ANGLE_MTL_GPU_FAMILY_MAC1;
                 break;
             case 2:
-                family = MTLGPUFamilyMacCatalyst2;
+                family = ANGLE_MTL_GPU_FAMILY_MAC2;
                 break;
                 ANGLE_APPLE_ALLOW_DEPRECATED_END
 #        else   // TARGET_OS_MACCATALYST
@@ -1613,7 +1687,7 @@ bool SupportsMacGPUFamily(id<MTLDevice> device, uint8_t macFamily)
 
     // If device doesn't support [MTLDevice supportsFamily:], then use
     // [MTLDevice supportsFeatureSet:].
-#    if TARGET_OS_MACCATALYST
+#    if TARGET_OS_MACCATALYST || ANGLE_MTL_FEATURE_SET_DEPRECATED
     UNREACHABLE();
     return false;
 #    else
@@ -1662,8 +1736,7 @@ static NSUInteger getNextLocationForAttachment(const mtl::RenderPassAttachmentDe
                                                const Context *context,
                                                NSUInteger currentRenderTargetSize)
 {
-    mtl::TextureRef texture =
-        attachment.implicitMSTexture ? attachment.implicitMSTexture : attachment.texture;
+    mtl::TextureRef texture = attachment.texture;
 
     if (texture)
     {
diff --git a/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py b/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py
new file mode 100644
index 0000000000000000000000000000000000000000..23e8295bcc16412d3aef3fc8e85748fa4ad77a70
--- /dev/null
+++ b/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py
@@ -0,0 +1,65 @@
+#!/usr/bin/python3
+# Copyright 2021 The ANGLE Project Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+#
+# create_mtl_internal_shaders.py:
+#   Script to compile a metalLib into NSData, for including the compilded
+#       library in the ANGLE dylib.
+
+import os
+import sys
+import json
+from datetime import datetime
+
+sys.path.append('../..')
+
+template_header_boilerplate = """// GENERATED FILE - DO NOT EDIT.
+// Generated by {script_name}
+//
+// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+"""
+
+
+# Convert content of a file to byte array and store in a header file.
+# variable_name: name of C++ variable that will hold the file content as byte array.
+# filename: the file whose content will be converted to C++ byte array.
+# dest_src_file: destination header file that will contain the byte array.
+def append_file_as_byte_array_string(variable_name, filename, dest_src_file):
+    string = '// Generated from {0}:\n'.format(filename)
+    string += 'constexpr uint8_t {0}[]={{\n'.format(variable_name)
+    bytes_ = open(filename, "rb").read()
+    for byte in bytes_:
+        string += '0x{:02x}'.format(byte) + ", "
+    string += "\n};\n"
+    with open(dest_src_file, "a") as out_file:
+        out_file.write(string)
+
+
+def main():
+    input_file = sys.argv[1]
+    output_file = sys.argv[2]
+    os.chdir(sys.path[0])
+
+    boilerplate_code = template_header_boilerplate.format(
+        script_name=os.path.basename(sys.argv[0]), copyright_year=datetime.today().year)
+
+    # -------- Compile shaders -----------
+    # boiler plate code
+    os.system("echo \"{0}\" > \"{1}\"".format(boilerplate_code, output_file))
+    os.system(
+        'echo "// Compiled binary for Metal default shaders.\n\n" >>  \"{0}\"'.format(output_file))
+    os.system('echo "#include <TargetConditionals.h>\n\n" >>  \"{0}\"'.format(output_file))
+
+    os.system('echo "// clang-format off" >> \"{0}\"'.format(output_file))
+
+    append_file_as_byte_array_string('gDefaultMetallib', input_file, output_file)
+
+    os.system('echo "// clang-format on" >> \"{0}\"'.format(output_file))
+
+
+if __name__ == '__main__':
+    sys.exit(main())
diff --git a/src/libANGLE/renderer/renderer_utils.h b/src/libANGLE/renderer/renderer_utils.h
index 500d9887460ed3401125d5a7c715b6b233370917..c60c1584b71e561f3837689da5590654b3fa0b7a 100644
--- a/src/libANGLE/renderer/renderer_utils.h
+++ b/src/libANGLE/renderer/renderer_utils.h
@@ -526,6 +526,21 @@ enum class PipelineType
     EnumCount   = 2,
 };
 
+// Return the log of samples.  Assumes |sampleCount| is a power of 2.  The result can be used to
+// index an array based on sample count.
+inline size_t PackSampleCount(int32_t sampleCount)
+{
+    if (sampleCount == 0)
+    {
+        sampleCount = 1;
+    }
+
+    // We currently only support up to 16xMSAA.
+    ASSERT(1 <= sampleCount && sampleCount <= 16);
+    ASSERT(gl::isPow2(sampleCount));
+    return gl::ScanForward(static_cast<uint32_t>(sampleCount));
+}
+
 }  // namespace rx
 
 // MultiDraw macro patterns
diff --git a/src/libANGLE/renderer/vulkan/CLCommandQueueVk.cpp b/src/libANGLE/renderer/vulkan/CLCommandQueueVk.cpp
index 6628ba3766331dcf4acfac3953a49677b8c1578c..4efe8c8a29f0f5ae86150d4a4abff34c5f39f68c 100644
--- a/src/libANGLE/renderer/vulkan/CLCommandQueueVk.cpp
+++ b/src/libANGLE/renderer/vulkan/CLCommandQueueVk.cpp
@@ -775,6 +775,14 @@ angle::Result CLCommandQueueVk::createEvent(CLEventImpl::CreateFunc *createFunc)
             // Save a reference to this event
             mAssociatedEvents.push_back(cl::EventPtr{&eventVk->getFrontendObject()});
 
+            if (mCommandQueue.getProperties().isSet(CL_QUEUE_PROFILING_ENABLE))
+            {
+                if (IsError(mCommandQueue.getImpl<CLCommandQueueVk>().flush()))
+                {
+                    ANGLE_CL_SET_ERROR(CL_OUT_OF_RESOURCES);
+                }
+            }
+
             return CLEventImpl::Ptr(eventVk);
         };
     }
diff --git a/src/libANGLE/renderer/vulkan/CLContextVk.cpp b/src/libANGLE/renderer/vulkan/CLContextVk.cpp
index a1f54c11d823a356932036dbaa736766da781fd6..04c1516b1f022e295107de0fc5a3a43f44510da0 100644
--- a/src/libANGLE/renderer/vulkan/CLContextVk.cpp
+++ b/src/libANGLE/renderer/vulkan/CLContextVk.cpp
@@ -219,6 +219,8 @@ angle::Result CLContextVk::linkProgram(const cl::Program &program,
         }
     }
 
+    programImpl->setBuildStatus(linkDeviceList, CL_BUILD_IN_PROGRESS);
+
     // Perform link
     if (notify)
     {
diff --git a/src/libANGLE/renderer/vulkan/CLEventVk.cpp b/src/libANGLE/renderer/vulkan/CLEventVk.cpp
index 53c5a0e10a386cc8530ec8e652fa6f334e44755a..8c9e05e19a859d67d24ed7012c3b65f7504c5e97 100644
--- a/src/libANGLE/renderer/vulkan/CLEventVk.cpp
+++ b/src/libANGLE/renderer/vulkan/CLEventVk.cpp
@@ -14,8 +14,12 @@ namespace rx
 {
 
 CLEventVk::CLEventVk(const cl::Event &event)
-    : CLEventImpl(event), mStatus(isUserEvent() ? CL_SUBMITTED : CL_QUEUED)
-{}
+    : CLEventImpl(event),
+      mStatus(isUserEvent() ? CL_SUBMITTED : CL_QUEUED),
+      mProfilingTimestamps(ProfilingTimestamps{})
+{
+    ANGLE_CL_IMPL_TRY(setTimestamp(*mStatus));
+}
 
 CLEventVk::~CLEventVk() {}
 
@@ -55,8 +59,46 @@ angle::Result CLEventVk::getProfilingInfo(cl::ProfilingInfo name,
                                           void *value,
                                           size_t *valueSizeRet)
 {
-    UNIMPLEMENTED();
-    ANGLE_CL_RETURN_ERROR(CL_OUT_OF_RESOURCES);
+    cl_ulong valueUlong   = 0;
+    size_t copySize       = 0;
+    const void *copyValue = nullptr;
+
+    auto profilingTimestamps = mProfilingTimestamps.synchronize();
+
+    switch (name)
+    {
+        case cl::ProfilingInfo::CommandQueued:
+            valueUlong = profilingTimestamps->commandQueuedTS;
+            break;
+        case cl::ProfilingInfo::CommandSubmit:
+            valueUlong = profilingTimestamps->commandSubmitTS;
+            break;
+        case cl::ProfilingInfo::CommandStart:
+            valueUlong = profilingTimestamps->commandStartTS;
+            break;
+        case cl::ProfilingInfo::CommandEnd:
+            valueUlong = profilingTimestamps->commandEndTS;
+            break;
+        case cl::ProfilingInfo::CommandComplete:
+            valueUlong = profilingTimestamps->commandCompleteTS;
+            break;
+        default:
+            UNREACHABLE();
+    }
+    copyValue = &valueUlong;
+    copySize  = sizeof(valueUlong);
+
+    if ((value != nullptr) && (copyValue != nullptr))
+    {
+        memcpy(value, copyValue, std::min(valueSize, copySize));
+    }
+
+    if (valueSizeRet != nullptr)
+    {
+        *valueSizeRet = copySize;
+    }
+
+    return angle::Result::Continue;
 }
 
 angle::Result CLEventVk::waitForUserEventStatus()
@@ -82,6 +124,7 @@ angle::Result CLEventVk::setStatusAndExecuteCallback(cl_int status)
 {
     *mStatus = status;
 
+    ANGLE_TRY(setTimestamp(status));
     if (status >= CL_COMPLETE && status < CL_QUEUED && mHaveCallbacks->at(status))
     {
         auto haveCallbacks = mHaveCallbacks.synchronize();
@@ -96,4 +139,46 @@ angle::Result CLEventVk::setStatusAndExecuteCallback(cl_int status)
     return angle::Result::Continue;
 }
 
+angle::Result CLEventVk::setTimestamp(cl_int status)
+{
+    if (!isUserEvent() &&
+        mEvent.getCommandQueue()->getProperties().isSet(CL_QUEUE_PROFILING_ENABLE))
+    {
+        // TODO(aannestrand) Just get current CPU timestamp for now, look into Vulkan GPU device
+        // timestamp query instead and later make CPU timestamp a fallback if GPU timestamp cannot
+        // be queried http://anglebug.com/357902514
+        cl_ulong cpuTS =
+            std::chrono::time_point_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now())
+                .time_since_epoch()
+                .count();
+
+        auto profilingTimestamps = mProfilingTimestamps.synchronize();
+
+        switch (status)
+        {
+            case CL_QUEUED:
+                profilingTimestamps->commandQueuedTS = cpuTS;
+                break;
+            case CL_SUBMITTED:
+                profilingTimestamps->commandSubmitTS = cpuTS;
+                break;
+            case CL_RUNNING:
+                profilingTimestamps->commandStartTS = cpuTS;
+                break;
+            case CL_COMPLETE:
+                profilingTimestamps->commandEndTS = cpuTS;
+
+                // Returns a value equivalent to passing CL_PROFILING_COMMAND_END if the device
+                // associated with event does not support device-side enqueue.
+                // https://registry.khronos.org/OpenCL/specs/3.0-unified/html/OpenCL_API.html#_device_side_enqueue
+                profilingTimestamps->commandCompleteTS = cpuTS;
+                break;
+            default:
+                UNREACHABLE();
+        }
+    }
+
+    return angle::Result::Continue;
+}
+
 }  // namespace rx
diff --git a/src/libANGLE/renderer/vulkan/CLEventVk.h b/src/libANGLE/renderer/vulkan/CLEventVk.h
index e49cc77401d5a4df332e63006d610ea426713c44..6b2dbbda92b3646bc324ef124a95f49937edde43 100644
--- a/src/libANGLE/renderer/vulkan/CLEventVk.h
+++ b/src/libANGLE/renderer/vulkan/CLEventVk.h
@@ -47,12 +47,24 @@ class CLEventVk : public CLEventImpl, public vk::Resource
 
     angle::Result waitForUserEventStatus();
     angle::Result setStatusAndExecuteCallback(cl_int status);
+    angle::Result setTimestamp(cl_int status);
 
   private:
     std::mutex mUserEventMutex;
     angle::SynchronizedValue<cl_int> mStatus;
     std::condition_variable mUserEventCondition;
     angle::SynchronizedValue<cl::EventStatusMap<bool>> mHaveCallbacks;
+
+    // Event profiling timestamps
+    struct ProfilingTimestamps
+    {
+        cl_ulong commandEndTS;
+        cl_ulong commandStartTS;
+        cl_ulong commandQueuedTS;
+        cl_ulong commandSubmitTS;
+        cl_ulong commandCompleteTS;
+    };
+    angle::SynchronizedValue<ProfilingTimestamps> mProfilingTimestamps;
 };
 
 }  // namespace rx
diff --git a/src/libANGLE/renderer/vulkan/CLProgramVk.cpp b/src/libANGLE/renderer/vulkan/CLProgramVk.cpp
index 31a856e241c6d570ae36647420c51d2d0fa87e71..155e852f4fc50dfc0fdfd23f68aff48174108e8e 100644
--- a/src/libANGLE/renderer/vulkan/CLProgramVk.cpp
+++ b/src/libANGLE/renderer/vulkan/CLProgramVk.cpp
@@ -384,6 +384,8 @@ angle::Result CLProgramVk::build(const cl::DevicePtrs &devices,
     BuildType buildType = !mProgram.getSource().empty() ? BuildType::BUILD : BuildType::BINARY;
     const cl::DevicePtrs &devicePtrs = !devices.empty() ? devices : mProgram.getDevices();
 
+    setBuildStatus(devicePtrs, CL_BUILD_IN_PROGRESS);
+
     if (notify)
     {
         std::shared_ptr<angle::WaitableEvent> asyncEvent =
@@ -441,6 +443,8 @@ angle::Result CLProgramVk::compile(const cl::DevicePtrs &devices,
         writeFile(headerFilePath.c_str(), inputHeaderSrc.data(), inputHeaderSrc.size());
     }
 
+    setBuildStatus(devicePtrs, CL_BUILD_IN_PROGRESS);
+
     // Perform compile
     if (notify)
     {
@@ -774,7 +778,11 @@ bool CLProgramVk::buildInternal(const cl::DevicePtrs &devices,
     {
         const cl::RefPointer<cl::Device> &device = devices.at(i);
         DeviceProgramData &deviceProgramData     = mAssociatedDevicePrograms[device->getNative()];
-        deviceProgramData.buildStatus            = CL_BUILD_IN_PROGRESS;
+
+        cl_uint addressBits;
+        ANGLE_CL_IMPL_TRY(
+            device->getInfo(cl::DeviceInfo::AddressBits, sizeof(cl_uint), &addressBits, nullptr));
+        processedOptions += addressBits == 64 ? " -arch=spir64" : " -arch=spir";
 
         cl_uint addressBits;
         ANGLE_CL_IMPL_TRY(
@@ -966,4 +974,16 @@ angle::Result CLProgramVk::allocateDescriptorSet(const vk::DescriptorSetLayout &
     return angle::Result::Continue;
 }
 
+void CLProgramVk::setBuildStatus(const cl::DevicePtrs &devices, cl_build_status status)
+{
+    std::scoped_lock<angle::SimpleMutex> sl(mProgramMutex);
+
+    for (const auto &device : devices)
+    {
+        ASSERT(mAssociatedDevicePrograms.contains(device->getNative()));
+        DeviceProgramData &deviceProgram = mAssociatedDevicePrograms.at(device->getNative());
+        deviceProgram.buildStatus        = status;
+    }
+}
+
 }  // namespace rx
diff --git a/src/libANGLE/renderer/vulkan/CLProgramVk.h b/src/libANGLE/renderer/vulkan/CLProgramVk.h
index da279b2ad5e6c85676163e1d2c89becc27791905..28701b0ce33c0f710fc8f732408b517912784431 100644
--- a/src/libANGLE/renderer/vulkan/CLProgramVk.h
+++ b/src/libANGLE/renderer/vulkan/CLProgramVk.h
@@ -239,6 +239,9 @@ class CLProgramVk : public CLProgramImpl
     angle::Result allocateDescriptorSet(const vk::DescriptorSetLayout &descriptorSetLayout,
                                         VkDescriptorSet *descriptorSetOut);
 
+    // Sets the status for given associated device programs
+    void setBuildStatus(const cl::DevicePtrs &devices, cl_build_status status);
+
   private:
     CLContextVk *mContext;
     std::string mProgramOpts;
diff --git a/src/libANGLE/renderer/vulkan/ContextVk.cpp b/src/libANGLE/renderer/vulkan/ContextVk.cpp
index 9a4828b31126de00a6152886ecd09797fa5e3f66..a404ad2d33bdb4031e7930ca0b93da57030e358c 100644
--- a/src/libANGLE/renderer/vulkan/ContextVk.cpp
+++ b/src/libANGLE/renderer/vulkan/ContextVk.cpp
@@ -5929,6 +5929,10 @@ angle::Result ContextVk::syncState(const gl::Context *context,
                             break;
                         case gl::state::EXTENDED_DIRTY_BIT_BLEND_ADVANCED_COHERENT:
                             break;
+                        case gl::state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE:
+                            // Noop until addition of backend support for
+                            // ANGLE_variable_rasterization_rate_metal extension
+                            break;
                         default:
                             UNREACHABLE();
                     }
diff --git a/src/libANGLE/renderer/vulkan/TextureVk.cpp b/src/libANGLE/renderer/vulkan/TextureVk.cpp
index 47f3321f035593a3929c6194d44cd982d2e3e1d6..05c8dd544b65475ed0250aa9cc64cae0717527e1 100644
--- a/src/libANGLE/renderer/vulkan/TextureVk.cpp
+++ b/src/libANGLE/renderer/vulkan/TextureVk.cpp
@@ -17,6 +17,7 @@
 #include "libANGLE/Image.h"
 #include "libANGLE/MemoryObject.h"
 #include "libANGLE/Surface.h"
+#include "libANGLE/renderer/renderer_utils.h"
 #include "libANGLE/renderer/vulkan/ContextVk.h"
 #include "libANGLE/renderer/vulkan/FramebufferVk.h"
 #include "libANGLE/renderer/vulkan/ImageVk.h"
diff --git a/src/libANGLE/renderer/vulkan/vk_renderer.cpp b/src/libANGLE/renderer/vulkan/vk_renderer.cpp
index 419425e81324e19143abe00ffbd83eccdf0e3fb8..66c3d7b5b7482c87502ec81ff4dc1f3a547847d8 100644
--- a/src/libANGLE/renderer/vulkan/vk_renderer.cpp
+++ b/src/libANGLE/renderer/vulkan/vk_renderer.cpp
@@ -1027,7 +1027,6 @@ void ComputePipelineCacheVkChunkKey(VkPhysicalDeviceProperties physicalDevicePro
 
 void CompressAndStorePipelineCacheVk(VkPhysicalDeviceProperties physicalDeviceProperties,
                                      vk::GlobalOps *globalOps,
-                                     ContextVk *contextVk,
                                      const std::vector<uint8_t> &cacheData,
                                      const size_t maxTotalSize)
 {
@@ -1035,10 +1034,15 @@ void CompressAndStorePipelineCacheVk(VkPhysicalDeviceProperties physicalDevicePr
     // cache, the largest total size of blob cache is only 2M in android now, so there is no use to
     // handle big pipeline cache when android will reject it finally.
     if (cacheData.size() >= maxTotalSize)
+    {
+        static bool warned = false;
+        if (!warned)
         {
             // TODO: handle the big pipeline cache. http://anglebug.com/42263322
-        ANGLE_PERF_WARNING(contextVk->getDebug(), GL_DEBUG_SEVERITY_LOW,
-                           "Skip syncing pipeline cache data when it's larger than maxTotalSize.");
+            WARN() << "Skip syncing pipeline cache data when it's larger than maxTotalSize. "
+                      "(this message will no longer repeat)";
+            warned = true;
+        }
         return;
     }
 
@@ -1047,8 +1051,7 @@ void CompressAndStorePipelineCacheVk(VkPhysicalDeviceProperties physicalDevicePr
 
     if (!angle::CompressBlob(cacheData.size(), cacheData.data(), &compressedData))
     {
-        ANGLE_PERF_WARNING(contextVk->getDebug(), GL_DEBUG_SEVERITY_LOW,
-                           "Skip syncing pipeline cache data as it failed compression.");
+        WARN() << "Skip syncing pipeline cache data as it failed compression.";
         return;
     }
 
@@ -1067,7 +1070,7 @@ void CompressAndStorePipelineCacheVk(VkPhysicalDeviceProperties physicalDevicePr
     uint32_t compressedDataCRC = 0;
     if (kEnableCRCForPipelineCache)
     {
-        compressedDataCRC = angle::GenerateCrc(compressedData.data(), compressedData.size());
+        compressedDataCRC = angle::GenerateCRC32(compressedData.data(), compressedData.size());
     }
 
     for (size_t chunkIndex = 0; chunkIndex < numChunks; ++chunkIndex)
@@ -1080,8 +1083,7 @@ void CompressAndStorePipelineCacheVk(VkPhysicalDeviceProperties physicalDevicePr
         angle::MemoryBuffer keyData;
         if (!keyData.resize(sizeof(CacheDataHeader) + chunkSize))
         {
-            ANGLE_PERF_WARNING(contextVk->getDebug(), GL_DEBUG_SEVERITY_LOW,
-                               "Skip syncing pipeline cache data due to out of memory.");
+            WARN() << "Skip syncing pipeline cache data due to out of memory.";
             return;
         }
 
@@ -1108,11 +1110,11 @@ class CompressAndStorePipelineCacheTask : public angle::Closure
 {
   public:
     CompressAndStorePipelineCacheTask(vk::GlobalOps *globalOps,
-                                      ContextVk *contextVk,
+                                      vk::Renderer *renderer,
                                       std::vector<uint8_t> &&cacheData,
                                       size_t kMaxTotalSize)
         : mGlobalOps(globalOps),
-          mContextVk(contextVk),
+          mRenderer(renderer),
           mCacheData(std::move(cacheData)),
           mMaxTotalSize(kMaxTotalSize)
     {}
@@ -1120,13 +1122,13 @@ class CompressAndStorePipelineCacheTask : public angle::Closure
     void operator()() override
     {
         ANGLE_TRACE_EVENT0("gpu.angle", "CompressAndStorePipelineCacheVk");
-        CompressAndStorePipelineCacheVk(mContextVk->getRenderer()->getPhysicalDeviceProperties(),
-                                        mGlobalOps, mContextVk, mCacheData, mMaxTotalSize);
+        CompressAndStorePipelineCacheVk(mRenderer->getPhysicalDeviceProperties(), mGlobalOps,
+                                        mCacheData, mMaxTotalSize);
     }
 
   private:
     vk::GlobalOps *mGlobalOps;
-    ContextVk *mContextVk;
+    vk::Renderer *mRenderer;
     std::vector<uint8_t> mCacheData;
     size_t mMaxTotalSize;
 };
@@ -1245,7 +1247,7 @@ angle::Result GetAndDecompressPipelineCacheVk(VkPhysicalDeviceProperties physica
     if (kEnableCRCForPipelineCache)
     {
         uint32_t computedCompressedDataCRC =
-            angle::GenerateCrc(compressedData.data(), compressedSize);
+            angle::GenerateCRC32(compressedData.data(), compressedSize);
         if (computedCompressedDataCRC != compressedDataCRC)
         {
             if (compressedDataCRC == 0)
@@ -1945,14 +1947,14 @@ angle::Result Renderer::initialize(vk::Context *context,
     const VkBool32 setting_check_shaders = IsAndroid() ? VK_FALSE : VK_TRUE;
     // http://b/316013423 Disable QueueSubmit Synchronization Validation. Lots of failures and some
     // test timeout due to https://github.com/KhronosGroup/Vulkan-ValidationLayers/issues/7285
-    const VkBool32 setting_sync_queue_submit = VK_FALSE;
+    const VkBool32 setting_syncval_submit_time_validation = VK_FALSE;
     const VkLayerSettingEXT layerSettings[]               = {
         {name, "validate_core", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &setting_validate_core},
         {name, "validate_sync", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &setting_validate_sync},
         {name, "thread_safety", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &setting_thread_safety},
         {name, "check_shaders", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &setting_check_shaders},
-        {name, "sync_queue_submit", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1,
-          &setting_sync_queue_submit},
+        {name, "syncval_submit_time_validation", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1,
+                       &setting_syncval_submit_time_validation},
     };
     VkLayerSettingsCreateInfoEXT layerSettingsCreateInfo = {
         VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT, nullptr,
@@ -3700,8 +3702,9 @@ angle::Result Renderer::createDeviceAndQueue(vk::Context *context, uint32_t queu
     mDefaultUniformBufferSize = std::min(
         mDefaultUniformBufferSize, getPhysicalDeviceProperties().limits.maxUniformBufferRange);
 
-    // Initialize the vulkan pipeline cache.
-    ANGLE_TRY(ensurePipelineCacheInitialized(context));
+    // Vulkan pipeline cache will be initialized lazily in ensurePipelineCacheInitialized() method.
+    ASSERT(!mPipelineCacheInitialized);
+    ASSERT(!mPipelineCache.valid());
 
     // Track the set of supported pipeline stages.  This is used when issuing image layout
     // transitions that cover many stages (such as AllGraphicsReadOnly) to mask out unsupported
@@ -5441,6 +5444,11 @@ angle::Result Renderer::syncPipelineCacheVk(vk::Context *context,
                                             vk::GlobalOps *globalOps,
                                             const gl::Context *contextGL)
 {
+    // Skip syncing until pipeline cache is initialized.
+    if (!mPipelineCacheInitialized)
+    {
+        return angle::Result::Continue;
+    }
     ASSERT(mPipelineCache.valid());
 
     if (!mFeatures.syncMonolithicPipelinesToBlobCache.enabled)
@@ -5455,6 +5463,17 @@ angle::Result Renderer::syncPipelineCacheVk(vk::Context *context,
 
     mPipelineCacheVkUpdateTimeout = kPipelineCacheVkUpdatePeriod;
 
+    ContextVk *contextVk = vk::GetImpl(contextGL);
+
+    // Use worker thread pool to complete compression.
+    // If the last task hasn't been finished, skip the syncing.
+    if (mCompressEvent && !mCompressEvent->isReady())
+    {
+        ANGLE_PERF_WARNING(contextVk->getDebug(), GL_DEBUG_SEVERITY_LOW,
+                           "Skip syncing pipeline cache data when the last task is not ready.");
+        return angle::Result::Continue;
+    }
+
     size_t pipelineCacheSize = 0;
     ANGLE_TRY(getPipelineCacheSize(context, &pipelineCacheSize));
     if (pipelineCacheSize <= mPipelineCacheSizeAtLastSync)
@@ -5472,17 +5491,6 @@ angle::Result Renderer::syncPipelineCacheVk(vk::Context *context,
         return angle::Result::Continue;
     }
 
-    ContextVk *contextVk = vk::GetImpl(contextGL);
-
-    // Use worker thread pool to complete compression.
-    // If the last task hasn't been finished, skip the syncing.
-    if (mCompressEvent && !mCompressEvent->isReady())
-    {
-        ANGLE_PERF_WARNING(contextVk->getDebug(), GL_DEBUG_SEVERITY_LOW,
-                           "Skip syncing pipeline cache data when the last task is not ready.");
-        return angle::Result::Continue;
-    }
-
     std::vector<uint8_t> pipelineCacheData(pipelineCacheSize);
 
     size_t oldPipelineCacheSize = pipelineCacheSize;
@@ -5525,15 +5533,15 @@ angle::Result Renderer::syncPipelineCacheVk(vk::Context *context,
         // Create task to compress.
         mCompressEvent = contextGL->getWorkerThreadPool()->postWorkerTask(
             std::make_shared<CompressAndStorePipelineCacheTask>(
-                globalOps, contextVk, std::move(pipelineCacheData), kMaxTotalSize));
+                globalOps, this, std::move(pipelineCacheData), kMaxTotalSize));
     }
     else
     {
         // If enableAsyncPipelineCacheCompression is disabled, to avoid the risk, set kMaxTotalSize
         // to 64k.
         constexpr size_t kMaxTotalSize = 64 * 1024;
-        CompressAndStorePipelineCacheVk(mPhysicalDeviceProperties, globalOps, contextVk,
-                                        pipelineCacheData, kMaxTotalSize);
+        CompressAndStorePipelineCacheVk(mPhysicalDeviceProperties, globalOps, pipelineCacheData,
+                                        kMaxTotalSize);
     }
 
     return angle::Result::Continue;
diff --git a/src/libANGLE/renderer/vulkan/vk_utils.cpp b/src/libANGLE/renderer/vulkan/vk_utils.cpp
index 97633853f22c09df159e41a29a5fa496d88ffc80..f7a6b08fd94a02cfbf07c5aedc2940d02d6f24e4 100644
--- a/src/libANGLE/renderer/vulkan/vk_utils.cpp
+++ b/src/libANGLE/renderer/vulkan/vk_utils.cpp
@@ -1232,21 +1232,6 @@ GLenum CalculateGenerateMipmapFilter(ContextVk *contextVk, angle::FormatID forma
     return formatSupportsLinearFiltering && !hintFastest ? GL_LINEAR : GL_NEAREST;
 }
 
-// Return the log of samples.  Assumes |sampleCount| is a power of 2.  The result can be used to
-// index an array based on sample count.  See for example TextureVk::PerSampleCountArray.
-size_t PackSampleCount(GLint sampleCount)
-{
-    if (sampleCount == 0)
-    {
-        sampleCount = 1;
-    }
-
-    // We currently only support up to 16xMSAA.
-    ASSERT(sampleCount <= VK_SAMPLE_COUNT_16_BIT);
-    ASSERT(gl::isPow2(sampleCount));
-    return gl::ScanForward(static_cast<uint32_t>(sampleCount));
-}
-
 namespace gl_vk
 {
 
diff --git a/src/libANGLE/renderer/vulkan/vk_utils.h b/src/libANGLE/renderer/vulkan/vk_utils.h
index e9982905334a891c0efdd52d4eb74d953cde1355..9f327efb08feedd5c69487f3c9d5f49dcc2e8614 100644
--- a/src/libANGLE/renderer/vulkan/vk_utils.h
+++ b/src/libANGLE/renderer/vulkan/vk_utils.h
@@ -1256,7 +1256,6 @@ void InitGetMemoryRequirements2KHRFunctionsFromCore();
 void InitBindMemory2KHRFunctionsFromCore();
 
 GLenum CalculateGenerateMipmapFilter(ContextVk *contextVk, angle::FormatID formatID);
-size_t PackSampleCount(GLint sampleCount);
 
 namespace gl_vk
 {
diff --git a/src/libANGLE/renderer/wgpu/ContextWgpu.cpp b/src/libANGLE/renderer/wgpu/ContextWgpu.cpp
index 4e02a4ca398767cf0a23c3abc575795daa561df4..e62be62093dc33c60200f00084088608d3aa21c9 100644
--- a/src/libANGLE/renderer/wgpu/ContextWgpu.cpp
+++ b/src/libANGLE/renderer/wgpu/ContextWgpu.cpp
@@ -562,20 +562,64 @@ angle::Result ContextWgpu::syncState(const gl::Context *context,
             case gl::state::DIRTY_BIT_DEPTH_TEST_ENABLED:
                 break;
             case gl::state::DIRTY_BIT_DEPTH_FUNC:
+                if (mRenderPipelineDesc.setDepthFunc(
+                        gl_wgpu::getCompareFunc(glState.getDepthStencilState().depthFunc)))
+                {
+                    invalidateCurrentRenderPipeline();
+                }
                 break;
             case gl::state::DIRTY_BIT_DEPTH_MASK:
                 break;
             case gl::state::DIRTY_BIT_STENCIL_TEST_ENABLED:
                 break;
             case gl::state::DIRTY_BIT_STENCIL_FUNCS_FRONT:
+                if (mRenderPipelineDesc.setStencilFrontFunc(
+                        gl_wgpu::getCompareFunc(glState.getDepthStencilState().stencilFunc)))
+                {
+                    invalidateCurrentRenderPipeline();
+                }
                 break;
             case gl::state::DIRTY_BIT_STENCIL_FUNCS_BACK:
+                if (mRenderPipelineDesc.setStencilBackFunc(
+                        gl_wgpu::getCompareFunc(glState.getDepthStencilState().stencilBackFunc)))
+                {
+                    invalidateCurrentRenderPipeline();
+                }
                 break;
             case gl::state::DIRTY_BIT_STENCIL_OPS_FRONT:
+            {
+                wgpu::StencilOperation failOp =
+                    gl_wgpu::getStencilOp(glState.getDepthStencilState().stencilFail);
+                wgpu::StencilOperation depthFailOp =
+                    gl_wgpu::getStencilOp(glState.getDepthStencilState().stencilPassDepthFail);
+                wgpu::StencilOperation passOp =
+                    gl_wgpu::getStencilOp(glState.getDepthStencilState().stencilPassDepthPass);
+                if (mRenderPipelineDesc.setStencilFrontOps(failOp, depthFailOp, passOp))
+                {
+                    invalidateCurrentRenderPipeline();
+                }
+            }
                 break;
             case gl::state::DIRTY_BIT_STENCIL_OPS_BACK:
+            {
+                wgpu::StencilOperation failOp =
+                    gl_wgpu::getStencilOp(glState.getDepthStencilState().stencilBackFail);
+                wgpu::StencilOperation depthFailOp =
+                    gl_wgpu::getStencilOp(glState.getDepthStencilState().stencilBackPassDepthFail);
+                wgpu::StencilOperation passOp =
+                    gl_wgpu::getStencilOp(glState.getDepthStencilState().stencilBackPassDepthPass);
+                if (mRenderPipelineDesc.setStencilBackOps(failOp, depthFailOp, passOp))
+                {
+                    invalidateCurrentRenderPipeline();
+                }
+            }
                 break;
             case gl::state::DIRTY_BIT_STENCIL_WRITEMASK_FRONT:
+                if (mRenderPipelineDesc.setStencilWriteMask(
+                        glState.getDepthStencilState().stencilWritemask))
+                {
+                    invalidateCurrentRenderPipeline();
+                }
                 break;
             case gl::state::DIRTY_BIT_STENCIL_WRITEMASK_BACK:
                 break;
diff --git a/src/libANGLE/renderer/wgpu/DisplayWgpu.cpp b/src/libANGLE/renderer/wgpu/DisplayWgpu.cpp
index 142a5254fff82ed6bd251e3d8a533cae9e4eb85d..161f92b4127cfbf052bbae0b968b38e6f619a2d4 100644
--- a/src/libANGLE/renderer/wgpu/DisplayWgpu.cpp
+++ b/src/libANGLE/renderer/wgpu/DisplayWgpu.cpp
@@ -58,7 +58,7 @@ egl::Error DisplayWgpu::makeCurrent(egl::Display *display,
 egl::ConfigSet DisplayWgpu::generateConfigs()
 {
     egl::Config config;
-    config.renderTargetFormat    = GL_RGBA8;
+    config.renderTargetFormat    = GL_BGRA8_EXT;
     config.depthStencilFormat    = GL_DEPTH24_STENCIL8;
     config.bufferSize            = 32;
     config.redSize               = 8;
diff --git a/src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp b/src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp
index 0a55ffad5bac0172228631610b0692e0e939809a..08c81160df8116094370ce02e5ee8f497203488d 100644
--- a/src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp
+++ b/src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp
@@ -424,12 +424,12 @@ angle::Result FramebufferWgpu::flushOneColorAttachmentUpdate(const gl::Context *
     {
         if (deferClears)
         {
-            ANGLE_TRY(drawRenderTarget->getImage()->flushStagedUpdates(
-                contextWgpu, &mDeferredClears, colorIndexGL));
+            ANGLE_TRY(
+                drawRenderTarget->flushStagedUpdates(contextWgpu, &mDeferredClears, colorIndexGL));
         }
         else
         {
-            ANGLE_TRY(drawRenderTarget->getImage()->flushStagedUpdates(contextWgpu));
+            ANGLE_TRY(drawRenderTarget->flushStagedUpdates(contextWgpu));
         }
     }
 
@@ -438,7 +438,7 @@ angle::Result FramebufferWgpu::flushOneColorAttachmentUpdate(const gl::Context *
         readRenderTarget = mRenderTargetCache.getColorRead(mState);
         if (readRenderTarget && readRenderTarget != drawRenderTarget)
         {
-            ANGLE_TRY(readRenderTarget->getImage()->flushStagedUpdates(contextWgpu));
+            ANGLE_TRY(readRenderTarget->flushStagedUpdates(contextWgpu));
         }
     }
 
diff --git a/src/libANGLE/renderer/wgpu/RenderTargetWgpu.cpp b/src/libANGLE/renderer/wgpu/RenderTargetWgpu.cpp
index 04f4f673c8e23eee7b128a21bdf9f9363bf37d4a..43ac5dda7151828f94590ceca76b0a0fef01a5af 100644
--- a/src/libANGLE/renderer/wgpu/RenderTargetWgpu.cpp
+++ b/src/libANGLE/renderer/wgpu/RenderTargetWgpu.cpp
@@ -46,4 +46,14 @@ void RenderTargetWgpu::reset()
     mLayerIndex  = 0;
     mFormat      = nullptr;
 }
+
+angle::Result RenderTargetWgpu::flushStagedUpdates(ContextWgpu *contextWgpu,
+                                                   webgpu::ClearValuesArray *deferredClears,
+                                                   uint32_t deferredClearIndex)
+{
+    gl::LevelIndex targetLevel = mImage->toGlLevel(mLevelIndex);
+    ANGLE_TRY(mImage->flushSingleLevelUpdates(contextWgpu, targetLevel, deferredClears,
+                                              deferredClearIndex));
+    return angle::Result::Continue;
+}
 }  // namespace rx
diff --git a/src/libANGLE/renderer/wgpu/RenderTargetWgpu.h b/src/libANGLE/renderer/wgpu/RenderTargetWgpu.h
index 356d874318c1db9b91562942d1ebb4eec5cfbd1c..518f5734b6919a8b20e20f17712f48e887c33899 100644
--- a/src/libANGLE/renderer/wgpu/RenderTargetWgpu.h
+++ b/src/libANGLE/renderer/wgpu/RenderTargetWgpu.h
@@ -35,6 +35,10 @@ class RenderTargetWgpu final : public FramebufferAttachmentRenderTarget
              const wgpu::TextureFormat &format);
     void reset();
 
+    angle::Result flushStagedUpdates(ContextWgpu *contextWgpu,
+                                     webgpu::ClearValuesArray *deferredClears = nullptr,
+                                     uint32_t deferredClearIndex              = 0);
+
     wgpu::TextureView getTextureView() { return mTextureView; }
     webgpu::ImageHelper *getImage() { return mImage; }
     webgpu::LevelIndex getLevelIndex() const { return mLevelIndex; }
diff --git a/src/libANGLE/renderer/wgpu/SurfaceWgpu.cpp b/src/libANGLE/renderer/wgpu/SurfaceWgpu.cpp
index 5e2b50b81797cf45345b9b2af76d7641ebf8427a..1022aa5f59614bcb06f73daa0e8ed6e291a08776 100644
--- a/src/libANGLE/renderer/wgpu/SurfaceWgpu.cpp
+++ b/src/libANGLE/renderer/wgpu/SurfaceWgpu.cpp
@@ -272,11 +272,11 @@ angle::Result WindowSurfaceWgpu::initializeImpl(const egl::Display *display)
 
     gl::Extents size;
     ANGLE_TRY(getCurrentWindowSize(display, &size));
-
+    const webgpu::Format &webgpuFormat      = displayWgpu->getFormat(config->renderTargetFormat);
     wgpu::SwapChainDescriptor swapChainDesc = {};
     swapChainDesc.usage = wgpu::TextureUsage::RenderAttachment | wgpu::TextureUsage::CopySrc |
                           wgpu::TextureUsage::CopyDst;
-    swapChainDesc.format                    = wgpu::TextureFormat::BGRA8Unorm;
+    swapChainDesc.format                    = webgpuFormat.getActualWgpuTextureFormat();
     swapChainDesc.width                     = size.width;
     swapChainDesc.height                    = size.height;
     swapChainDesc.presentMode               = wgpu::PresentMode::Mailbox;
@@ -309,11 +309,13 @@ angle::Result WindowSurfaceWgpu::updateCurrentTexture(const egl::Display *displa
     wgpu::Texture texture  = mSwapChain.GetCurrentTexture();
     wgpu::TextureView view = mSwapChain.GetCurrentTextureView();
 
-    ANGLE_TRY(mColorAttachment.texture.initExternal(angle::FormatID::B8G8R8A8_UNORM,
-                                                    angle::FormatID::B8G8R8A8_UNORM, texture));
+    wgpu::TextureFormat wgpuFormat = texture.GetFormat();
+    angle::FormatID angleFormat    = webgpu::GetFormatIDFromWgpuTextureFormat(wgpuFormat);
+
+    ANGLE_TRY(mColorAttachment.texture.initExternal(angleFormat, angleFormat, texture));
 
     mColorAttachment.renderTarget.set(&mColorAttachment.texture, view, webgpu::LevelIndex(0), 0,
-                                      mColorAttachment.texture.toWgpuTextureFormat());
+                                      wgpuFormat);
 
     return angle::Result::Continue;
 }
diff --git a/src/libANGLE/renderer/wgpu/wgpu_helpers.cpp b/src/libANGLE/renderer/wgpu/wgpu_helpers.cpp
index dc7d14dd1df67bc1093825bb0e809f8ae2e9f388..a0a45ff8cb5d47acdd465a597d23c39b47773bdc 100644
--- a/src/libANGLE/renderer/wgpu/wgpu_helpers.cpp
+++ b/src/libANGLE/renderer/wgpu/wgpu_helpers.cpp
@@ -94,11 +94,27 @@ angle::Result ImageHelper::initExternal(angle::FormatID intendedFormatID,
     return angle::Result::Continue;
 }
 
-angle::Result ImageHelper::flushStagedUpdates(ContextWgpu *contextWgpu,
+angle::Result ImageHelper::flushStagedUpdates(ContextWgpu *contextWgpu)
+{
+    if (mSubresourceQueue.empty())
+    {
+        return angle::Result::Continue;
+    }
+    for (gl::LevelIndex currentMipLevel = mFirstAllocatedLevel;
+         currentMipLevel < mFirstAllocatedLevel + getLevelCount(); ++currentMipLevel)
+    {
+        ANGLE_TRY(flushSingleLevelUpdates(contextWgpu, currentMipLevel));
+    }
+    return angle::Result::Continue;
+}
+
+angle::Result ImageHelper::flushSingleLevelUpdates(ContextWgpu *contextWgpu,
+                                                   gl::LevelIndex levelGL,
                                                    ClearValuesArray *deferredClears,
                                                    uint32_t deferredClearIndex)
 {
-    if (mSubresourceQueue.empty())
+    std::vector<SubresourceUpdate> *currentLevelQueue = getLevelUpdates(levelGL);
+    if (!currentLevelQueue || currentLevelQueue->empty())
     {
         return angle::Result::Continue;
     }
@@ -108,7 +124,9 @@ angle::Result ImageHelper::flushStagedUpdates(ContextWgpu *contextWgpu,
     wgpu::ImageCopyTexture dst;
     dst.texture = mTexture;
     std::vector<wgpu::RenderPassColorAttachment> colorAttachments;
-    for (const SubresourceUpdate &srcUpdate : mSubresourceQueue)
+    wgpu::TextureView textureView;
+    ANGLE_TRY(createTextureView(levelGL, 0, textureView));
+    for (const SubresourceUpdate &srcUpdate : *currentLevelQueue)
     {
         if (!isTextureLevelInAllocatedImage(srcUpdate.targetLevel))
         {
@@ -127,10 +145,6 @@ angle::Result ImageHelper::flushStagedUpdates(ContextWgpu *contextWgpu,
                 }
                 else
                 {
-
-                    wgpu::TextureView textureView;
-                    ANGLE_TRY(createTextureView(srcUpdate.targetLevel, 0, textureView));
-
                     colorAttachments.push_back(
                         CreateNewClearColorAttachment(srcUpdate.clearData.clearColor,
                                                       srcUpdate.clearData.depthSlice, textureView));
@@ -148,7 +162,7 @@ angle::Result ImageHelper::flushStagedUpdates(ContextWgpu *contextWgpu,
     wgpu::CommandBuffer commandBuffer = encoder.Finish();
     queue.Submit(1, &commandBuffer);
     encoder = nullptr;
-    mSubresourceQueue.clear();
+    currentLevelQueue->clear();
 
     return angle::Result::Continue;
 }
@@ -206,23 +220,24 @@ angle::Result ImageHelper::stageTextureUpload(ContextWgpu *contextWgpu,
     wgpu::ImageCopyBuffer imageCopyBuffer;
     imageCopyBuffer.layout = textureDataLayout;
     imageCopyBuffer.buffer = bufferHelper.getBuffer();
-    SubresourceUpdate subresourceUpdate(UpdateSource::Texture, levelGL, imageCopyBuffer);
-    mSubresourceQueue.emplace_back(std::move(subresourceUpdate));
+    appendSubresourceUpdate(levelGL,
+                            SubresourceUpdate(UpdateSource::Texture, levelGL, imageCopyBuffer));
     return angle::Result::Continue;
 }
 
 void ImageHelper::stageClear(gl::LevelIndex targetLevel, ClearValues clearValues)
 {
-    SubresourceUpdate subresourceUpdate(UpdateSource::Clear, targetLevel, clearValues);
-    mSubresourceQueue.emplace_back(std::move(subresourceUpdate));
+    appendSubresourceUpdate(targetLevel,
+                            SubresourceUpdate(UpdateSource::Clear, targetLevel, clearValues));
 }
 
 void ImageHelper::removeStagedUpdates(gl::LevelIndex levelToRemove)
 {
-    std::erase_if(mSubresourceQueue, [levelToRemove](const SubresourceUpdate &subUpdate) {
-        return subUpdate.updateSource == UpdateSource::Texture &&
-               subUpdate.targetLevel == levelToRemove;
-    });
+    std::vector<SubresourceUpdate> *updateToClear = getLevelUpdates(levelToRemove);
+    if (updateToClear)
+    {
+        updateToClear->clear();
+    }
 }
 
 void ImageHelper::resetImage()
@@ -366,6 +381,22 @@ bool ImageHelper::isTextureLevelInAllocatedImage(gl::LevelIndex textureLevel)
     return wgpuTextureLevel < LevelIndex(mTextureDescriptor.mipLevelCount);
 }
 
+void ImageHelper::appendSubresourceUpdate(gl::LevelIndex level, SubresourceUpdate &&update)
+{
+    if (mSubresourceQueue.size() <= static_cast<size_t>(level.get()))
+    {
+        mSubresourceQueue.resize(level.get() + 1);
+    }
+    mSubresourceQueue[level.get()].emplace_back(std::move(update));
+}
+
+std::vector<SubresourceUpdate> *ImageHelper::getLevelUpdates(gl::LevelIndex level)
+{
+    return static_cast<size_t>(level.get()) < mSubresourceQueue.size()
+               ? &mSubresourceQueue[level.get()]
+               : nullptr;
+}
+
 BufferHelper::BufferHelper() {}
 
 BufferHelper::~BufferHelper() {}
diff --git a/src/libANGLE/renderer/wgpu/wgpu_helpers.h b/src/libANGLE/renderer/wgpu/wgpu_helpers.h
index ca0fea4dfaa6f56e91cd8c77dd5a9a9d7149ba63..cd301c09eff779f91a0e379edeccb21e63cbe9a1 100644
--- a/src/libANGLE/renderer/wgpu/wgpu_helpers.h
+++ b/src/libANGLE/renderer/wgpu/wgpu_helpers.h
@@ -82,7 +82,9 @@ class ImageHelper
                                angle::FormatID actualFormatID,
                                wgpu::Texture externalTexture);
 
-    angle::Result flushStagedUpdates(ContextWgpu *contextWgpu,
+    angle::Result flushStagedUpdates(ContextWgpu *contextWgpu);
+    angle::Result flushSingleLevelUpdates(ContextWgpu *contextWgpu,
+                                          gl::LevelIndex levelGL,
                                           ClearValuesArray *deferredClears = nullptr,
                                           uint32_t deferredClearIndex      = 0);
 
@@ -144,6 +146,9 @@ class ImageHelper
     bool isInitialized() { return mInitialized; }
 
   private:
+    void appendSubresourceUpdate(gl::LevelIndex level, SubresourceUpdate &&update);
+    std::vector<SubresourceUpdate> *getLevelUpdates(gl::LevelIndex level);
+
     wgpu::Texture mTexture;
     wgpu::TextureDescriptor mTextureDescriptor = {};
     bool mInitialized                          = false;
@@ -152,7 +157,7 @@ class ImageHelper
     angle::FormatID mIntendedFormatID;
     angle::FormatID mActualFormatID;
 
-    std::vector<SubresourceUpdate> mSubresourceQueue;
+    std::vector<std::vector<SubresourceUpdate>> mSubresourceQueue;
 };
 struct BufferMapState
 {
diff --git a/src/libANGLE/renderer/wgpu/wgpu_pipeline_state.cpp b/src/libANGLE/renderer/wgpu/wgpu_pipeline_state.cpp
index 2ff3ed0814590d70b4e2e0622727f5ca31eda4c8..3b87a1d3d40e5b19eb7f838121fe56cd2925d3f9 100644
--- a/src/libANGLE/renderer/wgpu/wgpu_pipeline_state.cpp
+++ b/src/libANGLE/renderer/wgpu/wgpu_pipeline_state.cpp
@@ -130,6 +130,89 @@ bool RenderPipelineDesc::setDepthStencilAttachmentFormat(wgpu::TextureFormat for
     return true;
 }
 
+bool RenderPipelineDesc::setDepthFunc(wgpu::CompareFunction compareFunc)
+{
+    if (mDepthStencilState.depthCompare == static_cast<uint8_t>(compareFunc))
+    {
+        return false;
+    }
+    SetBitField(mDepthStencilState.depthCompare, compareFunc);
+    return true;
+}
+
+bool RenderPipelineDesc::setStencilFrontFunc(wgpu::CompareFunction compareFunc)
+{
+    if (mDepthStencilState.stencilFrontCompare == static_cast<uint8_t>(compareFunc))
+    {
+        return false;
+    }
+    SetBitField(mDepthStencilState.stencilFrontCompare, compareFunc);
+    return true;
+}
+
+bool RenderPipelineDesc::setStencilFrontOps(wgpu::StencilOperation failOp,
+                                            wgpu::StencilOperation depthFailOp,
+                                            wgpu::StencilOperation passOp)
+{
+    if (mDepthStencilState.stencilFrontFailOp == static_cast<uint8_t>(failOp) &&
+        mDepthStencilState.stencilFrontDepthFailOp == static_cast<uint8_t>(depthFailOp) &&
+        mDepthStencilState.stencilFrontPassOp == static_cast<uint8_t>(passOp))
+    {
+        return false;
+    }
+    SetBitField(mDepthStencilState.stencilFrontFailOp, failOp);
+    SetBitField(mDepthStencilState.stencilFrontDepthFailOp, depthFailOp);
+    SetBitField(mDepthStencilState.stencilFrontPassOp, passOp);
+    return true;
+}
+
+bool RenderPipelineDesc::setStencilBackFunc(wgpu::CompareFunction compareFunc)
+{
+    if (mDepthStencilState.stencilBackCompare == static_cast<uint8_t>(compareFunc))
+    {
+        return false;
+    }
+    SetBitField(mDepthStencilState.stencilBackCompare, compareFunc);
+    return true;
+}
+
+bool RenderPipelineDesc::setStencilBackOps(wgpu::StencilOperation failOp,
+                                           wgpu::StencilOperation depthFailOp,
+                                           wgpu::StencilOperation passOp)
+{
+    if (mDepthStencilState.stencilBackFailOp == static_cast<uint8_t>(failOp) &&
+        mDepthStencilState.stencilBackDepthFailOp == static_cast<uint8_t>(depthFailOp) &&
+        mDepthStencilState.stencilBackPassOp == static_cast<uint8_t>(passOp))
+    {
+        return false;
+    }
+    SetBitField(mDepthStencilState.stencilBackFailOp, failOp);
+    SetBitField(mDepthStencilState.stencilBackDepthFailOp, depthFailOp);
+    SetBitField(mDepthStencilState.stencilBackPassOp, passOp);
+    return true;
+}
+
+bool RenderPipelineDesc::setStencilReadMask(uint8_t readMask)
+{
+
+    if (mDepthStencilState.stencilReadMask == readMask)
+    {
+        return false;
+    }
+    mDepthStencilState.stencilReadMask = readMask;
+    return true;
+}
+
+bool RenderPipelineDesc::setStencilWriteMask(uint8_t writeMask)
+{
+    if (mDepthStencilState.stencilWriteMask == writeMask)
+    {
+        return false;
+    }
+    mDepthStencilState.stencilWriteMask = writeMask;
+    return true;
+}
+
 size_t RenderPipelineDesc::hash() const
 {
     return angle::ComputeGenericHash(this, sizeof(*this));
diff --git a/src/libANGLE/renderer/wgpu/wgpu_pipeline_state.h b/src/libANGLE/renderer/wgpu/wgpu_pipeline_state.h
index 48025bf88ca3b8abf5554afd78c3b75adb09559e..ea42ba5b59e09fb60477854da0748d88e357641f 100644
--- a/src/libANGLE/renderer/wgpu/wgpu_pipeline_state.h
+++ b/src/libANGLE/renderer/wgpu/wgpu_pipeline_state.h
@@ -135,6 +135,18 @@ class RenderPipelineDesc final
 
     bool setColorAttachmentFormat(size_t colorIndex, wgpu::TextureFormat format);
     bool setDepthStencilAttachmentFormat(wgpu::TextureFormat format);
+    bool setDepthFunc(wgpu::CompareFunction compareFunc);
+    bool setStencilFrontFunc(wgpu::CompareFunction compareFunc);
+    bool setStencilFrontOps(wgpu::StencilOperation failOp,
+                            wgpu::StencilOperation depthFailOp,
+                            wgpu::StencilOperation passOp);
+    bool setStencilBackFunc(wgpu::CompareFunction compareFunc);
+    bool setStencilBackOps(wgpu::StencilOperation failOp,
+                           wgpu::StencilOperation depthFailOp,
+                           wgpu::StencilOperation passOp);
+
+    bool setStencilReadMask(uint8_t readeMask);
+    bool setStencilWriteMask(uint8_t writeMask);
 
     size_t hash() const;
 
diff --git a/src/libANGLE/renderer/wgpu/wgpu_utils.cpp b/src/libANGLE/renderer/wgpu/wgpu_utils.cpp
index 7da7956293da6366a5a22778d7b74eacc4bba994..224fb0362d598cc50840ffb3818d82727414651d 100644
--- a/src/libANGLE/renderer/wgpu/wgpu_utils.cpp
+++ b/src/libANGLE/renderer/wgpu/wgpu_utils.cpp
@@ -83,70 +83,170 @@ void GenerateCaps(const wgpu::Device &device,
                   egl::DisplayExtensions *eglExtensions,
                   gl::Version *maxSupportedESVersion)
 {
-    wgpu::SupportedLimits limitsWgpu = {};
-    device.GetLimits(&limitsWgpu);
+    // WebGPU does not support separate front/back stencil masks.
+    glLimitations->noSeparateStencilRefsAndMasks = true;
+
+    wgpu::Limits limitsWgpu;
+    {
+        wgpu::SupportedLimits supportedLimits;
+        device.GetLimits(&supportedLimits);
+        limitsWgpu = supportedLimits.limits;
+    }
 
     // OpenGL ES extensions
-    glExtensions->blendEquationAdvancedKHR      = true;
-    glExtensions->blendFuncExtendedEXT          = true;
-    glExtensions->copyCompressedTextureCHROMIUM = true;
-    glExtensions->copyTextureCHROMIUM           = true;
     glExtensions->debugMarkerEXT              = true;
-    glExtensions->drawBuffersIndexedOES         = true;
-    glExtensions->fenceNV                       = true;
-    glExtensions->framebufferBlitANGLE          = true;
-    glExtensions->framebufferBlitNV             = true;
-    glExtensions->instancedArraysANGLE          = true;
-    glExtensions->instancedArraysEXT            = true;
-    glExtensions->mapBufferRangeEXT             = true;
-    glExtensions->mapbufferOES                  = true;
-    glExtensions->pixelBufferObjectNV           = true;
-    glExtensions->textureRectangleANGLE         = true;
     glExtensions->textureUsageANGLE           = true;
     glExtensions->translatedShaderSourceANGLE = true;
     glExtensions->vertexArrayObjectOES        = true;
 
     glExtensions->textureStorageEXT = true;
     glExtensions->rgb8Rgba8OES      = true;
-    glExtensions->textureCompressionDxt1EXT       = true;
-    glExtensions->textureCompressionDxt3ANGLE     = true;
-    glExtensions->textureCompressionDxt5ANGLE     = true;
-    glExtensions->textureCompressionS3tcSrgbEXT   = true;
-    glExtensions->textureCompressionAstcHdrKHR    = true;
-    glExtensions->textureCompressionAstcLdrKHR    = true;
-    glExtensions->textureCompressionAstcOES       = true;
-    glExtensions->compressedETC1RGB8TextureOES    = true;
-    glExtensions->compressedETC1RGB8SubTextureEXT = true;
-    glExtensions->lossyEtcDecodeANGLE             = true;
-    glExtensions->geometryShaderEXT               = true;
-    glExtensions->geometryShaderOES               = true;
-    glExtensions->multiDrawIndirectEXT            = true;
-
-    glExtensions->EGLImageOES                 = true;
-    glExtensions->EGLImageExternalOES         = true;
-    glExtensions->EGLImageExternalEssl3OES    = true;
-    glExtensions->EGLImageArrayEXT            = true;
-    glExtensions->EGLStreamConsumerExternalNV = true;
 
     // OpenGL ES caps
-    *glCaps                       = GenerateMinimumCaps(gl::Version(3, 1), *glExtensions);
     glCaps->maxElementIndex       = std::numeric_limits<GLuint>::max() - 1;
-    glCaps->max3DTextureSize      = rx::LimitToInt(limitsWgpu.limits.maxTextureDimension3D);
-    glCaps->max2DTextureSize      = rx::LimitToInt(limitsWgpu.limits.maxTextureDimension2D);
-    glCaps->maxArrayTextureLayers = rx::LimitToInt(limitsWgpu.limits.maxTextureArrayLayers);
-    glCaps->maxCubeMapTextureSize = rx::LimitToInt(limitsWgpu.limits.maxTextureDimension2D);
-    glCaps->maxRenderbufferSize   = rx::LimitToInt(limitsWgpu.limits.maxTextureDimension2D);
-
-    glCaps->maxDrawBuffers       = rx::LimitToInt(limitsWgpu.limits.maxColorAttachments);
-    glCaps->maxFramebufferWidth  = rx::LimitToInt(limitsWgpu.limits.maxTextureDimension2D);
-    glCaps->maxFramebufferHeight = rx::LimitToInt(limitsWgpu.limits.maxTextureDimension2D);
-    glCaps->maxColorAttachments  = rx::LimitToInt(limitsWgpu.limits.maxColorAttachments);
-
-    glCaps->maxVertexAttribStride = rx::LimitToInt(limitsWgpu.limits.maxVertexBufferArrayStride);
-
-    glCaps->maxVertexAttributes = rx::LimitToInt(limitsWgpu.limits.maxVertexAttributes);
+    glCaps->max3DTextureSize      = rx::LimitToInt(limitsWgpu.maxTextureDimension3D);
+    glCaps->max2DTextureSize      = rx::LimitToInt(limitsWgpu.maxTextureDimension2D);
+    glCaps->maxArrayTextureLayers = rx::LimitToInt(limitsWgpu.maxTextureArrayLayers);
+    glCaps->maxLODBias            = 0.0f;
+    glCaps->maxCubeMapTextureSize = rx::LimitToInt(limitsWgpu.maxTextureDimension2D);
+    glCaps->maxRenderbufferSize   = rx::LimitToInt(limitsWgpu.maxTextureDimension2D);
+    glCaps->minAliasedPointSize   = 1.0f;
+    glCaps->maxAliasedPointSize   = 1.0f;
+    glCaps->minAliasedLineWidth   = 1.0f;
+    glCaps->maxAliasedLineWidth   = 1.0f;
+
+    // "descriptor.sampleCount must be either 1 or 4."
+    constexpr uint32_t kMaxSampleCount = 4;
+
+    glCaps->maxDrawBuffers         = rx::LimitToInt(limitsWgpu.maxColorAttachments);
+    glCaps->maxFramebufferWidth    = rx::LimitToInt(limitsWgpu.maxTextureDimension2D);
+    glCaps->maxFramebufferHeight   = rx::LimitToInt(limitsWgpu.maxTextureDimension2D);
+    glCaps->maxFramebufferSamples  = kMaxSampleCount;
+    glCaps->maxColorAttachments    = rx::LimitToInt(limitsWgpu.maxColorAttachments);
+    glCaps->maxViewportWidth       = rx::LimitToInt(limitsWgpu.maxTextureDimension2D);
+    glCaps->maxViewportHeight      = glCaps->maxViewportWidth;
+    glCaps->maxSampleMaskWords     = 1;
+    glCaps->maxColorTextureSamples = kMaxSampleCount;
+    glCaps->maxDepthTextureSamples = kMaxSampleCount;
+    glCaps->maxIntegerSamples      = kMaxSampleCount;
+    glCaps->maxServerWaitTimeout   = 0;
+
+    glCaps->maxVertexAttribRelativeOffset = (1u << kAttributeOffsetMaxBits) - 1;
+    glCaps->maxVertexAttribBindings =
+        rx::LimitToInt(std::min(limitsWgpu.maxVertexBuffers, limitsWgpu.maxVertexAttributes));
+    glCaps->maxVertexAttribStride = rx::LimitToInt(limitsWgpu.maxVertexBufferArrayStride);
+    glCaps->maxElementsIndices    = std::numeric_limits<GLint>::max();
+    glCaps->maxElementsVertices   = std::numeric_limits<GLint>::max();
+    glCaps->vertexHighpFloat.setIEEEFloat();
+    glCaps->vertexMediumpFloat.setIEEEHalfFloat();
+    glCaps->vertexLowpFloat.setIEEEHalfFloat();
+    glCaps->fragmentHighpFloat.setIEEEFloat();
+    glCaps->fragmentMediumpFloat.setIEEEHalfFloat();
+    glCaps->fragmentLowpFloat.setIEEEHalfFloat();
+    glCaps->vertexHighpInt.setTwosComplementInt(32);
+    glCaps->vertexMediumpInt.setTwosComplementInt(16);
+    glCaps->vertexLowpInt.setTwosComplementInt(16);
+    glCaps->fragmentHighpInt.setTwosComplementInt(32);
+    glCaps->fragmentMediumpInt.setTwosComplementInt(16);
+    glCaps->fragmentLowpInt.setTwosComplementInt(16);
+
+    // Clamp the maxUniformBlockSize to 64KB (majority of devices support up to this size
+    // currently), on AMD the maxUniformBufferRange is near uint32_t max.
+    GLuint maxUniformBlockSize = static_cast<GLuint>(
+        std::min(static_cast<uint64_t>(0x10000), limitsWgpu.maxUniformBufferBindingSize));
+
+    const GLuint maxUniformVectors    = maxUniformBlockSize / (sizeof(GLfloat) * 4);
+    const GLuint maxUniformComponents = maxUniformVectors * 4;
+
+    const int32_t maxPerStageUniformBuffers = rx::LimitToInt(
+        limitsWgpu.maxUniformBuffersPerShaderStage - kReservedPerStageDefaultUniformSlotCount);
+
+    // There is no additional limit to the combined number of components.  We can have up to a
+    // maximum number of uniform buffers, each having the maximum number of components.  Note that
+    // this limit includes both components in and out of uniform buffers.
+    //
+    // This value is limited to INT_MAX to avoid overflow when queried from glGetIntegerv().
+    const uint64_t maxCombinedUniformComponents =
+        std::min<uint64_t>(static_cast<uint64_t>(maxPerStageUniformBuffers +
+                                                 kReservedPerStageDefaultUniformSlotCount) *
+                               maxUniformComponents,
+                           std::numeric_limits<GLint>::max());
+
+    for (gl::ShaderType shaderType : gl::AllShaderTypes())
+    {
+        glCaps->maxShaderUniformBlocks[shaderType] = maxPerStageUniformBuffers;
+        glCaps->maxShaderTextureImageUnits[shaderType] =
+            rx::LimitToInt(limitsWgpu.maxSamplersPerShaderStage);
+        glCaps->maxShaderStorageBlocks[shaderType]             = 0;
+        glCaps->maxShaderUniformComponents[shaderType]         = 0;
+        glCaps->maxShaderAtomicCounterBuffers[shaderType]      = 0;
+        glCaps->maxShaderAtomicCounters[shaderType]            = 0;
+        glCaps->maxShaderImageUniforms[shaderType]             = 0;
+        glCaps->maxCombinedShaderUniformComponents[shaderType] = maxCombinedUniformComponents;
+    }
 
-    glCaps->maxTextureBufferSize = rx::LimitToInt(limitsWgpu.limits.maxBufferSize);
+    const GLint maxVarryingComponents = rx::LimitToInt(limitsWgpu.maxInterStageShaderComponents);
+
+    glCaps->maxVertexAttributes = rx::LimitToInt(
+        limitsWgpu.maxVertexBuffers);  // WebGPU has maxVertexBuffers and maxVertexAttributes but
+                                       // since each vertex attribute can use a unique buffer, we
+                                       // are limited by the total number of vertex buffers
+    glCaps->maxVertexUniformVectors =
+        maxUniformVectors;  // Uniforms are implemented using a uniform buffer, so the max number of
+                            // uniforms we can support is the max buffer range divided by the size
+                            // of a single uniform (4X float).
+    glCaps->maxVertexOutputComponents = maxVarryingComponents;
+
+    glCaps->maxFragmentUniformVectors     = maxUniformVectors;
+    glCaps->maxFragmentInputComponents    = maxVarryingComponents;
+    glCaps->minProgramTextureGatherOffset = 0;
+    glCaps->maxProgramTextureGatherOffset = 0;
+    glCaps->minProgramTexelOffset         = -8;
+    glCaps->maxProgramTexelOffset         = 7;
+
+    glCaps->maxComputeWorkGroupCount       = {0, 0, 0};
+    glCaps->maxComputeWorkGroupSize        = {0, 0, 0};
+    glCaps->maxComputeWorkGroupInvocations = 0;
+    glCaps->maxComputeSharedMemorySize     = 0;
+
+    // Only 2 stages (vertex+fragment) are supported.
+    constexpr uint32_t kShaderStageCount = 2;
+
+    glCaps->maxUniformBufferBindings = maxPerStageUniformBuffers * kShaderStageCount;
+    glCaps->maxUniformBlockSize      = rx::LimitToInt(limitsWgpu.maxBufferSize);
+    glCaps->uniformBufferOffsetAlignment =
+        rx::LimitToInt(limitsWgpu.minUniformBufferOffsetAlignment);
+    glCaps->maxCombinedUniformBlocks = glCaps->maxUniformBufferBindings;
+    glCaps->maxVaryingComponents     = maxVarryingComponents;
+    glCaps->maxVaryingVectors        = rx::LimitToInt(limitsWgpu.maxInterStageShaderVariables);
+    glCaps->maxCombinedTextureImageUnits =
+        rx::LimitToInt(limitsWgpu.maxSamplersPerShaderStage * kShaderStageCount);
+    glCaps->maxCombinedShaderOutputResources = 0;
+
+    glCaps->maxUniformLocations                = maxUniformVectors;
+    glCaps->maxAtomicCounterBufferBindings     = 0;
+    glCaps->maxAtomicCounterBufferSize         = 0;
+    glCaps->maxCombinedAtomicCounterBuffers    = 0;
+    glCaps->maxCombinedAtomicCounters          = 0;
+    glCaps->maxImageUnits                      = 0;
+    glCaps->maxCombinedImageUniforms           = 0;
+    glCaps->maxShaderStorageBufferBindings     = 0;
+    glCaps->maxShaderStorageBlockSize          = 0;
+    glCaps->maxCombinedShaderStorageBlocks     = 0;
+    glCaps->shaderStorageBufferOffsetAlignment = 0;
+
+    glCaps->maxTransformFeedbackInterleavedComponents = 0;
+    glCaps->maxTransformFeedbackSeparateAttributes    = 0;
+    glCaps->maxTransformFeedbackSeparateComponents    = 0;
+
+    glCaps->lineWidthGranularity    = 0.0f;
+    glCaps->minMultisampleLineWidth = 0.0f;
+    glCaps->maxMultisampleLineWidth = 0.0f;
+
+    glCaps->maxTextureBufferSize         = 0;
+    glCaps->textureBufferOffsetAlignment = 0;
+
+    glCaps->maxSamples = kMaxSampleCount;
 
     // Max version
     *maxSupportedESVersion = gl::Version(3, 2);
@@ -346,5 +446,57 @@ wgpu::TextureDimension getWgpuTextureDimension(gl::TextureType glTextureType)
     }
     return dimension;
 }
+
+wgpu::CompareFunction getCompareFunc(const GLenum glCompareFunc)
+{
+    switch (glCompareFunc)
+    {
+        case GL_NEVER:
+            return wgpu::CompareFunction::Never;
+        case GL_LESS:
+            return wgpu::CompareFunction::Less;
+        case GL_EQUAL:
+            return wgpu::CompareFunction::Equal;
+        case GL_LEQUAL:
+            return wgpu::CompareFunction::LessEqual;
+        case GL_GREATER:
+            return wgpu::CompareFunction::Greater;
+        case GL_NOTEQUAL:
+            return wgpu::CompareFunction::NotEqual;
+        case GL_GEQUAL:
+            return wgpu::CompareFunction::GreaterEqual;
+        case GL_ALWAYS:
+            return wgpu::CompareFunction::Always;
+        default:
+            UNREACHABLE();
+            return wgpu::CompareFunction::Always;
+    }
+}
+
+wgpu::StencilOperation getStencilOp(const GLenum glStencilOp)
+{
+    switch (glStencilOp)
+    {
+        case GL_KEEP:
+            return wgpu::StencilOperation::Keep;
+        case GL_ZERO:
+            return wgpu::StencilOperation::Zero;
+        case GL_REPLACE:
+            return wgpu::StencilOperation::Replace;
+        case GL_INCR:
+            return wgpu::StencilOperation::IncrementClamp;
+        case GL_DECR:
+            return wgpu::StencilOperation::DecrementClamp;
+        case GL_INCR_WRAP:
+            return wgpu::StencilOperation::IncrementWrap;
+        case GL_DECR_WRAP:
+            return wgpu::StencilOperation::DecrementWrap;
+        case GL_INVERT:
+            return wgpu::StencilOperation::Invert;
+        default:
+            UNREACHABLE();
+            return wgpu::StencilOperation::Keep;
+    }
+}
 }  // namespace gl_wgpu
 }  // namespace rx
diff --git a/src/libANGLE/renderer/wgpu/wgpu_utils.h b/src/libANGLE/renderer/wgpu/wgpu_utils.h
index cc1c3b80b3bb829f8afc04743dca012891e3a13f..a404ff8c40c0cf94478ded39619c4afd0bdfe6cf 100644
--- a/src/libANGLE/renderer/wgpu/wgpu_utils.h
+++ b/src/libANGLE/renderer/wgpu/wgpu_utils.h
@@ -193,8 +193,14 @@ wgpu::IndexFormat GetIndexFormat(gl::DrawElementsType drawElementsTYpe);
 wgpu::FrontFace GetFrontFace(GLenum frontFace);
 wgpu::CullMode GetCullMode(gl::CullFaceMode mode, bool cullFaceEnabled);
 wgpu::ColorWriteMask GetColorWriteMask(bool r, bool g, bool b, bool a);
+
+wgpu::CompareFunction getCompareFunc(const GLenum glCompareFunc);
+wgpu::StencilOperation getStencilOp(const GLenum glStencilOp);
 }  // namespace gl_wgpu
 
+// Number of reserved binding slots to implement the default uniform block
+constexpr uint32_t kReservedPerStageDefaultUniformSlotCount = 0;
+
 }  // namespace rx
 
 #define ANGLE_WGPU_WRAPPER_OBJECTS_X(PROC) PROC(RenderPipeline)
diff --git a/src/libANGLE/validationES2.cpp b/src/libANGLE/validationES2.cpp
index eee496a8bb604930b3336b35126c400e52704d5f..a68767be82a7e7a337169782c98c5baae485f89f 100644
--- a/src/libANGLE/validationES2.cpp
+++ b/src/libANGLE/validationES2.cpp
@@ -691,6 +691,9 @@ bool ValidCap(const PrivateState &state, ErrorSet *errors, GLenum cap, bool quer
             return state.getClientVersion() >= Version(2, 0) &&
                    state.getExtensions().blendEquationAdvancedCoherentKHR;
 
+        case GL_VARIABLE_RASTERIZATION_RATE_ANGLE:
+            return state.getExtensions().variableRasterizationRateMetalANGLE;
+
         default:
             break;
     }
@@ -6344,6 +6347,18 @@ bool ValidateMaxShaderCompilerThreadsKHR(const Context *context,
     return true;
 }
 
+bool ValidateBindMetalRasterizationRateMapANGLE(const Context *context,
+                                                angle::EntryPoint entryPoint,
+                                                GLMTLRasterizationRateMapANGLE map)
+{
+    if (!context->getExtensions().variableRasterizationRateMetalANGLE)
+    {
+        ANGLE_VALIDATION_ERROR(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+    return true;
+}
+
 bool ValidateMultiDrawArraysANGLE(const Context *context,
                                   angle::EntryPoint entryPoint,
                                   PrimitiveMode mode,
diff --git a/src/libANGLE/validationES32.cpp b/src/libANGLE/validationES32.cpp
index f170fc4d8bac3b766bd80083641622fe3571dd6e..4a9c9053385b54ec158d6934e4349d60cd84646e 100644
--- a/src/libANGLE/validationES32.cpp
+++ b/src/libANGLE/validationES32.cpp
@@ -469,6 +469,9 @@ bool ValidateGetPointerv(const Context *context,
             case GL_DEBUG_CALLBACK_FUNCTION:
             case GL_DEBUG_CALLBACK_USER_PARAM:
                 return true;
+            // GL_ANGLE_variable_rasterization_rate_metal
+            case GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE:
+                return context->getExtensions().variableRasterizationRateMetalANGLE;
             default:
                 ANGLE_VALIDATION_ERROR(GL_INVALID_ENUM, kInvalidPointerQuery);
                 return false;
@@ -476,9 +479,16 @@ bool ValidateGetPointerv(const Context *context,
     }
     else
     {
+        switch (pname)
+        {
+            // GL_ANGLE_variable_rasterization_rate_metal
+            case GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE:
+                return context->getExtensions().variableRasterizationRateMetalANGLE;
+            default:
                 ANGLE_VALIDATION_ERROR(GL_INVALID_OPERATION, kES1or32Required);
                 return false;
         }
+    }
 }
 
 bool ValidateGetSamplerParameterIiv(const Context *context,
diff --git a/src/libANGLE/validationESEXT.cpp b/src/libANGLE/validationESEXT.cpp
index 34a61837a6999cf0cef25f64d8bd6cc75f18a8a6..427aa4e44ec90feefe684ed210292186a36fb488 100644
--- a/src/libANGLE/validationESEXT.cpp
+++ b/src/libANGLE/validationESEXT.cpp
@@ -4461,6 +4461,29 @@ bool ValidateLogicOpANGLE(const PrivateState &state,
     return ValidateLogicOpCommon(state, errors, entryPoint, opcodePacked);
 }
 
+// GL_WEBKIT_explicit_resolve_target
+bool ValidateFramebufferResolveRenderbufferWEBKIT(const Context *context,
+                                                  angle::EntryPoint entryPoint,
+                                                  GLenum target,
+                                                  GLenum attachment,
+                                                  GLenum renderbuffertarget,
+                                                  RenderbufferID renderbuffer)
+{
+#if ANGLE_WEBKIT_EXPLICIT_RESOLVE_TARGET_ENABLED
+    if (!context->getExtensions().explicitResolveTargetWEBKIT)
+    {
+        ANGLE_VALIDATION_ERROR(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    return ValidateFramebufferRenderbufferBase(context, entryPoint, target, attachment,
+                                               renderbuffertarget, renderbuffer);
+#else
+    UNIMPLEMENTED();
+    return false;
+#endif
+}
+
 bool ValidateFramebufferFoveationConfigQCOM(const Context *context,
                                             angle::EntryPoint entryPoint,
                                             FramebufferID framebufferPacked,
diff --git a/src/libANGLE/validationESEXT_autogen.h b/src/libANGLE/validationESEXT_autogen.h
index de36b7a9d310208e2a600c895b253003c0a11484..852d2761a5d4c2e970d0c0c43753e768a269a129 100644
--- a/src/libANGLE/validationESEXT_autogen.h
+++ b/src/libANGLE/validationESEXT_autogen.h
@@ -995,6 +995,11 @@ bool ValidateGetTranslatedShaderSourceANGLE(const Context *context,
                                             const GLsizei *length,
                                             const GLchar *source);
 
+// GL_ANGLE_variable_rasterization_rate_metal
+bool ValidateBindMetalRasterizationRateMapANGLE(const Context *context,
+                                                angle::EntryPoint entryPoint,
+                                                GLMTLRasterizationRateMapANGLE map);
+
 // GL_ANGLE_vulkan_image
 bool ValidateAcquireTexturesANGLE(const Context *context,
                                   angle::EntryPoint entryPoint,
@@ -2884,6 +2889,14 @@ bool ValidateStartTilingQCOM(const Context *context,
                              GLuint width,
                              GLuint height,
                              GLbitfield preserveMask);
+
+// GL_WEBKIT_explicit_resolve_target
+bool ValidateFramebufferResolveRenderbufferWEBKIT(const Context *context,
+                                                  angle::EntryPoint entryPoint,
+                                                  GLenum target,
+                                                  GLenum attachment,
+                                                  GLenum renderbuffertarget,
+                                                  RenderbufferID renderbufferPacked);
 }  // namespace gl
 
 #endif  // LIBANGLE_VALIDATION_ESEXT_AUTOGEN_H_
diff --git a/src/libGLESv2/entry_points_gles_ext_autogen.cpp b/src/libGLESv2/entry_points_gles_ext_autogen.cpp
index cb14151bfad4eade0972bec0dc9c1bb51b27f3e4..df04e91921ae76f265bf5bc3de19cc981a9912d3 100644
--- a/src/libGLESv2/entry_points_gles_ext_autogen.cpp
+++ b/src/libGLESv2/entry_points_gles_ext_autogen.cpp
@@ -4638,6 +4638,36 @@ void GL_APIENTRY GL_GetTranslatedShaderSourceANGLE(GLuint shader,
     ASSERT(!egl::Display::GetCurrentThreadUnlockedTailCall()->any());
 }
 
+// GL_ANGLE_variable_rasterization_rate_metal
+void GL_APIENTRY GL_BindMetalRasterizationRateMapANGLE(GLuint renderbuffer, GLMTLRasterizationRateMapANGLE map)
+{
+    Context *context = GetValidGlobalContext();
+    EVENT(context, GLBindMetalRasterizationRateMapANGLE, "context = %d, map = 0x%016" PRIxPTR "",
+          CID(context), (uintptr_t)map);
+
+    if (context)
+    {
+        SCOPED_SHARE_CONTEXT_LOCK(context);
+        bool isCallValid =
+            (context->skipValidation() ||
+             (ValidatePixelLocalStorageInactive(
+                  context->getPrivateState(), context->getMutableErrorSetForValidation(),
+                  angle::EntryPoint::GLBindMetalRasterizationRateMapANGLE) &&
+              ValidateBindMetalRasterizationRateMapANGLE(
+                  context, angle::EntryPoint::GLBindMetalRasterizationRateMapANGLE, map)));
+        if (isCallValid)
+        {
+            context->bindMetalRasterizationRateMap(renderbuffer, map);
+        }
+        ANGLE_CAPTURE_GL(BindMetalRasterizationRateMapANGLE, isCallValid, context, map);
+    }
+    else
+    {
+        GenerateContextLostErrorOnCurrentGlobalContext();
+    }
+    ASSERT(!egl::Display::GetCurrentThreadUnlockedTailCall()->any());
+}
+
 // GL_ANGLE_vulkan_image
 void GL_APIENTRY GL_AcquireTexturesANGLE(GLuint numTextures,
                                          const GLuint *textures,
@@ -13859,4 +13889,44 @@ GL_StartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield p
     ASSERT(!egl::Display::GetCurrentThreadUnlockedTailCall()->any());
 }
 
+// GL_WEBKIT_explicit_resolve_target
+void GL_APIENTRY GL_FramebufferResolveRenderbufferWEBKIT(GLenum target,
+                                                         GLenum attachment,
+                                                         GLenum renderbuffertarget,
+                                                         GLuint renderbuffer)
+{
+    Context *context = GetValidGlobalContext();
+    EVENT(context, GLFramebufferResolveRenderbufferWEBKIT,
+          "context = %d, target = %s, attachment = %s, renderbuffertarget = %s, renderbuffer = %u",
+          CID(context), GLenumToString(GLESEnum::AllEnums, target),
+          GLenumToString(GLESEnum::AllEnums, attachment),
+          GLenumToString(GLESEnum::AllEnums, renderbuffertarget), renderbuffer);
+
+    if (context)
+    {
+        RenderbufferID renderbufferPacked = PackParam<RenderbufferID>(renderbuffer);
+        SCOPED_SHARE_CONTEXT_LOCK(context);
+        bool isCallValid =
+            (context->skipValidation() ||
+             (ValidatePixelLocalStorageInactive(
+                  context->getPrivateState(), context->getMutableErrorSetForValidation(),
+                  angle::EntryPoint::GLFramebufferResolveRenderbufferWEBKIT) &&
+              ValidateFramebufferResolveRenderbufferWEBKIT(
+                  context, angle::EntryPoint::GLFramebufferResolveRenderbufferWEBKIT, target,
+                  attachment, renderbuffertarget, renderbufferPacked)));
+        if (isCallValid)
+        {
+            context->framebufferResolveRenderbufferWEBKIT(target, attachment, renderbuffertarget,
+                                                          renderbufferPacked);
+        }
+        ANGLE_CAPTURE_GL(FramebufferResolveRenderbufferWEBKIT, isCallValid, context, target,
+                         attachment, renderbuffertarget, renderbufferPacked);
+    }
+    else
+    {
+        GenerateContextLostErrorOnCurrentGlobalContext();
+    }
+    ASSERT(!egl::Display::GetCurrentThreadUnlockedTailCall()->any());
+}
+
 }  // extern "C"
diff --git a/src/libGLESv2/entry_points_gles_ext_autogen.h b/src/libGLESv2/entry_points_gles_ext_autogen.h
index e389d4728c4f16da54842c71e13e6857ed81daa2..8725696ee977c8bc8e041b3a4792e6b8a48ff5a0 100644
--- a/src/libGLESv2/entry_points_gles_ext_autogen.h
+++ b/src/libGLESv2/entry_points_gles_ext_autogen.h
@@ -738,6 +738,10 @@ ANGLE_EXPORT void GL_APIENTRY GL_GetTranslatedShaderSourceANGLE(GLuint shader,
                                                                 GLsizei *length,
                                                                 GLchar *source);
 
+// GL_ANGLE_variable_rasterization_rate_metal
+ANGLE_EXPORT void GL_APIENTRY
+GL_BindMetalRasterizationRateMapANGLE(GLuint framebuffer, GLMTLRasterizationRateMapANGLE map);
+
 // GL_ANGLE_vulkan_image
 ANGLE_EXPORT void GL_APIENTRY GL_AcquireTexturesANGLE(GLuint numTextures,
                                                       const GLuint *textures,
@@ -1935,6 +1939,12 @@ ANGLE_EXPORT void GL_APIENTRY GL_TextureFoveationParametersQCOM(GLuint texture,
 ANGLE_EXPORT void GL_APIENTRY GL_EndTilingQCOM(GLbitfield preserveMask);
 ANGLE_EXPORT void GL_APIENTRY
 GL_StartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask);
+
+// GL_WEBKIT_explicit_resolve_target
+ANGLE_EXPORT void GL_APIENTRY GL_FramebufferResolveRenderbufferWEBKIT(GLenum target,
+                                                                      GLenum attachment,
+                                                                      GLenum renderbuffertarget,
+                                                                      GLuint renderbuffer);
 }  // extern "C"
 
 #endif  // LIBGLESV2_ENTRY_POINTS_GLES_EXT_AUTOGEN_H_
diff --git a/src/libGLESv2/libGLESv2_autogen.cpp b/src/libGLESv2/libGLESv2_autogen.cpp
index 5cc6a38217e8074633a63afd66c8ac7519c75f43..8210a3e6a6cb521018cc4f9db47c5e9cc22d8e6e 100644
--- a/src/libGLESv2/libGLESv2_autogen.cpp
+++ b/src/libGLESv2/libGLESv2_autogen.cpp
@@ -3942,6 +3942,12 @@ void GL_APIENTRY glGetTranslatedShaderSourceANGLE(GLuint shader,
     return GL_GetTranslatedShaderSourceANGLE(shader, bufSize, length, source);
 }
 
+// GL_ANGLE_variable_rasterization_rate_metal
+void GL_APIENTRY glBindMetalRasterizationRateMapANGLE(GLuint renderbuffer, GLMTLRasterizationRateMapANGLE map)
+{
+    return GL_BindMetalRasterizationRateMapANGLE(renderbuffer, map);
+}
+
 // GL_ANGLE_vulkan_image
 void GL_APIENTRY glAcquireTexturesANGLE(GLuint numTextures,
                                         const GLuint *textures,
@@ -6067,6 +6073,16 @@ glStartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield pr
     return GL_StartTilingQCOM(x, y, width, height, preserveMask);
 }
 
+// GL_WEBKIT_explicit_resolve_target
+void GL_APIENTRY glFramebufferResolveRenderbufferWEBKIT(GLenum target,
+                                                        GLenum attachment,
+                                                        GLenum renderbuffertarget,
+                                                        GLuint renderbuffer)
+{
+    return GL_FramebufferResolveRenderbufferWEBKIT(target, attachment, renderbuffertarget,
+                                                   renderbuffer);
+}
+
 #if defined(ANGLE_ENABLE_GL_DESKTOP_FRONTEND)
 
 // GL 1.0
diff --git a/src/libGLESv2/libGLESv2_autogen.def b/src/libGLESv2/libGLESv2_autogen.def
index 8117e28d0ec91924ece75f22a64c87e6573f70a4..4897c4154c22d07fec87b9d15e45d7179987b5ec 100644
--- a/src/libGLESv2/libGLESv2_autogen.def
+++ b/src/libGLESv2/libGLESv2_autogen.def
@@ -668,6 +668,9 @@ EXPORTS
     ; GL_ANGLE_translated_shader_source
     glGetTranslatedShaderSourceANGLE
 
+    ; GL_ANGLE_variable_rasterization_rate_metal
+    glBindMetalRasterizationRateMapANGLE
+
     ; GL_ANGLE_vulkan_image
     glAcquireTexturesANGLE
     glReleaseTexturesANGLE
@@ -1265,6 +1268,9 @@ EXPORTS
     glEndTilingQCOM
     glStartTilingQCOM
 
+    ; GL_WEBKIT_explicit_resolve_target
+    glFramebufferResolveRenderbufferWEBKIT
+
     ; EGL 1.0
     EGL_ChooseConfig
     EGL_CopyBuffers
diff --git a/src/libGLESv2/libGLESv2_no_capture_autogen.def b/src/libGLESv2/libGLESv2_no_capture_autogen.def
index 57875834664dc72e867fd161b0f0b27d683affd4..0a189c1b388d82cbbfff55e6cd73e00d94019a53 100644
--- a/src/libGLESv2/libGLESv2_no_capture_autogen.def
+++ b/src/libGLESv2/libGLESv2_no_capture_autogen.def
@@ -668,6 +668,9 @@ EXPORTS
     ; GL_ANGLE_translated_shader_source
     glGetTranslatedShaderSourceANGLE
 
+    ; GL_ANGLE_variable_rasterization_rate_metal
+    glBindMetalRasterizationRateMapANGLE
+
     ; GL_ANGLE_vulkan_image
     glAcquireTexturesANGLE
     glReleaseTexturesANGLE
@@ -1265,6 +1268,9 @@ EXPORTS
     glEndTilingQCOM
     glStartTilingQCOM
 
+    ; GL_WEBKIT_explicit_resolve_target
+    glFramebufferResolveRenderbufferWEBKIT
+
     ; EGL 1.0
     EGL_ChooseConfig
     EGL_CopyBuffers
diff --git a/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def b/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def
index ba0237ae105122f6e8f6349a2f0f294b5de30375..feb75b2bec659049e6afb4ecbfcd5a56d52f241e 100644
--- a/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def
+++ b/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def
@@ -668,6 +668,9 @@ EXPORTS
     ; GL_ANGLE_translated_shader_source
     glGetTranslatedShaderSourceANGLE
 
+    ; GL_ANGLE_variable_rasterization_rate_metal
+    glBindMetalRasterizationRateMapANGLE
+
     ; GL_ANGLE_vulkan_image
     glAcquireTexturesANGLE
     glReleaseTexturesANGLE
@@ -1265,6 +1268,9 @@ EXPORTS
     glEndTilingQCOM
     glStartTilingQCOM
 
+    ; GL_WEBKIT_explicit_resolve_target
+    glFramebufferResolveRenderbufferWEBKIT
+
     ; EGL 1.0
     EGL_ChooseConfig
     EGL_CopyBuffers
diff --git a/src/libGLESv2/libGLESv2_with_capture_autogen.def b/src/libGLESv2/libGLESv2_with_capture_autogen.def
index a242e6df2f07d273730e8fead7b1a7e5086a08a8..5d2e6d06ad85fceffae7350679b824ea22dad31a 100644
--- a/src/libGLESv2/libGLESv2_with_capture_autogen.def
+++ b/src/libGLESv2/libGLESv2_with_capture_autogen.def
@@ -668,6 +668,9 @@ EXPORTS
     ; GL_ANGLE_translated_shader_source
     glGetTranslatedShaderSourceANGLE
 
+    ; GL_ANGLE_variable_rasterization_rate_metal
+    glBindMetalRasterizationRateMapANGLE
+
     ; GL_ANGLE_vulkan_image
     glAcquireTexturesANGLE
     glReleaseTexturesANGLE
@@ -1265,6 +1268,9 @@ EXPORTS
     glEndTilingQCOM
     glStartTilingQCOM
 
+    ; GL_WEBKIT_explicit_resolve_target
+    glFramebufferResolveRenderbufferWEBKIT
+
     ; EGL 1.0
     EGL_ChooseConfig
     EGL_CopyBuffers
diff --git a/src/libGLESv2/opengl32_autogen.def b/src/libGLESv2/opengl32_autogen.def
index 782e627b9e2270d8cbb335fee5f191e15cbd98c7..dfd2ad5a5579cb229c74e40ebaaa6588301cd405 100644
--- a/src/libGLESv2/opengl32_autogen.def
+++ b/src/libGLESv2/opengl32_autogen.def
@@ -668,6 +668,9 @@ EXPORTS
     ; GL_ANGLE_translated_shader_source
     glGetTranslatedShaderSourceANGLE
 
+    ; GL_ANGLE_variable_rasterization_rate_metal
+    glBindMetalRasterizationRateMapANGLE
+
     ; GL_ANGLE_vulkan_image
     glAcquireTexturesANGLE
     glReleaseTexturesANGLE
@@ -1265,6 +1268,9 @@ EXPORTS
     glEndTilingQCOM
     glStartTilingQCOM
 
+    ; GL_WEBKIT_explicit_resolve_target
+    glFramebufferResolveRenderbufferWEBKIT
+
     ; GL 1.0
     glAccum
     glAlphaFunc
diff --git a/src/libGLESv2/opengl32_with_wgl_autogen.def b/src/libGLESv2/opengl32_with_wgl_autogen.def
index 30763ef3b30b4184d92008adea49e0eb3d6d1f9c..9395c6b7da198127b2f54951d213941657e449d8 100644
--- a/src/libGLESv2/opengl32_with_wgl_autogen.def
+++ b/src/libGLESv2/opengl32_with_wgl_autogen.def
@@ -668,6 +668,9 @@ EXPORTS
     ; GL_ANGLE_translated_shader_source
     glGetTranslatedShaderSourceANGLE
 
+    ; GL_ANGLE_variable_rasterization_rate_metal
+    glBindMetalRasterizationRateMapANGLE
+
     ; GL_ANGLE_vulkan_image
     glAcquireTexturesANGLE
     glReleaseTexturesANGLE
@@ -1265,6 +1268,9 @@ EXPORTS
     glEndTilingQCOM
     glStartTilingQCOM
 
+    ; GL_WEBKIT_explicit_resolve_target
+    glFramebufferResolveRenderbufferWEBKIT
+
     ; GL 1.0
     glAccum
     glAlphaFunc
diff --git a/src/libGLESv2/proc_table_egl_autogen.cpp b/src/libGLESv2/proc_table_egl_autogen.cpp
index 4669eb7255e7c5d2f38415717e41f9a52978c446..3d2bb967c5f8876e7f218557e2939265abdcf033 100644
--- a/src/libGLESv2/proc_table_egl_autogen.cpp
+++ b/src/libGLESv2/proc_table_egl_autogen.cpp
@@ -190,6 +190,7 @@ const ProcEntry g_procTable[] = {
     {"glBindFramebufferOES", P(GL_BindFramebufferOES)},
     {"glBindImageTexture", P(GL_BindImageTexture)},
     DESKTOP_ONLY("glBindImageTextures", GL_BindImageTextures)
+    {"glBindMetalRasterizationRateMapANGLE", P(GL_BindMetalRasterizationRateMapANGLE)},
     {"glBindProgramPipeline", P(GL_BindProgramPipeline)},
     {"glBindProgramPipelineEXT", P(GL_BindProgramPipelineEXT)},
     {"glBindRenderbuffer", P(GL_BindRenderbuffer)},
@@ -528,6 +529,7 @@ const ProcEntry g_procTable[] = {
     {"glFramebufferPixelLocalStorageRestoreANGLE", P(GL_FramebufferPixelLocalStorageRestoreANGLE)},
     {"glFramebufferRenderbuffer", P(GL_FramebufferRenderbuffer)},
     {"glFramebufferRenderbufferOES", P(GL_FramebufferRenderbufferOES)},
+    {"glFramebufferResolveRenderbufferWEBKIT", P(GL_FramebufferResolveRenderbufferWEBKIT)},
     {"glFramebufferTexture", P(GL_FramebufferTexture)},
     DESKTOP_ONLY("glFramebufferTexture1D", GL_FramebufferTexture1D)
     {"glFramebufferTexture2D", P(GL_FramebufferTexture2D)},
diff --git a/src/libGLESv2/proc_table_glx_autogen.cpp b/src/libGLESv2/proc_table_glx_autogen.cpp
index 413a54610cfc5a2404c5b703e638e003041e3668..7bae292cdf41ebc30ec59f1c87423818f5ccb32b 100644
--- a/src/libGLESv2/proc_table_glx_autogen.cpp
+++ b/src/libGLESv2/proc_table_glx_autogen.cpp
@@ -67,6 +67,7 @@ const ProcEntry g_procTable[] = {
     {"glBindFramebufferOES", P(GL_BindFramebufferOES)},
     {"glBindImageTexture", P(GL_BindImageTexture)},
     {"glBindImageTextures", P(GL_BindImageTextures)},
+    {"glBindMetalRasterizationRateMapANGLE", P(GL_BindMetalRasterizationRateMapANGLE)},
     {"glBindProgramPipeline", P(GL_BindProgramPipeline)},
     {"glBindProgramPipelineEXT", P(GL_BindProgramPipelineEXT)},
     {"glBindRenderbuffer", P(GL_BindRenderbuffer)},
@@ -405,6 +406,7 @@ const ProcEntry g_procTable[] = {
     {"glFramebufferPixelLocalStorageRestoreANGLE", P(GL_FramebufferPixelLocalStorageRestoreANGLE)},
     {"glFramebufferRenderbuffer", P(GL_FramebufferRenderbuffer)},
     {"glFramebufferRenderbufferOES", P(GL_FramebufferRenderbufferOES)},
+    {"glFramebufferResolveRenderbufferWEBKIT", P(GL_FramebufferResolveRenderbufferWEBKIT)},
     {"glFramebufferTexture", P(GL_FramebufferTexture)},
     {"glFramebufferTexture1D", P(GL_FramebufferTexture1D)},
     {"glFramebufferTexture2D", P(GL_FramebufferTexture2D)},
diff --git a/src/libGLESv2/proc_table_wgl_autogen.cpp b/src/libGLESv2/proc_table_wgl_autogen.cpp
index 4cfd778a60259c742692602a6a0d9f10bdab5806..f939f35fe62e450710c8f73f6ed3f773146e6d18 100644
--- a/src/libGLESv2/proc_table_wgl_autogen.cpp
+++ b/src/libGLESv2/proc_table_wgl_autogen.cpp
@@ -67,6 +67,7 @@ const ProcEntry g_procTable[] = {
     {"glBindFramebufferOES", P(GL_BindFramebufferOES)},
     {"glBindImageTexture", P(GL_BindImageTexture)},
     {"glBindImageTextures", P(GL_BindImageTextures)},
+    {"glBindMetalRasterizationRateMapANGLE", P(GL_BindMetalRasterizationRateMapANGLE)},
     {"glBindProgramPipeline", P(GL_BindProgramPipeline)},
     {"glBindProgramPipelineEXT", P(GL_BindProgramPipelineEXT)},
     {"glBindRenderbuffer", P(GL_BindRenderbuffer)},
@@ -405,6 +406,7 @@ const ProcEntry g_procTable[] = {
     {"glFramebufferPixelLocalStorageRestoreANGLE", P(GL_FramebufferPixelLocalStorageRestoreANGLE)},
     {"glFramebufferRenderbuffer", P(GL_FramebufferRenderbuffer)},
     {"glFramebufferRenderbufferOES", P(GL_FramebufferRenderbufferOES)},
+    {"glFramebufferResolveRenderbufferWEBKIT", P(GL_FramebufferResolveRenderbufferWEBKIT)},
     {"glFramebufferTexture", P(GL_FramebufferTexture)},
     {"glFramebufferTexture1D", P(GL_FramebufferTexture1D)},
     {"glFramebufferTexture2D", P(GL_FramebufferTexture2D)},
diff --git a/src/tests/angle_end2end_tests.gni b/src/tests/angle_end2end_tests.gni
index 879a6de5c94c64e6a676fe177df432a1cdc7f680..b46227c7c52fe621c00e3b124995729ba0e68ebd 100644
--- a/src/tests/angle_end2end_tests.gni
+++ b/src/tests/angle_end2end_tests.gni
@@ -86,6 +86,7 @@ angle_end2end_tests_sources = [
   "gl_tests/FramebufferMixedSamplesTest.cpp",
   "gl_tests/FramebufferMultiviewTest.cpp",
   "gl_tests/FramebufferRenderMipmapTest.cpp",
+  "gl_tests/FramebufferResolveTest.cpp",
   "gl_tests/FramebufferTest.cpp",
   "gl_tests/GLSLTest.cpp",
   "gl_tests/GeometryShaderTest.cpp",
@@ -226,6 +227,7 @@ angle_end2end_tests_mac_sources = [
   "egl_tests/EGLSyncTestMetalSharedEvent.mm",
   "egl_tests/EGLWaitUntilWorkScheduledTest.cpp",
   "gl_tests/ImageTestMetal.mm",
+  "gl_tests/VariableRasterizationRateTestMetal.mm",
 ]
 angle_end2end_tests_win_sources = [
   "egl_tests/EGLDeviceTest.cpp",
diff --git a/src/tests/angle_end2end_tests_expectations.txt b/src/tests/angle_end2end_tests_expectations.txt
index 69dd354f49bb0c7684ab45014304186d9475bbca..00717f52a19f8bd0c1165eb0e37a8d8bf899f82a 100644
--- a/src/tests/angle_end2end_tests_expectations.txt
+++ b/src/tests/angle_end2end_tests_expectations.txt
@@ -1104,6 +1104,7 @@ b/330697097 PIXEL6 VULKAN : FramebufferTest_ES31.MultisampleResolveBothAttachmen
 352584420 GLES : ReadPixelsTextureNorm16PBOTest.RG16_RGBA/* = SKIP
 
 354109768 MAC AMD OPENGL : ReadPixelsPBOTest.SmallRowLength/* = SKIP
+358407353 LINUX INTEL OPENGL : ReadPixelsPBOTest.SmallRowLength/* = SKIP
 
 // D3D needs a workaround to follow OpenGL rules
 42266528 D3D9 : DepthWriteTest.Test/ES2_D3D9__DepthRangeReduced_Clipped_VertexDepthInsideClipVolume_FragmentDepthBetweenZeroAndNearPlane_* = SKIP
@@ -1477,5 +1478,8 @@ b/292285899 PIXEL4ORXL GLES : EGLSurfaceTest.DestroyAndRecreateWhileCurrent/* =
 42263645 : GLSLTest.VerifyMaxFragmentUniformVectors* = TIMEOUT
 42264781 : MultithreadingTest* = TIMEOUT
 
+// Metal backend doesn't support different sized attachments.
+42261786 METAL : MultisampledRenderToTextureES3Test.MultipleLevelsMultisampleMRTDraw2DColor/* = SKIP
+
 // Please do not add expectations below this line,
 // so that TIMEOUT expectations above don't override more precise SKIP expectations
diff --git a/src/tests/deqp_support/deqp_gles2_test_expectations.txt b/src/tests/deqp_support/deqp_gles2_test_expectations.txt
index f4acf353bfa6ea6a018e51448e6d6d5401ef7599..c2d38eac75a9bea516204ba5249ba7361e59c8d8 100644
--- a/src/tests/deqp_support/deqp_gles2_test_expectations.txt
+++ b/src/tests/deqp_support/deqp_gles2_test_expectations.txt
@@ -396,8 +396,6 @@ b/328156792 PINEAPPLE VULKAN : dEQP-GLES2.functional.uniform_api.value.assigned.
 356399840 WGPU : dEQP-GLES2.functional.rasterization.* = FAIL
 356399840 WGPU : dEQP-GLES2.functional.read_pixels.* = FAIL
 356399840 WGPU : dEQP-GLES2.functional.shaders.* = FAIL
-356399840 WGPU : dEQP-GLES2.functional.state_query.shader.precision_fragment_lowp_int = FAIL
-356399840 WGPU : dEQP-GLES2.functional.state_query.shader.precision_vertex_lowp_int = FAIL
 356399840 WGPU : dEQP-GLES2.functional.state_query.shader.uniform_value_* = FAIL
 356399840 WGPU : dEQP-GLES2.functional.texture.* = FAIL
 356399840 WGPU : dEQP-GLES2.functional.uniform_api.random.* = FAIL
diff --git a/src/tests/gl_tests/GLSLTest.cpp b/src/tests/gl_tests/GLSLTest.cpp
index c0fe811e7ca379c7fabbd1d276f19bf5ff7cd937..3942200e6f7fe7a96275bc04a2d11fb9e45fc72a 100644
--- a/src/tests/gl_tests/GLSLTest.cpp
+++ b/src/tests/gl_tests/GLSLTest.cpp
@@ -9060,7 +9060,7 @@ void main()
     EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::blue);
 }
 
-// Test that basic infinite loops are pruned in WebGL
+// Test that basic infinite loops are either rejected or are pruned in WebGL
 TEST_P(WebGL2GLSLTest, BasicInfiniteLoop)
 {
     constexpr char kFS[] = R"(#version 300 es
@@ -9159,9 +9159,62 @@ void main()
     color = vec4(r, g, b, 1);
 })";
 
+    if (getEGLWindow()->isFeatureEnabled(Feature::RejectWebglShadersWithUndefinedBehavior))
+    {
+        GLuint shader = CompileShader(GL_FRAGMENT_SHADER, kFS);
+        EXPECT_EQ(0u, shader);
+    }
+    else
+    {
         ANGLE_GL_PROGRAM(program, essl3_shaders::vs::Simple(), kFS);
         drawQuad(program, essl3_shaders::PositionAttrib(), 0.5f, 1.0f, true);
         EXPECT_PIXEL_NEAR(0, 0, 178, 255, 127, 255, 1);
+    }
+}
+
+// Test that while(true) loops with break/return are not rejected
+TEST_P(WebGL2GLSLTest, NotInfiniteLoop)
+{
+    constexpr char kFS[] = R"(#version 300 es
+precision highp float;
+uniform uint zero;
+out vec4 color;
+
+void main()
+{
+    float r = 0.;
+    float g = 1.;
+    float b = 0.;
+
+    while (true)
+    {
+        r += 0.1;
+        if (r > 0.4)
+        {
+            break;
+        }
+    }
+
+    for (;;)
+    {
+        g -= 0.1;
+
+        switch (zero)
+        {
+            case 0u:
+                g -= 0.6;
+                color = vec4(r, g, b, 1);
+                return;
+            default:
+                r = 0.2;
+                break;
+        }
+    }
+})";
+
+    ANGLE_GL_PROGRAM(program, essl3_shaders::vs::Simple(), kFS);
+    drawQuad(program, essl3_shaders::PositionAttrib(), 0.5f, 1.0f, true);
+    EXPECT_PIXEL_NEAR(0, 0, 127, 76, 0, 255, 1);
 }
 
 // Test that a constant struct inside an expression is handled correctly.
diff --git a/src/tests/gl_tests/MultisampleTest.cpp b/src/tests/gl_tests/MultisampleTest.cpp
index 263bef806d4f52b1c705c3dc60ce4504c8e7bccd..408fb149ef8085e15bf85d73e626573aaab962cb 100644
--- a/src/tests/gl_tests/MultisampleTest.cpp
+++ b/src/tests/gl_tests/MultisampleTest.cpp
@@ -1176,8 +1176,6 @@ ANGLE_INSTANTIATE_TEST_ES32_AND(MultisampleTestES32,
 
 ANGLE_INSTANTIATE_TEST_ES3_AND(
     MultisampleResolveTest,
-    ES3_METAL().disable(Feature::AlwaysResolveMultisampleRenderBuffers),
-    ES3_METAL().enable(Feature::AlwaysResolveMultisampleRenderBuffers),
     ES3_VULKAN().enable(Feature::EmulatedPrerotation90),
     ES3_VULKAN().enable(Feature::EmulatedPrerotation180),
     ES3_VULKAN().enable(Feature::EmulatedPrerotation270),
diff --git a/src/tests/gl_tests/MultisampledRenderToTextureTest.cpp b/src/tests/gl_tests/MultisampledRenderToTextureTest.cpp
index 37048bcff21c7543cd7452e4567727ab1456338b..0581a35b079d889673d7d3de468d24ec64228612 100644
--- a/src/tests/gl_tests/MultisampledRenderToTextureTest.cpp
+++ b/src/tests/gl_tests/MultisampledRenderToTextureTest.cpp
@@ -472,7 +472,8 @@ TEST_P(MultisampledRenderToTextureTest, FramebufferCompleteness)
     // http://anglebug.com/42261786
     ANGLE_SKIP_TEST_IF(IsD3D());
 
-    if (getClientMajorVersion() >= 3)
+    if (getClientMajorVersion() >= 3 &&
+        EnsureGLExtensionEnabled("GL_EXT_multisampled_render_to_texture2"))
     {
         // Texture attachment for color attachment 1.
         GLTexture texture2;
@@ -548,9 +549,6 @@ TEST_P(MultisampledRenderToTextureTest, UnsizedTextureFormatSampleMissmatch)
     ANGLE_SKIP_TEST_IF(!EnsureGLExtensionEnabled("GL_EXT_multisampled_render_to_texture"));
     ANGLE_SKIP_TEST_IF(!EnsureGLExtensionEnabled("GL_EXT_texture_rg"));
 
-    // Test failure introduced by Apple's changes (anglebug.com/40096755)
-    ANGLE_SKIP_TEST_IF(IsMetal() && IsAMD());
-
     GLsizei samples = 0;
     glGetIntegerv(GL_MAX_SAMPLES, &samples);
 
@@ -1903,6 +1901,10 @@ void MultisampledRenderToTextureES3Test::drawCopyDrawAttachDepthStencilClearThen
     bool useRenderbuffer)
 {
     ANGLE_SKIP_TEST_IF(!EnsureGLExtensionEnabled("GL_EXT_multisampled_render_to_texture"));
+    // Use glFramebufferTexture2DMultisampleEXT for depth/stencil texture is only supported with
+    // GL_EXT_multisampled_render_to_texture2.
+    ANGLE_SKIP_TEST_IF(!useRenderbuffer &&
+                       !EnsureGLExtensionEnabled("GL_EXT_multisampled_render_to_texture2"));
     constexpr GLsizei kSize = 64;
 
     // http://anglebug.com/42263509
@@ -3285,28 +3287,45 @@ TEST_P(MultisampledRenderToTextureES3Test, DepthStencilInvalidate)
     ASSERT_NE(-1, positionLocation);
 
     // Setup vertices such that depth is varied from top to bottom.
-    std::array<Vector3, 6> quadVertices = {
+    std::array<Vector3, 6> redQuadVertices = {
         Vector3(-1.0f, 1.0f, 0.8f), Vector3(-1.0f, -1.0f, 0.2f), Vector3(1.0f, -1.0f, 0.2f),
         Vector3(-1.0f, 1.0f, 0.8f), Vector3(1.0f, -1.0f, 0.2f),  Vector3(1.0f, 1.0f, 0.8f),
     };
-    GLBuffer quadVertexBuffer;
-    glBindBuffer(GL_ARRAY_BUFFER, quadVertexBuffer);
-    glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * 3 * 6, quadVertices.data(), GL_STATIC_DRAW);
-    glVertexAttribPointer(positionLocation, 3, GL_FLOAT, GL_FALSE, 0, 0);
+    GLBuffer redQuadVertexBuffer;
+    glBindBuffer(GL_ARRAY_BUFFER, redQuadVertexBuffer);
+    glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * 3 * 6, redQuadVertices.data(), GL_STATIC_DRAW);
     glEnableVertexAttribArray(positionLocation);
 
+    // Green quad has the same depth.
+    std::array<Vector3, 6> greenQuadVertices = {
+        Vector3(-1.0f, 1.0f, 0.5f), Vector3(-1.0f, -1.0f, 0.5f), Vector3(1.0f, -1.0f, 0.5f),
+        Vector3(-1.0f, 1.0f, 0.5f), Vector3(1.0f, -1.0f, 0.5f),  Vector3(1.0f, 1.0f, 0.5f),
+    };
+    GLBuffer greenQuadVertexBuffer;
+    glBindBuffer(GL_ARRAY_BUFFER, greenQuadVertexBuffer);
+    glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * 3 * 6, greenQuadVertices.data(),
+                 GL_STATIC_DRAW);
+
     // Draw red into the framebuffer.
     glViewport(0, 0, kWidth, 1);
     glUniform4f(colorUniformLocation, 1.0f, 0.0f, 0.0f, 1.0f);
     glEnable(GL_DEPTH_TEST);
     glDepthFunc(GL_ALWAYS);
+    glBindBuffer(GL_ARRAY_BUFFER, redQuadVertexBuffer);
+    glVertexAttribPointer(positionLocation, 3, GL_FLOAT, GL_FALSE, 0, 0);
     glDrawArrays(GL_TRIANGLES, 0, 6);
     ASSERT_GL_NO_ERROR();
 
     // Draw green such that half the samples of each pixel pass the depth test.
+    // Note: We don't use drawQuad() because it could internally create a vertex buffer
+    // or client array pointer on the fly. Those could break the render pass in some backends and
+    // force unresolve unwantedly. The unexpected unresolve would have written average depth value
+    // to all samples in the depth buffer.
     glUniform4f(colorUniformLocation, 0.0f, 1.0f, 0.0f, 1.0f);
     glDepthFunc(GL_GREATER);
-    drawQuad(drawColor, essl1_shaders::PositionAttrib(), 0.5f);
+    glBindBuffer(GL_ARRAY_BUFFER, greenQuadVertexBuffer);
+    glVertexAttribPointer(positionLocation, 3, GL_FLOAT, GL_FALSE, 0, 0);
+    glDrawArrays(GL_TRIANGLES, 0, 6);
     ASSERT_GL_NO_ERROR();
 
     // Invalidate depth attachment
@@ -4358,12 +4377,15 @@ TEST_P(MultisampledRenderToTextureWithAdvancedBlendTest, RenderbufferClearThenDr
     drawTestCommon(true, InitMethod::Clear);
 }
 
-ANGLE_INSTANTIATE_TEST_COMBINE_1(MultisampledRenderToTextureTest,
+ANGLE_INSTANTIATE_TEST_COMBINE_1(
+    MultisampledRenderToTextureTest,
     PrintToStringParamName,
     testing::Bool(),
     ANGLE_ALL_TEST_PLATFORMS_ES2,
     ANGLE_ALL_TEST_PLATFORMS_ES3,
     ANGLE_ALL_TEST_PLATFORMS_ES31,
+    ES2_METAL().enable(Feature::EnableMultisampledRenderToTextureOnNonTilers),
+    ES3_METAL().enable(Feature::EnableMultisampledRenderToTextureOnNonTilers),
     ES3_VULKAN()
         .disable(Feature::SupportsExtendedDynamicState)
         .disable(Feature::SupportsExtendedDynamicState2),
@@ -4378,11 +4400,13 @@ ANGLE_INSTANTIATE_TEST_COMBINE_1(MultisampledRenderToTextureTest,
         .enable(Feature::AsyncCommandQueue));
 
 GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(MultisampledRenderToTextureES3Test);
-ANGLE_INSTANTIATE_TEST_COMBINE_1(MultisampledRenderToTextureES3Test,
+ANGLE_INSTANTIATE_TEST_COMBINE_1(
+    MultisampledRenderToTextureES3Test,
     PrintToStringParamName,
     testing::Bool(),
     ANGLE_ALL_TEST_PLATFORMS_ES3,
     ANGLE_ALL_TEST_PLATFORMS_ES31,
+    ES3_METAL().enable(Feature::EnableMultisampledRenderToTextureOnNonTilers),
     ES3_VULKAN()
         .disable(Feature::SupportsExtendedDynamicState)
         .disable(Feature::SupportsExtendedDynamicState2),
diff --git a/src/tests/gl_tests/PbufferTest.cpp b/src/tests/gl_tests/PbufferTest.cpp
index 969cd2f96d302d74dd3515ac842b93eb51387cd2..730d0ffa536caf536ec750e2bac82c8187cda8ce 100644
--- a/src/tests/gl_tests/PbufferTest.cpp
+++ b/src/tests/gl_tests/PbufferTest.cpp
@@ -302,7 +302,6 @@ TEST_P(PbufferTest, BindTexImageOverwrite)
     // Test skipped because Pbuffers are not supported or Pbuffer does not support binding to RGBA
     // textures.
     ANGLE_SKIP_TEST_IF(!mSupportsPbuffers || !mSupportsBindTexImage);
-
     EGLWindow *window = getEGLWindow();
     window->makeCurrent();
 
@@ -532,7 +531,6 @@ TEST_P(PbufferTest, BindTexImageOverwriteReleasesOrphanedPbuffer)
     // Test skipped because Pbuffers are not supported or Pbuffer does not support binding to RGBA
     // textures.
     ANGLE_SKIP_TEST_IF(!mSupportsPbuffers || !mSupportsBindTexImage);
-
     EGLWindow *window = getEGLWindow();
     window->makeCurrent();
 
diff --git a/src/tests/gl_tests/RenderbufferMultisampleTest.cpp b/src/tests/gl_tests/RenderbufferMultisampleTest.cpp
index 39f7a02f21c03b0c57dff6c5c43c3e79ff2142a6..bbaa8fc81c3b0019bcc0ae2c39dfdaa997f5a51a 100644
--- a/src/tests/gl_tests/RenderbufferMultisampleTest.cpp
+++ b/src/tests/gl_tests/RenderbufferMultisampleTest.cpp
@@ -253,10 +253,7 @@ TEST_P(RenderbufferMultisampleTestES31, ColorBurnBlend)
 }
 
 GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(RenderbufferMultisampleTest);
-ANGLE_INSTANTIATE_TEST_ES3_AND_ES31_AND(
-    RenderbufferMultisampleTest,
-    ES3_METAL().disable(Feature::AlwaysResolveMultisampleRenderBuffers),
-    ES3_METAL().enable(Feature::AlwaysResolveMultisampleRenderBuffers));
+ANGLE_INSTANTIATE_TEST_ES3_AND_ES31(RenderbufferMultisampleTest);
 
 GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(RenderbufferMultisampleTestES31);
 ANGLE_INSTANTIATE_TEST_ES31(RenderbufferMultisampleTestES31);
diff --git a/src/tests/gl_tests/TextureTest.cpp b/src/tests/gl_tests/TextureTest.cpp
index faa8fd8a3e306e67b64814dc172cb99a2fcb9369..515bba49acf50e4d2d79342c0119e258cae07eef 100644
--- a/src/tests/gl_tests/TextureTest.cpp
+++ b/src/tests/gl_tests/TextureTest.cpp
@@ -12326,6 +12326,141 @@ TEST_P(Texture2DTestES3Foveation, DrawWithMsaaFramebuffer)
     EXPECT_PIXEL_COLOR_EQ(0, 0, angle::GLColor::green);
 }
 
+// QCOM framebuffer foveated rendering with multiple attachments
+TEST_P(Texture2DTestES3Foveation, DrawWithMultipleAttachments)
+{
+    ANGLE_SKIP_TEST_IF(!IsGLExtensionEnabled("GL_QCOM_framebuffer_foveated"));
+
+    const GLsizei kSizeW = getWindowWidth();
+    const GLsizei kSizeH = getWindowHeight();
+
+    // Setup sampling texture
+    glBindTexture(GL_TEXTURE_2D, mTexture2D);
+
+    std::vector<GLColor> data(kSizeW * kSizeH);
+    // Generate red / blue checkered pattern
+    for (int i = 0; i < kSizeH; i++)
+    {
+        for (int j = 0; j < kSizeW; j++)
+        {
+            data[(i * kSizeW) + j] = ((i + j) % 2 == 0) ? GLColor::red : GLColor::blue;
+        }
+    }
+
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, kSizeW, kSizeH, 0, GL_RGBA, GL_UNSIGNED_BYTE,
+                 data.data());
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+    EXPECT_GL_NO_ERROR();
+
+    // Draw without foveation
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, mTexture2D);
+
+    glBindFramebuffer(GL_FRAMEBUFFER, 0);
+    glUseProgram(mProgram);
+    drawQuad(mProgram, "position", 0.5f);
+    EXPECT_GL_NO_ERROR();
+
+    // Record original data
+    std::vector<GLColor> originalData(kSizeW * kSizeH, {0, 0, 0, 0});
+    glReadPixels(0, 0, kSizeW, kSizeH, GL_RGBA, GL_UNSIGNED_BYTE, originalData.data());
+
+    // Switch to foveated framebuffer
+    glBindFramebuffer(GL_FRAMEBUFFER, mFramebuffer);
+
+    // Setup mutliple color attachments
+    std::array<GLTexture, 3> colorAttachments;
+    GLenum attachmentBase  = GL_COLOR_ATTACHMENT0;
+    GLuint attachmentIndex = 0;
+    for (GLTexture &attachment : colorAttachments)
+    {
+        glBindTexture(GL_TEXTURE_2D, attachment);
+        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, kSizeW, kSizeH, 0, GL_RGBA, GL_UNSIGNED_BYTE,
+                     nullptr);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+        EXPECT_GL_NO_ERROR();
+
+        glFramebufferTexture2D(GL_FRAMEBUFFER, attachmentBase + attachmentIndex, GL_TEXTURE_2D,
+                               attachment, 0);
+        ASSERT_GL_NO_ERROR();
+        EXPECT_GL_FRAMEBUFFER_COMPLETE(GL_FRAMEBUFFER);
+
+        glBindTexture(GL_TEXTURE_2D, 0);
+
+        attachmentIndex++;
+    }
+
+    // Setup foveation parameters, just need 1 focal point
+    GLuint providedFeatures = 0;
+    glFramebufferFoveationConfigQCOM(mFramebuffer, 1, 1, GL_FOVEATION_ENABLE_BIT_QCOM,
+                                     &providedFeatures);
+    ASSERT_NE(providedFeatures & GL_FOVEATION_ENABLE_BIT_QCOM, 0u);
+
+    glFramebufferFoveationParametersQCOM(mFramebuffer, 0, 0, 0.0f, 0.0f, 8.0f, 8.0f, 0.0f);
+    EXPECT_GL_NO_ERROR();
+
+    constexpr char kFS[] = R"(#version 300 es
+precision highp float;
+
+in vec2 texcoord;
+uniform sampler2D tex;
+
+layout(location = 0) out vec4 color0;
+layout(location = 1) out vec4 color1;
+layout(location = 2) out vec4 color2;
+
+void main()
+{
+    vec4 fragColor = texture(tex, texcoord);
+    color0 = fragColor;
+    color1 = fragColor;
+    color2 = fragColor;
+})";
+
+    ANGLE_GL_PROGRAM(program, getVertexShaderSource(), kFS);
+    glUseProgram(program);
+
+    std::array<GLenum, 3> drawBuffers = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1,
+                                         GL_COLOR_ATTACHMENT2};
+    glDrawBuffers(3, drawBuffers.data());
+
+    // Draw with foveation into multiple attachments
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, mTexture2D);
+    drawQuad(program, "position", 0.5f);
+    EXPECT_GL_NO_ERROR();
+
+    // Verify
+    GLFramebuffer readFBO;
+    glBindFramebuffer(GL_READ_FRAMEBUFFER, readFBO);
+
+    // Use colorAttachments[0]'s content as reference data
+    std::vector<GLColor> referenceData(kSizeW * kSizeH, {0, 0, 0, 0});
+    std::vector<GLColor> result(kSizeW * kSizeH, {0, 0, 0, 0});
+    glFramebufferTexture2D(GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
+                           colorAttachments[0], 0);
+    EXPECT_GL_FRAMEBUFFER_COMPLETE(GL_READ_FRAMEBUFFER);
+    glReadPixels(0, 0, kSizeW, kSizeH, GL_RGBA, GL_UNSIGNED_BYTE, referenceData.data());
+
+    // Foveated rendering should produce content that differs from original data
+    ASSERT(originalData != referenceData);
+
+    // Verify rest of the attachments
+    for (size_t index = 1; index < colorAttachments.size(); index++)
+    {
+        glFramebufferTexture2D(GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
+                               colorAttachments[index], 0);
+        EXPECT_GL_FRAMEBUFFER_COMPLETE(GL_READ_FRAMEBUFFER);
+
+        result.assign(result.size(), {0, 0, 0, 0});
+        glReadPixels(0, 0, kSizeW, kSizeH, GL_RGBA, GL_UNSIGNED_BYTE, result.data());
+
+        ASSERT(referenceData == result);
+    }
+}
+
 // QCOM texture foveated rendering, basic draw
 TEST_P(Texture2DTestES3Foveation, FoveatedTextureDraw)
 {
diff --git a/util/autogen/angle_features_autogen.cpp b/util/autogen/angle_features_autogen.cpp
index e88058987f8106847c4df94afc7cb385cbb19d62..9b361e5606f45968e9a5e8996cc26b1eb0da4955 100644
--- a/util/autogen/angle_features_autogen.cpp
+++ b/util/autogen/angle_features_autogen.cpp
@@ -41,7 +41,6 @@ constexpr PackedEnumMap<Feature, const char *> kFeatureNames = {{
     {Feature::AllowTranslateUniformBlockToStructuredBuffer, "allowTranslateUniformBlockToStructuredBuffer"},
     {Feature::AlwaysCallUseProgramAfterLink, "alwaysCallUseProgramAfterLink"},
     {Feature::AlwaysPreferStagedTextureUploads, "alwaysPreferStagedTextureUploads"},
-    {Feature::AlwaysResolveMultisampleRenderBuffers, "alwaysResolveMultisampleRenderBuffers"},
     {Feature::AlwaysRunLinkSubJobsThreaded, "alwaysRunLinkSubJobsThreaded"},
     {Feature::AlwaysUnbindFramebufferTexture2D, "alwaysUnbindFramebufferTexture2D"},
     {Feature::AlwaysUseManagedStorageModeForBuffers, "alwaysUseManagedStorageModeForBuffers"},
@@ -145,6 +144,7 @@ constexpr PackedEnumMap<Feature, const char *> kFeatureNames = {{
     {Feature::EnableInMemoryMtlLibraryCache, "enableInMemoryMtlLibraryCache"},
     {Feature::EnableMergeClientAttribBuffer, "enableMergeClientAttribBuffer"},
     {Feature::EnableMultisampledRenderToTexture, "enableMultisampledRenderToTexture"},
+    {Feature::EnableMultisampledRenderToTextureOnNonTilers, "enableMultisampledRenderToTextureOnNonTilers"},
     {Feature::EnableParallelCompileAndLink, "enableParallelCompileAndLink"},
     {Feature::EnableParallelMtlLibraryCompilation, "enableParallelMtlLibraryCompilation"},
     {Feature::EnablePipelineCacheDataCompression, "enablePipelineCacheDataCompression"},
@@ -204,6 +204,7 @@ constexpr PackedEnumMap<Feature, const char *> kFeatureNames = {{
     {Feature::HasShaderStencilOutput, "hasShaderStencilOutput"},
     {Feature::HasStencilAutoResolve, "hasStencilAutoResolve"},
     {Feature::HasTextureSwizzle, "hasTextureSwizzle"},
+    {Feature::HasVariableRasterizationRate, "hasVariableRasterizationRate"},
     {Feature::InitFragmentOutputVariables, "initFragmentOutputVariables"},
     {Feature::InitializeCurrentVertexAttributes, "initializeCurrentVertexAttributes"},
     {Feature::InjectAsmStatementIntoLoopBodies, "injectAsmStatementIntoLoopBodies"},
@@ -261,6 +262,7 @@ constexpr PackedEnumMap<Feature, const char *> kFeatureNames = {{
     {Feature::ReadPixelsUsingImplementationColorReadFormatForNorm16, "readPixelsUsingImplementationColorReadFormatForNorm16"},
     {Feature::ReapplyUBOBindingsAfterUsingBinaryProgram, "reapplyUBOBindingsAfterUsingBinaryProgram"},
     {Feature::RegenerateStructNames, "regenerateStructNames"},
+    {Feature::RejectWebglShadersWithUndefinedBehavior, "rejectWebglShadersWithUndefinedBehavior"},
     {Feature::RemoveDynamicIndexingOfSwizzledVector, "removeDynamicIndexingOfSwizzledVector"},
     {Feature::RemoveInvariantAndCentroidForESSL3, "removeInvariantAndCentroidForESSL3"},
     {Feature::RequireGpuFamily2, "requireGpuFamily2"},
diff --git a/util/autogen/angle_features_autogen.h b/util/autogen/angle_features_autogen.h
index b9878bf856c75e1bd044108bd870c1976db88fab..5a42655f64dcfbd5935b6f91d34dd664db203746 100644
--- a/util/autogen/angle_features_autogen.h
+++ b/util/autogen/angle_features_autogen.h
@@ -41,7 +41,6 @@ enum class Feature
     AllowTranslateUniformBlockToStructuredBuffer,
     AlwaysCallUseProgramAfterLink,
     AlwaysPreferStagedTextureUploads,
-    AlwaysResolveMultisampleRenderBuffers,
     AlwaysRunLinkSubJobsThreaded,
     AlwaysUnbindFramebufferTexture2D,
     AlwaysUseManagedStorageModeForBuffers,
@@ -145,6 +144,7 @@ enum class Feature
     EnableInMemoryMtlLibraryCache,
     EnableMergeClientAttribBuffer,
     EnableMultisampledRenderToTexture,
+    EnableMultisampledRenderToTextureOnNonTilers,
     EnableParallelCompileAndLink,
     EnableParallelMtlLibraryCompilation,
     EnablePipelineCacheDataCompression,
@@ -204,6 +204,7 @@ enum class Feature
     HasShaderStencilOutput,
     HasStencilAutoResolve,
     HasTextureSwizzle,
+    HasVariableRasterizationRate,
     InitFragmentOutputVariables,
     InitializeCurrentVertexAttributes,
     InjectAsmStatementIntoLoopBodies,
@@ -261,6 +262,7 @@ enum class Feature
     ReadPixelsUsingImplementationColorReadFormatForNorm16,
     ReapplyUBOBindingsAfterUsingBinaryProgram,
     RegenerateStructNames,
+    RejectWebglShadersWithUndefinedBehavior,
     RemoveDynamicIndexingOfSwizzledVector,
     RemoveInvariantAndCentroidForESSL3,
     RequireGpuFamily2,
diff --git a/util/capture/frame_capture_replay_autogen.cpp b/util/capture/frame_capture_replay_autogen.cpp
index 0356ae084c4e6394c3de340273b2426f9d8c2497..51cf85872ae18efa21c6d94d56e969e41508a659 100644
--- a/util/capture/frame_capture_replay_autogen.cpp
+++ b/util/capture/frame_capture_replay_autogen.cpp
@@ -105,6 +105,10 @@ void ReplayTraceFunctionCall(const CallCapture &call, const TraceFunctionMap &cu
                                captures[3].value.GLbooleanVal, captures[4].value.GLintVal,
                                captures[5].value.GLenumVal, captures[6].value.GLenumVal);
             break;
+        case angle::EntryPoint::GLBindMetalRasterizationRateMapANGLE:
+            glBindMetalRasterizationRateMapANGLE(
+                captures[0].value.GLMTLRasterizationRateMapANGLEVal);
+            break;
         case angle::EntryPoint::GLBindProgramPipeline:
             glBindProgramPipeline(gProgramPipelineMap[captures[0].value.GLuintVal]);
             break;
@@ -1053,6 +1057,11 @@ void ReplayTraceFunctionCall(const CallCapture &call, const TraceFunctionMap &cu
                                          captures[2].value.GLenumVal,
                                          gRenderbufferMap[captures[3].value.GLuintVal]);
             break;
+        case angle::EntryPoint::GLFramebufferResolveRenderbufferWEBKIT:
+            glFramebufferResolveRenderbufferWEBKIT(
+                captures[0].value.GLenumVal, captures[1].value.GLenumVal,
+                captures[2].value.GLenumVal, gRenderbufferMap[captures[3].value.GLuintVal]);
+            break;
         case angle::EntryPoint::GLFramebufferTexture:
             glFramebufferTexture(captures[0].value.GLenumVal, captures[1].value.GLenumVal,
                                  gTextureMap[captures[2].value.GLuintVal],
diff --git a/util/capture/trace_gles_loader_autogen.cpp b/util/capture/trace_gles_loader_autogen.cpp
index 2a2450169abf46c88371eb7cfc3c4f5755db5a84..f746dabe8e8de21fe69bd99d7d9a8e75fa11723f 100644
--- a/util/capture/trace_gles_loader_autogen.cpp
+++ b/util/capture/trace_gles_loader_autogen.cpp
@@ -630,6 +630,8 @@ ANGLE_TRACE_LOADER_EXPORT PFNGLSAMPLEMASKIANGLEPROC t_glSampleMaskiANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLTEXSTORAGE2DMULTISAMPLEANGLEPROC t_glTexStorage2DMultisampleANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC
     t_glGetTranslatedShaderSourceANGLE;
+ANGLE_TRACE_LOADER_EXPORT PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC
+    t_glBindMetalRasterizationRateMapANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLACQUIRETEXTURESANGLEPROC t_glAcquireTexturesANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLRELEASETEXTURESANGLEPROC t_glReleaseTexturesANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLBINDUNIFORMLOCATIONCHROMIUMPROC t_glBindUniformLocationCHROMIUM;
@@ -879,6 +881,8 @@ ANGLE_TRACE_LOADER_EXPORT PFNGLTEXTUREFOVEATIONPARAMETERSQCOMPROC
     t_glTextureFoveationParametersQCOM;
 ANGLE_TRACE_LOADER_EXPORT PFNGLENDTILINGQCOMPROC t_glEndTilingQCOM;
 ANGLE_TRACE_LOADER_EXPORT PFNGLSTARTTILINGQCOMPROC t_glStartTilingQCOM;
+ANGLE_TRACE_LOADER_EXPORT PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC
+    t_glFramebufferResolveRenderbufferWEBKIT;
 ANGLE_TRACE_LOADER_EXPORT PFNGLDRAWTEXFOESPROC t_glDrawTexfOES;
 ANGLE_TRACE_LOADER_EXPORT PFNGLDRAWTEXFVOESPROC t_glDrawTexfvOES;
 ANGLE_TRACE_LOADER_EXPORT PFNGLDRAWTEXIOESPROC t_glDrawTexiOES;
@@ -1845,6 +1849,9 @@ void LoadTraceGLES(LoadProc loadProc)
         loadProc("glTexStorage2DMultisampleANGLE"));
     t_glGetTranslatedShaderSourceANGLE = reinterpret_cast<PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC>(
         loadProc("glGetTranslatedShaderSourceANGLE"));
+    t_glBindMetalRasterizationRateMapANGLE =
+        reinterpret_cast<PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC>(
+            loadProc("glBindMetalRasterizationRateMapANGLE"));
     t_glAcquireTexturesANGLE =
         reinterpret_cast<PFNGLACQUIRETEXTURESANGLEPROC>(loadProc("glAcquireTexturesANGLE"));
     t_glReleaseTexturesANGLE =
@@ -2274,6 +2281,9 @@ void LoadTraceGLES(LoadProc loadProc)
         loadProc("glTextureFoveationParametersQCOM"));
     t_glEndTilingQCOM   = reinterpret_cast<PFNGLENDTILINGQCOMPROC>(loadProc("glEndTilingQCOM"));
     t_glStartTilingQCOM = reinterpret_cast<PFNGLSTARTTILINGQCOMPROC>(loadProc("glStartTilingQCOM"));
+    t_glFramebufferResolveRenderbufferWEBKIT =
+        reinterpret_cast<PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC>(
+            loadProc("glFramebufferResolveRenderbufferWEBKIT"));
     t_glDrawTexfOES  = reinterpret_cast<PFNGLDRAWTEXFOESPROC>(loadProc("glDrawTexfOES"));
     t_glDrawTexfvOES = reinterpret_cast<PFNGLDRAWTEXFVOESPROC>(loadProc("glDrawTexfvOES"));
     t_glDrawTexiOES  = reinterpret_cast<PFNGLDRAWTEXIOESPROC>(loadProc("glDrawTexiOES"));
diff --git a/util/capture/trace_gles_loader_autogen.h b/util/capture/trace_gles_loader_autogen.h
index c1e82cb5725914d533051df5e521b01e2fb872ff..64a5dee4e3114de59ff638e098a3f4f56e4f853e 100644
--- a/util/capture/trace_gles_loader_autogen.h
+++ b/util/capture/trace_gles_loader_autogen.h
@@ -595,6 +595,7 @@
 #define glSampleMaskiANGLE t_glSampleMaskiANGLE
 #define glTexStorage2DMultisampleANGLE t_glTexStorage2DMultisampleANGLE
 #define glGetTranslatedShaderSourceANGLE t_glGetTranslatedShaderSourceANGLE
+#define glBindMetalRasterizationRateMapANGLE t_glBindMetalRasterizationRateMapANGLE
 #define glAcquireTexturesANGLE t_glAcquireTexturesANGLE
 #define glReleaseTexturesANGLE t_glReleaseTexturesANGLE
 #define glBindUniformLocationCHROMIUM t_glBindUniformLocationCHROMIUM
@@ -827,6 +828,7 @@
 #define glTextureFoveationParametersQCOM t_glTextureFoveationParametersQCOM
 #define glEndTilingQCOM t_glEndTilingQCOM
 #define glStartTilingQCOM t_glStartTilingQCOM
+#define glFramebufferResolveRenderbufferWEBKIT t_glFramebufferResolveRenderbufferWEBKIT
 #define glDrawTexfOES t_glDrawTexfOES
 #define glDrawTexfvOES t_glDrawTexfvOES
 #define glDrawTexiOES t_glDrawTexiOES
@@ -1515,6 +1517,8 @@ ANGLE_TRACE_LOADER_EXPORT extern PFNGLTEXSTORAGE2DMULTISAMPLEANGLEPROC
     t_glTexStorage2DMultisampleANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC
     t_glGetTranslatedShaderSourceANGLE;
+ANGLE_TRACE_LOADER_EXPORT extern PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC
+    t_glBindMetalRasterizationRateMapANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLACQUIRETEXTURESANGLEPROC t_glAcquireTexturesANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLRELEASETEXTURESANGLEPROC t_glReleaseTexturesANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLBINDUNIFORMLOCATIONCHROMIUMPROC
@@ -1782,6 +1786,8 @@ ANGLE_TRACE_LOADER_EXPORT extern PFNGLTEXTUREFOVEATIONPARAMETERSQCOMPROC
     t_glTextureFoveationParametersQCOM;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLENDTILINGQCOMPROC t_glEndTilingQCOM;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLSTARTTILINGQCOMPROC t_glStartTilingQCOM;
+ANGLE_TRACE_LOADER_EXPORT extern PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC
+    t_glFramebufferResolveRenderbufferWEBKIT;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLDRAWTEXFOESPROC t_glDrawTexfOES;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLDRAWTEXFVOESPROC t_glDrawTexfvOES;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLDRAWTEXIOESPROC t_glDrawTexiOES;
diff --git a/util/capture/trace_interpreter_autogen.cpp b/util/capture/trace_interpreter_autogen.cpp
index 7e73814693678a881dd1f461afa8b8d0c4e33606..dbafb580bcc61702fedfd189c7c42e71d556d4e4 100644
--- a/util/capture/trace_interpreter_autogen.cpp
+++ b/util/capture/trace_interpreter_autogen.cpp
@@ -896,6 +896,13 @@ CallCapture ParseCallCapture(const Token &nameToken,
             paramTokens, strings);
         return CallCapture(EntryPoint::GLBindImageTexture, std::move(params));
     }
+    if (strcmp(nameToken, "glBindMetalRasterizationRateMapANGLE") == 0)
+    {
+        ParamBuffer params =
+            ParseParameters<std::remove_pointer<PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC>::type>(
+                paramTokens, strings);
+        return CallCapture(EntryPoint::GLBindMetalRasterizationRateMapANGLE, std::move(params));
+    }
     if (strcmp(nameToken, "glBindProgramPipeline") == 0)
     {
         ParamBuffer params =
@@ -2290,6 +2297,13 @@ CallCapture ParseCallCapture(const Token &nameToken,
                 paramTokens, strings);
         return CallCapture(EntryPoint::GLFramebufferRenderbufferOES, std::move(params));
     }
+    if (strcmp(nameToken, "glFramebufferResolveRenderbufferWEBKIT") == 0)
+    {
+        ParamBuffer params = ParseParameters<
+            std::remove_pointer<PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC>::type>(paramTokens,
+                                                                                      strings);
+        return CallCapture(EntryPoint::GLFramebufferResolveRenderbufferWEBKIT, std::move(params));
+    }
     if (strcmp(nameToken, "glFramebufferTexture") == 0)
     {
         ParamBuffer params =
diff --git a/util/gles_loader_autogen.cpp b/util/gles_loader_autogen.cpp
index 65c2f5ab70c3a73d292c4225b83d2ce9403eeef0..46d6b09779d604793cf8c6895aa64663e4385c28 100644
--- a/util/gles_loader_autogen.cpp
+++ b/util/gles_loader_autogen.cpp
@@ -607,6 +607,8 @@ ANGLE_UTIL_EXPORT PFNGLGETMULTISAMPLEFVANGLEPROC l_glGetMultisamplefvANGLE;
 ANGLE_UTIL_EXPORT PFNGLSAMPLEMASKIANGLEPROC l_glSampleMaskiANGLE;
 ANGLE_UTIL_EXPORT PFNGLTEXSTORAGE2DMULTISAMPLEANGLEPROC l_glTexStorage2DMultisampleANGLE;
 ANGLE_UTIL_EXPORT PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC l_glGetTranslatedShaderSourceANGLE;
+ANGLE_UTIL_EXPORT PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC
+    l_glBindMetalRasterizationRateMapANGLE;
 ANGLE_UTIL_EXPORT PFNGLACQUIRETEXTURESANGLEPROC l_glAcquireTexturesANGLE;
 ANGLE_UTIL_EXPORT PFNGLRELEASETEXTURESANGLEPROC l_glReleaseTexturesANGLE;
 ANGLE_UTIL_EXPORT PFNGLBINDUNIFORMLOCATIONCHROMIUMPROC l_glBindUniformLocationCHROMIUM;
@@ -847,6 +849,8 @@ ANGLE_UTIL_EXPORT PFNGLSHADINGRATEQCOMPROC l_glShadingRateQCOM;
 ANGLE_UTIL_EXPORT PFNGLTEXTUREFOVEATIONPARAMETERSQCOMPROC l_glTextureFoveationParametersQCOM;
 ANGLE_UTIL_EXPORT PFNGLENDTILINGQCOMPROC l_glEndTilingQCOM;
 ANGLE_UTIL_EXPORT PFNGLSTARTTILINGQCOMPROC l_glStartTilingQCOM;
+ANGLE_UTIL_EXPORT PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC
+    l_glFramebufferResolveRenderbufferWEBKIT;
 ANGLE_UTIL_EXPORT PFNGLDRAWTEXFOESPROC l_glDrawTexfOES;
 ANGLE_UTIL_EXPORT PFNGLDRAWTEXFVOESPROC l_glDrawTexfvOES;
 ANGLE_UTIL_EXPORT PFNGLDRAWTEXIOESPROC l_glDrawTexiOES;
@@ -1812,6 +1816,9 @@ void LoadUtilGLES(LoadProc loadProc)
         loadProc("glTexStorage2DMultisampleANGLE"));
     l_glGetTranslatedShaderSourceANGLE = reinterpret_cast<PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC>(
         loadProc("glGetTranslatedShaderSourceANGLE"));
+    l_glBindMetalRasterizationRateMapANGLE =
+        reinterpret_cast<PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC>(
+            loadProc("glBindMetalRasterizationRateMapANGLE"));
     l_glAcquireTexturesANGLE =
         reinterpret_cast<PFNGLACQUIRETEXTURESANGLEPROC>(loadProc("glAcquireTexturesANGLE"));
     l_glReleaseTexturesANGLE =
@@ -2241,6 +2248,9 @@ void LoadUtilGLES(LoadProc loadProc)
         loadProc("glTextureFoveationParametersQCOM"));
     l_glEndTilingQCOM   = reinterpret_cast<PFNGLENDTILINGQCOMPROC>(loadProc("glEndTilingQCOM"));
     l_glStartTilingQCOM = reinterpret_cast<PFNGLSTARTTILINGQCOMPROC>(loadProc("glStartTilingQCOM"));
+    l_glFramebufferResolveRenderbufferWEBKIT =
+        reinterpret_cast<PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC>(
+            loadProc("glFramebufferResolveRenderbufferWEBKIT"));
     l_glDrawTexfOES  = reinterpret_cast<PFNGLDRAWTEXFOESPROC>(loadProc("glDrawTexfOES"));
     l_glDrawTexfvOES = reinterpret_cast<PFNGLDRAWTEXFVOESPROC>(loadProc("glDrawTexfvOES"));
     l_glDrawTexiOES  = reinterpret_cast<PFNGLDRAWTEXIOESPROC>(loadProc("glDrawTexiOES"));
diff --git a/util/gles_loader_autogen.h b/util/gles_loader_autogen.h
index 2ffeb4c8deebff80248ffc9c07230322c1a5e956..0ecc4a1a2586396e87bb1946c12657b9d84292f1 100644
--- a/util/gles_loader_autogen.h
+++ b/util/gles_loader_autogen.h
@@ -595,6 +595,7 @@
 #define glSampleMaskiANGLE l_glSampleMaskiANGLE
 #define glTexStorage2DMultisampleANGLE l_glTexStorage2DMultisampleANGLE
 #define glGetTranslatedShaderSourceANGLE l_glGetTranslatedShaderSourceANGLE
+#define glBindMetalRasterizationRateMapANGLE l_glBindMetalRasterizationRateMapANGLE
 #define glAcquireTexturesANGLE l_glAcquireTexturesANGLE
 #define glReleaseTexturesANGLE l_glReleaseTexturesANGLE
 #define glBindUniformLocationCHROMIUM l_glBindUniformLocationCHROMIUM
@@ -827,6 +828,7 @@
 #define glTextureFoveationParametersQCOM l_glTextureFoveationParametersQCOM
 #define glEndTilingQCOM l_glEndTilingQCOM
 #define glStartTilingQCOM l_glStartTilingQCOM
+#define glFramebufferResolveRenderbufferWEBKIT l_glFramebufferResolveRenderbufferWEBKIT
 #define glDrawTexfOES l_glDrawTexfOES
 #define glDrawTexfvOES l_glDrawTexfvOES
 #define glDrawTexiOES l_glDrawTexiOES
@@ -1480,6 +1482,8 @@ ANGLE_UTIL_EXPORT extern PFNGLGETMULTISAMPLEFVANGLEPROC l_glGetMultisamplefvANGL
 ANGLE_UTIL_EXPORT extern PFNGLSAMPLEMASKIANGLEPROC l_glSampleMaskiANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLTEXSTORAGE2DMULTISAMPLEANGLEPROC l_glTexStorage2DMultisampleANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC l_glGetTranslatedShaderSourceANGLE;
+ANGLE_UTIL_EXPORT extern PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC
+    l_glBindMetalRasterizationRateMapANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLACQUIRETEXTURESANGLEPROC l_glAcquireTexturesANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLRELEASETEXTURESANGLEPROC l_glReleaseTexturesANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLBINDUNIFORMLOCATIONCHROMIUMPROC l_glBindUniformLocationCHROMIUM;
@@ -1722,6 +1726,8 @@ ANGLE_UTIL_EXPORT extern PFNGLSHADINGRATEQCOMPROC l_glShadingRateQCOM;
 ANGLE_UTIL_EXPORT extern PFNGLTEXTUREFOVEATIONPARAMETERSQCOMPROC l_glTextureFoveationParametersQCOM;
 ANGLE_UTIL_EXPORT extern PFNGLENDTILINGQCOMPROC l_glEndTilingQCOM;
 ANGLE_UTIL_EXPORT extern PFNGLSTARTTILINGQCOMPROC l_glStartTilingQCOM;
+ANGLE_UTIL_EXPORT extern PFNGLFRAMEBUFFERRESOLVERENDERBUFFERWEBKITPROC
+    l_glFramebufferResolveRenderbufferWEBKIT;
 ANGLE_UTIL_EXPORT extern PFNGLDRAWTEXFOESPROC l_glDrawTexfOES;
 ANGLE_UTIL_EXPORT extern PFNGLDRAWTEXFVOESPROC l_glDrawTexfvOES;
 ANGLE_UTIL_EXPORT extern PFNGLDRAWTEXIOESPROC l_glDrawTexiOES;
