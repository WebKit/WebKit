#line 17 "glslang.l"
// GENERATED FILE - DO NOT EDIT.
// Generated by generate_parser.py from glslang.l
//
// Copyright 2019 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// glslang.l:
//   Lexer for the OpenGL shading language.

// Ignore errors in auto-generated code.
#if defined(__GNUC__)
#    pragma GCC diagnostic ignored "-Wswitch-enum"
#    pragma GCC diagnostic ignored "-Wunused-function"
#    pragma GCC diagnostic ignored "-Wunused-variable"
#elif defined(_MSC_VER)
#    pragma warning(disable : 4005)
#    pragma warning(disable : 4065)
#    pragma warning(disable : 4189)
#    pragma warning(disable : 4244)
#    pragma warning(disable : 4505)
#    pragma warning(disable : 4701)
#    pragma warning(disable : 4702)
#endif
#if defined(__clang__)
#    pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#    if defined(__APPLE__)
// Older clang versions don't have -Wextra-semi-stmt, and detecting Apple clang versions is
// difficult because they use different yet overlapping version numbers vs. regular clang.
#        pragma clang diagnostic ignored "-Wunknown-warning-option"
#    endif
// Flex isn't semi-colon clean.
#    pragma clang diagnostic ignored "-Wextra-semi-stmt"
#    pragma clang diagnostic ignored "-Wunreachable-code"
#endif

#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#    define FLEX_BETA
#endif

#ifdef yyget_lval
#    define yyget_lval_ALREADY_DEFINED
#else
#    define yyget_lval yyget_lval
#endif

#ifdef yyset_lval
#    define yyset_lval_ALREADY_DEFINED
#else
#    define yyset_lval yyset_lval
#endif

#ifdef yyget_lloc
#    define yyget_lloc_ALREADY_DEFINED
#else
#    define yyget_lloc yyget_lloc
#endif

#ifdef yyset_lloc
#    define yyset_lloc_ALREADY_DEFINED
#else
#    define yyset_lloc yyset_lloc
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#    define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#    if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#        ifndef __STDC_LIMIT_MACROS
#            define __STDC_LIMIT_MACROS 1
#        endif

#        include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#    else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#        ifndef INT8_MIN
#            define INT8_MIN (-128)
#        endif
#        ifndef INT16_MIN
#            define INT16_MIN (-32767 - 1)
#        endif
#        ifndef INT32_MIN
#            define INT32_MIN (-2147483647 - 1)
#        endif
#        ifndef INT8_MAX
#            define INT8_MAX (127)
#        endif
#        ifndef INT16_MAX
#            define INT16_MAX (32767)
#        endif
#        ifndef INT32_MAX
#            define INT32_MAX (2147483647)
#        endif
#        ifndef UINT8_MAX
#            define UINT8_MAX (255U)
#        endif
#        ifndef UINT16_MAX
#            define UINT16_MAX (65535U)
#        endif
#        ifndef UINT32_MAX
#            define UINT32_MAX (4294967295U)
#        endif

#        ifndef SIZE_MAX
#            define SIZE_MAX (~(size_t)0)
#        endif

#    endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#    define yynoreturn __attribute__((__noreturn__))
#else
#    define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR)(c))

/* An opaque pointer. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#    define YY_TYPEDEF_YY_SCANNER_T
typedef void *yyscan_t;
#endif

/* For convenience, these vars (plus the bison vars far below)
   are macros in the reentrant scanner. */
#define yyin yyg->yyin_r
#define yyout yyg->yyout_r
#define yyextra yyg->yyextra_r
#define yyleng yyg->yyleng_r
#define yytext yyg->yytext_r
#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
#define yy_flex_debug yyg->yy_flex_debug_r

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yyg->yy_start = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yyg->yy_start - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin, yyscanner)
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#    ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#        define YY_BUF_SIZE 32768
#    else
#        define YY_BUF_SIZE 16384
#    endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#    define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#    define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
 *       access to the local variable yy_act. Since yyless() is a macro, it would break
 *       existing scanners that call yyless() from OUTSIDE yylex.
 *       One obvious solution it to make yy_act a global. I tried that, and saw
 *       a 5% performance hit in a non-yylineno scanner, because yy_act is
 *       normally declared as a register variable-- so it is not worth it.
 */
#define YY_LESS_LINENO(n)                  \
    do                                     \
    {                                      \
        int yyl;                           \
        for (yyl = n; yyl < yyleng; ++yyl) \
            if (yytext[yyl] == '\n')       \
                --yylineno;                \
    } while (0)
#define YY_LINENO_REWIND_TO(dst)             \
    do                                       \
    {                                        \
        const char *p;                       \
        for (p = yy_cp - 1; p >= (dst); --p) \
            if (*p == '\n')                  \
                --yylineno;                  \
    } while (0)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                         \
    do                                                                    \
    {                                                                     \
        /* Undo effects of setting up yytext. */                          \
        int yyless_macro_arg = (n);                                       \
        YY_LESS_LINENO(yyless_macro_arg);                                 \
        *yy_cp = yyg->yy_hold_char;                                       \
        YY_RESTORE_YY_MORE_OFFSET                                         \
        yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
        YY_DO_BEFORE_ACTION; /* set up yytext again */                    \
    } while (0)
#define unput(c) yyunput(c, yyg->yytext_ptr, yyscanner)

#ifndef YY_STRUCT_YY_BUFFER_STATE
#    define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
{
    FILE *yy_input_file;

    char *yy_ch_buf;  /* input buffer */
    char *yy_buf_pos; /* current position in input buffer */

    /* Size of input buffer in bytes, not including room for EOB
     * characters.
     */
    int yy_buf_size;

    /* Number of characters read into yy_ch_buf, not including EOB
     * characters.
     */
    int yy_n_chars;

    /* Whether we "own" the buffer - i.e., we know we created it,
     * and can realloc() it to grow it, and should free() it to
     * delete it.
     */
    int yy_is_our_buffer;

    /* Whether this is an "interactive" input source; if so, and
     * if we're using stdio for input, then we want to use getc()
     * instead of fread(), to make sure we stop fetching input after
     * each newline.
     */
    int yy_is_interactive;

    /* Whether we're considered to be at the beginning of a line.
     * If so, '^' rules will be active on the next match, otherwise
     * not.
     */
    int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */

    /* Whether to try to fill the input buffer when we reach the
     * end of it.
     */
    int yy_fill_buffer;

    int yy_buffer_status;

#    define YY_BUFFER_NEW 0
#    define YY_BUFFER_NORMAL 1
    /* When an EOF's been seen but there's still some text to process
     * then we mark the buffer as YY_EOF_PENDING, to indicate that we
     * shouldn't try reading from the input source any more.  We might
     * still have a bunch of tokens to match, though, because of
     * possible backing-up.
     *
     * When we actually see the EOF, we change the status to "new"
     * (via yyrestart()), so that the user can continue scanning by
     * just pointing yyin at a new input file.
     */
#    define YY_BUFFER_EOF_PENDING 2
};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER \
    (yyg->yy_buffer_stack ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]

void yyrestart(FILE *input_file, yyscan_t yyscanner);
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer, yyscan_t yyscanner);
YY_BUFFER_STATE yy_create_buffer(FILE *file, int size, yyscan_t yyscanner);
void yy_delete_buffer(YY_BUFFER_STATE b, yyscan_t yyscanner);
void yy_flush_buffer(YY_BUFFER_STATE b, yyscan_t yyscanner);
void yypush_buffer_state(YY_BUFFER_STATE new_buffer, yyscan_t yyscanner);
void yypop_buffer_state(yyscan_t yyscanner);

static void yyensure_buffer_stack(yyscan_t yyscanner);
static void yy_load_buffer_state(yyscan_t yyscanner);
static void yy_init_buffer(YY_BUFFER_STATE b, FILE *file, yyscan_t yyscanner);
#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER, yyscanner)

YY_BUFFER_STATE yy_scan_buffer(char *base, yy_size_t size, yyscan_t yyscanner);
YY_BUFFER_STATE yy_scan_string(const char *yy_str, yyscan_t yyscanner);
YY_BUFFER_STATE yy_scan_bytes(const char *bytes, int len, yyscan_t yyscanner);

void *yyalloc(yy_size_t, yyscan_t yyscanner);
void *yyrealloc(void *, yy_size_t, yyscan_t yyscanner);
void yyfree(void *, yyscan_t yyscanner);

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive)                                             \
    {                                                                                  \
        if (!YY_CURRENT_BUFFER)                                                        \
        {                                                                              \
            yyensure_buffer_stack(yyscanner);                                          \
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE, yyscanner); \
        }                                                                              \
        YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;                  \
    }
#define yy_set_bol(at_bol)                                                             \
    {                                                                                  \
        if (!YY_CURRENT_BUFFER)                                                        \
        {                                                                              \
            yyensure_buffer_stack(yyscanner);                                          \
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE, yyscanner); \
        }                                                                              \
        YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                                  \
    }
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

#define yywrap(yyscanner) (/*CONSTCOND*/ 1)
#define YY_SKIP_YYWRAP
typedef flex_uint8_t YY_CHAR;

typedef int yy_state_type;

#define yytext_ptr yytext_r

static yy_state_type yy_get_previous_state(yyscan_t yyscanner);
static yy_state_type yy_try_NUL_trans(yy_state_type current_state, yyscan_t yyscanner);
static int yy_get_next_buffer(yyscan_t yyscanner);
static void yynoreturn yy_fatal_error(const char *msg, yyscan_t yyscanner);

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION                   \
    yyg->yytext_ptr   = yy_bp;                \
    yyleng            = (int)(yy_cp - yy_bp); \
    yyg->yy_hold_char = *yy_cp;               \
    *yy_cp            = '\0';                 \
    yyg->yy_c_buf_p   = yy_cp;
#define YY_NUM_RULES 259
#define YY_END_OF_BUFFER 260
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
{
    flex_int32_t yy_verify;
    flex_int32_t yy_nxt;
};
static const flex_int16_t yy_accept[982] = {
    0,   0,   0,   0,   0,   260, 258, 257, 257, 241, 247, 252, 236, 237, 245, 244, 233,
    242, 240, 246, 199, 199, 234, 230, 248, 235, 249, 253, 196, 238, 239, 251, 196, 196,
    196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196,
    196, 196, 196, 231, 250, 232, 243, 256, 255, 259, 254, 227, 213, 232, 221, 216, 211,
    219, 209, 220, 210, 205, 212, 204, 198, 199, 0,   202, 0,   239, 231, 238, 228, 224,
    226, 225, 229, 196, 217, 223, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196,

    196, 196, 196, 196, 13,  196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196,
    196, 16,  196, 196, 26,  196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196,
    196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196,
    196, 196, 196, 196, 196, 196, 196, 196, 196, 218, 222, 254, 0,   208, 204, 0,   207,
    201, 0,   203, 197, 214, 215, 196, 196, 156, 196, 196, 196, 196, 196, 196, 196, 196,
    196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196,

    196, 14,  196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 31,  196, 196, 196, 196,
    196, 196, 196, 196, 196, 196, 196, 196, 196, 27,  196, 196, 196, 196, 196, 196, 196,
    196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196,
    196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 0,   205, 0,
    204, 206, 200, 196, 196, 196, 196, 34,  196, 196, 196, 19,  193, 196, 196, 196, 196,
    196, 196, 196, 196, 196, 196, 17,  159, 196, 196, 196, 196, 22,  196, 196,

    163, 174, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 171,
    4,   39,  40,  41,  196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196,
    196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 162, 35,  196, 196,
    32,  196, 196, 196, 196, 196, 196, 196, 196, 51,  52,  53,  33,  196, 196, 196, 196,
    196, 196, 196, 196, 11,  196, 57,  58,  59,  196, 157, 196, 196, 7,   196, 196, 196,
    196, 183, 184, 185, 196, 36,  196, 175, 30,  186, 187, 188, 2,   180, 181,

    182, 196, 196, 196, 28,  178, 196, 196, 196, 196, 196, 196, 54,  55,  56,  196, 196,
    196, 196, 196, 196, 196, 196, 196, 196, 196, 25,  196, 196, 196, 196, 196, 196, 196,
    196, 196, 172, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 158, 196, 196,
    196, 195, 60,  61,  62,  196, 196, 15,  196, 196, 196, 135, 196, 196, 9,   196, 196,
    133, 196, 196, 196, 173, 168, 136, 196, 196, 196, 196, 196, 196, 164, 196, 196, 196,
    196, 196, 196, 97,  42,  45,  47,  46,  43,  49,  48,  50,  44,  196, 196,

    196, 196, 179, 155, 196, 196, 196, 166, 196, 196, 196, 38,  126, 29,  192, 23,  167,
    96,  196, 177, 18,  196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196,
    196, 196, 196, 196, 20,  37,  196, 196, 196, 196, 196, 196, 137, 102, 108, 196, 196,
    196, 196, 196, 196, 99,  101, 3,   196, 196, 196, 196, 196, 127, 196, 196, 196, 196,
    196, 196, 196, 160, 196, 196, 196, 196, 196, 8,   196, 196, 196, 10,  196, 196, 196,
    196, 196, 196, 21,  122, 12,  169, 138, 103, 110, 196, 196, 196, 196, 196,

    196, 196, 196, 196, 196, 196, 196, 196, 196, 165, 196, 196, 196, 196, 120, 131, 123,
    196, 196, 196, 196, 196, 196, 196, 196, 161, 139, 104, 109, 196, 196, 176, 196, 196,
    124, 196, 196, 196, 196, 6,   196, 196, 196, 196, 196, 196, 196, 196, 196, 113, 170,
    1,   196, 196, 196, 196, 196, 196, 196, 194, 196, 134, 196, 5,   189, 63,  66,  196,
    196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 121, 196, 196,
    196, 196, 196, 196, 111, 196, 196, 196, 196, 196, 196, 196, 149, 71,  72,

    196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 132,
    196, 196, 196, 112, 196, 151, 76,  77,  196, 196, 196, 196, 125, 196, 196, 196, 196,
    196, 196, 196, 196, 117, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196,
    196, 196, 70,  196, 196, 196, 196, 64,  196, 196, 196, 196, 196, 196, 196, 196, 196,
    196, 196, 196, 196, 196, 196, 196, 196, 118, 196, 140, 196, 105, 196, 196, 196, 196,
    196, 75,  196, 196, 73,  196, 196, 196, 196, 196, 196, 196, 196, 196, 196,

    196, 196, 196, 196, 196, 196, 196, 119, 196, 196, 196, 196, 80,  196, 196, 78,  196,
    196, 141, 106, 196, 196, 143, 196, 144, 196, 196, 196, 196, 196, 196, 196, 196, 196,
    24,  196, 196, 196, 196, 196, 68,  196, 67,  89,  196, 196, 196, 196, 142, 107, 196,
    196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 114, 196, 196, 196, 196,
    153, 92,  196, 196, 196, 147, 196, 69,  196, 196, 196, 196, 196, 196, 196, 196, 196,
    196, 196, 196, 154, 94,  196, 196, 196, 115, 196, 196, 196, 150, 74,  196,

    196, 196, 128, 196, 190, 196, 196, 196, 81,  196, 196, 196, 196, 116, 196, 152, 79,
    196, 196, 196, 196, 196, 196, 129, 196, 196, 196, 196, 196, 85,  196, 88,  196, 196,
    196, 130, 196, 196, 196, 196, 196, 196, 86,  91,  196, 196, 196, 196, 196, 82,  196,
    95,  87,  93,  98,  196, 145, 146, 100, 196, 196, 196, 196, 65,  196, 196, 196, 191,
    196, 196, 148, 83,  196, 196, 196, 196, 90,  196, 196, 84,  0};

static const YY_CHAR yy_ec[256] = {
    0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  2,  2,  2,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  4,  1,  1,  1,  5,  6,  1,  7,  8,
    9,  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
    30, 1,  31, 32, 33, 34, 35, 36, 37, 38, 38, 38, 38, 39, 40, 41, 42, 38, 38, 43, 44,
    45, 46, 47, 48, 49, 50, 38, 51, 1,  52, 53, 54, 1,  55, 56, 57, 58,

    59, 60, 61, 62, 63, 38, 64, 65, 66, 67, 68, 69, 38, 70, 71, 72, 73, 74, 75, 76, 77,
    78, 79, 80, 81, 82, 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1};

static const YY_CHAR yy_meta[83] = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 3, 3, 3, 3, 3, 3,
                                    3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 3, 5, 6, 6, 6, 6, 6,
                                    6, 6, 6, 6, 7, 6, 6, 6, 6, 1, 1, 1, 6, 4, 4, 4, 4, 3, 5, 6, 6,
                                    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 1, 1, 1, 1};

static const flex_int16_t yy_base[988] = {
    0,    0,    0,    82,   0,    1237, 1238, 1238, 1238, 1208, 137,  161,  1238, 1238, 1207,
    158,  1238, 157,  155,  1206, 177,  168,  1204, 1238, 177,  1204, 155,  1238, 0,    1238,
    1238, 160,  1177, 149,  160,  170,  148,  143,  177,  1162, 184,  194,  163,  132,  169,
    1156, 189,  1169, 209,  208,  220,  218,  147,  1154, 1238, 215,  1238, 1238, 1238, 1238,
    1238, 0,    1238, 1238, 1238, 1238, 1238, 1238, 1238, 1238, 1238, 1238, 220,  1238, 257,
    250,  263,  322,  1238, 0,    1238, 1238, 1238, 1198, 1238, 1238, 1238, 1197, 0,    1238,
    1238, 1153, 1151, 1156, 229,  1153, 1161, 1159, 1159, 1146, 1149,

    1160, 238,  1154, 1142, 1139, 1152, 1139, 1136, 1136, 1142, 237,  235,  1136, 1146, 1132,
    1138, 1141, 1142, 0,    1134, 1144, 246,  1135, 1142, 1123, 1136, 1117, 252,  1121, 1134,
    1125, 243,  1118, 278,  1113, 1129, 1131, 253,  1120, 292,  1107, 1116, 294,  296,  1120,
    1116, 1118, 1107, 1110, 182,  258,  1115, 296,  1118, 1106, 1118, 265,  1111, 1110, 1098,
    1238, 1238, 0,    351,  1238, 318,  369,  1238, 1238, 379,  389,  285,  1238, 1238, 1116,
    1107, 0,    1103, 1098, 1102, 1111, 1105, 1107, 355,  1091, 1091, 1102, 1094, 284,  1104,
    1101, 1101, 1099, 1096, 1088, 1094, 1081, 1079, 1091, 1077,

    1093, 0,    1090, 1078, 1085, 1082, 1086, 1087, 1080, 1077, 1066, 1065, 1078, 1081, 1059,
    1068, 1079, 1075, 1063, 1069, 1060, 398,  1065, 1068, 1059, 1066, 1055, 1059, 1050, 1064,
    1061, 1062, 1053, 1059, 308,  1043, 1046, 1044, 1043, 1053, 1043, 1038, 1036, 1038, 1048,
    1034, 1036, 1033, 1044, 1043, 1046, 1028, 358,  1036, 1022, 1031, 1029, 1038, 1017, 402,
    1035, 1037, 1026, 1018, 1056, 413,  423,  445,  455,  1238, 1238, 1022, 1013, 1023, 1022,
    0,    1020, 1024, 405,  0,    0,    1012, 1010, 1010, 1011, 1006, 1014, 1003, 1020, 1009,
    433,  0,    0,    1003, 1013, 1012, 1012, 0,    997,  436,

    0,    0,    999,  439,  1006, 1007, 998,  992,  991,  992,  991,  1001, 990,  361,  463,
    985,  0,    0,    981,  980,  979,  981,  982,  987,  981,  977,  990,  985,  985,  981,
    982,  981,  975,  969,  971,  970,  974,  979,  965,  968,  963,  971,  976,  964,  961,
    973,  964,  0,    0,    970,  966,  0,    958,  958,  963,  964,  953,  960,  467,  957,
    0,    0,    0,    0,    947,  959,  958,  945,  946,  955,  956,  956,  0,    941,  0,
    0,    0,    942,  0,    950,  941,  0,    940,  941,  935,  945,  0,    0,    0,    936,
    0,    932,  0,    0,    0,    0,    0,    0,    0,    0,

    0,    942,  471,  941,  0,    0,    939,  935,  932,  931,  980,  979,  0,    0,    0,
    921,  475,  478,  481,  926,  922,  927,  918,  916,  929,  914,  0,    946,  913,  926,
    915,  911,  917,  912,  919,  919,  0,    916,  913,  917,  901,  899,  902,  908,  914,
    909,  908,  896,  0,    898,  899,  898,  0,    0,    0,    0,    895,  898,  0,    892,
    902,  893,  0,    903,  883,  0,    892,  887,  0,    880,  880,  893,  0,    895,  0,
    489,  915,  914,  913,  873,  872,  0,    889,  888,  903,  882,  924,  915,  0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    869,  882,

    869,  866,  0,    0,    871,  865,  449,  0,    867,  874,  873,  0,    859,  0,    0,
    0,    0,    0,    856,  0,    0,    855,  866,  493,  859,  865,  884,  863,  860,  855,
    852,  874,  858,  843,  843,  856,  841,  853,  0,    0,    846,  876,  875,  874,  834,
    833,  470,  485,  0,    845,  848,  846,  835,  833,  830,  845,  0,    0,    841,  838,
    837,  827,  837,  0,    825,  815,  832,  818,  501,  826,  829,  0,    853,  852,  851,
    811,  810,  0,    824,  813,  810,  0,    820,  813,  805,  806,  812,  815,  0,    0,
    0,    0,    842,  841,  0,    811,  814,  799,  806,  797,

    804,  805,  805,  804,  790,  804,  514,  800,  800,  0,    801,  790,  801,  788,  0,
    0,    0,    820,  819,  818,  778,  777,  773,  785,  780,  0,    815,  814,  0,    784,
    787,  0,    785,  521,  0,    764,  785,  804,  771,  0,    767,  766,  775,  775,  763,
    777,  761,  775,  770,  797,  0,    0,    772,  792,  791,  790,  750,  749,  748,  0,
    748,  0,    754,  0,    496,  512,  775,  757,  760,  743,  756,  754,  742,  741,  750,
    750,  753,  773,  772,  771,  731,  730,  0,    735,  725,  728,  729,  728,  738,  765,
    740,  736,  738,  734,  721,  720,  724,  757,  518,  0,

    727,  730,  720,  721,  752,  712,  719,  710,  735,  719,  715,  717,  715,  715,  714,
    713,  0,    701,  700,  710,  737,  702,  735,  519,  0,    705,  708,  705,  690,  0,
    706,  705,  689,  688,  680,  688,  678,  686,  0,    683,  721,  681,  680,  705,  689,
    687,  687,  680,  670,  698,  666,  668,  652,  690,  123,  160,  189,  210,  497,  204,
    220,  252,  255,  263,  287,  331,  378,  420,  458,  454,  460,  464,  469,  476,  465,
    467,  0,    475,  507,  482,  516,  488,  509,  524,  496,  497,  537,  512,  511,  540,
    518,  514,  537,  520,  518,  522,  508,  507,  522,  509,

    512,  513,  522,  518,  538,  510,  511,  0,    519,  549,  521,  522,  562,  537,  536,
    565,  527,  528,  0,    0,    544,  538,  0,    539,  0,    525,  566,  549,  550,  536,
    535,  538,  539,  540,  0,    572,  535,  545,  537,  545,  572,  549,  0,    0,    548,
    564,  565,  586,  0,    0,    567,  586,  569,  570,  556,  555,  558,  559,  572,  564,
    555,  578,  579,  0,    596,  559,  560,  568,  0,    0,    569,  585,  606,  598,  568,
    600,  590,  584,  572,  593,  591,  585,  619,  575,  614,  577,  578,  586,  0,    0,
    587,  623,  604,  0,    602,  603,  627,  0,    0,    608,

    609,  598,  0,    604,  0,    605,  591,  614,  0,    593,  603,  630,  636,  0,    639,
    0,    0,    620,  621,  628,  613,  611,  612,  0,    604,  605,  622,  629,  630,  0,
    628,  643,  613,  654,  651,  0,    614,  615,  648,  677,  620,  621,  0,    0,    638,
    640,  641,  632,  639,  0,    658,  0,    0,    0,    0,    669,  0,    0,    0,    636,
    637,  631,  652,  0,    658,  634,  635,  0,    653,  695,  0,    0,    645,  664,  640,
    681,  0,    668,  673,  0,    1238, 717,  722,  727,  732,  735,  738};

static const flex_int16_t yy_def[988] = {
    0,   981, 1,   981, 3,   981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981,
    981, 981, 981, 982, 981, 981, 981, 981, 981, 981, 983, 981, 981, 981, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    981, 981, 981, 981, 981, 981, 981, 984, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981,
    985, 981, 986, 20,  982, 981, 981, 987, 981, 981, 981, 981, 981, 981, 981, 981, 983, 981,
    981, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,

    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 981, 981, 984, 981, 981, 986, 981, 981, 981, 981, 981, 987,
    981, 981, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983,

    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 981, 981, 981, 981, 981, 981, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983,

    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983,

    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983,

    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983,

    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983,

    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983,

    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983,

    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,
    983, 983, 983, 983, 983, 983, 983, 983, 0,   981, 981, 981, 981, 981, 981};

static const flex_int16_t yy_nxt[1321] = {
    0,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,
    21,  21,  21,  21,  21,  21,  21,  21,  22,  23,  24,  25,  26,  27,  28,  28,  28,
    28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,
    29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  28,  42,  43,  44,
    45,  46,  47,  48,  49,  50,  51,  52,  28,  53,  28,  54,  55,  56,  57,  58,  59,
    60,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,

    58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  61,  61,  61,  61,  61,
    61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  58,  58,
    58,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,
    61,  61,  61,  61,  61,  61,  61,  61,  61,  58,  58,  58,  58,  63,  64,  65,  68,
    70,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  798, 74,  81,  86,  87,  71,
    69,  129, 89,  66,  74,  130, 75,  75,  75,  75,  75,  75,  75,  75,  76,

    76,  82,  77,  83,  84,  92,  103, 107, 158, 108, 104, 77,  90,  78,  799, 105, 159,
    127, 109, 93,  94,  106, 78,  131, 99,  79,  77,  95,  100, 96,  128, 110, 97,  98,
    101, 77,  132, 102, 116, 111, 78,  112, 161, 134, 113, 800, 117, 251, 252, 78,  114,
    135, 79,  119, 164, 165, 120, 118, 136, 121, 122, 137, 123, 139, 124, 125, 146, 126,
    801, 147, 140, 141, 155, 804, 142, 74,  156, 148, 164, 165, 143, 144, 150, 145, 149,
    157, 151, 805, 152, 200, 153, 167, 168, 154, 162, 169, 178, 77,  981, 187,

    179, 198, 201, 188, 189, 225, 806, 234, 78,  807, 210, 226, 199, 211, 212, 167, 168,
    213, 220, 214, 253, 77,  169, 235, 236, 981, 221, 261, 254, 262, 271, 170, 808, 170,
    228, 78,  171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 238, 229, 242, 230, 256,
    244, 167, 168, 286, 287, 809, 271, 257, 239, 266, 810, 266, 243, 245, 267, 267, 267,
    267, 267, 267, 267, 267, 267, 267, 334, 167, 168, 268, 335, 268, 411, 412, 269, 269,
    269, 269, 269, 269, 269, 269, 269, 269, 171, 171, 171, 171, 171, 171, 171,

    171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 280, 319, 320, 321,
    353, 361, 362, 363, 375, 376, 377, 270, 354, 281, 267, 267, 267, 267, 267, 267, 267,
    267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 811, 270, 387, 388,
    389, 395, 396, 397, 399, 400, 401, 165, 269, 269, 269, 269, 269, 269, 269, 269, 269,
    269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 413, 414, 415, 165, 454, 455,
    456, 477, 478, 479, 812, 168, 490, 491, 492, 493, 494, 495, 496, 497, 498,

    598, 813, 480, 481, 542, 543, 544, 564, 573, 574, 575, 565, 814, 599, 168, 600, 618,
    619, 620, 815, 545, 546, 816, 817, 576, 577, 706, 802, 601, 654, 655, 656, 621, 622,
    818, 623, 678, 679, 680, 707, 803, 819, 708, 820, 821, 657, 658, 624, 743, 768, 822,
    709, 681, 682, 710, 711, 823, 744, 769, 824, 745, 770, 825, 826, 827, 828, 829, 830,
    831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847,
    848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862,

    863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879,
    880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896,
    897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913,
    914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930,
    931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947,
    948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962,

    963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979,
    980, 76,  76,  797, 796, 795, 76,  88,  88,  88,  88,  88,  163, 163, 163, 163, 163,
    72,  794, 72,  166, 793, 166, 172, 172, 172, 792, 791, 790, 789, 788, 787, 786, 785,
    784, 783, 782, 781, 780, 779, 778, 777, 776, 775, 774, 773, 772, 771, 767, 766, 765,
    764, 763, 762, 761, 760, 759, 758, 757, 756, 755, 754, 753, 752, 751, 750, 749, 748,
    747, 746, 742, 741, 740, 739, 738, 737, 736, 735, 734, 733, 732, 731, 730,

    729, 728, 727, 726, 725, 724, 723, 722, 721, 720, 719, 718, 717, 716, 715, 714, 713,
    712, 705, 704, 703, 702, 701, 700, 699, 698, 697, 696, 695, 694, 693, 692, 691, 690,
    689, 688, 687, 686, 685, 684, 683, 677, 676, 675, 674, 673, 672, 671, 670, 669, 668,
    667, 666, 665, 664, 663, 662, 661, 660, 659, 653, 652, 651, 650, 649, 648, 647, 646,
    645, 644, 643, 642, 641, 640, 639, 638, 637, 636, 635, 634, 633, 632, 631, 630, 629,
    628, 627, 626, 625, 617, 616, 615, 614, 613, 612, 611, 610, 609, 608, 607,

    606, 605, 604, 603, 602, 597, 596, 595, 594, 593, 592, 591, 590, 589, 588, 587, 586,
    585, 584, 583, 582, 581, 580, 579, 578, 572, 571, 570, 569, 568, 567, 566, 563, 562,
    561, 560, 559, 558, 557, 556, 555, 554, 553, 552, 551, 550, 549, 548, 547, 541, 540,
    539, 538, 537, 536, 535, 534, 533, 532, 531, 530, 529, 528, 527, 526, 525, 524, 523,
    522, 521, 520, 519, 518, 517, 516, 515, 514, 513, 512, 511, 510, 509, 508, 507, 506,
    505, 504, 503, 502, 501, 500, 499, 489, 488, 487, 486, 485, 484, 483, 482,

    476, 475, 474, 473, 472, 471, 470, 469, 468, 467, 466, 465, 464, 463, 462, 461, 460,
    459, 458, 457, 453, 452, 451, 450, 449, 448, 447, 446, 445, 444, 443, 442, 441, 440,
    439, 438, 437, 436, 435, 434, 433, 432, 431, 430, 429, 428, 427, 426, 425, 424, 423,
    422, 421, 420, 419, 418, 417, 416, 410, 409, 408, 407, 406, 405, 404, 403, 402, 398,
    394, 393, 392, 391, 390, 386, 385, 384, 383, 382, 381, 380, 379, 378, 374, 373, 372,
    371, 370, 369, 368, 367, 366, 365, 364, 360, 359, 358, 357, 356, 355, 352,

    351, 350, 349, 348, 347, 346, 345, 344, 343, 342, 341, 340, 339, 338, 337, 336, 333,
    332, 331, 330, 329, 328, 327, 326, 325, 324, 323, 322, 318, 317, 316, 315, 314, 313,
    312, 311, 310, 309, 308, 307, 306, 305, 304, 303, 302, 301, 300, 299, 298, 297, 296,
    295, 294, 293, 292, 291, 290, 289, 288, 285, 284, 283, 282, 279, 278, 277, 276, 275,
    274, 273, 272, 265, 264, 263, 260, 259, 258, 255, 250, 249, 248, 247, 246, 241, 240,
    237, 233, 232, 231, 227, 224, 223, 222, 219, 218, 217, 216, 215, 209, 208,

    207, 206, 205, 204, 203, 202, 197, 196, 195, 194, 193, 192, 191, 190, 186, 185, 184,
    183, 182, 181, 180, 177, 176, 175, 174, 173, 160, 138, 133, 115, 91,  85,  80,  73,
    67,  62,  981, 5,   981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981,
    981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981,
    981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981,
    981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981,

    981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981,
    981, 981, 981};

static const flex_int16_t yy_chk[1321] = {
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   3,   3,
    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,

    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   10,  10,  11,  15,
    17,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  755, 21,  24,  26,  26,  17,
    15,  43,  31,  11,  20,  43,  20,  20,  20,  20,  20,  20,  20,  20,  20,

    20,  24,  21,  24,  24,  33,  36,  37,  52,  37,  36,  20,  31,  21,  756, 36,  52,
    42,  37,  33,  33,  36,  20,  44,  35,  20,  21,  34,  35,  34,  42,  38,  34,  34,
    35,  20,  44,  35,  40,  38,  21,  38,  55,  46,  38,  757, 40,  150, 150, 20,  38,
    46,  20,  41,  72,  72,  41,  40,  46,  41,  41,  46,  41,  48,  41,  41,  49,  41,
    758, 49,  48,  48,  51,  760, 48,  76,  51,  49,  72,  72,  48,  48,  50,  48,  49,
    51,  50,  761, 50,  112, 50,  74,  74,  50,  55,  75,  94,  76,  75,  102,

    94,  111, 112, 102, 102, 132, 762, 138, 76,  763, 122, 132, 111, 122, 122, 74,  74,
    122, 128, 122, 151, 76,  75,  138, 138, 75,  128, 157, 151, 157, 172, 77,  764, 77,
    134, 76,  77,  77,  77,  77,  77,  77,  77,  77,  77,  77,  140, 134, 143, 134, 153,
    144, 166, 166, 189, 189, 765, 172, 153, 140, 164, 766, 164, 143, 144, 164, 164, 164,
    164, 164, 164, 164, 164, 164, 164, 235, 166, 166, 167, 235, 167, 314, 314, 167, 167,
    167, 167, 167, 167, 167, 167, 167, 167, 170, 170, 170, 170, 170, 170, 170,

    170, 170, 170, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 184, 222, 222, 222,
    253, 260, 260, 260, 279, 279, 279, 171, 253, 184, 266, 266, 266, 266, 266, 266, 266,
    266, 266, 266, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 767, 171, 291, 291,
    291, 300, 300, 300, 304, 304, 304, 267, 268, 268, 268, 268, 268, 268, 268, 268, 268,
    268, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 315, 315, 315, 267, 359, 359,
    359, 403, 403, 403, 768, 269, 417, 417, 417, 418, 418, 418, 419, 419, 419,

    547, 769, 403, 403, 476, 476, 476, 507, 524, 524, 524, 507, 770, 547, 269, 548, 569,
    569, 569, 771, 476, 476, 772, 773, 524, 524, 665, 759, 548, 607, 607, 607, 569, 569,
    774, 569, 634, 634, 634, 665, 759, 775, 666, 776, 778, 607, 607, 569, 699, 724, 779,
    666, 634, 634, 666, 666, 780, 699, 724, 781, 699, 724, 782, 783, 784, 785, 786, 787,
    788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804,
    805, 806, 807, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 821, 822,

    824, 826, 827, 828, 829, 830, 831, 832, 833, 834, 836, 837, 838, 839, 840, 841, 842,
    845, 846, 847, 848, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863,
    865, 866, 867, 868, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883,
    884, 885, 886, 887, 888, 891, 892, 893, 895, 896, 897, 900, 901, 902, 904, 906, 907,
    908, 910, 911, 912, 913, 915, 918, 919, 920, 921, 922, 923, 925, 926, 927, 928, 929,
    931, 932, 933, 934, 935, 937, 938, 939, 940, 941, 942, 945, 946, 947, 948,

    949, 951, 956, 960, 961, 962, 963, 965, 966, 967, 969, 970, 973, 974, 975, 976, 978,
    979, 982, 982, 754, 753, 752, 982, 983, 983, 983, 983, 983, 984, 984, 984, 984, 984,
    985, 751, 985, 986, 750, 986, 987, 987, 987, 749, 748, 747, 746, 745, 744, 743, 742,
    741, 740, 738, 737, 736, 735, 734, 733, 732, 731, 729, 728, 727, 726, 723, 722, 721,
    720, 719, 718, 716, 715, 714, 713, 712, 711, 710, 709, 708, 707, 706, 705, 704, 703,
    702, 701, 698, 697, 696, 695, 694, 693, 692, 691, 690, 689, 688, 687, 686,

    685, 684, 682, 681, 680, 679, 678, 677, 676, 675, 674, 673, 672, 671, 670, 669, 668,
    667, 663, 661, 659, 658, 657, 656, 655, 654, 653, 650, 649, 648, 647, 646, 645, 644,
    643, 642, 641, 639, 638, 637, 636, 633, 631, 630, 628, 627, 625, 624, 623, 622, 621,
    620, 619, 618, 614, 613, 612, 611, 609, 608, 606, 605, 604, 603, 602, 601, 600, 599,
    598, 597, 596, 594, 593, 588, 587, 586, 585, 584, 583, 581, 580, 579, 577, 576, 575,
    574, 573, 571, 570, 568, 567, 566, 565, 563, 562, 561, 560, 559, 556, 555,

    554, 553, 552, 551, 550, 546, 545, 544, 543, 542, 541, 538, 537, 536, 535, 534, 533,
    532, 531, 530, 529, 528, 527, 526, 525, 523, 522, 519, 513, 511, 510, 509, 506, 505,
    502, 501, 500, 499, 488, 487, 486, 485, 484, 483, 481, 480, 479, 478, 477, 474, 472,
    471, 470, 468, 467, 465, 464, 462, 461, 460, 458, 457, 452, 451, 450, 448, 447, 446,
    445, 444, 443, 442, 441, 440, 439, 438, 436, 435, 434, 433, 432, 431, 430, 429, 428,
    426, 425, 424, 423, 422, 421, 420, 416, 412, 411, 410, 409, 408, 407, 404,

    402, 392, 390, 386, 385, 384, 383, 381, 380, 378, 374, 372, 371, 370, 369, 368, 367,
    366, 365, 360, 358, 357, 356, 355, 354, 353, 351, 350, 347, 346, 345, 344, 343, 342,
    341, 340, 339, 338, 337, 336, 335, 334, 333, 332, 331, 330, 329, 328, 327, 326, 325,
    324, 323, 322, 321, 320, 319, 316, 313, 312, 311, 310, 309, 308, 307, 306, 305, 303,
    299, 297, 296, 295, 294, 290, 289, 288, 287, 286, 285, 284, 283, 282, 278, 277, 275,
    274, 273, 272, 265, 264, 263, 262, 261, 259, 258, 257, 256, 255, 254, 252,

    251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 234,
    233, 232, 231, 230, 229, 228, 227, 226, 225, 224, 223, 221, 220, 219, 218, 217, 216,
    215, 214, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 201, 200, 199, 198,
    197, 196, 195, 194, 193, 192, 191, 190, 188, 187, 186, 185, 183, 182, 181, 180, 179,
    178, 176, 175, 160, 159, 158, 156, 155, 154, 152, 149, 148, 147, 146, 145, 142, 141,
    139, 137, 136, 135, 133, 131, 130, 129, 127, 126, 125, 124, 123, 121, 120,

    118, 117, 116, 115, 114, 113, 110, 109, 108, 107, 106, 105, 104, 103, 101, 100, 99,
    98,  97,  96,  95,  93,  92,  91,  87,  83,  53,  47,  45,  39,  32,  25,  22,  19,
    14,  9,   5,   981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981,
    981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981,
    981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981,
    981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981,

    981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981,
    981, 981, 981};

/* Table of booleans, true if rule could match eol. */
static const flex_int32_t yy_rule_can_match_eol[260] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
};

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
/*
//
// Copyright 2002 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//

This file contains the Lex specification for GLSL ES.
Based on ANSI C grammar, Lex specification:
http://www.lysator.liu.se/c/ANSI-C-grammar-l.html

IF YOU MODIFY THIS FILE YOU ALSO NEED TO RUN scripts/run_code_generation.py
WHICH GENERATES THE GLSL ES LEXER (glslang_lex_autogen.cpp).
*/

#include "compiler/preprocessor/Token.h"
#include "compiler/translator/ParseContext.h"
#include "compiler/translator/glslang.h"
#include "compiler/translator/length_limits.h"
#include "compiler/translator/util.h"

using namespace sh;

#include "glslang_tab_autogen.h"

/* windows only pragma */
#ifdef _MSC_VER
#    pragma warning(disable : 4102)
#endif

// Workaround for flex using the register keyword, deprecated in C++11.
#ifdef __cplusplus
#    if __cplusplus > 199711L
#        define register
#    endif
#endif

#define YY_NO_INPUT
#define YY_USER_ACTION                                 \
    yylloc->first_file = yylloc->last_file = yycolumn; \
    yylloc->first_line = yylloc->last_line = yylineno;

#define YY_INPUT(buf, result, max_size) result = string_input(buf, max_size, yyscanner);

static yy_size_t string_input(char *buf, yy_size_t max_size, yyscan_t yyscanner);
static int check_type(yyscan_t yyscanner);
static int reserved_word(yyscan_t yyscanner);
// Tests if an extension is enabled.  If the extension is promoted to core, this function returns
// true.
static bool is_extension_enabled_or_is_core(TParseContext *context,
                                            int extension_version,
                                            TExtension extension,
                                            int promotion_version);
// Helpers to determine if a symbol is reserved, keyword in extension or core, or identifier.
// Formatted as:
//
//    [V1_reserved_][V2_extension_][V3_keyword]
//
// which means in version V1, the symbol is reserved, and remains reserved until V3.  From versions
// V2 until V3, it's a keyword if the extension is enabled.  From version V3 on, it's a keyword in
// the spec itself.  Prior to V1, the symbol can be used as identifier.
static int ES2_extensions_ES3_keyword(TParseContext *context,
                                      TExtension extension1,
                                      TExtension extension2,
                                      TExtension extension3,
                                      int token);
static int ES2_reserved_ES3_keyword(TParseContext *context, int token);
static int ES2_keyword_ES3_reserved(TParseContext *context, int token);
static int ES3_keyword(TParseContext *context, int token);
static int ES3_reserved_ES3_1_keyword(TParseContext *context, int token);
static int ES2_reserved_ES3_1_keyword(TParseContext *context, int token);
static int ES3_1_keyword(TParseContext *context, int token);
static int ES2_reserved_ES2_extension_ES3_keyword(TParseContext *context,
                                                  TExtension extension,
                                                  int token);
static int ES3_extension(TParseContext *context, TExtension extension, int token);
static int ES3_reserved_ES3_1_extension_ES3_2_keyword(TParseContext *context,
                                                      TExtension extension,
                                                      int token);
static int ES3_reserved_ES3_extension(TParseContext *context, TExtension extension, int token);
static int ES3_reserved_ES3_extension_ES3_1_keyword(TParseContext *context,
                                                    TExtension extension,
                                                    int token);
static int ES3_reserved_ES3_extension_ES3_2_keyword(TParseContext *context,
                                                    TExtension extension,
                                                    int token);
static int ES3_1_reserved_ES3_1_extension_ES3_2_keyword(TParseContext *context,
                                                        TExtension extension,
                                                        int token);
static int ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(TParseContext *context,
                                                          TExtension extension1,
                                                          TExtension extension2,
                                                          int token1,
                                                          int token2);
static int ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(TParseContext *context,
                                                                TExtension extension1,
                                                                TExtension extension2,
                                                                int token1,
                                                                int token2);
static int WEBGL_video_texture_extension(TParseContext *context, int token);
static int uint_constant(TParseContext *context);
static int int_constant(TParseContext *context);
static int float_constant(yyscan_t yyscanner);
static int floatsuffix_check(TParseContext *context);
static int yuvcscstandardext_constant(TParseContext *context);

#define INITIAL 0
#define FIELDS 1

#define YY_EXTRA_TYPE TParseContext *

/* Holds the entire state of the reentrant scanner. */
struct yyguts_t
{

    /* User-defined. Not touched by flex. */
    YY_EXTRA_TYPE yyextra_r;

    /* The rest are the same as the globals declared in the non-reentrant scanner. */
    FILE *yyin_r, *yyout_r;
    size_t yy_buffer_stack_top;       /**< index of top of stack. */
    size_t yy_buffer_stack_max;       /**< capacity of stack. */
    YY_BUFFER_STATE *yy_buffer_stack; /**< Stack as an array. */
    char yy_hold_char;
    int yy_n_chars;
    int yyleng_r;
    char *yy_c_buf_p;
    int yy_init;
    int yy_start;
    int yy_did_buffer_switch_on_eof;
    int yy_start_stack_ptr;
    int yy_start_stack_depth;
    int *yy_start_stack;
    yy_state_type yy_last_accepting_state;
    char *yy_last_accepting_cpos;

    int yylineno_r;
    int yy_flex_debug_r;

    char *yytext_r;
    int yy_more_flag;
    int yy_more_len;

    YYSTYPE *yylval_r;

    YYLTYPE *yylloc_r;

}; /* end struct yyguts_t */

static int yy_init_globals(yyscan_t yyscanner);

/* This must go here because YYSTYPE and YYLTYPE are included
 * from bison output in section 1.*/
#define yylval yyg->yylval_r

#define yylloc yyg->yylloc_r

int yylex_init(yyscan_t *scanner);

int yylex_init_extra(YY_EXTRA_TYPE user_defined, yyscan_t *scanner);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy(yyscan_t yyscanner);

int yyget_debug(yyscan_t yyscanner);

void yyset_debug(int debug_flag, yyscan_t yyscanner);

YY_EXTRA_TYPE yyget_extra(yyscan_t yyscanner);

void yyset_extra(YY_EXTRA_TYPE user_defined, yyscan_t yyscanner);

FILE *yyget_in(yyscan_t yyscanner);

void yyset_in(FILE *_in_str, yyscan_t yyscanner);

FILE *yyget_out(yyscan_t yyscanner);

void yyset_out(FILE *_out_str, yyscan_t yyscanner);

int yyget_leng(yyscan_t yyscanner);

char *yyget_text(yyscan_t yyscanner);

int yyget_lineno(yyscan_t yyscanner);

void yyset_lineno(int _line_number, yyscan_t yyscanner);

int yyget_column(yyscan_t yyscanner);

void yyset_column(int _column_no, yyscan_t yyscanner);

YYSTYPE *yyget_lval(yyscan_t yyscanner);

void yyset_lval(YYSTYPE *yylval_param, yyscan_t yyscanner);

YYLTYPE *yyget_lloc(yyscan_t yyscanner);

void yyset_lloc(YYLTYPE *yylloc_param, yyscan_t yyscanner);

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#    ifdef __cplusplus
extern "C" int yywrap(yyscan_t yyscanner);
#    else
extern int yywrap(yyscan_t yyscanner);
#    endif
#endif

#ifndef YY_NO_UNPUT

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy(char *, const char *, int, yyscan_t yyscanner);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char *, yyscan_t yyscanner);
#endif

#ifndef YY_NO_INPUT
#    ifdef __cplusplus
static int yyinput(yyscan_t yyscanner);
#    else
static int input(yyscan_t yyscanner);
#    endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#    ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#        define YY_READ_BUF_SIZE 16384
#    else
#        define YY_READ_BUF_SIZE 8192
#    endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#    define ECHO                                          \
        do                                                \
        {                                                 \
            if (fwrite(yytext, (size_t)yyleng, 1, yyout)) \
            {}                                            \
        } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#    define YY_INPUT(buf, result, max_size)                                                       \
        if (YY_CURRENT_BUFFER_LVALUE->yy_is_interactive)                                          \
        {                                                                                         \
            int c = '*';                                                                          \
            int n;                                                                                \
            for (n = 0; n < max_size && (c = getc(yyin)) != EOF && c != '\n'; ++n)                \
                buf[n] = (char)c;                                                                 \
            if (c == '\n')                                                                        \
                buf[n++] = (char)c;                                                               \
            if (c == EOF && ferror(yyin))                                                         \
                YY_FATAL_ERROR("input in flex scanner failed");                                   \
            result = n;                                                                           \
        }                                                                                         \
        else                                                                                      \
        {                                                                                         \
            errno = 0;                                                                            \
            while ((result = (int)fread(buf, 1, (yy_size_t)max_size, yyin)) == 0 && ferror(yyin)) \
            {                                                                                     \
                if (errno != EINTR)                                                               \
                {                                                                                 \
                    YY_FATAL_ERROR("input in flex scanner failed");                               \
                    break;                                                                        \
                }                                                                                 \
                errno = 0;                                                                        \
                clearerr(yyin);                                                                   \
            }                                                                                     \
        }

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#    define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#    define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#    define YY_FATAL_ERROR(msg) yy_fatal_error(msg, yyscanner)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#    define YY_DECL_IS_OURS 1

extern int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param, yyscan_t yyscanner);

#    define YY_DECL int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param, yyscan_t yyscanner)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#    define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#    define YY_BREAK /*LINTED*/ break;
#endif

#define YY_RULE_SETUP YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
    yy_state_type yy_current_state;
    char *yy_cp, *yy_bp;
    int yy_act;
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    yylval = yylval_param;

    yylloc = yylloc_param;

    if (!yyg->yy_init)
    {
        yyg->yy_init = 1;

#ifdef YY_USER_INIT
        YY_USER_INIT;
#endif

        if (!yyg->yy_start)
            yyg->yy_start = 1; /* first start state */

        if (!yyin)
            yyin = stdin;

        if (!yyout)
            yyout = stdout;

        if (!YY_CURRENT_BUFFER)
        {
            yyensure_buffer_stack(yyscanner);
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE, yyscanner);
        }

        yy_load_buffer_state(yyscanner);
    }

    {

        TParseContext *context = yyextra;

        while (/*CONSTCOND*/ 1) /* loops until end-of-file is reached */
        {
            yy_cp = yyg->yy_c_buf_p;

            /* Support of yytext. */
            *yy_cp = yyg->yy_hold_char;

            /* yy_bp points to the position in yy_ch_buf of the start of
             * the current run.
             */
            yy_bp = yy_cp;

            yy_current_state = yyg->yy_start;
        yy_match:
            do
            {
                YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                if (yy_accept[yy_current_state])
                {
                    yyg->yy_last_accepting_state = yy_current_state;
                    yyg->yy_last_accepting_cpos  = yy_cp;
                }
                while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
                {
                    yy_current_state = (int)yy_def[yy_current_state];
                    if (yy_current_state >= 982)
                        yy_c = yy_meta[yy_c];
                }
                yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
                ++yy_cp;
            } while (yy_current_state != 981);
            yy_cp            = yyg->yy_last_accepting_cpos;
            yy_current_state = yyg->yy_last_accepting_state;

        yy_find_action:
            yy_act = yy_accept[yy_current_state];

            YY_DO_BEFORE_ACTION;

            if (yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act])
            {
                int yyl;
                for (yyl = 0; yyl < yyleng; ++yyl)
                    if (yytext[yyl] == '\n')

                        do
                        {
                            yylineno++;
                            yycolumn = 0;
                        } while (0);
            }

        do_action: /* This label is used only to access EOF actions. */

            switch (yy_act)
            {           /* beginning of action switch */
                case 0: /* must back up */
                    /* undo the effects of YY_DO_BEFORE_ACTION */
                    *yy_cp           = yyg->yy_hold_char;
                    yy_cp            = yyg->yy_last_accepting_cpos;
                    yy_current_state = yyg->yy_last_accepting_state;
                    goto yy_find_action;

                case 1:
                    YY_RULE_SETUP
                    {
                        return INVARIANT;
                    }
                    YY_BREAK
                case 2:
                    YY_RULE_SETUP
                    {
                        return HIGH_PRECISION;
                    }
                    YY_BREAK
                case 3:
                    YY_RULE_SETUP
                    {
                        return MEDIUM_PRECISION;
                    }
                    YY_BREAK
                case 4:
                    YY_RULE_SETUP
                    {
                        return LOW_PRECISION;
                    }
                    YY_BREAK
                case 5:
                    YY_RULE_SETUP
                    {
                        return PRECISION;
                    }
                    YY_BREAK
                case 6:
                    YY_RULE_SETUP
                    {
                        return ES2_keyword_ES3_reserved(context, ATTRIBUTE);
                    }
                    YY_BREAK
                case 7:
                    YY_RULE_SETUP
                    {
                        return CONST_QUAL;
                    }
                    YY_BREAK
                case 8:
                    YY_RULE_SETUP
                    {
                        return UNIFORM;
                    }
                    YY_BREAK
                case 9:
                    YY_RULE_SETUP
                    {
                        return ES3_1_keyword(context, BUFFER);
                    }
                    YY_BREAK
                case 10:
                    YY_RULE_SETUP
                    {
                        return ES2_keyword_ES3_reserved(context, VARYING);
                    }
                    YY_BREAK
                case 11:
                    YY_RULE_SETUP
                    {
                        return BREAK;
                    }
                    YY_BREAK
                case 12:
                    YY_RULE_SETUP
                    {
                        return CONTINUE;
                    }
                    YY_BREAK
                case 13:
                    YY_RULE_SETUP
                    {
                        return DO;
                    }
                    YY_BREAK
                case 14:
                    YY_RULE_SETUP
                    {
                        return FOR;
                    }
                    YY_BREAK
                case 15:
                    YY_RULE_SETUP
                    {
                        return WHILE;
                    }
                    YY_BREAK
                case 16:
                    YY_RULE_SETUP
                    {
                        return IF;
                    }
                    YY_BREAK
                case 17:
                    YY_RULE_SETUP
                    {
                        return ELSE;
                    }
                    YY_BREAK
                case 18:
                    YY_RULE_SETUP
                    {
                        return ES2_reserved_ES3_keyword(context, SWITCH);
                    }
                    YY_BREAK
                case 19:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, CASE);
                    }
                    YY_BREAK
                case 20:
                    YY_RULE_SETUP
                    {
                        return ES2_reserved_ES3_keyword(context, DEFAULT);
                    }
                    YY_BREAK
                case 21:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, CENTROID);
                    }
                    YY_BREAK
                case 22:
                    YY_RULE_SETUP
                    {
                        return ES2_reserved_ES3_keyword(context, FLAT);
                    }
                    YY_BREAK
                case 23:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, SMOOTH);
                    }
                    YY_BREAK
                case 24:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_extension(
                            context, TExtension::NV_shader_noperspective_interpolation,
                            NOPERSPECTIVE);
                    }
                    YY_BREAK
                case 25:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_extension_ES3_2_keyword(
                            context, TExtension::EXT_tessellation_shader, PATCH);
                    }
                    YY_BREAK
                case 26:
                    YY_RULE_SETUP
                    {
                        return IN_QUAL;
                    }
                    YY_BREAK
                case 27:
                    YY_RULE_SETUP
                    {
                        return OUT_QUAL;
                    }
                    YY_BREAK
                case 28:
                    YY_RULE_SETUP
                    {
                        return INOUT_QUAL;
                    }
                    YY_BREAK
                case 29:
                    YY_RULE_SETUP
                    {
                        return ES3_1_keyword(context, SHARED);
                    }
                    YY_BREAK
                case 30:
                    YY_RULE_SETUP
                    {
                        return FLOAT_TYPE;
                    }
                    YY_BREAK
                case 31:
                    YY_RULE_SETUP
                    {
                        return INT_TYPE;
                    }
                    YY_BREAK
                case 32:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, UINT_TYPE);
                    }
                    YY_BREAK
                case 33:
                    YY_RULE_SETUP
                    {
                        return VOID_TYPE;
                    }
                    YY_BREAK
                case 34:
                    YY_RULE_SETUP
                    {
                        return BOOL_TYPE;
                    }
                    YY_BREAK
                case 35:
                    YY_RULE_SETUP
                    {
                        yylval->lex.b = true;
                        return BOOLCONSTANT;
                    }
                    YY_BREAK
                case 36:
                    YY_RULE_SETUP
                    {
                        yylval->lex.b = false;
                        return BOOLCONSTANT;
                    }
                    YY_BREAK
                case 37:
                    YY_RULE_SETUP
                    {
                        return DISCARD;
                    }
                    YY_BREAK
                case 38:
                    YY_RULE_SETUP
                    {
                        return RETURN;
                    }
                    YY_BREAK
                case 39:
                    YY_RULE_SETUP
                    {
                        return MATRIX2;
                    }
                    YY_BREAK
                case 40:
                    YY_RULE_SETUP
                    {
                        return MATRIX3;
                    }
                    YY_BREAK
                case 41:
                    YY_RULE_SETUP
                    {
                        return MATRIX4;
                    }
                    YY_BREAK
                case 42:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, MATRIX2);
                    }
                    YY_BREAK
                case 43:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, MATRIX3);
                    }
                    YY_BREAK
                case 44:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, MATRIX4);
                    }
                    YY_BREAK
                case 45:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, MATRIX2x3);
                    }
                    YY_BREAK
                case 46:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, MATRIX3x2);
                    }
                    YY_BREAK
                case 47:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, MATRIX2x4);
                    }
                    YY_BREAK
                case 48:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, MATRIX4x2);
                    }
                    YY_BREAK
                case 49:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, MATRIX3x4);
                    }
                    YY_BREAK
                case 50:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, MATRIX4x3);
                    }
                    YY_BREAK
                case 51:
                    YY_RULE_SETUP
                    {
                        return VEC2;
                    }
                    YY_BREAK
                case 52:
                    YY_RULE_SETUP
                    {
                        return VEC3;
                    }
                    YY_BREAK
                case 53:
                    YY_RULE_SETUP
                    {
                        return VEC4;
                    }
                    YY_BREAK
                case 54:
                    YY_RULE_SETUP
                    {
                        return IVEC2;
                    }
                    YY_BREAK
                case 55:
                    YY_RULE_SETUP
                    {
                        return IVEC3;
                    }
                    YY_BREAK
                case 56:
                    YY_RULE_SETUP
                    {
                        return IVEC4;
                    }
                    YY_BREAK
                case 57:
                    YY_RULE_SETUP
                    {
                        return BVEC2;
                    }
                    YY_BREAK
                case 58:
                    YY_RULE_SETUP
                    {
                        return BVEC3;
                    }
                    YY_BREAK
                case 59:
                    YY_RULE_SETUP
                    {
                        return BVEC4;
                    }
                    YY_BREAK
                case 60:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, UVEC2);
                    }
                    YY_BREAK
                case 61:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, UVEC3);
                    }
                    YY_BREAK
                case 62:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, UVEC4);
                    }
                    YY_BREAK
                case 63:
                    YY_RULE_SETUP
                    {
                        return SAMPLER2D;
                    }
                    YY_BREAK
                case 64:
                    YY_RULE_SETUP
                    {
                        return SAMPLERCUBE;
                    }
                    YY_BREAK
                case 65:
                    YY_RULE_SETUP
                    {
                        return SAMPLER_EXTERNAL_OES;
                    }
                    YY_BREAK
                case 66:
                    YY_RULE_SETUP
                    {
                        return ES2_reserved_ES2_extension_ES3_keyword(
                            context, TExtension::OES_texture_3D, SAMPLER3D);
                    }
                    YY_BREAK
                case 67:
                    YY_RULE_SETUP
                    {
                        return ES2_reserved_ES3_keyword(context, SAMPLER3DRECT);
                    }
                    YY_BREAK
                case 68:
                    YY_RULE_SETUP
                    {
                        return SAMPLER2DRECT;
                    }
                    YY_BREAK
                case 69:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, SAMPLER2DARRAY);
                    }
                    YY_BREAK
                case 70:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_extension_ES3_1_keyword(
                            context, TExtension::ANGLE_texture_multisample, SAMPLER2DMS);
                    }
                    YY_BREAK
                case 71:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, ISAMPLER2D);
                    }
                    YY_BREAK
                case 72:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, ISAMPLER3D);
                    }
                    YY_BREAK
                case 73:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, ISAMPLERCUBE);
                    }
                    YY_BREAK
                case 74:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, ISAMPLER2DARRAY);
                    }
                    YY_BREAK
                case 75:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_extension_ES3_1_keyword(
                            context, TExtension::ANGLE_texture_multisample, ISAMPLER2DMS);
                    }
                    YY_BREAK
                case 76:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, USAMPLER2D);
                    }
                    YY_BREAK
                case 77:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, USAMPLER3D);
                    }
                    YY_BREAK
                case 78:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, USAMPLERCUBE);
                    }
                    YY_BREAK
                case 79:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, USAMPLER2DARRAY);
                    }
                    YY_BREAK
                case 80:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_extension_ES3_1_keyword(
                            context, TExtension::ANGLE_texture_multisample, USAMPLER2DMS);
                    }
                    YY_BREAK
                case 81:
                    YY_RULE_SETUP
                    {
                        return ES2_reserved_ES2_extension_ES3_keyword(
                            context, TExtension::EXT_shadow_samplers, SAMPLER2DSHADOW);
                    }
                    YY_BREAK
                case 82:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, SAMPLERCUBESHADOW);
                    }
                    YY_BREAK
                case 83:
                    YY_RULE_SETUP
                    {
                        return ES3_keyword(context, SAMPLER2DARRAYSHADOW);
                    }
                    YY_BREAK
                case 84:
                    YY_RULE_SETUP
                    {
                        return ES3_extension(context, TExtension::EXT_YUV_target,
                                             SAMPLEREXTERNAL2DY2YEXT);
                    }
                    YY_BREAK
                case 85:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_extension_ES3_2_keyword(
                            context, TExtension::OES_texture_storage_multisample_2d_array,
                            SAMPLER2DMSARRAY);
                    }
                    YY_BREAK
                case 86:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_extension_ES3_2_keyword(
                            context, TExtension::OES_texture_storage_multisample_2d_array,
                            ISAMPLER2DMSARRAY);
                    }
                    YY_BREAK
                case 87:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_extension_ES3_2_keyword(
                            context, TExtension::OES_texture_storage_multisample_2d_array,
                            USAMPLER2DMSARRAY);
                    }
                    YY_BREAK
                case 88:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_cube_map_array,
                            TExtension::EXT_texture_cube_map_array, SAMPLERCUBEARRAYOES,
                            SAMPLERCUBEARRAYEXT);
                    }
                    YY_BREAK
                case 89:
                    YY_RULE_SETUP
                    {
                        return ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_buffer, TExtension::EXT_texture_buffer,
                            SAMPLERBUFFER, SAMPLERBUFFER);
                    }
                    YY_BREAK
                case 90:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_cube_map_array,
                            TExtension::EXT_texture_cube_map_array, SAMPLERCUBEARRAYSHADOWOES,
                            SAMPLERCUBEARRAYSHADOWEXT);
                    }
                    YY_BREAK
                case 91:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_cube_map_array,
                            TExtension::EXT_texture_cube_map_array, ISAMPLERCUBEARRAYOES,
                            ISAMPLERCUBEARRAYEXT);
                    }
                    YY_BREAK
                case 92:
                    YY_RULE_SETUP
                    {
                        return ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_buffer, TExtension::EXT_texture_buffer,
                            ISAMPLERBUFFER, ISAMPLERBUFFER);
                    }
                    YY_BREAK
                case 93:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_cube_map_array,
                            TExtension::EXT_texture_cube_map_array, USAMPLERCUBEARRAYOES,
                            USAMPLERCUBEARRAYEXT);
                    }
                    YY_BREAK
                case 94:
                    YY_RULE_SETUP
                    {
                        return ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_buffer, TExtension::EXT_texture_buffer,
                            USAMPLERBUFFER, USAMPLERBUFFER);
                    }
                    YY_BREAK
                case 95:
                    YY_RULE_SETUP
                    {
                        return WEBGL_video_texture_extension(context, SAMPLERVIDEOWEBGL);
                    }
                    YY_BREAK
                case 96:
                    YY_RULE_SETUP
                    {
                        return STRUCT;
                    }
                    YY_BREAK
                case 97:
                    YY_RULE_SETUP
                    {
                        return ES2_extensions_ES3_keyword(
                            context, TExtension::EXT_shader_framebuffer_fetch,
                            TExtension::EXT_shader_framebuffer_fetch_non_coherent,
                            TExtension::KHR_blend_equation_advanced, LAYOUT);
                    }
                    YY_BREAK
                case 98:
                    YY_RULE_SETUP
                    {
                        return ES3_extension(context, TExtension::EXT_YUV_target,
                                             YUVCSCSTANDARDEXT);
                    }
                    YY_BREAK
                case 99:
                    YY_RULE_SETUP
                    {
                        return yuvcscstandardext_constant(context);
                    }
                    YY_BREAK
                case 100:
                    YY_RULE_SETUP
                    {
                        return yuvcscstandardext_constant(context);
                    }
                    YY_BREAK
                case 101:
                    YY_RULE_SETUP
                    {
                        return yuvcscstandardext_constant(context);
                    }
                    YY_BREAK
                case 102:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, IMAGE2D);
                    }
                    YY_BREAK
                case 103:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, IIMAGE2D);
                    }
                    YY_BREAK
                case 104:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, UIMAGE2D);
                    }
                    YY_BREAK
                case 105:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, IMAGE2DARRAY);
                    }
                    YY_BREAK
                case 106:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, IIMAGE2DARRAY);
                    }
                    YY_BREAK
                case 107:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, UIMAGE2DARRAY);
                    }
                    YY_BREAK
                case 108:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, IMAGE3D);
                    }
                    YY_BREAK
                case 109:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, UIMAGE3D);
                    }
                    YY_BREAK
                case 110:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, IIMAGE3D);
                    }
                    YY_BREAK
                case 111:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, IIMAGECUBE);
                    }
                    YY_BREAK
                case 112:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, UIMAGECUBE);
                    }
                    YY_BREAK
                case 113:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, IMAGECUBE);
                    }
                    YY_BREAK
                case 114:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_cube_map_array,
                            TExtension::EXT_texture_cube_map_array, IMAGECUBEARRAYOES,
                            IMAGECUBEARRAYEXT);
                    }
                    YY_BREAK
                case 115:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_cube_map_array,
                            TExtension::EXT_texture_cube_map_array, IIMAGECUBEARRAYOES,
                            IIMAGECUBEARRAYEXT);
                    }
                    YY_BREAK
                case 116:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_cube_map_array,
                            TExtension::EXT_texture_cube_map_array, UIMAGECUBEARRAYOES,
                            UIMAGECUBEARRAYEXT);
                    }
                    YY_BREAK
                case 117:
                    YY_RULE_SETUP
                    {
                        return ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_buffer, TExtension::EXT_texture_buffer,
                            IMAGEBUFFER, IMAGEBUFFER);
                    }
                    YY_BREAK
                case 118:
                    YY_RULE_SETUP
                    {
                        return ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_buffer, TExtension::EXT_texture_buffer,
                            IIMAGEBUFFER, IIMAGEBUFFER);
                    }
                    YY_BREAK
                case 119:
                    YY_RULE_SETUP
                    {
                        return ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_buffer, TExtension::EXT_texture_buffer,
                            UIMAGEBUFFER, UIMAGEBUFFER);
                    }
                    YY_BREAK
                case 120:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, READONLY);
                    }
                    YY_BREAK
                case 121:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, WRITEONLY);
                    }
                    YY_BREAK
                case 122:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, COHERENT);
                    }
                    YY_BREAK
                case 123:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, RESTRICT);
                    }
                    YY_BREAK
                case 124:
                    YY_RULE_SETUP
                    {
                        return ES2_reserved_ES3_1_keyword(context, VOLATILE);
                    }
                    YY_BREAK
                case 125:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_keyword(context, ATOMICUINT);
                    }
                    YY_BREAK
                case 126:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_extension_ES3_2_keyword(
                            context, TExtension::OES_shader_multisample_interpolation, SAMPLE);
                    }
                    YY_BREAK
                case 127:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword(
                            context, TExtension::EXT_gpu_shader5, PRECISE);
                    }
                    YY_BREAK
                /* ANGLE_shader_pixel_local_storage */
                case 128:
                    YY_RULE_SETUP
                    {
                        return ES3_extension(context, TExtension::ANGLE_shader_pixel_local_storage,
                                             PIXELLOCALANGLE);
                    }
                    YY_BREAK
                case 129:
                    YY_RULE_SETUP
                    {
                        return ES3_extension(context, TExtension::ANGLE_shader_pixel_local_storage,
                                             IPIXELLOCALANGLE);
                    }
                    YY_BREAK
                case 130:
                    YY_RULE_SETUP
                    {
                        return ES3_extension(context, TExtension::ANGLE_shader_pixel_local_storage,
                                             UPIXELLOCALANGLE);
                    }
                    YY_BREAK
                /* Reserved keywords for GLSL ES 3.00 that are not reserved for GLSL ES 1.00 */
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                case 138:
                case 139:
                case 140:
                case 141:
                case 142:
                case 143:
                case 144:
                case 145:
                case 146:
                case 147:
                case 148:
                case 149:
                case 150:
                case 151:
                case 152:
                case 153:
                case 154:
                    YY_RULE_SETUP
                    {
                        if (context->getShaderVersion() < 300)
                        {
                            yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
                            return check_type(yyscanner);
                        }
                        return reserved_word(yyscanner);
                    }
                    YY_BREAK
                /* Reserved keywords in GLSL ES 1.00 that are not reserved in GLSL ES 3.00 */
                case 155:
                    YY_RULE_SETUP
                    {
                        if (context->getShaderVersion() >= 300)
                        {
                            yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
                            return check_type(yyscanner);
                        }

                        return reserved_word(yyscanner);
                    }
                    YY_BREAK
                /* Reserved keywords */
                case 156:
                case 157:
                case 158:
                case 159:
                case 160:
                case 161:
                case 162:
                case 163:
                case 164:
                case 165:
                case 166:
                case 167:
                case 168:
                case 169:
                case 170:
                case 171:
                case 172:
                case 173:
                case 174:
                case 175:
                case 176:
                case 177:
                case 178:
                case 179:
                case 180:
                case 181:
                case 182:
                case 183:
                case 184:
                case 185:
                case 186:
                case 187:
                case 188:
                case 189:
                case 190:
                case 191:
                case 192:
                case 193:
                case 194:
                case 195:
                    YY_RULE_SETUP
                    {
                        return reserved_word(yyscanner);
                    }
                    YY_BREAK
                case 196:
                    YY_RULE_SETUP
                    {
                        yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
                        return check_type(yyscanner);
                    }
                    YY_BREAK
                case 197:
                    YY_RULE_SETUP
                    {
                        return int_constant(context);
                    }
                    YY_BREAK
                case 198:
                    YY_RULE_SETUP
                    {
                        return int_constant(context);
                    }
                    YY_BREAK
                case 199:
                    YY_RULE_SETUP
                    {
                        return int_constant(context);
                    }
                    YY_BREAK
                case 200:
                    YY_RULE_SETUP
                    {
                        return uint_constant(context);
                    }
                    YY_BREAK
                case 201:
                    YY_RULE_SETUP
                    {
                        return uint_constant(context);
                    }
                    YY_BREAK
                case 202:
                    YY_RULE_SETUP
                    {
                        return uint_constant(context);
                    }
                    YY_BREAK
                case 203:
                    YY_RULE_SETUP
                    {
                        return float_constant(yyscanner);
                    }
                    YY_BREAK
                case 204:
                    YY_RULE_SETUP
                    {
                        return float_constant(yyscanner);
                    }
                    YY_BREAK
                case 205:
                    YY_RULE_SETUP
                    {
                        return float_constant(yyscanner);
                    }
                    YY_BREAK
                case 206:
                    YY_RULE_SETUP
                    {
                        return floatsuffix_check(context);
                    }
                    YY_BREAK
                case 207:
                    YY_RULE_SETUP
                    {
                        return floatsuffix_check(context);
                    }
                    YY_BREAK
                case 208:
                    YY_RULE_SETUP
                    {
                        return floatsuffix_check(context);
                    }
                    YY_BREAK
                case 209:
                    YY_RULE_SETUP
                    {
                        return ADD_ASSIGN;
                    }
                    YY_BREAK
                case 210:
                    YY_RULE_SETUP
                    {
                        return SUB_ASSIGN;
                    }
                    YY_BREAK
                case 211:
                    YY_RULE_SETUP
                    {
                        return MUL_ASSIGN;
                    }
                    YY_BREAK
                case 212:
                    YY_RULE_SETUP
                    {
                        return DIV_ASSIGN;
                    }
                    YY_BREAK
                case 213:
                    YY_RULE_SETUP
                    {
                        return MOD_ASSIGN;
                    }
                    YY_BREAK
                case 214:
                    YY_RULE_SETUP
                    {
                        return LEFT_ASSIGN;
                    }
                    YY_BREAK
                case 215:
                    YY_RULE_SETUP
                    {
                        return RIGHT_ASSIGN;
                    }
                    YY_BREAK
                case 216:
                    YY_RULE_SETUP
                    {
                        return AND_ASSIGN;
                    }
                    YY_BREAK
                case 217:
                    YY_RULE_SETUP
                    {
                        return XOR_ASSIGN;
                    }
                    YY_BREAK
                case 218:
                    YY_RULE_SETUP
                    {
                        return OR_ASSIGN;
                    }
                    YY_BREAK
                case 219:
                    YY_RULE_SETUP
                    {
                        return INC_OP;
                    }
                    YY_BREAK
                case 220:
                    YY_RULE_SETUP
                    {
                        return DEC_OP;
                    }
                    YY_BREAK
                case 221:
                    YY_RULE_SETUP
                    {
                        return AND_OP;
                    }
                    YY_BREAK
                case 222:
                    YY_RULE_SETUP
                    {
                        return OR_OP;
                    }
                    YY_BREAK
                case 223:
                    YY_RULE_SETUP
                    {
                        return XOR_OP;
                    }
                    YY_BREAK
                case 224:
                    YY_RULE_SETUP
                    {
                        return LE_OP;
                    }
                    YY_BREAK
                case 225:
                    YY_RULE_SETUP
                    {
                        return GE_OP;
                    }
                    YY_BREAK
                case 226:
                    YY_RULE_SETUP
                    {
                        return EQ_OP;
                    }
                    YY_BREAK
                case 227:
                    YY_RULE_SETUP
                    {
                        return NE_OP;
                    }
                    YY_BREAK
                case 228:
                    YY_RULE_SETUP
                    {
                        return LEFT_OP;
                    }
                    YY_BREAK
                case 229:
                    YY_RULE_SETUP
                    {
                        return RIGHT_OP;
                    }
                    YY_BREAK
                case 230:
                    YY_RULE_SETUP
                    {
                        return SEMICOLON;
                    }
                    YY_BREAK
                case 231:
                    YY_RULE_SETUP
                    {
                        return LEFT_BRACE;
                    }
                    YY_BREAK
                case 232:
                    YY_RULE_SETUP
                    {
                        return RIGHT_BRACE;
                    }
                    YY_BREAK
                case 233:
                    YY_RULE_SETUP
                    {
                        return COMMA;
                    }
                    YY_BREAK
                case 234:
                    YY_RULE_SETUP
                    {
                        return COLON;
                    }
                    YY_BREAK
                case 235:
                    YY_RULE_SETUP
                    {
                        return EQUAL;
                    }
                    YY_BREAK
                case 236:
                    YY_RULE_SETUP
                    {
                        return LEFT_PAREN;
                    }
                    YY_BREAK
                case 237:
                    YY_RULE_SETUP
                    {
                        return RIGHT_PAREN;
                    }
                    YY_BREAK
                case 238:
                    YY_RULE_SETUP
                    {
                        return LEFT_BRACKET;
                    }
                    YY_BREAK
                case 239:
                    YY_RULE_SETUP
                    {
                        return RIGHT_BRACKET;
                    }
                    YY_BREAK
                case 240:
                    YY_RULE_SETUP
                    {
                        BEGIN(FIELDS);
                        return DOT;
                    }
                    YY_BREAK
                case 241:
                    YY_RULE_SETUP
                    {
                        return BANG;
                    }
                    YY_BREAK
                case 242:
                    YY_RULE_SETUP
                    {
                        return DASH;
                    }
                    YY_BREAK
                case 243:
                    YY_RULE_SETUP
                    {
                        return TILDE;
                    }
                    YY_BREAK
                case 244:
                    YY_RULE_SETUP
                    {
                        return PLUS;
                    }
                    YY_BREAK
                case 245:
                    YY_RULE_SETUP
                    {
                        return STAR;
                    }
                    YY_BREAK
                case 246:
                    YY_RULE_SETUP
                    {
                        return SLASH;
                    }
                    YY_BREAK
                case 247:
                    YY_RULE_SETUP
                    {
                        return PERCENT;
                    }
                    YY_BREAK
                case 248:
                    YY_RULE_SETUP
                    {
                        return LEFT_ANGLE;
                    }
                    YY_BREAK
                case 249:
                    YY_RULE_SETUP
                    {
                        return RIGHT_ANGLE;
                    }
                    YY_BREAK
                case 250:
                    YY_RULE_SETUP
                    {
                        return VERTICAL_BAR;
                    }
                    YY_BREAK
                case 251:
                    YY_RULE_SETUP
                    {
                        return CARET;
                    }
                    YY_BREAK
                case 252:
                    YY_RULE_SETUP
                    {
                        return AMPERSAND;
                    }
                    YY_BREAK
                case 253:
                    YY_RULE_SETUP
                    {
                        return QUESTION;
                    }
                    YY_BREAK
                case 254:
                    YY_RULE_SETUP
                    {
                        BEGIN(INITIAL);
                        yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
                        return FIELD_SELECTION;
                    }
                    YY_BREAK
                case 255:
                    YY_RULE_SETUP {}
                    YY_BREAK
                case 256:
                    YY_RULE_SETUP
                    {
                        yyextra->error(*yylloc, "Illegal character at fieldname start", yytext);
                        return 0;
                    }
                    YY_BREAK
                case 257:
                    /* rule 257 can match eol */
                    YY_RULE_SETUP {}
                    YY_BREAK
                case YY_STATE_EOF(INITIAL):
                case YY_STATE_EOF(FIELDS):
                {
                    yyterminate();
                }
                    YY_BREAK
                case 258:
                    YY_RULE_SETUP
                    {
                        assert(false);
                        return 0;
                    }
                    YY_BREAK
                case 259:
                    YY_RULE_SETUP
                    ECHO;
                    YY_BREAK

                case YY_END_OF_BUFFER:
                {
                    /* Amount of text matched not including the EOB char. */
                    int yy_amount_of_matched_text = (int)(yy_cp - yyg->yytext_ptr) - 1;

                    /* Undo the effects of YY_DO_BEFORE_ACTION. */
                    *yy_cp = yyg->yy_hold_char;
                    YY_RESTORE_YY_MORE_OFFSET

                    if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW)
                    {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file    = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                    }

                    /* Note that here we test for yy_c_buf_p "<=" to the position
                     * of the first EOB in the buffer, since yy_c_buf_p will
                     * already have been incremented past the NUL character
                     * (since all states make transitions on EOB to the
                     * end-of-buffer state).  Contrast this with the test
                     * in input().
                     */
                    if (yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars])
                    { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state(yyscanner);

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans(yy_current_state, yyscanner);

                        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

                        if (yy_next_state)
                        {
                            /* Consume the NUL. */
                            yy_cp            = ++yyg->yy_c_buf_p;
                            yy_current_state = yy_next_state;
                            goto yy_match;
                        }

                        else
                        {
                            yy_cp            = yyg->yy_last_accepting_cpos;
                            yy_current_state = yyg->yy_last_accepting_state;
                            goto yy_find_action;
                        }
                    }

                    else
                        switch (yy_get_next_buffer(yyscanner))
                        {
                            case EOB_ACT_END_OF_FILE:
                            {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if (yywrap(yyscanner))
                                {
                                    /* Note: because we've taken care in
                                     * yy_get_next_buffer() to have set up
                                     * yytext, we can now set up
                                     * yy_c_buf_p so that if some total
                                     * hoser (like flex itself) wants to
                                     * call the scanner after we return the
                                     * YY_NULL, it'll still work - another
                                     * YY_NULL will get returned.
                                     */
                                    yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

                                    yy_act = YY_STATE_EOF(YY_START);
                                    goto do_action;
                                }

                                else
                                {
                                    if (!yyg->yy_did_buffer_switch_on_eof)
                                        YY_NEW_FILE;
                                }
                                break;
                            }

                            case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state(yyscanner);

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_match;

                            case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                    &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state(yyscanner);

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                    break;
                }

                default:
                    YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
            } /* end of action switch */
        }     /* end of scanning one token */
    }         /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *    EOB_ACT_LAST_MATCH -
 *    EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *    EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    char *dest           = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
    char *source         = yyg->yytext_ptr;
    int number_to_move, i;
    int ret_val;

    if (yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1])
        YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

    if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0)
    { /* Don't try to fill the buffer, so this is an EOF. */
        if (yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1)
        {
            /* We matched a single character, the EOB, so
             * treat this as a final EOF.
             */
            return EOB_ACT_END_OF_FILE;
        }

        else
        {
            /* We matched some text prior to the EOB, first
             * process it.
             */
            return EOB_ACT_LAST_MATCH;
        }
    }

    /* Try to read more data. */

    /* First move last chars to start of buffer. */
    number_to_move = (int)(yyg->yy_c_buf_p - yyg->yytext_ptr - 1);

    for (i = 0; i < number_to_move; ++i)
        *(dest++) = *(source++);

    if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
        /* don't do the read, it's not guaranteed to return an EOF,
         * just force an EOF
         */
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

    else
    {
        int num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

        while (num_to_read <= 0)
        { /* Not enough room in the buffer - grow it. */

            /* just a shorter name for the current buffer */
            YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

            int yy_c_buf_p_offset = (int)(yyg->yy_c_buf_p - b->yy_ch_buf);

            if (b->yy_is_our_buffer)
            {
                int new_size = b->yy_buf_size * 2;

                if (new_size <= 0)
                    b->yy_buf_size += b->yy_buf_size / 8;
                else
                    b->yy_buf_size *= 2;

                b->yy_ch_buf = (char *)
                    /* Include room in for 2 EOB chars. */
                    yyrealloc((void *)b->yy_ch_buf, (yy_size_t)(b->yy_buf_size + 2), yyscanner);
            }
            else
                /* Can't grow it, we don't own it. */
                b->yy_ch_buf = NULL;

            if (!b->yy_ch_buf)
                YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

            yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

            num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
        }

        if (num_to_read > YY_READ_BUF_SIZE)
            num_to_read = YY_READ_BUF_SIZE;

        /* Read in more data. */
        yy_size_t ret = 0;
        YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]), ret, num_to_read);
        yyg->yy_n_chars = static_cast<int>(ret);

        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

    if (yyg->yy_n_chars == 0)
    {
        if (number_to_move == YY_MORE_ADJ)
        {
            ret_val = EOB_ACT_END_OF_FILE;
            yyrestart(yyin, yyscanner);
        }

        else
        {
            ret_val                                    = EOB_ACT_LAST_MATCH;
            YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
        }
    }

    else
        ret_val = EOB_ACT_CONTINUE_SCAN;

    if ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size)
    {
        /* Extend the array by 50%, plus the number we really need. */
        int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *)yyrealloc(
            (void *)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t)new_size, yyscanner);
        if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
            YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
        /* "- 2" to take care of EOB's */
        YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int)(new_size - 2);
    }

    yyg->yy_n_chars += number_to_move;
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars]     = YY_END_OF_BUFFER_CHAR;
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

    return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state(yyscan_t yyscanner)
{
    yy_state_type yy_current_state;
    char *yy_cp;
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    yy_current_state = yyg->yy_start;

    for (yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp)
    {
        YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
        if (yy_accept[yy_current_state])
        {
            yyg->yy_last_accepting_state = yy_current_state;
            yyg->yy_last_accepting_cpos  = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
        {
            yy_current_state = (int)yy_def[yy_current_state];
            if (yy_current_state >= 982)
                yy_c = yy_meta[yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    }

    return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *    next_state = yy_try_NUL_trans( current_state );
 */
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state, yyscan_t yyscanner)
{
    int yy_is_jam;
    struct yyguts_t *yyg =
        (struct yyguts_t *)yyscanner; /* This var may be unused depending upon options. */
    char *yy_cp = yyg->yy_c_buf_p;

    YY_CHAR yy_c = 1;
    if (yy_accept[yy_current_state])
    {
        yyg->yy_last_accepting_state = yy_current_state;
        yyg->yy_last_accepting_cpos  = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
    {
        yy_current_state = (int)yy_def[yy_current_state];
        if (yy_current_state >= 982)
            yy_c = yy_meta[yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    yy_is_jam        = (yy_current_state == 981);

    (void)yyg;
    return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#    ifdef __cplusplus
static int yyinput(yyscan_t yyscanner)
#    else
static int input(yyscan_t yyscanner)
#    endif

{
    int c;
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    *yyg->yy_c_buf_p = yyg->yy_hold_char;

    if (*yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR)
    {
        /* yy_c_buf_p now points to the character we want to return.
         * If this occurs *before* the EOB characters, then it's a
         * valid NUL; if not, then we've hit the end of the buffer.
         */
        if (yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars])
            /* This was really a NUL. */
            *yyg->yy_c_buf_p = '\0';

        else
        { /* need more input */
            int offset = (int)(yyg->yy_c_buf_p - yyg->yytext_ptr);
            ++yyg->yy_c_buf_p;

            switch (yy_get_next_buffer(yyscanner))
            {
                case EOB_ACT_LAST_MATCH:
                    /* This happens because yy_g_n_b()
                     * sees that we've accumulated a
                     * token and flags that we need to
                     * try matching the token before
                     * proceeding.  But for input(),
                     * there's no matching to consider.
                     * So convert the EOB_ACT_LAST_MATCH
                     * to EOB_ACT_END_OF_FILE.
                     */

                    /* Reset buffer status. */
                    yyrestart(yyin, yyscanner);

                    /*FALLTHROUGH*/

                case EOB_ACT_END_OF_FILE:
                {
                    if (yywrap(yyscanner))
                        return 0;

                    if (!yyg->yy_did_buffer_switch_on_eof)
                        YY_NEW_FILE;
#    ifdef __cplusplus
                    return yyinput(yyscanner);
#    else
                    return input(yyscanner);
#    endif
                }

                case EOB_ACT_CONTINUE_SCAN:
                    yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
                    break;
            }
        }
    }

    c                 = *(unsigned char *)yyg->yy_c_buf_p; /* cast for 8-bit char's */
    *yyg->yy_c_buf_p  = '\0';                              /* preserve yytext */
    yyg->yy_hold_char = *++yyg->yy_c_buf_p;

    if (c == '\n')

        do
        {
            yylineno++;
            yycolumn = 0;
        } while (0);

    return c;
}
#endif /* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * @param yyscanner The scanner object.
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyrestart(FILE *input_file, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    if (!YY_CURRENT_BUFFER)
    {
        yyensure_buffer_stack(yyscanner);
        YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE, yyscanner);
    }

    yy_init_buffer(YY_CURRENT_BUFFER, input_file, yyscanner);
    yy_load_buffer_state(yyscanner);
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * @param yyscanner The scanner object.
 */
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    /* TODO. We should be able to replace this entire function body
     * with
     *        yypop_buffer_state();
     *        yypush_buffer_state(new_buffer);
     */
    yyensure_buffer_stack(yyscanner);
    if (YY_CURRENT_BUFFER == new_buffer)
        return;

    if (YY_CURRENT_BUFFER)
    {
        /* Flush out information for old buffer. */
        *yyg->yy_c_buf_p                     = yyg->yy_hold_char;
        YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

    YY_CURRENT_BUFFER_LVALUE = new_buffer;
    yy_load_buffer_state(yyscanner);

    /* We don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    yyg->yy_did_buffer_switch_on_eof = 1;
}

static void yy_load_buffer_state(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    yyg->yy_n_chars      = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
    yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
    yyin                              = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
    yyg->yy_hold_char                 = *yyg->yy_c_buf_p;
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * @param yyscanner The scanner object.
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE yy_create_buffer(FILE *file, int size, yyscan_t yyscanner)
{
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state), yyscanner);
    if (!b)
        YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (char *)yyalloc((yy_size_t)(b->yy_buf_size + 2), yyscanner);
    if (!b->yy_ch_buf)
        YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

    b->yy_is_our_buffer = 1;

    yy_init_buffer(b, file, yyscanner);

    return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * @param yyscanner The scanner object.
 */
void yy_delete_buffer(YY_BUFFER_STATE b, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    if (!b)
        return;

    if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
        YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

    if (b->yy_is_our_buffer)
        yyfree((void *)b->yy_ch_buf, yyscanner);

    yyfree((void *)b, yyscanner);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
static void yy_init_buffer(YY_BUFFER_STATE b, FILE *file, yyscan_t yyscanner)

{
    int oerrno           = errno;
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    yy_flush_buffer(b, yyscanner);

    b->yy_input_file  = file;
    b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER)
    {
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

    b->yy_is_interactive = 0;

    errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * @param yyscanner The scanner object.
 */
void yy_flush_buffer(YY_BUFFER_STATE b, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    if (!b)
        return;

    b->yy_n_chars = 0;

    /* We always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[0];

    b->yy_at_bol        = 1;
    b->yy_buffer_status = YY_BUFFER_NEW;

    if (b == YY_CURRENT_BUFFER)
        yy_load_buffer_state(yyscanner);
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  @param yyscanner The scanner object.
 */
void yypush_buffer_state(YY_BUFFER_STATE new_buffer, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    if (new_buffer == NULL)
        return;

    yyensure_buffer_stack(yyscanner);

    /* This block is copied from yy_switch_to_buffer. */
    if (YY_CURRENT_BUFFER)
    {
        /* Flush out information for old buffer. */
        *yyg->yy_c_buf_p                     = yyg->yy_hold_char;
        YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

    /* Only push if top exists. Otherwise, replace top. */
    if (YY_CURRENT_BUFFER)
        yyg->yy_buffer_stack_top++;
    YY_CURRENT_BUFFER_LVALUE = new_buffer;

    /* copied from yy_switch_to_buffer. */
    yy_load_buffer_state(yyscanner);
    yyg->yy_did_buffer_switch_on_eof = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  @param yyscanner The scanner object.
 */
void yypop_buffer_state(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    if (!YY_CURRENT_BUFFER)
        return;

    yy_delete_buffer(YY_CURRENT_BUFFER, yyscanner);
    YY_CURRENT_BUFFER_LVALUE = NULL;
    if (yyg->yy_buffer_stack_top > 0)
        --yyg->yy_buffer_stack_top;

    if (YY_CURRENT_BUFFER)
    {
        yy_load_buffer_state(yyscanner);
        yyg->yy_did_buffer_switch_on_eof = 1;
    }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack(yyscan_t yyscanner)
{
    yy_size_t num_to_alloc;
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    if (!yyg->yy_buffer_stack)
    {

        /* First allocation is just for 2 elements, since we don't know if this
         * scanner will even need a stack. We use 2 instead of 1 to avoid an
         * immediate realloc on the next call.
         */
        num_to_alloc         = 1; /* After all that talk, this was set to 1 anyways... */
        yyg->yy_buffer_stack = (struct yy_buffer_state **)yyalloc(
            num_to_alloc * sizeof(struct yy_buffer_state *), yyscanner);
        if (!yyg->yy_buffer_stack)
            YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

        memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state *));

        yyg->yy_buffer_stack_max = num_to_alloc;
        yyg->yy_buffer_stack_top = 0;
        return;
    }

    if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1)
    {

        /* Increase the buffer to prepare for a possible push. */
        yy_size_t grow_size = 8 /* arbitrary grow size */;

        num_to_alloc         = yyg->yy_buffer_stack_max + grow_size;
        yyg->yy_buffer_stack = (struct yy_buffer_state **)yyrealloc(
            yyg->yy_buffer_stack, num_to_alloc * sizeof(struct yy_buffer_state *), yyscanner);
        if (!yyg->yy_buffer_stack)
            YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

        /* zero only the new slots.*/
        memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0,
               grow_size * sizeof(struct yy_buffer_state *));
        yyg->yy_buffer_stack_max = num_to_alloc;
    }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer(char *base, yy_size_t size, yyscan_t yyscanner)
{
    YY_BUFFER_STATE b;

    if (size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR ||
        base[size - 1] != YY_END_OF_BUFFER_CHAR)
        /* They forgot to leave room for the EOB's. */
        return NULL;

    b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state), yyscanner);
    if (!b)
        YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");

    b->yy_buf_size = (int)(size - 2); /* "- 2" to take care of EOB's */
    b->yy_buf_pos = b->yy_ch_buf = base;
    b->yy_is_our_buffer          = 0;
    b->yy_input_file             = NULL;
    b->yy_n_chars                = b->yy_buf_size;
    b->yy_is_interactive         = 0;
    b->yy_at_bol                 = 1;
    b->yy_fill_buffer            = 0;
    b->yy_buffer_status          = YY_BUFFER_NEW;

    yy_switch_to_buffer(b, yyscanner);

    return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string(const char *yystr, yyscan_t yyscanner)
{

    return yy_scan_bytes(yystr, (int)strlen(yystr), yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes(const char *yybytes, int _yybytes_len, yyscan_t yyscanner)
{
    YY_BUFFER_STATE b;
    char *buf;
    yy_size_t n;
    int i;

    /* Get memory for full buffer, including space for trailing EOB's. */
    n   = (yy_size_t)(_yybytes_len + 2);
    buf = (char *)yyalloc(n, yyscanner);
    if (!buf)
        YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");

    for (i = 0; i < _yybytes_len; ++i)
        buf[i] = yybytes[i];

    buf[_yybytes_len] = buf[_yybytes_len + 1] = YY_END_OF_BUFFER_CHAR;

    b = yy_scan_buffer(buf, n, yyscanner);
    if (!b)
        YY_FATAL_ERROR("bad buffer in yy_scan_bytes()");

    /* It's okay to grow etc. this buffer, and we should throw it
     * away when we're done.
     */
    b->yy_is_our_buffer = 1;

    return b;
}

#ifndef YY_EXIT_FAILURE
#    define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error(const char *msg, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    (void)yyg;
    fprintf(stderr, "%s\n", msg);
    exit(YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                      \
    do                                                 \
    {                                                  \
        /* Undo effects of setting up yytext. */       \
        int yyless_macro_arg = (n);                    \
        YY_LESS_LINENO(yyless_macro_arg);              \
        yytext[yyleng]    = yyg->yy_hold_char;         \
        yyg->yy_c_buf_p   = yytext + yyless_macro_arg; \
        yyg->yy_hold_char = *yyg->yy_c_buf_p;          \
        *yyg->yy_c_buf_p  = '\0';                      \
        yyleng            = yyless_macro_arg;          \
    } while (0)

/* Accessor  methods (get/set functions) to struct members. */

/** Get the user-defined data for this scanner.
 * @param yyscanner The scanner object.
 */
YY_EXTRA_TYPE yyget_extra(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yyextra;
}

/** Get the current line number.
 * @param yyscanner The scanner object.
 */
int yyget_lineno(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    if (!YY_CURRENT_BUFFER)
        return 0;

    return yylineno;
}

/** Get the current column number.
 * @param yyscanner The scanner object.
 */
int yyget_column(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    if (!YY_CURRENT_BUFFER)
        return 0;

    return yycolumn;
}

/** Get the input stream.
 * @param yyscanner The scanner object.
 */
FILE *yyget_in(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yyin;
}

/** Get the output stream.
 * @param yyscanner The scanner object.
 */
FILE *yyget_out(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yyout;
}

/** Get the length of the current token.
 * @param yyscanner The scanner object.
 */
int yyget_leng(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yyleng;
}

/** Get the current token.
 * @param yyscanner The scanner object.
 */

char *yyget_text(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yytext;
}

/** Set the user-defined data. This data is never touched by the scanner.
 * @param user_defined The data to be associated with this scanner.
 * @param yyscanner The scanner object.
 */
void yyset_extra(YY_EXTRA_TYPE user_defined, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    yyextra              = user_defined;
}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void yyset_lineno(int _line_number, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    /* lineno is only valid if an input buffer exists. */
    if (!YY_CURRENT_BUFFER)
        YY_FATAL_ERROR("yyset_lineno called with no buffer");

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void yyset_column(int _column_no, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    /* column is only valid if an input buffer exists. */
    if (!YY_CURRENT_BUFFER)
        YY_FATAL_ERROR("yyset_column called with no buffer");

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see yy_switch_to_buffer
 */
void yyset_in(FILE *_in_str, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    yyin                 = _in_str;
}

void yyset_out(FILE *_out_str, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    yyout                = _out_str;
}

int yyget_debug(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yy_flex_debug;
}

void yyset_debug(int _bdebug, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    yy_flex_debug        = _bdebug;
}

/* Accessor methods for yylval and yylloc */

YYSTYPE *yyget_lval(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yylval;
}

void yyset_lval(YYSTYPE *yylval_param, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    yylval               = yylval_param;
}

YYLTYPE *yyget_lloc(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yylloc;
}

void yyset_lloc(YYLTYPE *yylloc_param, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    yylloc               = yylloc_param;
}

/* User-visible API */

/* yylex_init is special because it creates the scanner itself, so it is
 * the ONLY reentrant function that doesn't take the scanner as the last argument.
 * That's why we explicitly handle the declaration, instead of using our macros.
 */
int yylex_init(yyscan_t *ptr_yy_globals)
{
    if (ptr_yy_globals == NULL)
    {
        errno = EINVAL;
        return 1;
    }

    *ptr_yy_globals = (yyscan_t)yyalloc(sizeof(struct yyguts_t), NULL);

    if (*ptr_yy_globals == NULL)
    {
        errno = ENOMEM;
        return 1;
    }

    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
    memset(*ptr_yy_globals, 0x00, sizeof(struct yyguts_t));

    return yy_init_globals(*ptr_yy_globals);
}

/* yylex_init_extra has the same functionality as yylex_init, but follows the
 * convention of taking the scanner as the last argument. Note however, that
 * this is a *pointer* to a scanner, as it will be allocated by this call (and
 * is the reason, too, why this function also must handle its own declaration).
 * The user defined value in the first argument will be available to yyalloc in
 * the yyextra field.
 */
int yylex_init_extra(YY_EXTRA_TYPE yy_user_defined, yyscan_t *ptr_yy_globals)
{
    struct yyguts_t dummy_yyguts;

    yyset_extra(yy_user_defined, &dummy_yyguts);

    if (ptr_yy_globals == NULL)
    {
        errno = EINVAL;
        return 1;
    }

    *ptr_yy_globals = (yyscan_t)yyalloc(sizeof(struct yyguts_t), &dummy_yyguts);

    if (*ptr_yy_globals == NULL)
    {
        errno = ENOMEM;
        return 1;
    }

    /* By setting to 0xAA, we expose bugs in
    yy_init_globals. Leave at 0x00 for releases. */
    memset(*ptr_yy_globals, 0x00, sizeof(struct yyguts_t));

    yyset_extra(yy_user_defined, *ptr_yy_globals);

    return yy_init_globals(*ptr_yy_globals);
}

static int yy_init_globals(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    yyg->yy_buffer_stack     = NULL;
    yyg->yy_buffer_stack_top = 0;
    yyg->yy_buffer_stack_max = 0;
    yyg->yy_c_buf_p          = NULL;
    yyg->yy_init             = 0;
    yyg->yy_start            = 0;

    yyg->yy_start_stack_ptr   = 0;
    yyg->yy_start_stack_depth = 0;
    yyg->yy_start_stack       = NULL;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin  = stdin;
    yyout = stdout;
#else
    yyin  = NULL;
    yyout = NULL;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    /* Pop the buffer stack, destroying each element. */
    while (YY_CURRENT_BUFFER)
    {
        yy_delete_buffer(YY_CURRENT_BUFFER, yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        yypop_buffer_state(yyscanner);
    }

    /* Destroy the stack itself. */
    yyfree(yyg->yy_buffer_stack, yyscanner);
    yyg->yy_buffer_stack = NULL;

    /* Destroy the start condition stack. */
    yyfree(yyg->yy_start_stack, yyscanner);
    yyg->yy_start_stack = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals(yyscanner);

    /* Destroy the main struct (reentrant only). */
    yyfree(yyscanner, yyscanner);
    yyscanner = NULL;
    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy(char *s1, const char *s2, int n, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    (void)yyg;

    int i;
    for (i = 0; i < n; ++i)
        s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char *s, yyscan_t yyscanner)
{
    int n;
    for (n = 0; s[n]; ++n)
        ;

    return n;
}
#endif

void *yyalloc(yy_size_t size, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    (void)yyg;
    return malloc(size);
}

void *yyrealloc(void *ptr, yy_size_t size, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    (void)yyg;

    /* The cast to (char *) in the following accommodates both
     * implementations that use char* generic pointers, and those
     * that use void* generic pointers.  It works with the latter
     * because both ANSI C and C++ allow castless assignment from
     * any pointer type to void*, and deal with argument conversions
     * as though doing an assignment.
     */
    return realloc(ptr, size);
}

void yyfree(void *ptr, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    (void)yyg;
    free((char *)ptr); /* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

yy_size_t string_input(char *buf, yy_size_t max_size, yyscan_t yyscanner)
{
    angle::pp::Token token;
    yyget_extra(yyscanner)->getPreprocessor().lex(&token);
    yy_size_t len = token.type == angle::pp::Token::LAST ? 0 : token.text.size();
    if (len < max_size)
        memcpy(buf, token.text.c_str(), len);
    yyset_column(token.location.file, yyscanner);
    yyset_lineno(token.location.line, yyscanner);

    if (len >= max_size)
        YY_FATAL_ERROR("Input buffer overflow");
    else if (len > 0)
        buf[len++] = ' ';
    return len;
}

int check_type(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    int token = IDENTIFIER;
    // Note that the ImmutableString used here isn't static or pool allocated - but it's fine since
    // yytext is valid for the duration of its use.
    const TSymbol *symbol =
        yyextra->symbolTable.find(ImmutableString(yytext, yyleng), yyextra->getShaderVersion());
    if (symbol && symbol->isStruct())
    {
        token = TYPE_NAME;
    }
    yylval->lex.symbol = symbol;
    return token;
}

int reserved_word(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    yyextra->error(*yylloc, "Illegal use of reserved word", yytext);
    return 0;
}

static bool is_extension_enabled_or_is_core(TParseContext *context,
                                            int extension_version,
                                            TExtension extension,
                                            int promotion_version)
{
    int version = context->getShaderVersion();

    // If version is at least promotion_version, symbol is definitely keyword.  Otherwise it's a
    // keyword if version is at least extension_version (where the extension was introduced) and
    // the extension is enabled.
    return version >= promotion_version ||
           (version >= extension_version && context->isExtensionEnabled(extension));
}

int ES2_reserved_ES3_keyword(TParseContext *context, int token)
{
    yyscan_t yyscanner = (yyscan_t)context->getScanner();

    if (context->getShaderVersion() < 300)
    {
        return reserved_word(yyscanner);
    }

    return token;
}

int ES2_keyword_ES3_reserved(TParseContext *context, int token)
{
    yyscan_t yyscanner = (yyscan_t)context->getScanner();

    if (context->getShaderVersion() >= 300)
    {
        return reserved_word(yyscanner);
    }

    return token;
}

int ES3_reserved_ES3_1_keyword(TParseContext *context, int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    if (context->getShaderVersion() < 300)
    {
        yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
        return check_type(yyscanner);
    }
    else if (context->getShaderVersion() == 300)
    {
        return reserved_word(yyscanner);
    }

    return token;
}

int ES3_keyword(TParseContext *context, int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // not a reserved word in GLSL ES 1.00, so could be used as an identifier/type name
    if (context->getShaderVersion() < 300)
    {
        yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
        return check_type(yyscanner);
    }

    return token;
}

int ES2_reserved_ES3_1_keyword(TParseContext *context, int token)
{
    yyscan_t yyscanner = (yyscan_t)context->getScanner();

    if (context->getShaderVersion() < 310)
    {
        return reserved_word(yyscanner);
    }

    return token;
}

int ES3_1_keyword(TParseContext *context, int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.10.
    if (context->getShaderVersion() >= 310)
    {
        return token;
    }

    // Otherwise can be used as an identifier/type name
    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int WEBGL_video_texture_extension(TParseContext *context, int token)
{
    // Available with WEBGL_video_texture_extension
    if (context->isExtensionEnabled(TExtension::WEBGL_video_texture))
    {
        return token;
    }

    // Otherwise can be used as an identifier/type name
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int ES2_extensions_ES3_keyword(TParseContext *context,
                               TExtension extension1,
                               TExtension extension2,
                               TExtension extension3,
                               int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.00 or GLSL ES 1.00 with enabled extension.
    if (is_extension_enabled_or_is_core(context, 100, extension1, 300))
    {
        return token;
    }
    else if (is_extension_enabled_or_is_core(context, 100, extension2, 300))
    {
        return token;
    }
    else if (is_extension_enabled_or_is_core(context, 100, extension3, 300))
    {
        return token;
    }

    // not a reserved word in GLSL ES 1.00, so could be used as an identifier/type name
    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int ES2_reserved_ES2_extension_ES3_keyword(TParseContext *context, TExtension extension, int token)
{
    yyscan_t yyscanner = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.00 or GLSL ES 1.00 with enabled extension.
    if (is_extension_enabled_or_is_core(context, 100, extension, 300))
    {
        return token;
    }

    // Reserved otherwise.
    return reserved_word(yyscanner);
}

int ES3_extension(TParseContext *context, TExtension extension, int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // a keyword word in GLSL ES 3.00 with enabled extension.
    if (context->getShaderVersion() >= 300 && context->isExtensionEnabled(extension))
    {
        return token;
    }

    // Otherwise can be used as an identifier/type name
    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int ES3_reserved_ES3_1_extension_ES3_2_keyword(TParseContext *context,
                                               TExtension extension,
                                               int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // a keyword in GLSL ES 3.10 with enabled extension
    if (is_extension_enabled_or_is_core(context, 310, extension, 320))
    {
        return token;
    }
    // a reserved word in GLSL ES 3.00+
    if (context->getShaderVersion() >= 300)
    {
        return reserved_word(yyscanner);
    }

    // Otherwise can be used as an identifier/type name
    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int ES3_reserved_ES3_extension(TParseContext *context, TExtension extension, int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    if (context->getShaderVersion() >= 300)
    {
        if (context->isExtensionEnabled(extension))
        {
            return token;
        }
        else
        {
            return reserved_word(yyscanner);
        }
    }

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int ES3_reserved_ES3_extension_ES3_1_keyword(TParseContext *context,
                                             TExtension extension,
                                             int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.00 with enabled extension or in GLSL ES 3.10
    if (is_extension_enabled_or_is_core(context, 300, extension, 310))
    {
        return token;
    }

    if (context->getShaderVersion() == 300)
    {
        return reserved_word(yyscanner);
    }

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int ES3_reserved_ES3_extension_ES3_2_keyword(TParseContext *context,
                                             TExtension extension,
                                             int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.00 with enabled extension or in GLSL ES 3.20
    if (is_extension_enabled_or_is_core(context, 300, extension, 320))
    {
        return token;
    }

    if (context->getShaderVersion() == 300 || context->getShaderVersion() == 310)
    {
        return reserved_word(yyscanner);
    }

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

static int ES3_1_reserved_ES3_1_extension_ES3_2_keyword(TParseContext *context,
                                                        TExtension extension,
                                                        int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.20 or GLSL ES 3.10 with enabled extension.
    if (is_extension_enabled_or_is_core(context, 310, extension, 320))
    {
        return token;
    }

    // A reserved word in GLSL ES 3.10
    if (context->getShaderVersion() == 310)
    {
        return reserved_word(yyscanner);
    }

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

static int ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(TParseContext *context,
                                                          TExtension extension1,
                                                          TExtension extension2,
                                                          int token1,
                                                          int token2)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.20 or GLSL ES 3.10 with enabled extension.
    if (is_extension_enabled_or_is_core(context, 310, extension1, 320))
    {
        return token1;
    }
    else if (is_extension_enabled_or_is_core(context, 310, extension2, 320))
    {
        return token2;
    }

    // A reserved word in GLSL ES 3.10
    if (context->getShaderVersion() == 310)
    {
        return reserved_word(yyscanner);
    }

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

static int ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(TParseContext *context,
                                                                TExtension extension1,
                                                                TExtension extension2,
                                                                int token1,
                                                                int token2)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.20 or GLSL ES 3.10 with enabled extension.
    if (is_extension_enabled_or_is_core(context, 310, extension1, 320))
    {
        return token1;
    }
    else if (is_extension_enabled_or_is_core(context, 310, extension2, 320))
    {
        return token2;
    }

    // A reserved word in GLSL ES 3.00 and 3.10
    if (context->getShaderVersion() >= 300)
    {
        return reserved_word(yyscanner);
    }

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int uint_constant(TParseContext *context)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();

    if (context->getShaderVersion() < 300)
    {
        context->error(*yylloc, "Unsigned integers are unsupported prior to GLSL ES 3.00", yytext);
        return 0;
    }

    if (!atoi_clamp(yytext, &(yylval->lex.u)))
        yyextra->error(*yylloc, "Integer overflow", yytext);

    return UINTCONSTANT;
}

int floatsuffix_check(TParseContext *context)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();

    if (context->getShaderVersion() < 300)
    {
        context->error(*yylloc, "Floating-point suffix unsupported prior to GLSL ES 3.00", yytext);
        return 0;
    }

    std::string text = yytext;
    text.resize(text.size() - 1);
    if (!strtof_clamp(text, &(yylval->lex.f)))
        yyextra->warning(*yylloc, "Float overflow", yytext);

    return (FLOATCONSTANT);
}

void yyerror(YYLTYPE *lloc, TParseContext *context, void *scanner, const char *reason)
{
    context->error(*lloc, reason, yyget_text(scanner));
}

int int_constant(TParseContext *context)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();

    unsigned int u;
    if (!atoi_clamp(yytext, &u))
    {
        if (context->getShaderVersion() >= 300)
            yyextra->error(*yylloc, "Integer overflow", yytext);
        else
            yyextra->warning(*yylloc, "Integer overflow", yytext);
    }
    yylval->lex.i = static_cast<int>(u);
    return INTCONSTANT;
}

int float_constant(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    if (!strtof_clamp(yytext, &(yylval->lex.f)))
        yyextra->warning(*yylloc, "Float overflow", yytext);
    return FLOATCONSTANT;
}

int yuvcscstandardext_constant(TParseContext *context)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // a reserved word in GLSL ES 3.00 with enabled extension, otherwise could be used as an
    // identifier/type name
    if (context->getShaderVersion() >= 300 &&
        context->isExtensionEnabled(TExtension::EXT_YUV_target))
    {
        yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
        return YUVCSCSTANDARDEXTCONSTANT;
    }

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int glslang_initialize(TParseContext *context)
{
    yyscan_t scanner = NULL;
    if (yylex_init_extra(context, &scanner))
        return 1;

    context->setScanner(scanner);
    return 0;
}

int glslang_finalize(TParseContext *context)
{
    yyscan_t scanner = context->getScanner();
    if (scanner == NULL)
        return 0;

    context->setScanner(NULL);
    yylex_destroy(scanner);

    return 0;
}

int glslang_scan(size_t count,
                 const char *const string[],
                 const int length[],
                 TParseContext *context)
{
    yyrestart(NULL, context->getScanner());
    yyset_column(0, context->getScanner());
    yyset_lineno(1, context->getScanner());

    // Initialize preprocessor.
    angle::pp::Preprocessor *preprocessor = &context->getPreprocessor();

    if (!preprocessor->init(count, string, length))
        return 1;

    // Define extension macros.
    const TExtensionBehavior &extBehavior = context->extensionBehavior();
    for (TExtensionBehavior::const_iterator iter = extBehavior.begin(); iter != extBehavior.end();
         ++iter)
    {
        // OVR_multiview should not be defined for WebGL spec'ed shaders.
        if (sh::IsWebGLBasedSpec(context->getShaderSpec()) &&
            iter->first == TExtension::OVR_multiview)
        {
            continue;
        }
        preprocessor->predefineMacro(GetExtensionNameString(iter->first), 1);
    }
    if (context->getFragmentPrecisionHigh())
        preprocessor->predefineMacro("GL_FRAGMENT_PRECISION_HIGH", 1);

    preprocessor->setMaxTokenSize(sh::GetGlobalMaxTokenSize(context->getShaderSpec()));

    return 0;
}
