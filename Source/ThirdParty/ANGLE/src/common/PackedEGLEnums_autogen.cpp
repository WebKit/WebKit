// GENERATED FILE - DO NOT EDIT.
// Generated by gen_packed_gl_enums.py using data from packed_egl_enums.json.
//
// Copyright 2017 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// PackedEGLEnums_autogen.cpp:
//   Implements ANGLE-specific enums classes for EGLenums and functions operating
//   on them.

#include "common/PackedEGLEnums_autogen.h"
#include "common/debug.h"

namespace egl
{

template <>
ColorSpace FromEGLenum<ColorSpace>(EGLenum from)
{
    switch (from)
    {
        case EGL_COLORSPACE_sRGB:
            return ColorSpace::sRGB;
        case EGL_COLORSPACE_LINEAR:
            return ColorSpace::Linear;
        default:
            return ColorSpace::InvalidEnum;
    }
}

EGLenum ToEGLenum(ColorSpace from)
{
    switch (from)
    {
        case ColorSpace::sRGB:
            return EGL_COLORSPACE_sRGB;
        case ColorSpace::Linear:
            return EGL_COLORSPACE_LINEAR;
        default:
            UNREACHABLE();
            return 0;
    }
}

std::ostream &operator<<(std::ostream &os, ColorSpace value)
{
    switch (value)
    {
        case ColorSpace::sRGB:
            os << "EGL_COLORSPACE_sRGB";
            break;
        case ColorSpace::Linear:
            os << "EGL_COLORSPACE_LINEAR";
            break;
        default:
            os << "GL_INVALID_ENUM";
            break;
    }
    return os;
}

template <>
CompositorTiming FromEGLenum<CompositorTiming>(EGLenum from)
{
    switch (from)
    {
        case EGL_COMPOSITE_DEADLINE_ANDROID:
            return CompositorTiming::CompositeDeadline;
        case EGL_COMPOSITE_INTERVAL_ANDROID:
            return CompositorTiming::CompositInterval;
        case EGL_COMPOSITE_TO_PRESENT_LATENCY_ANDROID:
            return CompositorTiming::CompositToPresentLatency;
        default:
            return CompositorTiming::InvalidEnum;
    }
}

EGLenum ToEGLenum(CompositorTiming from)
{
    switch (from)
    {
        case CompositorTiming::CompositeDeadline:
            return EGL_COMPOSITE_DEADLINE_ANDROID;
        case CompositorTiming::CompositInterval:
            return EGL_COMPOSITE_INTERVAL_ANDROID;
        case CompositorTiming::CompositToPresentLatency:
            return EGL_COMPOSITE_TO_PRESENT_LATENCY_ANDROID;
        default:
            UNREACHABLE();
            return 0;
    }
}

std::ostream &operator<<(std::ostream &os, CompositorTiming value)
{
    switch (value)
    {
        case CompositorTiming::CompositeDeadline:
            os << "EGL_COMPOSITE_DEADLINE_ANDROID";
            break;
        case CompositorTiming::CompositInterval:
            os << "EGL_COMPOSITE_INTERVAL_ANDROID";
            break;
        case CompositorTiming::CompositToPresentLatency:
            os << "EGL_COMPOSITE_TO_PRESENT_LATENCY_ANDROID";
            break;
        default:
            os << "GL_INVALID_ENUM";
            break;
    }
    return os;
}

template <>
ContextPriority FromEGLenum<ContextPriority>(EGLenum from)
{
    switch (from)
    {
        case EGL_CONTEXT_PRIORITY_LOW_IMG:
            return ContextPriority::Low;
        case EGL_CONTEXT_PRIORITY_MEDIUM_IMG:
            return ContextPriority::Medium;
        case EGL_CONTEXT_PRIORITY_HIGH_IMG:
            return ContextPriority::High;
        default:
            return ContextPriority::InvalidEnum;
    }
}

EGLenum ToEGLenum(ContextPriority from)
{
    switch (from)
    {
        case ContextPriority::Low:
            return EGL_CONTEXT_PRIORITY_LOW_IMG;
        case ContextPriority::Medium:
            return EGL_CONTEXT_PRIORITY_MEDIUM_IMG;
        case ContextPriority::High:
            return EGL_CONTEXT_PRIORITY_HIGH_IMG;
        default:
            UNREACHABLE();
            return 0;
    }
}

std::ostream &operator<<(std::ostream &os, ContextPriority value)
{
    switch (value)
    {
        case ContextPriority::Low:
            os << "EGL_CONTEXT_PRIORITY_LOW_IMG";
            break;
        case ContextPriority::Medium:
            os << "EGL_CONTEXT_PRIORITY_MEDIUM_IMG";
            break;
        case ContextPriority::High:
            os << "EGL_CONTEXT_PRIORITY_HIGH_IMG";
            break;
        default:
            os << "GL_INVALID_ENUM";
            break;
    }
    return os;
}

template <>
MessageType FromEGLenum<MessageType>(EGLenum from)
{
    switch (from)
    {
        case EGL_DEBUG_MSG_CRITICAL_KHR:
            return MessageType::Critical;
        case EGL_DEBUG_MSG_ERROR_KHR:
            return MessageType::Error;
        case EGL_DEBUG_MSG_WARN_KHR:
            return MessageType::Warn;
        case EGL_DEBUG_MSG_INFO_KHR:
            return MessageType::Info;
        default:
            return MessageType::InvalidEnum;
    }
}

EGLenum ToEGLenum(MessageType from)
{
    switch (from)
    {
        case MessageType::Critical:
            return EGL_DEBUG_MSG_CRITICAL_KHR;
        case MessageType::Error:
            return EGL_DEBUG_MSG_ERROR_KHR;
        case MessageType::Warn:
            return EGL_DEBUG_MSG_WARN_KHR;
        case MessageType::Info:
            return EGL_DEBUG_MSG_INFO_KHR;
        default:
            UNREACHABLE();
            return 0;
    }
}

std::ostream &operator<<(std::ostream &os, MessageType value)
{
    switch (value)
    {
        case MessageType::Critical:
            os << "EGL_DEBUG_MSG_CRITICAL_KHR";
            break;
        case MessageType::Error:
            os << "EGL_DEBUG_MSG_ERROR_KHR";
            break;
        case MessageType::Warn:
            os << "EGL_DEBUG_MSG_WARN_KHR";
            break;
        case MessageType::Info:
            os << "EGL_DEBUG_MSG_INFO_KHR";
            break;
        default:
            os << "GL_INVALID_ENUM";
            break;
    }
    return os;
}

template <>
ObjectType FromEGLenum<ObjectType>(EGLenum from)
{
    switch (from)
    {
        case EGL_OBJECT_THREAD_KHR:
            return ObjectType::Thread;
        case EGL_OBJECT_DISPLAY_KHR:
            return ObjectType::Display;
        case EGL_OBJECT_CONTEXT_KHR:
            return ObjectType::Context;
        case EGL_OBJECT_SURFACE_KHR:
            return ObjectType::Surface;
        case EGL_OBJECT_IMAGE_KHR:
            return ObjectType::Image;
        case EGL_OBJECT_SYNC_KHR:
            return ObjectType::Sync;
        case EGL_OBJECT_STREAM_KHR:
            return ObjectType::Stream;
        default:
            return ObjectType::InvalidEnum;
    }
}

EGLenum ToEGLenum(ObjectType from)
{
    switch (from)
    {
        case ObjectType::Thread:
            return EGL_OBJECT_THREAD_KHR;
        case ObjectType::Display:
            return EGL_OBJECT_DISPLAY_KHR;
        case ObjectType::Context:
            return EGL_OBJECT_CONTEXT_KHR;
        case ObjectType::Surface:
            return EGL_OBJECT_SURFACE_KHR;
        case ObjectType::Image:
            return EGL_OBJECT_IMAGE_KHR;
        case ObjectType::Sync:
            return EGL_OBJECT_SYNC_KHR;
        case ObjectType::Stream:
            return EGL_OBJECT_STREAM_KHR;
        default:
            UNREACHABLE();
            return 0;
    }
}

std::ostream &operator<<(std::ostream &os, ObjectType value)
{
    switch (value)
    {
        case ObjectType::Thread:
            os << "EGL_OBJECT_THREAD_KHR";
            break;
        case ObjectType::Display:
            os << "EGL_OBJECT_DISPLAY_KHR";
            break;
        case ObjectType::Context:
            os << "EGL_OBJECT_CONTEXT_KHR";
            break;
        case ObjectType::Surface:
            os << "EGL_OBJECT_SURFACE_KHR";
            break;
        case ObjectType::Image:
            os << "EGL_OBJECT_IMAGE_KHR";
            break;
        case ObjectType::Sync:
            os << "EGL_OBJECT_SYNC_KHR";
            break;
        case ObjectType::Stream:
            os << "EGL_OBJECT_STREAM_KHR";
            break;
        default:
            os << "GL_INVALID_ENUM";
            break;
    }
    return os;
}

template <>
TextureFormat FromEGLenum<TextureFormat>(EGLenum from)
{
    switch (from)
    {
        case EGL_NO_TEXTURE:
            return TextureFormat::NoTexture;
        case EGL_TEXTURE_RGB:
            return TextureFormat::RGB;
        case EGL_TEXTURE_RGBA:
            return TextureFormat::RGBA;
        default:
            return TextureFormat::InvalidEnum;
    }
}

EGLenum ToEGLenum(TextureFormat from)
{
    switch (from)
    {
        case TextureFormat::NoTexture:
            return EGL_NO_TEXTURE;
        case TextureFormat::RGB:
            return EGL_TEXTURE_RGB;
        case TextureFormat::RGBA:
            return EGL_TEXTURE_RGBA;
        default:
            UNREACHABLE();
            return 0;
    }
}

std::ostream &operator<<(std::ostream &os, TextureFormat value)
{
    switch (value)
    {
        case TextureFormat::NoTexture:
            os << "EGL_NO_TEXTURE";
            break;
        case TextureFormat::RGB:
            os << "EGL_TEXTURE_RGB";
            break;
        case TextureFormat::RGBA:
            os << "EGL_TEXTURE_RGBA";
            break;
        default:
            os << "GL_INVALID_ENUM";
            break;
    }
    return os;
}

template <>
Timestamp FromEGLenum<Timestamp>(EGLenum from)
{
    switch (from)
    {
        case EGL_REQUESTED_PRESENT_TIME_ANDROID:
            return Timestamp::RequestedPresentTime;
        case EGL_RENDERING_COMPLETE_TIME_ANDROID:
            return Timestamp::RenderingCompleteTime;
        case EGL_COMPOSITION_LATCH_TIME_ANDROID:
            return Timestamp::CompositionLatchTime;
        case EGL_FIRST_COMPOSITION_START_TIME_ANDROID:
            return Timestamp::FirstCompositionStartTime;
        case EGL_LAST_COMPOSITION_START_TIME_ANDROID:
            return Timestamp::LastCompositionStartTime;
        case EGL_FIRST_COMPOSITION_GPU_FINISHED_TIME_ANDROID:
            return Timestamp::FirstCompositionGPUFinishedTime;
        case EGL_DISPLAY_PRESENT_TIME_ANDROID:
            return Timestamp::DisplayPresentTime;
        case EGL_DEQUEUE_READY_TIME_ANDROID:
            return Timestamp::DequeueReadyTime;
        case EGL_READS_DONE_TIME_ANDROID:
            return Timestamp::ReadsDoneTime;
        default:
            return Timestamp::InvalidEnum;
    }
}

EGLenum ToEGLenum(Timestamp from)
{
    switch (from)
    {
        case Timestamp::RequestedPresentTime:
            return EGL_REQUESTED_PRESENT_TIME_ANDROID;
        case Timestamp::RenderingCompleteTime:
            return EGL_RENDERING_COMPLETE_TIME_ANDROID;
        case Timestamp::CompositionLatchTime:
            return EGL_COMPOSITION_LATCH_TIME_ANDROID;
        case Timestamp::FirstCompositionStartTime:
            return EGL_FIRST_COMPOSITION_START_TIME_ANDROID;
        case Timestamp::LastCompositionStartTime:
            return EGL_LAST_COMPOSITION_START_TIME_ANDROID;
        case Timestamp::FirstCompositionGPUFinishedTime:
            return EGL_FIRST_COMPOSITION_GPU_FINISHED_TIME_ANDROID;
        case Timestamp::DisplayPresentTime:
            return EGL_DISPLAY_PRESENT_TIME_ANDROID;
        case Timestamp::DequeueReadyTime:
            return EGL_DEQUEUE_READY_TIME_ANDROID;
        case Timestamp::ReadsDoneTime:
            return EGL_READS_DONE_TIME_ANDROID;
        default:
            UNREACHABLE();
            return 0;
    }
}

std::ostream &operator<<(std::ostream &os, Timestamp value)
{
    switch (value)
    {
        case Timestamp::RequestedPresentTime:
            os << "EGL_REQUESTED_PRESENT_TIME_ANDROID";
            break;
        case Timestamp::RenderingCompleteTime:
            os << "EGL_RENDERING_COMPLETE_TIME_ANDROID";
            break;
        case Timestamp::CompositionLatchTime:
            os << "EGL_COMPOSITION_LATCH_TIME_ANDROID";
            break;
        case Timestamp::FirstCompositionStartTime:
            os << "EGL_FIRST_COMPOSITION_START_TIME_ANDROID";
            break;
        case Timestamp::LastCompositionStartTime:
            os << "EGL_LAST_COMPOSITION_START_TIME_ANDROID";
            break;
        case Timestamp::FirstCompositionGPUFinishedTime:
            os << "EGL_FIRST_COMPOSITION_GPU_FINISHED_TIME_ANDROID";
            break;
        case Timestamp::DisplayPresentTime:
            os << "EGL_DISPLAY_PRESENT_TIME_ANDROID";
            break;
        case Timestamp::DequeueReadyTime:
            os << "EGL_DEQUEUE_READY_TIME_ANDROID";
            break;
        case Timestamp::ReadsDoneTime:
            os << "EGL_READS_DONE_TIME_ANDROID";
            break;
        default:
            os << "GL_INVALID_ENUM";
            break;
    }
    return os;
}

}  // namespace egl
