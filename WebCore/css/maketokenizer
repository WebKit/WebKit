print <<END;
/*
 * This file is part of the DOM implementation for KDE.
 *
 * Copyright (C) 2003 Lars Knoll (knoll\@kde.org)
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */

/* This file is mostly data generated by flex. Unfortunately flex
   can't handle 16bit strings directly, so we just copy the part of
   the code we need and modify it to our needs.

   Most of the defines below are to make sure we can easily use the
   flex generated code, using as little editing as possible.

   The flex syntax to generate the lexer are more or less directly
   copied from the CSS2.1 specs, with some fixes for comments and
   the important symbol.

   To regenerate, run flex on tokenizer.flex. After this, copy the
   data tables and the YY_DECL method over to this file. Remove the
   init code from YY_DECL and change the YY_END_OF_BUFFER to only call
   yyterminate().

*/

// --------- begin generated code -------------------

END

{
print<<END

#include "CSSGrammar.h"

#define INITIAL 0
#define mediaquery 1
#define forkeyword 2

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;
#endif /* ! C99 */
END
}


while (<>) {
    last if /YY_NUM_RULES/;
}

print;
while (<>) {
    last if /yy_last_accepting/;
    print;
}

# media query, tokenizer state support
while (<>) {
  last if /yytext/;
}
while (<>) {
  last if not (/define/ || /line/) ;
  print;
}

while (<>) {
    last if /^YY_DECL/;
}

print;
while (<>) {
    s/char/UChar/;
    print;
    last if /yy_act/;
}

while (<>) {
    last if /while \( 1 \)/;
}

print;
while (<>) {
    next if /^yy_match:/;
    next if /^do_action:/;
    last if /YY_END_OF_BUFFER/;
    print;
    print "case YY_END_OF_BUFFER:\n" if /^case YY_STATE_EOF\(INITIAL\):/;
}

while (<>) {
    last if /default:/;
}

print;
while (<>) {
    print;
    last if /end of yylex/;
}

# We don't want the remainder of flex's output.
# However, flex may choke with "flex: error writing output file <stdout>"
# if its stdout is unexpectedly closed on it.
# Consume the remaining output.
while (<>) {
}
