#!/usr/bin/env python
#
# Copyright (C) 2009 Google Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#    * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#    * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""Does WebKit-lint on C/C++ files.

The goal of this script is to identify places in the code that *may*
be in non-compliance with WebKit style.  It does not attempt to fix
up these problems -- the point is to educate.  It does also not
attempt to find all problems, or to ensure that everything it does
find is legitimately a problem.

In particular, we can get very confused by /* and // inside strings!
We do a small hack, which is to ignore //'s with "'s after them on the
same line, but it is far from perfect (in either direction).
"""

import codecs
import os
import os.path
import sys

import modules.cpp_style as cpp_style
from modules.diff_parser import DiffParser
from modules.scm import detect_scm_system


cpp_style._USAGE = """
Syntax: %(program_name)s [--verbose=#] [--git-commit=<SingleCommit>] [--output=vs7]
        [--filter=-x,+y,...] [file] ...

  The style guidelines this tries to follow are here:
    http://webkit.org/coding/coding-style.html

  Every style error is given a confidence score from 1-5, with 5 meaning
  we are certain of the problem, and 1 meaning it could be a legitimate
  construct.  This can miss some errors and does not substitute for
  code review.

  To prevent specific lines from being linted, add a '// NOLINT' comment to the
  end of the line.

  Linted extensions are .cpp, .c and .h.  Other file types are ignored.

  The file parameter is optional and accepts multiple files.  Leaving
  out the file parameter applies the check to all files considered changed
  by your source control management system.

  Flags:

    verbose=#
      A number 0-5 to restrict errors to certain verbosity levels.
      Defaults to %(default_verbosity)s.

    git-commit=<SingleCommit>
      Checks the style of everything from the given commit to the local tree.

    output=vs7
      The output format, which may be one of
        emacs : to ease emacs parsing
        vs7   : compatible with Visual Studio
      Defaults to "%(default_output_format)s". Other formats are unsupported.

    filter=-x,+y,...
      A comma-separated list of boolean filter rules used to filter
      which categories of style guidelines to check.  The script checks
      a category if the category passes the filter rules, as follows.

      Any webkit category starts out passing.  All filter rules are then
      evaluated left to right, with later rules taking precedence.  For
      example, the rule "+foo" passes any category that starts with "foo",
      and "-foo" fails any such category.  The filter input "-whitespace,
      +whitespace/braces" fails the category "whitespace/tab" and passes
      "whitespace/braces".

      Examples: --filter=-whitespace,+whitespace/braces
                --filter=-whitespace,-runtime/printf,+runtime/printf_format
                --filter=-,+build/include_what_you_use

      Category names appear in error messages in brackets, for example
      [whitespace/indent].  To see a list of all categories available to
      %(program_name)s, along with which are enabled by default, pass
      the empty filter as follows:
         --filter=
""" % {
    'program_name': os.path.basename(sys.argv[0]),
    'default_verbosity': cpp_style._DEFAULT_VERBOSITY,
    'default_output_format': cpp_style._DEFAULT_OUTPUT_FORMAT
    }


def process_patch(patch_string):
    """Does lint on a single patch.

    Args:
      patch_string: A string of a patch.
    """
    patch = DiffParser(patch_string.splitlines())
    for filename, diff in patch.files.iteritems():
        file_extension = os.path.splitext(filename)[1]

        if file_extension in ['.cpp', '.c', '.h']:
            line_numbers = set()

            def error_for_patch(filename, line_number, category, confidence, message):
                """Wrapper function of cpp_style.error for patches.

                This function outputs errors only if the line number
                corresponds to lines which are modified or added.
                """
                if not line_numbers:
                    for line in diff.lines:
                        # When deleted line is not set, it means that
                        # the line is newly added.
                        if not line[0]:
                            line_numbers.add(line[1])

                if line_number in line_numbers:
                    cpp_style.error(filename, line_number, category, confidence, message)

            cpp_style.process_file(filename, error=error_for_patch)


def main():
    cpp_style._DEFAULT_FILTER_RULES = cpp_style._WEBKIT_FILTER_RULES

    (files, flags) = cpp_style.parse_arguments(sys.argv[1:], ["git-commit="],
                                               display_help=True)

    # Change stderr to write with replacement characters so we don't die
    # if we try to print something containing non-ASCII characters.
    sys.stderr = codecs.StreamReaderWriter(sys.stderr,
                                           codecs.getreader('utf8'),
                                           codecs.getwriter('utf8'),
                                           'replace')

    if files and "--git-commit" in flags:
        cpp_style.exit_with_usage('It is not possible to check files and a '
                                  'specific commit at the same time.',
                                  display_help=True)

    if files:
        for filename in files:
            cpp_style.process_file(filename)

    else:
        cwd = os.path.abspath('.')
        scm = detect_scm_system(cwd)

        if "--git-commit" in flags:
            commit = flags["--git-commit"]
            if '..' in commit:
                # FIXME: If the range is a "...", the code should find the common ancestor and
                # start there (see git diff --help for information about how ... usually works).
                commit = commit[:commit.find('..')]
                print >> sys.stderr, "Warning: Ranges are not supported for --git-commit. Checking all changes since %s.\n" % commit
            patch = scm.create_patch_since_local_commit(commit)
        else:
            patch = scm.create_patch()
        process_patch(patch)

    sys.stderr.write('Total errors found: %d\n' % cpp_style.error_count())
    sys.exit(cpp_style.error_count() > 0)


if __name__ == "__main__":
    main()
