#!/usr/bin/env ruby

# Copyright (C) 2012 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
# THE POSSIBILITY OF SUCH DAMAGE.

require 'rubygems'

require 'json'
require 'readline'

class Bytecode
    attr_accessor :bytecodeIndex, :opcode, :description, :topCounts
    
    def initialize(bytecodeIndex, opcode, description)
        @bytecodeIndex = bytecodeIndex
        @opcode = opcode
        @description = description
        @topCounts = []
    end
    
    def shouldHaveCounts?
        @opcode != "op_call_put_result"
    end
    
    def addTopCount(count)
        @topCounts << count
    end
    
    def totalExecutionCount
        sum = 0
        @topCounts.each {
            | value |
            sum += value.count
        }
        sum
    end
    
    def executionCount(engine)
        sum = 0
        @topCounts.each {
            | value |
            if value.engine == engine
                sum += value.count
            end
        }
        sum
    end
end

class Bytecodes
    attr_accessor :hash, :source
    include Enumerable
    
    def initialize(json)
        @hash = json["hash"].to_s
        @source = json["sourceCode"].to_s
        @bytecode = {}
        json["bytecode"].each {
            | subJson |
            index = subJson["bytecodeIndex"].to_i
            @bytecode[index] = Bytecode.new(index, subJson["opcode"].to_s, subJson["description"].to_s)
        }
    end
    
    def each
        @bytecode.values.sort{|a, b| a.bytecodeIndex <=> b.bytecodeIndex}.each {
            | value |
            yield value
        }
    end
    
    def bytecode(bytecodeIndex)
        @bytecode[bytecodeIndex]
    end
    
    def totalMaxExecutionCount
        max = 0
        @bytecode.each_value {
            | bytecode |
            max = [max, bytecode.totalExecutionCount].max
        }
        max
    end
    
    def maxExecutionCount(engine)
        max = 0
        @bytecode.each_value {
            | bytecode |
            max = [max, bytecode.executionCount(engine)].max
        }
        max
    end
end

def originStackFromJSON(json)
    json.map {
        | subJson |
        $bytecodes[subJson["bytecodesID"].to_i].bytecode(subJson["bytecodeIndex"].to_i)
    }
end

class CompiledBytecode
    attr_accessor :origin, :description
    
    def initialize(json)
        @origin = originStackFromJSON(json["origin"])
        @description = json["description"].to_s
    end
end

class ExecutionCounter
    attr_accessor :origin, :engine, :count
    
    def initialize(origin, engine, count)
        @origin = origin
        @engine = engine
        @count = count
    end
end

class Compilation
    attr_accessor :bytecode, :engine, :descriptions, :counters
    
    def initialize(json)
        @bytecode = $bytecodes[json["bytecodesID"].to_i]
        @engine = json["compilationKind"]
        @descriptions = json["descriptions"].map {
            | subJson |
            CompiledBytecode.new(subJson)
        }
        @counters = {}
        json["counters"].each {
            | subJson |
            origin = originStackFromJSON(subJson["origin"])
            counter = ExecutionCounter.new(origin, @engine, subJson["executionCount"].to_i)
            @counters[origin] = counter
            origin[-1].addTopCount(counter)
        }
    end
end

$json = JSON::parse(IO::read(ARGV[0]))
$bytecodes = $json["bytecodes"].map {
    | subJson |
    Bytecodes.new(subJson)
}
$compilations = $json["compilations"].map {
    | subJson |
    Compilation.new(subJson)
}
$engines = ["Baseline", "DFG"]

def lpad(str,chars)
  if str.length>chars
    str
  else
    "%#{chars}s"%(str)
  end
end

def rpad(str, chars)
    while str.length < chars
        str += " "
    end
    str
end

def center(str, chars)
    while str.length < chars
        str += " "
        if str.length < chars
            str = " " + str
        end
    end
    str
end

def mayBeHash(hash)
    hash =~ /^#/ or hash.size == 6
end

def getHash(hash)
    if hash =~ /^#/
        $~.post_match
    else
        hash
    end
end

def sourceOnOneLine(source)
    source = source.gsub(/\s+/, ' ')
    if source.size > 80
        source[0..77] + "..."
    else
        source
    end
end

def executeCommand(*commandArray)
    command = commandArray[0]
    args = commandArray[1..-1]
    case command
    when "help", "h", "?"
        puts "summary (s)     Print a summary of code block execution rates."
        puts "display (d)     Display details for a code block."
        puts "help (h)        Print this message."
        puts "quit (q)        Quit."
    when "quit", "q", "exit"
        exit 0
    when "summary", "s"
        hashCols = 14
        countCols = 10 * $engines.size
        
        puts(rpad("CodeBlock", hashCols) + " " + rpad($engines.join("/") + " Counts", countCols) + " Source")
        $bytecodes.sort {
            | a, b |
            b.totalMaxExecutionCount <=> a.totalMaxExecutionCount
        }.each {
            | bytecode |
            puts(center("#" + bytecode.hash, hashCols) + " " +
                 center($engines.map {
                            | engine |
                            bytecode.maxExecutionCount(engine).to_s
                        }.join("/"), countCols) + " " +
                 sourceOnOneLine(bytecode.source))
        }
    when "display", "d"
        case args.length
        when 1
            hash = args[0]
            engine = "Baseline"
            $compilations.each {
                | compilation |
                next if compilation.bytecode.hash != hash
                
                if compilation.engine == "DFG"
                    engine = "DFG"
                    break
                end
            }
        when 2
            if mayBeHash(args[0])
                hash = args[0]
                engine = args[1]
            else
                engine = args[0]
                hash = args[1]
            end
        else
            puts "Usage: summary <code block hash> <engine>"
            return
        end
        
        unless $engines.index(engine)
            puts "#{engine} is not a valid engine, try #{$engines.join(' or ')}."
            return
        end
        
        countCols = 10 * $engines.size
        $compilations.each {
            | compilation |
            next if compilation.bytecode.hash != hash
            next if compilation.engine != engine
            
            puts(rpad($engines.join("/") + " Counts", countCols) + " Disassembly for #{hash} in #{engine}")
            compilation.descriptions.each {
                | description |
                # FIXME: We should have a better way of detecting things like CountExecution nodes
                # and slow path entries in the baseline JIT.
                next if description.description =~ /CountExecution\(/ and engine == "DFG"
                if description.origin.empty? or not description.origin[-1].shouldHaveCounts? or (engine == "Baseline" and description.description =~ /^\s*\(S\)/)
                    countsString = ""
                else
                    countsString = $engines.map {
                        | myEngine |
                        description.origin[-1].executionCount(myEngine)
                    }.join("/")
                end
                description.description.split("\n").each {
                    | line |
                    puts(center(countsString, countCols) + " " + line.chomp)
                }
            }
        }
    else
        puts "Invalid command: #{command}"
    end
end

executeCommand("summary")

while commandLine = Readline.readline("> ", true)
    executeCommand(*commandLine.split)
end

