{"version":3,"file":"tree.js","names":["assert","compareQueries","Ordering","TestQueryMultiCase","TestQuerySingleCase","TestQueryMultiFile","TestQueryMultiTest","kBigSeparator","kWildcard","kPathSeparator","kParamSeparator","stringifySingleParam","StacklessError","TestTree","constructor","forQuery","root","propagateCounts","query","level","depthInLevel","iterateCollapsedNodes","includeIntermediateNodes","includeEmptySubtrees","alwaysExpandThroughLevel","expandThroughLevel","Math","max","iterateSubtreeNodes","iterateLeaves","iterateSubtreeLeaves","dissolveSingleChildTrees","newRoot","toString","subtreeToString","subtree","opts","child","children","collapsible","size","subtreeCounts","tests","nodesWithTODO","counts","countsToString","tree","name","indent","s","JSON","stringify","description","undefined","loadTreeForQuery","loader","queryToLoad","subqueriesToExpand","suite","specs","listing","subqueriesToExpandEntries","Array","from","entries","seenSubqueriesToExpand","length","fill","isCollapsible","subquery","every","i","toExpand","ordering","Equal","StrictSubset","foundCase","subtreeL0","makeTreeForSuite","entry","file","setSubtreeDescriptionAndCountTODOs","readme","queryL1","orderingL1","Unordered","readmeSubtree","addSubtreeForDirPath","spec","importSpecFile","subtreeL1","addSubtreeForFilePath","groupHasTests","t","g","iterate","queryL2","testPath","orderingL2","subtreeL2","addSubtreeForTestPath","testCreationStack","c","queryL3","id","test","params","orderingL3","StrictSuperset","addLeafForCase","sq","subquerySeen","trim","indexOf","readableRelativeName","Map","subqueryFile","part","push","getOrInsertSubtree","filePathParts","subqueryTest","checkCollapsible","subqueryParams","k","v","Object","testPathParts","insertLeaf","key","parent","createSubtree","get","set","leaf","readableNameForCase","run","rec","expectations","isUnimplemented","has","shouldDissolveThisTree","newChild","paramsKeys","keys","lastKey"],"sources":["../../../src/common/internal/tree.ts"],"sourcesContent":["import { RunCase, RunFn } from '../internal/test_group.js';\nimport { assert } from '../util/util.js';\n\nimport { TestFileLoader } from './file_loader.js';\nimport { TestParamsRW } from './params_utils.js';\nimport { compareQueries, Ordering } from './query/compare.js';\nimport {\n  TestQuery,\n  TestQueryMultiCase,\n  TestQuerySingleCase,\n  TestQueryMultiFile,\n  TestQueryMultiTest,\n} from './query/query.js';\nimport { kBigSeparator, kWildcard, kPathSeparator, kParamSeparator } from './query/separators.js';\nimport { stringifySingleParam } from './query/stringify_params.js';\nimport { StacklessError } from './util.js';\n\n// `loadTreeForQuery()` loads a TestTree for a given queryToLoad.\n// The resulting tree is a linked-list all the way from `suite:*` to queryToLoad,\n// and under queryToLoad is a tree containing every case matched by queryToLoad.\n//\n// `subqueriesToExpand` influences the `collapsible` flag on nodes in the resulting tree.\n// A node is considered \"collapsible\" if none of the subqueriesToExpand is a StrictSubset\n// of that node.\n//\n// In WebKit/Blink-style web_tests, an expectation file marks individual cts.https.html \"variants\n// as \"Failure\", \"Crash\", etc. By passing in the list of expectations as the subqueriesToExpand,\n// we can programmatically subdivide the cts.https.html \"variants\" list to be able to implement\n// arbitrarily-fine suppressions (instead of having to suppress entire test files, which would\n// lose a lot of coverage).\n//\n// `iterateCollapsedNodes()` produces the list of queries for the variants list.\n//\n// Though somewhat complicated, this system has important benefits:\n//   - Avoids having to suppress entire test files, which would cause large test coverage loss.\n//   - Minimizes the number of page loads needed for fine-grained suppressions.\n//     (In the naive case, we could do one page load per test case - but the test suite would\n//     take impossibly long to run.)\n//   - Enables developers to put any number of tests in one file as appropriate, without worrying\n//     about expectation granularity.\n\ninterface TestTreeNodeBase<T extends TestQuery> {\n  readonly query: T;\n  /**\n   * Readable \"relative\" name for display in standalone runner.\n   * Not always the exact relative name, because sometimes there isn't\n   * one (e.g. s:f:* relative to s:f,*), but something that is readable.\n   */\n  readonly readableRelativeName: string;\n  subtreeCounts?: { tests: number; nodesWithTODO: number };\n}\n\nexport interface TestSubtree<T extends TestQuery = TestQuery> extends TestTreeNodeBase<T> {\n  readonly children: Map<string, TestTreeNode>;\n  readonly collapsible: boolean;\n  description?: string;\n  readonly testCreationStack?: Error;\n}\n\nexport interface TestTreeLeaf extends TestTreeNodeBase<TestQuerySingleCase> {\n  readonly run: RunFn;\n  readonly isUnimplemented?: boolean;\n  subtreeCounts?: undefined;\n}\n\nexport type TestTreeNode = TestSubtree | TestTreeLeaf;\n\n/**\n * When iterating through \"collapsed\" tree nodes, indicates how many \"query levels\" to traverse\n * through before starting to collapse nodes.\n *\n * Corresponds with TestQueryLevel, but excludes 4 (SingleCase):\n * - 1 = MultiFile. Expands so every file is in the collapsed tree.\n * - 2 = MultiTest. Expands so every test is in the collapsed tree.\n * - 3 = MultiCase. Expands so every case is in the collapsed tree (i.e. collapsing disabled).\n */\nexport type ExpandThroughLevel = 1 | 2 | 3;\n\nexport class TestTree {\n  /**\n   * The `queryToLoad` that this test tree was created for.\n   * Test trees are always rooted at `suite:*`, but they only contain nodes that fit\n   * within `forQuery`.\n   *\n   * This is used for `iterateCollapsedNodes` which only starts collapsing at the next\n   * `TestQueryLevel` after `forQuery`.\n   */\n  readonly forQuery: TestQuery;\n  readonly root: TestSubtree;\n\n  constructor(forQuery: TestQuery, root: TestSubtree) {\n    this.forQuery = forQuery;\n    TestTree.propagateCounts(root);\n    this.root = root;\n    assert(\n      root.query.level === 1 && root.query.depthInLevel === 0,\n      'TestTree root must be the root (suite:*)'\n    );\n  }\n\n  /**\n   * Iterate through the leaves of a version of the tree which has been pruned to exclude\n   * subtrees which:\n   * - are at a deeper `TestQueryLevel` than `this.forQuery`, and\n   * - were not a `Ordering.StrictSubset` of any of the `subqueriesToExpand` during tree creation.\n   */\n  iterateCollapsedNodes({\n    includeIntermediateNodes = false,\n    includeEmptySubtrees = false,\n    alwaysExpandThroughLevel,\n  }: {\n    /** Whether to include intermediate tree nodes or only collapsed-leaves. */\n    includeIntermediateNodes?: boolean;\n    /** Whether to include collapsed-leaves with no children. */\n    includeEmptySubtrees?: boolean;\n    /** Never collapse nodes up through this level. */\n    alwaysExpandThroughLevel: ExpandThroughLevel;\n  }): IterableIterator<Readonly<TestTreeNode>> {\n    const expandThroughLevel = Math.max(this.forQuery.level, alwaysExpandThroughLevel);\n    return TestTree.iterateSubtreeNodes(this.root, {\n      includeIntermediateNodes,\n      includeEmptySubtrees,\n      expandThroughLevel,\n    });\n  }\n\n  iterateLeaves(): IterableIterator<Readonly<TestTreeLeaf>> {\n    return TestTree.iterateSubtreeLeaves(this.root);\n  }\n\n  /**\n   * Dissolve nodes which have only one child, e.g.:\n   *   a,* { a,b,* { a,b:* { ... } } }\n   * collapses down into:\n   *   a,* { a,b:* { ... } }\n   * which is less needlessly verbose when displaying the tree in the standalone runner.\n   */\n  dissolveSingleChildTrees(): void {\n    const newRoot = dissolveSingleChildTrees(this.root);\n    assert(newRoot === this.root);\n  }\n\n  toString(): string {\n    return TestTree.subtreeToString('(root)', this.root, '');\n  }\n\n  static *iterateSubtreeNodes(\n    subtree: TestSubtree,\n    opts: {\n      includeIntermediateNodes: boolean;\n      includeEmptySubtrees: boolean;\n      expandThroughLevel: number;\n    }\n  ): IterableIterator<TestTreeNode> {\n    if (opts.includeIntermediateNodes) {\n      yield subtree;\n    }\n\n    for (const [, child] of subtree.children) {\n      if ('children' in child) {\n        // Is a subtree\n        const collapsible = child.collapsible && child.query.level > opts.expandThroughLevel;\n        if (child.children.size > 0 && !collapsible) {\n          yield* TestTree.iterateSubtreeNodes(child, opts);\n        } else if (child.children.size > 0 || opts.includeEmptySubtrees) {\n          // Don't yield empty subtrees (e.g. files with no tests) unless includeEmptySubtrees\n          yield child;\n        }\n      } else {\n        // Is a leaf\n        yield child;\n      }\n    }\n  }\n\n  static *iterateSubtreeLeaves(subtree: TestSubtree): IterableIterator<TestTreeLeaf> {\n    for (const [, child] of subtree.children) {\n      if ('children' in child) {\n        yield* TestTree.iterateSubtreeLeaves(child);\n      } else {\n        yield child;\n      }\n    }\n  }\n\n  /** Propagate the subtreeTODOs/subtreeTests state upward from leaves to parent nodes. */\n  static propagateCounts(subtree: TestSubtree): { tests: number; nodesWithTODO: number } {\n    subtree.subtreeCounts ??= { tests: 0, nodesWithTODO: 0 };\n    for (const [, child] of subtree.children) {\n      if ('children' in child) {\n        const counts = TestTree.propagateCounts(child);\n        subtree.subtreeCounts.tests += counts.tests;\n        subtree.subtreeCounts.nodesWithTODO += counts.nodesWithTODO;\n      }\n    }\n    return subtree.subtreeCounts;\n  }\n\n  /** Displays counts in the format `(Nodes with TODOs) / (Total test count)`. */\n  static countsToString(tree: TestTreeNode): string {\n    if (tree.subtreeCounts) {\n      return `${tree.subtreeCounts.nodesWithTODO} / ${tree.subtreeCounts.tests}`;\n    } else {\n      return '';\n    }\n  }\n\n  static subtreeToString(name: string, tree: TestTreeNode, indent: string): string {\n    const collapsible = 'run' in tree ? '>' : tree.collapsible ? '+' : '-';\n    let s =\n      indent +\n      `${collapsible} ${TestTree.countsToString(tree)} ${JSON.stringify(name)} => ${tree.query}`;\n    if ('children' in tree) {\n      if (tree.description !== undefined) {\n        s += `\\n${indent}  | ${JSON.stringify(tree.description)}`;\n      }\n\n      for (const [name, child] of tree.children) {\n        s += '\\n' + TestTree.subtreeToString(name, child, indent + '  ');\n      }\n    }\n    return s;\n  }\n}\n\n// MAINTENANCE_TODO: Consider having subqueriesToExpand actually impact the depth-order of params\n// in the tree.\nexport async function loadTreeForQuery(\n  loader: TestFileLoader,\n  queryToLoad: TestQuery,\n  subqueriesToExpand: TestQuery[]\n): Promise<TestTree> {\n  const suite = queryToLoad.suite;\n  const specs = await loader.listing(suite);\n\n  const subqueriesToExpandEntries = Array.from(subqueriesToExpand.entries());\n  const seenSubqueriesToExpand: boolean[] = new Array(subqueriesToExpand.length);\n  seenSubqueriesToExpand.fill(false);\n\n  const isCollapsible = (subquery: TestQuery) =>\n    subqueriesToExpandEntries.every(([i, toExpand]) => {\n      const ordering = compareQueries(toExpand, subquery);\n\n      // If toExpand == subquery, no expansion is needed (but it's still \"seen\").\n      if (ordering === Ordering.Equal) seenSubqueriesToExpand[i] = true;\n      return ordering !== Ordering.StrictSubset;\n    });\n\n  // L0 = suite-level, e.g. suite:*\n  // L1 =  file-level, e.g. suite:a,b:*\n  // L2 =  test-level, e.g. suite:a,b:c,d:*\n  // L3 =  case-level, e.g. suite:a,b:c,d:\n  let foundCase = false;\n  // L0 is suite:*\n  const subtreeL0 = makeTreeForSuite(suite, isCollapsible);\n  for (const entry of specs) {\n    if (entry.file.length === 0 && 'readme' in entry) {\n      // Suite-level readme.\n      setSubtreeDescriptionAndCountTODOs(subtreeL0, entry.readme);\n      continue;\n    }\n\n    {\n      const queryL1 = new TestQueryMultiFile(suite, entry.file);\n      const orderingL1 = compareQueries(queryL1, queryToLoad);\n      if (orderingL1 === Ordering.Unordered) {\n        // File path is not matched by this query.\n        continue;\n      }\n    }\n\n    if ('readme' in entry) {\n      // Entry is a README that is an ancestor or descendant of the query.\n      // (It's included for display in the standalone runner.)\n\n      // readmeSubtree is suite:a,b,*\n      // (This is always going to dedup with a file path, if there are any test spec files under\n      // the directory that has the README).\n      const readmeSubtree: TestSubtree<TestQueryMultiFile> = addSubtreeForDirPath(\n        subtreeL0,\n        entry.file,\n        isCollapsible\n      );\n      setSubtreeDescriptionAndCountTODOs(readmeSubtree, entry.readme);\n      continue;\n    }\n    // Entry is a spec file.\n\n    const spec = await loader.importSpecFile(queryToLoad.suite, entry.file);\n    // subtreeL1 is suite:a,b:*\n    const subtreeL1: TestSubtree<TestQueryMultiTest> = addSubtreeForFilePath(\n      subtreeL0,\n      entry.file,\n      isCollapsible\n    );\n    setSubtreeDescriptionAndCountTODOs(subtreeL1, spec.description);\n\n    let groupHasTests = false;\n    for (const t of spec.g.iterate()) {\n      groupHasTests = true;\n      {\n        const queryL2 = new TestQueryMultiCase(suite, entry.file, t.testPath, {});\n        const orderingL2 = compareQueries(queryL2, queryToLoad);\n        if (orderingL2 === Ordering.Unordered) {\n          // Test path is not matched by this query.\n          continue;\n        }\n      }\n\n      // subtreeL2 is suite:a,b:c,d:*\n      const subtreeL2: TestSubtree<TestQueryMultiCase> = addSubtreeForTestPath(\n        subtreeL1,\n        t.testPath,\n        t.testCreationStack,\n        isCollapsible\n      );\n      // This is 1 test. Set tests=1 then count TODOs.\n      subtreeL2.subtreeCounts ??= { tests: 1, nodesWithTODO: 0 };\n      if (t.description) setSubtreeDescriptionAndCountTODOs(subtreeL2, t.description);\n\n      // MAINTENANCE_TODO: If tree generation gets too slow, avoid actually iterating the cases in a\n      // file if there's no need to (based on the subqueriesToExpand).\n      for (const c of t.iterate()) {\n        {\n          const queryL3 = new TestQuerySingleCase(suite, entry.file, c.id.test, c.id.params);\n          const orderingL3 = compareQueries(queryL3, queryToLoad);\n          if (orderingL3 === Ordering.Unordered || orderingL3 === Ordering.StrictSuperset) {\n            // Case is not matched by this query.\n            continue;\n          }\n        }\n\n        // Leaf for case is suite:a,b:c,d:x=1;y=2\n        addLeafForCase(subtreeL2, c, isCollapsible);\n\n        foundCase = true;\n      }\n    }\n    if (!groupHasTests && !subtreeL1.subtreeCounts) {\n      throw new StacklessError(\n        `${subtreeL1.query} has no tests - it must have \"TODO\" in its description`\n      );\n    }\n  }\n\n  for (const [i, sq] of subqueriesToExpandEntries) {\n    const subquerySeen = seenSubqueriesToExpand[i];\n    if (!subquerySeen) {\n      throw new StacklessError(\n        `subqueriesToExpand entry did not match anything \\\n(could be wrong, or could be redundant with a previous subquery):\\n  ${sq.toString()}`\n      );\n    }\n  }\n  assert(foundCase, `Query \\`${queryToLoad.toString()}\\` does not match any cases`);\n\n  return new TestTree(queryToLoad, subtreeL0);\n}\n\nfunction setSubtreeDescriptionAndCountTODOs(\n  subtree: TestSubtree<TestQueryMultiFile>,\n  description: string\n) {\n  assert(subtree.description === undefined);\n  subtree.description = description.trim();\n  subtree.subtreeCounts ??= { tests: 0, nodesWithTODO: 0 };\n  if (subtree.description.indexOf('TODO') !== -1) {\n    subtree.subtreeCounts.nodesWithTODO++;\n  }\n}\n\nfunction makeTreeForSuite(\n  suite: string,\n  isCollapsible: (sq: TestQuery) => boolean\n): TestSubtree<TestQueryMultiFile> {\n  const query = new TestQueryMultiFile(suite, []);\n  return {\n    readableRelativeName: suite + kBigSeparator,\n    query,\n    children: new Map(),\n    collapsible: isCollapsible(query),\n  };\n}\n\nfunction addSubtreeForDirPath(\n  tree: TestSubtree<TestQueryMultiFile>,\n  file: string[],\n  isCollapsible: (sq: TestQuery) => boolean\n): TestSubtree<TestQueryMultiFile> {\n  const subqueryFile: string[] = [];\n  // To start, tree is suite:*\n  // This loop goes from that -> suite:a,* -> suite:a,b,*\n  for (const part of file) {\n    subqueryFile.push(part);\n    tree = getOrInsertSubtree(part, tree, () => {\n      const query = new TestQueryMultiFile(tree.query.suite, subqueryFile);\n      return {\n        readableRelativeName: part + kPathSeparator + kWildcard,\n        query,\n        collapsible: isCollapsible(query),\n      };\n    });\n  }\n  return tree;\n}\n\nfunction addSubtreeForFilePath(\n  tree: TestSubtree<TestQueryMultiFile>,\n  file: string[],\n  isCollapsible: (sq: TestQuery) => boolean\n): TestSubtree<TestQueryMultiTest> {\n  // To start, tree is suite:*\n  // This goes from that -> suite:a,* -> suite:a,b,*\n  tree = addSubtreeForDirPath(tree, file, isCollapsible);\n  // This goes from that -> suite:a,b:*\n  const subtree = getOrInsertSubtree('', tree, () => {\n    const query = new TestQueryMultiTest(tree.query.suite, tree.query.filePathParts, []);\n    assert(file.length > 0, 'file path is empty');\n    return {\n      readableRelativeName: file[file.length - 1] + kBigSeparator + kWildcard,\n      query,\n      collapsible: isCollapsible(query),\n    };\n  });\n  return subtree;\n}\n\nfunction addSubtreeForTestPath(\n  tree: TestSubtree<TestQueryMultiTest>,\n  test: readonly string[],\n  testCreationStack: Error,\n  isCollapsible: (sq: TestQuery) => boolean\n): TestSubtree<TestQueryMultiCase> {\n  const subqueryTest: string[] = [];\n  // To start, tree is suite:a,b:*\n  // This loop goes from that -> suite:a,b:c,* -> suite:a,b:c,d,*\n  for (const part of test) {\n    subqueryTest.push(part);\n    tree = getOrInsertSubtree(part, tree, () => {\n      const query = new TestQueryMultiTest(\n        tree.query.suite,\n        tree.query.filePathParts,\n        subqueryTest\n      );\n      return {\n        readableRelativeName: part + kPathSeparator + kWildcard,\n        query,\n        collapsible: isCollapsible(query),\n      };\n    });\n  }\n  // This goes from that -> suite:a,b:c,d:*\n  return getOrInsertSubtree('', tree, () => {\n    const query = new TestQueryMultiCase(\n      tree.query.suite,\n      tree.query.filePathParts,\n      subqueryTest,\n      {}\n    );\n    assert(subqueryTest.length > 0, 'subqueryTest is empty');\n    return {\n      readableRelativeName: subqueryTest[subqueryTest.length - 1] + kBigSeparator + kWildcard,\n      kWildcard,\n      query,\n      testCreationStack,\n      collapsible: isCollapsible(query),\n    };\n  });\n}\n\nfunction addLeafForCase(\n  tree: TestSubtree<TestQueryMultiTest>,\n  t: RunCase,\n  checkCollapsible: (sq: TestQuery) => boolean\n): void {\n  const query = tree.query;\n  let name: string = '';\n  const subqueryParams: TestParamsRW = {};\n\n  // To start, tree is suite:a,b:c,d:*\n  // This loop goes from that -> suite:a,b:c,d:x=1;* -> suite:a,b:c,d:x=1;y=2;*\n  for (const [k, v] of Object.entries(t.id.params)) {\n    name = stringifySingleParam(k, v);\n    subqueryParams[k] = v;\n\n    tree = getOrInsertSubtree(name, tree, () => {\n      const subquery = new TestQueryMultiCase(\n        query.suite,\n        query.filePathParts,\n        query.testPathParts,\n        subqueryParams\n      );\n      return {\n        readableRelativeName: name + kParamSeparator + kWildcard,\n        query: subquery,\n        collapsible: checkCollapsible(subquery),\n      };\n    });\n  }\n\n  // This goes from that -> suite:a,b:c,d:x=1;y=2\n  const subquery = new TestQuerySingleCase(\n    query.suite,\n    query.filePathParts,\n    query.testPathParts,\n    subqueryParams\n  );\n  checkCollapsible(subquery); // mark seenSubqueriesToExpand\n  insertLeaf(tree, subquery, t);\n}\n\nfunction getOrInsertSubtree<T extends TestQuery>(\n  key: string,\n  parent: TestSubtree,\n  createSubtree: () => Omit<TestSubtree<T>, 'children'>\n): TestSubtree<T> {\n  let v: TestSubtree<T>;\n  const child = parent.children.get(key);\n  if (child !== undefined) {\n    assert('children' in child); // Make sure cached subtree is not actually a leaf\n    v = child as TestSubtree<T>;\n  } else {\n    v = { ...createSubtree(), children: new Map() };\n    parent.children.set(key, v);\n  }\n  return v;\n}\n\nfunction insertLeaf(parent: TestSubtree, query: TestQuerySingleCase, t: RunCase) {\n  const leaf: TestTreeLeaf = {\n    readableRelativeName: readableNameForCase(query),\n    query,\n    run: (rec, expectations) => t.run(rec, query, expectations || []),\n    isUnimplemented: t.isUnimplemented,\n  };\n\n  // This is a leaf (e.g. s:f:t:x=1;* -> s:f:t:x=1). The key is always ''.\n  const key = '';\n  assert(!parent.children.has(key), `Duplicate testcase: ${query}`);\n  parent.children.set(key, leaf);\n}\n\nfunction dissolveSingleChildTrees(tree: TestTreeNode): TestTreeNode {\n  if ('children' in tree) {\n    const shouldDissolveThisTree =\n      tree.children.size === 1 && tree.query.depthInLevel !== 0 && tree.description === undefined;\n    if (shouldDissolveThisTree) {\n      // Loops exactly once\n      for (const [, child] of tree.children) {\n        // Recurse on child\n        return dissolveSingleChildTrees(child);\n      }\n    }\n\n    for (const [k, child] of tree.children) {\n      // Recurse on each child\n      const newChild = dissolveSingleChildTrees(child);\n      if (newChild !== child) {\n        tree.children.set(k, newChild);\n      }\n    }\n  }\n  return tree;\n}\n\n/** Generate a readable relative name for a case (used in standalone). */\nfunction readableNameForCase(query: TestQuerySingleCase): string {\n  const paramsKeys = Object.keys(query.params);\n  if (paramsKeys.length === 0) {\n    return query.testPathParts[query.testPathParts.length - 1] + kBigSeparator;\n  } else {\n    const lastKey = paramsKeys[paramsKeys.length - 1];\n    return stringifySingleParam(lastKey, query.params[lastKey]);\n  }\n}\n"],"mappings":"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"}