{"version":3,"sources":["../../../../src/common/internal/query/json_param_value.ts"],"names":["assert","sortObjectByKey","jsUndefinedMagicValue","jsNaNMagicValue","jsPositiveInfinityMagicValue","jsNegativeInfinityMagicValue","jsNegativeZeroMagicValue","toStringMagicValue","Map","undefined","NaN","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","fromStringMagicValue","stringifyFilter","k","v","has","Object","is","get","stringifyParamValue","value","JSON","stringify","stringifyParamValueUniquely","parseParamValueReviver","parseParamValue","s","parse"],"mappings":";AAAA;AACA,GADA,SAASA,MAAT,EAAiBC,eAAjB,QAAwC,oBAAxC;AAGA;AACA;AACA,MAAMC,qBAAqB,GAAG,SAA9B;AACA,MAAMC,eAAe,GAAG,OAAxB;AACA,MAAMC,4BAA4B,GAAG,eAArC;AACA,MAAMC,4BAA4B,GAAG,eAArC;;AAEA;AACA;AACA;AACA,MAAMC,wBAAwB,GAAG,WAAjC;;AAEA,MAAMC,kBAAkB,GAAG,IAAIC,GAAJ,CAAyB;AAClD,CAACC,SAAD,EAAYP,qBAAZ,CADkD;AAElD,CAACQ,GAAD,EAAMP,eAAN,CAFkD;AAGlD,CAACQ,MAAM,CAACC,iBAAR,EAA2BR,4BAA3B,CAHkD;AAIlD,CAACO,MAAM,CAACE,iBAAR,EAA2BR,4BAA3B;AACA;AALkD,CAAzB,CAA3B;;AAQA,MAAMS,oBAAoB,GAAG,IAAIN,GAAJ,CAAyB;AACpD,CAACN,qBAAD,EAAwBO,SAAxB,CADoD;AAEpD,CAACN,eAAD,EAAkBO,GAAlB,CAFoD;AAGpD,CAACN,4BAAD,EAA+BO,MAAM,CAACC,iBAAtC,CAHoD;AAIpD,CAACP,4BAAD,EAA+BM,MAAM,CAACE,iBAAtC,CAJoD;AAKpD;AACA,CAACP,wBAAD,EAA2B,CAAC,CAA5B,CANoD,CAAzB,CAA7B;;;AASA,SAASS,eAAT,CAAyBC,CAAzB,EAAoCC,CAApC,EAAyD;AACvD;AACA,MAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B;AACzBjB,IAAAA,MAAM;AACJ,KAACc,oBAAoB,CAACI,GAArB,CAAyBD,CAAzB,CADG;AAEH,OAAEA,CAAE,0DAFD,CAAN;;;AAKAjB,IAAAA,MAAM;AACJiB,IAAAA,CAAC,KAAKX,wBADF;AAEH,OAAEW,CAAE,0DAFD,CAAN;;AAID;;AAED,MAAIE,MAAM,CAACC,EAAP,CAAUH,CAAV,EAAa,CAAC,CAAd,CAAJ,EAAsB;AACpB,WAAOX,wBAAP;AACD;;AAED,SAAOC,kBAAkB,CAACW,GAAnB,CAAuBD,CAAvB,IAA4BV,kBAAkB,CAACc,GAAnB,CAAuBJ,CAAvB,CAA5B,GAAwDA,CAA/D;AACD;;AAED,OAAO,SAASK,mBAAT,CAA6BC,KAA7B,EAA+D;AACpE,SAAOC,IAAI,CAACC,SAAL,CAAeF,KAAf,EAAsBR,eAAtB,CAAP;AACD;;AAED;AACA;AACA;AACA,OAAO,SAASW,2BAAT,CAAqCH,KAArC,EAAuE;AAC5E,SAAOC,IAAI,CAACC,SAAL,CAAeF,KAAf,EAAsB,CAACP,CAAD,EAAIC,CAAJ,KAAU;AACrC,QAAI,OAAOA,CAAP,KAAa,QAAb,IAAyBA,CAAC,KAAK,IAAnC,EAAyC;AACvC,aAAOhB,eAAe,CAACgB,CAAD,CAAtB;AACD;;AAED,WAAOF,eAAe,CAACC,CAAD,EAAIC,CAAJ,CAAtB;AACD,GANM,CAAP;AAOD;;AAED;;AAEA,SAASU,sBAAT,CAAgCX,CAAhC,EAA2CC,CAA3C,EAAwD;AACtD,MAAIH,oBAAoB,CAACI,GAArB,CAAyBD,CAAzB,CAAJ,EAAiC;AAC/B,WAAOH,oBAAoB,CAACO,GAArB,CAAyBJ,CAAzB,CAAP;AACD;;AAED,SAAOA,CAAP;AACD;;AAED,OAAO,SAASW,eAAT,CAAyBC,CAAzB,EAAuD;AAC5D,SAAOL,IAAI,CAACM,KAAL,CAAWD,CAAX,EAAcF,sBAAd,CAAP;AACD","sourcesContent":["import { assert, sortObjectByKey } from '../../util/util.js';\nimport { JSONWithUndefined } from '../params_utils.js';\n\n// JSON can't represent various values and by default stores them as `null`.\n// Instead, storing them as a magic string values in JSON.\nconst jsUndefinedMagicValue = '_undef_';\nconst jsNaNMagicValue = '_nan_';\nconst jsPositiveInfinityMagicValue = '_posinfinity_';\nconst jsNegativeInfinityMagicValue = '_neginfinity_';\n\n// -0 needs to be handled separately, because -0 === +0 returns true. Not\n// special casing +0/0, since it behaves intuitively. Assuming that if -0 is\n// being used, the differentiation from +0 is desired.\nconst jsNegativeZeroMagicValue = '_negzero_';\n\nconst toStringMagicValue = new Map<unknown, string>([\n  [undefined, jsUndefinedMagicValue],\n  [NaN, jsNaNMagicValue],\n  [Number.POSITIVE_INFINITY, jsPositiveInfinityMagicValue],\n  [Number.NEGATIVE_INFINITY, jsNegativeInfinityMagicValue],\n  // No -0 handling because it is special cased.\n]);\n\nconst fromStringMagicValue = new Map<string, unknown>([\n  [jsUndefinedMagicValue, undefined],\n  [jsNaNMagicValue, NaN],\n  [jsPositiveInfinityMagicValue, Number.POSITIVE_INFINITY],\n  [jsNegativeInfinityMagicValue, Number.NEGATIVE_INFINITY],\n  // -0 is handled in this direction because there is no comparison issue.\n  [jsNegativeZeroMagicValue, -0],\n]);\n\nfunction stringifyFilter(k: string, v: unknown): unknown {\n  // Make sure no one actually uses a magic value as a parameter.\n  if (typeof v === 'string') {\n    assert(\n      !fromStringMagicValue.has(v),\n      `${v} is a magic value for stringification, so cannot be used`\n    );\n\n    assert(\n      v !== jsNegativeZeroMagicValue,\n      `${v} is a magic value for stringification, so cannot be used`\n    );\n  }\n\n  if (Object.is(v, -0)) {\n    return jsNegativeZeroMagicValue;\n  }\n\n  return toStringMagicValue.has(v) ? toStringMagicValue.get(v) : v;\n}\n\nexport function stringifyParamValue(value: JSONWithUndefined): string {\n  return JSON.stringify(value, stringifyFilter);\n}\n\n/**\n * Like stringifyParamValue but sorts dictionaries by key, for hashing.\n */\nexport function stringifyParamValueUniquely(value: JSONWithUndefined): string {\n  return JSON.stringify(value, (k, v) => {\n    if (typeof v === 'object' && v !== null) {\n      return sortObjectByKey(v);\n    }\n\n    return stringifyFilter(k, v);\n  });\n}\n\n// 'any' is part of the JSON.parse reviver interface, so cannot be avoided.\n// eslint-disable-next-line  @typescript-eslint/no-explicit-any\nfunction parseParamValueReviver(k: string, v: any): any {\n  if (fromStringMagicValue.has(v)) {\n    return fromStringMagicValue.get(v);\n  }\n\n  return v;\n}\n\nexport function parseParamValue(s: string): JSONWithUndefined {\n  return JSON.parse(s, parseParamValueReviver);\n}\n"],"file":"json_param_value.js"}