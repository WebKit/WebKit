{"version":3,"sources":["../../../../src/common/internal/query/parseQuery.ts"],"names":["assert","badParamValueChars","paramKeyIsPublic","parseParamValue","TestQueryMultiFile","TestQueryMultiTest","TestQueryMultiCase","TestQuerySingleCase","kBigSeparator","kWildcard","kPathSeparator","kParamSeparator","validQueryPart","parseQuery","s","parseQueryImpl","ex","Error","message","decodeURIComponent","suite","fileString","testString","paramsString","i1","indexOf","substring","i2","i3","parts","file","wildcard","filePathHasWildcard","parseBigPart","undefined","test","testPathHasWildcard","length","paramsParts","paramsHasWildcard","params","paramPart","k","v","parseSingleParam","kExampleQueries","separator","split","endsWithWildcard","i","part","entries","paramSubstring","parseSingleParamValue"],"mappings":"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","sourcesContent":["import { assert } from '../../util/util.js';\nimport {\n  TestParamsRW,\n  JSONWithUndefined,\n  badParamValueChars,\n  paramKeyIsPublic,\n} from '../params_utils.js';\n\nimport { parseParamValue } from './json_param_value.js';\nimport {\n  TestQuery,\n  TestQueryMultiFile,\n  TestQueryMultiTest,\n  TestQueryMultiCase,\n  TestQuerySingleCase,\n} from './query.js';\nimport { kBigSeparator, kWildcard, kPathSeparator, kParamSeparator } from './separators.js';\nimport { validQueryPart } from './validQueryPart.js';\n\nexport function parseQuery(s: string): TestQuery {\n  try {\n    return parseQueryImpl(s);\n  } catch (ex) {\n    if (ex instanceof Error) {\n      ex.message += '\\n  on: ' + s;\n    }\n    throw ex;\n  }\n}\n\nfunction parseQueryImpl(s: string): TestQuery {\n  // Undo encodeURIComponentSelectively\n  s = decodeURIComponent(s);\n\n  // bigParts are: suite, file, test, params (note kBigSeparator could appear in params)\n  let suite: string;\n  let fileString: string | undefined;\n  let testString: string | undefined;\n  let paramsString: string | undefined;\n  {\n    const i1 = s.indexOf(kBigSeparator);\n    assert(i1 !== -1, `query string must have at least one ${kBigSeparator}`);\n    suite = s.substring(0, i1);\n    const i2 = s.indexOf(kBigSeparator, i1 + 1);\n    if (i2 === -1) {\n      fileString = s.substring(i1 + 1);\n    } else {\n      fileString = s.substring(i1 + 1, i2);\n      const i3 = s.indexOf(kBigSeparator, i2 + 1);\n      if (i3 === -1) {\n        testString = s.substring(i2 + 1);\n      } else {\n        testString = s.substring(i2 + 1, i3);\n        paramsString = s.substring(i3 + 1);\n      }\n    }\n  }\n\n  const { parts: file, wildcard: filePathHasWildcard } = parseBigPart(fileString, kPathSeparator);\n\n  if (testString === undefined) {\n    // Query is file-level\n    assert(\n      filePathHasWildcard,\n      `File-level query without wildcard ${kWildcard}. Did you want a file-level query \\\n(append ${kPathSeparator}${kWildcard}) or test-level query (append ${kBigSeparator}${kWildcard})?`\n    );\n    return new TestQueryMultiFile(suite, file);\n  }\n  assert(!filePathHasWildcard, `Wildcard ${kWildcard} must be at the end of the query string`);\n\n  const { parts: test, wildcard: testPathHasWildcard } = parseBigPart(testString, kPathSeparator);\n\n  if (paramsString === undefined) {\n    // Query is test-level\n    assert(\n      testPathHasWildcard,\n      `Test-level query without wildcard ${kWildcard}; did you want a test-level query \\\n(append ${kPathSeparator}${kWildcard}) or case-level query (append ${kBigSeparator}${kWildcard})?`\n    );\n    assert(file.length > 0, 'File part of test-level query was empty (::)');\n    return new TestQueryMultiTest(suite, file, test);\n  }\n\n  // Query is case-level\n  assert(!testPathHasWildcard, `Wildcard ${kWildcard} must be at the end of the query string`);\n\n  const { parts: paramsParts, wildcard: paramsHasWildcard } = parseBigPart(\n    paramsString,\n    kParamSeparator\n  );\n\n  assert(test.length > 0, 'Test part of case-level query was empty (::)');\n\n  const params: TestParamsRW = {};\n  for (const paramPart of paramsParts) {\n    const [k, v] = parseSingleParam(paramPart);\n    assert(validQueryPart.test(k), 'param key names must match ' + validQueryPart);\n    params[k] = v;\n  }\n  if (paramsHasWildcard) {\n    return new TestQueryMultiCase(suite, file, test, params);\n  } else {\n    return new TestQuerySingleCase(suite, file, test, params);\n  }\n}\n\n// webgpu:a,b,* or webgpu:a,b,c:*\nconst kExampleQueries = `\\\nwebgpu${kBigSeparator}a${kPathSeparator}b${kPathSeparator}${kWildcard} or \\\nwebgpu${kBigSeparator}a${kPathSeparator}b${kPathSeparator}c${kBigSeparator}${kWildcard}`;\n\nfunction parseBigPart(\n  s: string,\n  separator: typeof kParamSeparator | typeof kPathSeparator\n): { parts: string[]; wildcard: boolean } {\n  if (s === '') {\n    return { parts: [], wildcard: false };\n  }\n  const parts = s.split(separator);\n\n  let endsWithWildcard = false;\n  for (const [i, part] of parts.entries()) {\n    if (i === parts.length - 1) {\n      endsWithWildcard = part === kWildcard;\n    }\n    assert(\n      part.indexOf(kWildcard) === -1 || endsWithWildcard,\n      `Wildcard ${kWildcard} must be complete last part of a path (e.g. ${kExampleQueries})`\n    );\n  }\n  if (endsWithWildcard) {\n    // Remove the last element of the array (which is just the wildcard).\n    parts.length = parts.length - 1;\n  }\n  return { parts, wildcard: endsWithWildcard };\n}\n\nfunction parseSingleParam(paramSubstring: string): [string, JSONWithUndefined] {\n  assert(paramSubstring !== '', 'Param in a query must not be blank (is there a trailing comma?)');\n  const i = paramSubstring.indexOf('=');\n  assert(i !== -1, 'Param in a query must be of form key=value');\n  const k = paramSubstring.substring(0, i);\n  assert(paramKeyIsPublic(k), 'Param in a query must not be private (start with _)');\n  const v = paramSubstring.substring(i + 1);\n  return [k, parseSingleParamValue(v)];\n}\n\nfunction parseSingleParamValue(s: string): JSONWithUndefined {\n  assert(\n    !badParamValueChars.test(s),\n    `param value must not match ${badParamValueChars} - was ${s}`\n  );\n  return parseParamValue(s);\n}\n"],"file":"parseQuery.js"}