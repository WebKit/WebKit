{"version":3,"sources":["../../../src/common/util/types.ts"],"names":["assertTypeTrue"],"mappings":";AAAA;AACA;;;;;;;;;;;AAYA,OAAO,SAASA,cAAT,GAA0C,CAAE;;AAEnD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCU","sourcesContent":["/** Forces a type to resolve its type definitions, to make it readable/debuggable. */\nexport type ResolveType<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: ResolveType<O[K]> }\n    : never\n  : T;\n\n/** Returns the type `true` iff X and Y are exactly equal */\nexport type TypeEqual<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2\n  ? true\n  : false;\n\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\nexport function assertTypeTrue<T extends true>() {}\n\n/**\n * Computes the intersection of a set of types, given the union of those types.\n *\n * From: https://stackoverflow.com/a/56375136\n */\nexport type UnionToIntersection<U> =\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;\n\n/** \"Type asserts\" that `X` is a subtype of `Y`. */\ntype EnsureSubtype<X, Y> = X extends Y ? X : never;\n\ntype TupleHeadOr<T, Default> = T extends readonly [infer H, ...(readonly unknown[])] ? H : Default;\ntype TupleTailOr<T, Default> = T extends readonly [unknown, ...infer Tail] ? Tail : Default;\ntype TypeOr<T, Default> = T extends undefined ? Default : T;\n\n/**\n * Zips a key tuple type and a value tuple type together into an object.\n *\n * @template Keys Keys of the resulting object.\n * @template Values Values of the resulting object. If a key corresponds to a `Values` member that\n *   is undefined or past the end, it defaults to the corresponding `Defaults` member.\n * @template Defaults Default values. If a key corresponds to a `Defaults` member that is past the\n *   end, the default falls back to `undefined`.\n */\nexport type ZipKeysWithValues<\n  Keys extends readonly string[],\n  Values extends readonly unknown[],\n  Defaults extends readonly unknown[]\n> =\n  //\n  Keys extends readonly [infer KHead, ...infer KTail]\n    ? {\n        readonly [k in EnsureSubtype<KHead, string>]: TypeOr<\n          TupleHeadOr<Values, undefined>,\n          TupleHeadOr<Defaults, undefined>\n        >;\n      } &\n        ZipKeysWithValues<\n          EnsureSubtype<KTail, readonly string[]>,\n          TupleTailOr<Values, []>,\n          TupleTailOr<Defaults, []>\n        >\n    : {}; // K exhausted\n"],"file":"types.js"}