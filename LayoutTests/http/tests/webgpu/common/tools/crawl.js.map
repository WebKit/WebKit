{"version":3,"file":"crawl.js","names":["fs","path","validQueryPart","assert","unreachable","specFileSuffix","__filename","endsWith","crawlFilesRecursively","dir","subpathInfo","Promise","all","promises","readdir","map","d","p","join","stats","stat","isDirectory","isFile","files","filter","i","sep","concat","reduce","a","b","resolve","crawl","suiteDir","validate","existsSync","console","error","process","exit","filesToEnumerate","f","relative","replace","sort","entries","file","filepathWithoutExtension","substring","length","suite","basename","filename","env","STANDALONE_DEV_SERVER","mod","description","undefined","g","pathSegments","split","test","push","dirname","readme","readFileSync","trim","makeListing"],"sources":["../../../src/common/tools/crawl.ts"],"sourcesContent":["// Node can look at the filesystem, but JS in the browser can't.\n// This crawls the file tree under src/suites/${suite} to generate a (non-hierarchical) static\n// listing file that can then be used in the browser to load the modules containing the tests.\n\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nimport { SpecFile } from '../internal/file_loader.js';\nimport { validQueryPart } from '../internal/query/validQueryPart.js';\nimport { TestSuiteListingEntry, TestSuiteListing } from '../internal/test_suite_listing.js';\nimport { assert, unreachable } from '../util/util.js';\n\nconst specFileSuffix = __filename.endsWith('.ts') ? '.spec.ts' : '.spec.js';\n\nasync function crawlFilesRecursively(dir: string): Promise<string[]> {\n  const subpathInfo = await Promise.all(\n    (await fs.promises.readdir(dir)).map(async d => {\n      const p = path.join(dir, d);\n      const stats = await fs.promises.stat(p);\n      return {\n        path: p,\n        isDirectory: stats.isDirectory(),\n        isFile: stats.isFile(),\n      };\n    })\n  );\n\n  const files = subpathInfo\n    .filter(\n      i =>\n        i.isFile &&\n        (i.path.endsWith(specFileSuffix) ||\n          i.path.endsWith(`${path.sep}README.txt`) ||\n          i.path === 'README.txt')\n    )\n    .map(i => i.path);\n\n  return files.concat(\n    await subpathInfo\n      .filter(i => i.isDirectory)\n      .map(i => crawlFilesRecursively(i.path))\n      .reduce(async (a, b) => (await a).concat(await b), Promise.resolve([]))\n  );\n}\n\nexport async function crawl(\n  suiteDir: string,\n  validate: boolean = true\n): Promise<TestSuiteListingEntry[]> {\n  if (!fs.existsSync(suiteDir)) {\n    console.error(`Could not find ${suiteDir}`);\n    process.exit(1);\n  }\n\n  // Crawl files and convert paths to be POSIX-style, relative to suiteDir.\n  const filesToEnumerate = (await crawlFilesRecursively(suiteDir))\n    .map(f => path.relative(suiteDir, f).replace(/\\\\/g, '/'))\n    .sort();\n\n  const entries: TestSuiteListingEntry[] = [];\n  for (const file of filesToEnumerate) {\n    // |file| is the suite-relative file path.\n    if (file.endsWith(specFileSuffix)) {\n      const filepathWithoutExtension = file.substring(0, file.length - specFileSuffix.length);\n\n      const suite = path.basename(suiteDir);\n\n      if (validate) {\n        const filename = `../../${suite}/${filepathWithoutExtension}.spec.js`;\n\n        assert(!process.env.STANDALONE_DEV_SERVER);\n        const mod = (await import(filename)) as SpecFile;\n        assert(mod.description !== undefined, 'Test spec file missing description: ' + filename);\n        assert(mod.g !== undefined, 'Test spec file missing TestGroup definition: ' + filename);\n\n        mod.g.validate();\n      }\n\n      const pathSegments = filepathWithoutExtension.split('/');\n      for (const p of pathSegments) {\n        assert(validQueryPart.test(p), `Invalid directory name ${p}; must match ${validQueryPart}`);\n      }\n      entries.push({ file: pathSegments });\n    } else if (path.basename(file) === 'README.txt') {\n      const dirname = path.dirname(file);\n      const readme = fs.readFileSync(path.join(suiteDir, file), 'utf8').trim();\n\n      const pathSegments = dirname !== '.' ? dirname.split('/') : [];\n      entries.push({ file: pathSegments, readme });\n    } else {\n      unreachable(`Matched an unrecognized filename ${file}`);\n    }\n  }\n\n  return entries;\n}\n\nexport function makeListing(filename: string): Promise<TestSuiteListing> {\n  // Don't validate. This path is only used for the dev server and running tests with Node.\n  // Validation is done for listing generation and presubmit.\n  return crawl(path.dirname(filename), false);\n}\n"],"mappings":"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"}