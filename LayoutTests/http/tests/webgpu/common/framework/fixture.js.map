{"version":3,"sources":["../../../src/common/framework/fixture.ts"],"names":["assert","unreachable","SkipTestCase","Error","UnexpectedPassError","TestCaseRecorder","Fixture","eventualExpectations","numOutstandingAsyncExpectations","objectsToCleanUp","constructor","rec","params","_params","init","finalize","length","p","shift","ex","threw","o","WEBGL_lose_context","getExtension","loseContext","destroy","close","doInit","doFinalize","trackForCleanup","push","tryTrackForCleanup","WebGLRenderingContext","WebGL2RenderingContext","debug","msg","skip","warn","fail","expectationFailed","immediateAsyncExpectation","fn","ret","eventualAsyncExpectation","promise","expectErrorValue","expectedError","niceStack","message","actualName","name","shouldResolve","m","shouldReject","expectedName","shouldThrow","expect","cond","expectOK","error","mode","stack"],"mappings":"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","sourcesContent":["import { TestCaseRecorder } from '../internal/logging/test_case_recorder.js';\nimport { JSONWithUndefined } from '../internal/params_utils.js';\nimport { assert, unreachable } from '../util/util.js';\n\nexport class SkipTestCase extends Error {}\nexport class UnexpectedPassError extends Error {}\n\nexport { TestCaseRecorder } from '../internal/logging/test_case_recorder.js';\n\n/** The fully-general type for params passed to a test function invocation. */\nexport type TestParams = {\n  readonly [k: string]: JSONWithUndefined;\n};\n\ntype DestroyableObject =\n  | { destroy(): void }\n  | { close(): void }\n  | { getExtension(extensionName: 'WEBGL_lose_context'): WEBGL_lose_context };\n\n/**\n * A Fixture is a class used to instantiate each test sub/case at run time.\n * A new instance of the Fixture is created for every single test subcase\n * (i.e. every time the test function is run).\n */\nexport class Fixture {\n  private _params: unknown;\n  /**\n   * Interface for recording logs and test status.\n   *\n   * @internal\n   */\n  protected rec: TestCaseRecorder;\n  private eventualExpectations: Array<Promise<unknown>> = [];\n  private numOutstandingAsyncExpectations = 0;\n  private objectsToCleanUp: DestroyableObject[] = [];\n\n  /** @internal */\n  constructor(rec: TestCaseRecorder, params: TestParams) {\n    this.rec = rec;\n    this._params = params;\n  }\n\n  /**\n   * Returns the (case+subcase) parameters for this test function invocation.\n   */\n  get params(): unknown {\n    return this._params;\n  }\n\n  // This has to be a member function instead of an async `createFixture` function, because\n  // we need to be able to ergonomically override it in subclasses.\n  /**\n   * Override this to do additional pre-test-function work in a derived fixture.\n   */\n  protected async init(): Promise<void> {}\n\n  /**\n   * Override this to do additional post-test-function work in a derived fixture.\n   *\n   * Called even if init was unsuccessful.\n   */\n  protected async finalize(): Promise<void> {\n    assert(\n      this.numOutstandingAsyncExpectations === 0,\n      'there were outstanding immediateAsyncExpectations (e.g. expectUncapturedError) at the end of the test'\n    );\n\n    // Loop to exhaust the eventualExpectations in case they chain off each other.\n    while (this.eventualExpectations.length) {\n      const p = this.eventualExpectations.shift()!;\n      try {\n        await p;\n      } catch (ex) {\n        this.rec.threw(ex);\n      }\n    }\n\n    // And clean up any objects now that they're done being used.\n    for (const o of this.objectsToCleanUp) {\n      if ('getExtension' in o) {\n        const WEBGL_lose_context = o.getExtension('WEBGL_lose_context');\n        if (WEBGL_lose_context) WEBGL_lose_context.loseContext();\n      } else if ('destroy' in o) {\n        o.destroy();\n      } else {\n        o.close();\n      }\n    }\n  }\n\n  /** @internal */\n  doInit(): Promise<void> {\n    return this.init();\n  }\n\n  /** @internal */\n  doFinalize(): Promise<void> {\n    return this.finalize();\n  }\n\n  /**\n   * Tracks an object to be cleaned up after the test finishes.\n   *\n   * MAINTENANCE_TODO: Use this in more places. (Will be easier once .destroy() is allowed on\n   * invalid objects.)\n   */\n  trackForCleanup<T extends DestroyableObject>(o: T): T {\n    this.objectsToCleanUp.push(o);\n    return o;\n  }\n\n  /** Tracks an object, if it's destroyable, to be cleaned up after the test finishes. */\n  tryTrackForCleanup<T>(o: T): T {\n    if (typeof o === 'object' && o !== null) {\n      if (\n        'destroy' in o ||\n        'close' in o ||\n        o instanceof WebGLRenderingContext ||\n        o instanceof WebGL2RenderingContext\n      ) {\n        this.objectsToCleanUp.push((o as unknown) as DestroyableObject);\n      }\n    }\n    return o;\n  }\n\n  /** Log a debug message. */\n  debug(msg: string): void {\n    this.rec.debug(new Error(msg));\n  }\n\n  /** Throws an exception marking the subcase as skipped. */\n  skip(msg: string): never {\n    throw new SkipTestCase(msg);\n  }\n\n  /** Log a warning and increase the result status to \"Warn\". */\n  warn(msg?: string): void {\n    this.rec.warn(new Error(msg));\n  }\n\n  /** Log an error and increase the result status to \"ExpectFailed\". */\n  fail(msg?: string): void {\n    this.rec.expectationFailed(new Error(msg));\n  }\n\n  /**\n   * Wraps an async function. Tracks its status to fail if the test tries to report a test status\n   * before the async work has finished.\n   */\n  protected async immediateAsyncExpectation<T>(fn: () => Promise<T>): Promise<T> {\n    this.numOutstandingAsyncExpectations++;\n    const ret = await fn();\n    this.numOutstandingAsyncExpectations--;\n    return ret;\n  }\n\n  /**\n   * Wraps an async function, passing it an `Error` object recording the original stack trace.\n   * The async work will be implicitly waited upon before reporting a test status.\n   */\n  protected eventualAsyncExpectation<T>(fn: (niceStack: Error) => Promise<T>): Promise<T> {\n    const promise = fn(new Error());\n    this.eventualExpectations.push(promise);\n    return promise;\n  }\n\n  private expectErrorValue(expectedError: string | true, ex: unknown, niceStack: Error): void {\n    if (!(ex instanceof Error)) {\n      niceStack.message = `THREW non-error value, of type ${typeof ex}: ${ex}`;\n      this.rec.expectationFailed(niceStack);\n      return;\n    }\n    const actualName = ex.name;\n    if (expectedError !== true && actualName !== expectedError) {\n      niceStack.message = `THREW ${actualName}, instead of ${expectedError}: ${ex}`;\n      this.rec.expectationFailed(niceStack);\n    } else {\n      niceStack.message = `OK: threw ${actualName}: ${ex.message}`;\n      this.rec.debug(niceStack);\n    }\n  }\n\n  /** Expect that the provided promise resolves (fulfills). */\n  shouldResolve(p: Promise<unknown>, msg?: string): void {\n    this.eventualAsyncExpectation(async niceStack => {\n      const m = msg ? ': ' + msg : '';\n      try {\n        await p;\n        niceStack.message = 'resolved as expected' + m;\n      } catch (ex) {\n        niceStack.message = `REJECTED${m}`;\n        if (ex instanceof Error) {\n          niceStack.message += '\\n' + ex.message;\n        }\n        this.rec.expectationFailed(niceStack);\n      }\n    });\n  }\n\n  /** Expect that the provided promise rejects, with the provided exception name. */\n  shouldReject(expectedName: string, p: Promise<unknown>, msg?: string): void {\n    this.eventualAsyncExpectation(async niceStack => {\n      const m = msg ? ': ' + msg : '';\n      try {\n        await p;\n        niceStack.message = 'DID NOT REJECT' + m;\n        this.rec.expectationFailed(niceStack);\n      } catch (ex) {\n        niceStack.message = 'rejected as expected' + m;\n        this.expectErrorValue(expectedName, ex, niceStack);\n      }\n    });\n  }\n\n  /**\n   * Expect that the provided function throws.\n   * If an `expectedName` is provided, expect that the throw exception has that name.\n   */\n  shouldThrow(expectedError: string | boolean, fn: () => void, msg?: string): void {\n    const m = msg ? ': ' + msg : '';\n    try {\n      fn();\n      if (expectedError === false) {\n        this.rec.debug(new Error('did not throw, as expected' + m));\n      } else {\n        this.rec.expectationFailed(new Error('unexpectedly did not throw' + m));\n      }\n    } catch (ex) {\n      if (expectedError === false) {\n        this.rec.expectationFailed(new Error('threw unexpectedly' + m));\n      } else {\n        this.expectErrorValue(expectedError, ex, new Error(m));\n      }\n    }\n  }\n\n  /** Expect that a condition is true. */\n  expect(cond: boolean, msg?: string): boolean {\n    if (cond) {\n      const m = msg ? ': ' + msg : '';\n      this.rec.debug(new Error('expect OK' + m));\n    } else {\n      this.rec.expectationFailed(new Error(msg));\n    }\n    return cond;\n  }\n\n  /** If the argument is an Error, fail (or warn). Otherwise, no-op. */\n  expectOK(\n    error: Error | unknown,\n    { mode = 'fail', niceStack }: { mode?: 'fail' | 'warn'; niceStack?: Error } = {}\n  ): void {\n    if (error instanceof Error) {\n      if (niceStack) {\n        error.stack = niceStack.stack;\n      }\n      if (mode === 'fail') {\n        this.rec.expectationFailed(error);\n      } else if (mode === 'warn') {\n        this.rec.warn(error);\n      } else {\n        unreachable();\n      }\n    }\n  }\n}\n"],"file":"fixture.js"}