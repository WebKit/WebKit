{"version":3,"sources":["../../../src/common/framework/params_builder.ts"],"names":["mergeParams","ParamsBuilderBase","constructor","cases","builderIterateCasesWithSubcases","builder","iterateCasesWithSubcases","CaseParamsBuilder","a","undefined","Symbol","iterator","expandWithParams","expander","newGenerator","expanderGenerator","expand","key","p","value","combineWithParams","newParams","combine","values","filter","pred","filterGenerator","unless","x","beginSubcases","SubcaseParamsBuilder","kUnitCaseParamsBuilder","generator","subcases","caseP","Array","from","length","baseGenerator","base","b"],"mappings":";AAAA;AACA,GADA,SAAiBA,WAAjB,QAAoC,6BAApC,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyFA;AACA;AACA;AACA,OAAO,MAAeC,iBAAf,CAAwE;;;AAG7EC,EAAAA,WAAW,CAACC,KAAD,EAAgC;AACzC,SAAKA,KAAL,GAAaA,KAAb;AACD;;AAED;AACF;AACA,KAT+E;;;;AAa/E;AACA;AACA;AACA,OAAO,SAASC,+BAAT,CAAyCC,OAAzC,EAA6E;;;;;AAKlF,SAASA,OAAF,CAAgDC,wBAAhD,EAAP;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAN;AACGN;AACkC;AACjB,GAAxBK,wBAAwB,GAAmC;AAC1D,SAAK,MAAME,CAAX,IAAgB,KAAKL,KAAL,EAAhB,EAA8B;AAC5B,YAAM,CAACK,CAAD,EAAIC,SAAJ,CAAN;AACD;AACF;;AAEe,GAAfC,MAAM,CAACC,QAAQ,IAAqB;AACnC,WAAO,KAAKR,KAAL,EAAP;AACD;;AAED;AACAS,EAAAA,gBAAgB;AACdC,EAAAA,QADc;AAE0B;AACxC,UAAMC,YAAY,GAAGC,iBAAiB,CAAC,KAAKZ,KAAN,EAAaU,QAAb,CAAtC;AACA,WAAO,IAAIN,iBAAJ,CAAsB,MAAMO,YAAY,CAAC,EAAD,CAAxC,CAAP;AACD;;AAED;AACAE,EAAAA,MAAM;AACJC,EAAAA,GADI;AAEJJ,EAAAA,QAFI;AAGgE;AACpE,WAAO,KAAKD,gBAAL,CAAsB,WAAWM,CAAX,EAAc;AACzC,WAAK,MAAMC,KAAX,IAAoBN,QAAQ,CAACK,CAAD,CAA5B,EAAiC;AAC/B;AACA,cAAM,EAAE,CAACD,GAAD,GAAOE,KAAT,EAAN;AACD;AACF,KALM,CAAP;AAMD;;AAED;AACAC,EAAAA,iBAAiB;AACfC,EAAAA,SADe;AAEyB;AACxC,WAAO,KAAKT,gBAAL,CAAsB,MAAMS,SAA5B,CAAP;AACD;;AAED;AACAC,EAAAA,OAAO;AACLL,EAAAA,GADK;AAELM,EAAAA,MAFK;AAG+D;AACpE,WAAO,KAAKP,MAAL,CAAYC,GAAZ,EAAiB,MAAMM,MAAvB,CAAP;AACD;;AAED;AACAC,EAAAA,MAAM,CAACC,IAAD,EAAoE;AACxE,UAAMX,YAAY,GAAGY,eAAe,CAAC,KAAKvB,KAAN,EAAasB,IAAb,CAApC;AACA,WAAO,IAAIlB,iBAAJ,CAAsB,MAAMO,YAAY,CAAC,EAAD,CAAxC,CAAP;AACD;;AAED;AACAa,EAAAA,MAAM,CAACF,IAAD,EAAoE;AACxE,WAAO,KAAKD,MAAL,CAAY,CAAAI,CAAC,KAAI,CAACH,IAAI,CAACG,CAAD,CAAtB,CAAP;AACD;;AAED;AACF;AACA;AACA;AACA;AACEC,EAAAA,aAAa,GAAoC;AAC/C,WAAO,IAAIC,oBAAJ;AACL,UAAM,KAAK3B,KAAL,EADD;AAEL,iBAAa;AACX,YAAM,EAAN;AACD,KAJI,CAAP;;AAMD,GAtEyC;;;AAyE5C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM4B,sBAAsB,GAAG,IAAIxB,iBAAJ,CAAsB,aAAa;AACvE,QAAM,EAAN;AACD,CAFqC,CAA/B;;AAIP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMuB,oBAAN;AACG7B;AACiB;;;AAGzBC,EAAAA,WAAW,CAACC,KAAD,EAAgC6B,SAAhC,EAA8E;AACvF,UAAM7B,KAAN;AACA,SAAK8B,QAAL,GAAgBD,SAAhB;AACD;;AAEwB,GAAxB1B,wBAAwB,GAAyC;AAChE,SAAK,MAAM4B,KAAX,IAAoB,KAAK/B,KAAL,EAApB,EAAkC;AAChC,YAAM8B,QAAQ,GAAGE,KAAK,CAACC,IAAN,CAAW,KAAKH,QAAL,CAAcC,KAAd,CAAX,CAAjB;AACA,UAAID,QAAQ,CAACI,MAAb,EAAqB;AACnB,cAAM,CAACH,KAAD,EAAQD,QAAR,CAAN;AACD;AACF;AACF;;AAED;AACArB,EAAAA,gBAAgB;AACdC,EAAAA,QADc;AAEuC;AACrD,WAAO,IAAIiB,oBAAJ,CAAyB,KAAK3B,KAA9B,EAAqCY,iBAAiB,CAAC,KAAKkB,QAAN,EAAgBpB,QAAhB,CAAtD,CAAP;AACD;;AAED;AACAG,EAAAA,MAAM;AACJC,EAAAA,GADI;AAEJJ,EAAAA,QAFI;AAG6E;AACjF,WAAO,KAAKD,gBAAL,CAAsB,WAAWM,CAAX,EAAc;AACzC,WAAK,MAAMC,KAAX,IAAoBN,QAAQ,CAACK,CAAD,CAA5B,EAAiC;AAC/B;AACA,cAAM,EAAE,CAACD,GAAD,GAAOE,KAAT,EAAN;AACD;AACF,KALM,CAAP;AAMD;;AAED;AACAC,EAAAA,iBAAiB;AACfC,EAAAA,SADe;AAEsC;AACrD,WAAO,KAAKT,gBAAL,CAAsB,MAAMS,SAA5B,CAAP;AACD;;AAED;AACAC,EAAAA,OAAO;AACLL,EAAAA,GADK;AAELM,EAAAA,MAFK;AAG4E;AACjF,WAAO,KAAKP,MAAL,CAAYC,GAAZ,EAAiB,MAAMM,MAAvB,CAAP;AACD;;AAED;AACAC,EAAAA,MAAM,CAACC,IAAD,EAAuF;AAC3F,WAAO,IAAIK,oBAAJ,CAAyB,KAAK3B,KAA9B,EAAqCuB,eAAe,CAAC,KAAKO,QAAN,EAAgBR,IAAhB,CAApD,CAAP;AACD;;AAED;AACAE,EAAAA,MAAM,CAACF,IAAD,EAAuF;AAC3F,WAAO,KAAKD,MAAL,CAAY,CAAAI,CAAC,KAAI,CAACH,IAAI,CAACG,CAAD,CAAtB,CAAP;AACD,GA5DwB;;;AA+D3B,SAASb,iBAAT;AACEuB,aADF;AAEEzB,QAFF;AAGwC;AACtC,SAAO,WAAW0B,IAAX,EAAuB;AAC5B,SAAK,MAAM/B,CAAX,IAAgB8B,aAAa,CAACC,IAAD,CAA7B,EAAqC;AACnC,WAAK,MAAMC,CAAX,IAAgB3B,QAAQ,CAACb,WAAW,CAACuC,IAAD,EAAO/B,CAAP,CAAZ,CAAxB,EAAgD;AAC9C,cAAMR,WAAW,CAACQ,CAAD,EAAIgC,CAAJ,CAAjB;AACD;AACF;AACF,GAND;AAOD;;AAED,SAASd,eAAT;AACEY,aADF;AAEEb,IAFF;AAG6B;AAC3B,SAAO,WAAWc,IAAX,EAAuB;AAC5B,SAAK,MAAM/B,CAAX,IAAgB8B,aAAa,CAACC,IAAD,CAA7B,EAAqC;AACnC,UAAId,IAAI,CAACzB,WAAW,CAACuC,IAAD,EAAO/B,CAAP,CAAZ,CAAR,EAAgC;AAC9B,cAAMA,CAAN;AACD;AACF;AACF,GAND;AAOD","sourcesContent":["import { Merged, mergeParams } from '../internal/params_utils.js';\n\n// ================================================================\n// \"Public\" ParamsBuilder API / Documentation\n// ================================================================\n\n/**\n * Provides doc comments for the methods of CaseParamsBuilder and SubcaseParamsBuilder.\n * (Also enforces rough interface match between them.)\n */\nexport interface ParamsBuilder {\n  /**\n   * Expands each item in `this` into zero or more items.\n   * Each item has its parameters expanded with those returned by the `expander`.\n   *\n   * **Note:** When only a single key is being added, use the simpler `expand` for readability.\n   *\n   * ```text\n   *               this = [     a       ,      b     ,       c       ]\n   * this.map(expander) = [   f(a)           f(b)          f(c)      ]\n   *                    = [[a1, a2, a3] ,    [ b1 ]  ,       []      ]\n   *  merge and flatten = [ merge(a, a1), merge(a, a2), merge(a, a3), merge(b, b1) ]\n   * ```\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  expandWithParams(expander: (_: any) => any): any;\n\n  /**\n   * Expands each item in `this` into zero or more items. Each item has its parameters expanded\n   * with one new key, `key`, and the values returned by `expander`.\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  expand(key: string, expander: (_: any) => any): any;\n\n  /**\n   * Expands each item in `this` to multiple items, one for each item in `newParams`.\n   *\n   * In other words, takes the cartesian product of [ the items in `this` ] and `newParams`.\n   *\n   * **Note:** When only a single key is being added, use the simpler `combine` for readability.\n   *\n   * ```text\n   *                     this = [ {a:1}, {b:2} ]\n   *                newParams = [ {x:1}, {y:2} ]\n   * this.combineP(newParams) = [ {a:1,x:1}, {a:1,y:2}, {b:2,x:1}, {b:2,y:2} ]\n   * ```\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  combineWithParams(newParams: Iterable<any>): any;\n\n  /**\n   * Expands each item in `this` to multiple items with `{ [name]: value }` for each value.\n   *\n   * In other words, takes the cartesian product of [ the items in `this` ]\n   * and `[ {[name]: value} for each value in values ]`\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  combine(key: string, newParams: Iterable<any>): any;\n\n  /**\n   * Filters `this` to only items for which `pred` returns true.\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  filter(pred: (_: any) => boolean): any;\n\n  /**\n   * Filters `this` to only items for which `pred` returns false.\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  unless(pred: (_: any) => boolean): any;\n}\n\n/**\n * Determines the resulting parameter object type which would be generated by an object of\n * the given ParamsBuilder type.\n */\nexport type ParamTypeOf<\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  T extends ParamsBuilder\n> = T extends SubcaseParamsBuilder<infer CaseP, infer SubcaseP>\n  ? Merged<CaseP, SubcaseP>\n  : T extends CaseParamsBuilder<infer CaseP>\n  ? CaseP\n  : never;\n\n// ================================================================\n// Implementation\n// ================================================================\n\n/**\n * Iterable over pairs of either:\n * - `[case params, Iterable<subcase params>]` if there are subcases.\n * - `[case params, undefined]` if not.\n */\nexport type CaseSubcaseIterable<CaseP, SubcaseP> = Iterable<\n  readonly [CaseP, Iterable<SubcaseP> | undefined]\n>;\n\n/**\n * Base class for `CaseParamsBuilder` and `SubcaseParamsBuilder`.\n */\nexport abstract class ParamsBuilderBase<CaseP extends {}, SubcaseP extends {}> {\n  protected readonly cases: () => Generator<CaseP>;\n\n  constructor(cases: () => Generator<CaseP>) {\n    this.cases = cases;\n  }\n\n  /**\n   * Hidden from test files. Use `builderIterateCasesWithSubcases` to access this.\n   */\n  protected abstract iterateCasesWithSubcases(): CaseSubcaseIterable<CaseP, SubcaseP>;\n}\n\n/**\n * Calls the (normally hidden) `iterateCasesWithSubcases()` method.\n */\nexport function builderIterateCasesWithSubcases(builder: ParamsBuilderBase<{}, {}>) {\n  interface IterableParamsBuilder {\n    iterateCasesWithSubcases(): CaseSubcaseIterable<{}, {}>;\n  }\n\n  return ((builder as unknown) as IterableParamsBuilder).iterateCasesWithSubcases();\n}\n\n/**\n * Builder for combinatorial test **case** parameters.\n *\n * CaseParamsBuilder is immutable. Each method call returns a new, immutable object,\n * modifying the list of cases according to the method called.\n *\n * This means, for example, that the `unit` passed into `TestBuilder.params()` can be reused.\n */\nexport class CaseParamsBuilder<CaseP extends {}>\n  extends ParamsBuilderBase<CaseP, {}>\n  implements Iterable<CaseP>, ParamsBuilder {\n  *iterateCasesWithSubcases(): CaseSubcaseIterable<CaseP, {}> {\n    for (const a of this.cases()) {\n      yield [a, undefined];\n    }\n  }\n\n  [Symbol.iterator](): Iterator<CaseP> {\n    return this.cases();\n  }\n\n  /** @inheritdoc */\n  expandWithParams<NewP extends {}>(\n    expander: (_: Merged<{}, CaseP>) => Iterable<NewP>\n  ): CaseParamsBuilder<Merged<CaseP, NewP>> {\n    const newGenerator = expanderGenerator(this.cases, expander);\n    return new CaseParamsBuilder(() => newGenerator({}));\n  }\n\n  /** @inheritdoc */\n  expand<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    expander: (_: Merged<{}, CaseP>) => Iterable<NewPValue>\n  ): CaseParamsBuilder<Merged<CaseP, { [name in NewPKey]: NewPValue }>> {\n    return this.expandWithParams(function* (p) {\n      for (const value of expander(p)) {\n        // TypeScript doesn't know here that NewPKey is always a single literal string type.\n        yield { [key]: value } as { [name in NewPKey]: NewPValue };\n      }\n    });\n  }\n\n  /** @inheritdoc */\n  combineWithParams<NewP extends {}>(\n    newParams: Iterable<NewP>\n  ): CaseParamsBuilder<Merged<CaseP, NewP>> {\n    return this.expandWithParams(() => newParams);\n  }\n\n  /** @inheritdoc */\n  combine<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    values: Iterable<NewPValue>\n  ): CaseParamsBuilder<Merged<CaseP, { [name in NewPKey]: NewPValue }>> {\n    return this.expand(key, () => values);\n  }\n\n  /** @inheritdoc */\n  filter(pred: (_: Merged<{}, CaseP>) => boolean): CaseParamsBuilder<CaseP> {\n    const newGenerator = filterGenerator(this.cases, pred);\n    return new CaseParamsBuilder(() => newGenerator({}));\n  }\n\n  /** @inheritdoc */\n  unless(pred: (_: Merged<{}, CaseP>) => boolean): CaseParamsBuilder<CaseP> {\n    return this.filter(x => !pred(x));\n  }\n\n  /**\n   * \"Finalize\" the list of cases and begin defining subcases.\n   * Returns a new SubcaseParamsBuilder. Methods called on SubcaseParamsBuilder\n   * generate new subcases instead of new cases.\n   */\n  beginSubcases(): SubcaseParamsBuilder<CaseP, {}> {\n    return new SubcaseParamsBuilder(\n      () => this.cases(),\n      function* () {\n        yield {};\n      }\n    );\n  }\n}\n\n/**\n * The unit CaseParamsBuilder, representing a single case with no params: `[ {} ]`.\n *\n * `punit` is passed to every `.params()`/`.paramsSubcasesOnly()` call, so `kUnitCaseParamsBuilder`\n * is only explicitly needed if constructing a ParamsBuilder outside of a test builder.\n */\nexport const kUnitCaseParamsBuilder = new CaseParamsBuilder(function* () {\n  yield {};\n});\n\n/**\n * Builder for combinatorial test _subcase_ parameters.\n *\n * SubcaseParamsBuilder is immutable. Each method call returns a new, immutable object,\n * modifying the list of subcases according to the method called.\n */\nexport class SubcaseParamsBuilder<CaseP extends {}, SubcaseP extends {}>\n  extends ParamsBuilderBase<CaseP, SubcaseP>\n  implements ParamsBuilder {\n  protected readonly subcases: (_: CaseP) => Generator<SubcaseP>;\n\n  constructor(cases: () => Generator<CaseP>, generator: (_: CaseP) => Generator<SubcaseP>) {\n    super(cases);\n    this.subcases = generator;\n  }\n\n  *iterateCasesWithSubcases(): CaseSubcaseIterable<CaseP, SubcaseP> {\n    for (const caseP of this.cases()) {\n      const subcases = Array.from(this.subcases(caseP));\n      if (subcases.length) {\n        yield [caseP, subcases];\n      }\n    }\n  }\n\n  /** @inheritdoc */\n  expandWithParams<NewP extends {}>(\n    expander: (_: Merged<CaseP, SubcaseP>) => Iterable<NewP>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, NewP>> {\n    return new SubcaseParamsBuilder(this.cases, expanderGenerator(this.subcases, expander));\n  }\n\n  /** @inheritdoc */\n  expand<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    expander: (_: Merged<CaseP, SubcaseP>) => Iterable<NewPValue>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, { [name in NewPKey]: NewPValue }>> {\n    return this.expandWithParams(function* (p) {\n      for (const value of expander(p)) {\n        // TypeScript doesn't know here that NewPKey is always a single literal string type.\n        yield { [key]: value } as { [name in NewPKey]: NewPValue };\n      }\n    });\n  }\n\n  /** @inheritdoc */\n  combineWithParams<NewP extends {}>(\n    newParams: Iterable<NewP>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, NewP>> {\n    return this.expandWithParams(() => newParams);\n  }\n\n  /** @inheritdoc */\n  combine<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    values: Iterable<NewPValue>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, { [name in NewPKey]: NewPValue }>> {\n    return this.expand(key, () => values);\n  }\n\n  /** @inheritdoc */\n  filter(pred: (_: Merged<CaseP, SubcaseP>) => boolean): SubcaseParamsBuilder<CaseP, SubcaseP> {\n    return new SubcaseParamsBuilder(this.cases, filterGenerator(this.subcases, pred));\n  }\n\n  /** @inheritdoc */\n  unless(pred: (_: Merged<CaseP, SubcaseP>) => boolean): SubcaseParamsBuilder<CaseP, SubcaseP> {\n    return this.filter(x => !pred(x));\n  }\n}\n\nfunction expanderGenerator<Base, A, B>(\n  baseGenerator: (_: Base) => Generator<A>,\n  expander: (_: Merged<Base, A>) => Iterable<B>\n): (_: Base) => Generator<Merged<A, B>> {\n  return function* (base: Base) {\n    for (const a of baseGenerator(base)) {\n      for (const b of expander(mergeParams(base, a))) {\n        yield mergeParams(a, b);\n      }\n    }\n  };\n}\n\nfunction filterGenerator<Base, A>(\n  baseGenerator: (_: Base) => Generator<A>,\n  pred: (_: Merged<Base, A>) => boolean\n): (_: Base) => Generator<A> {\n  return function* (base: Base) {\n    for (const a of baseGenerator(base)) {\n      if (pred(mergeParams(base, a))) {\n        yield a;\n      }\n    }\n  };\n}\n"],"file":"params_builder.js"}