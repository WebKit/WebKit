{"version":3,"file":"params_builder.js","names":["mergeParams","stringifyPublicParams","assert","mapLazy","ParamsBuilderBase","constructor","cases","builderIterateCasesWithSubcases","builder","iterateCasesWithSubcases","CaseParamsBuilder","a","undefined","Symbol","iterator","expandWithParams","expander","newGenerator","expanderGenerator","expand","key","p","value","combineWithParams","newParams","assertNotGenerator","seenValues","Set","params","paramsStr","has","add","combine","values","mapped","v","filter","pred","filterGenerator","unless","x","beginSubcases","SubcaseParamsBuilder","kUnitCaseParamsBuilder","generator","subcases","caseP","Array","from","length","baseGenerator","base","b"],"sources":["../../../src/common/framework/params_builder.ts"],"sourcesContent":["import { Merged, mergeParams } from '../internal/params_utils.js';\nimport { stringifyPublicParams } from '../internal/query/stringify_params.js';\nimport { assert, mapLazy } from '../util/util.js';\n\n// ================================================================\n// \"Public\" ParamsBuilder API / Documentation\n// ================================================================\n\n/**\n * Provides doc comments for the methods of CaseParamsBuilder and SubcaseParamsBuilder.\n * (Also enforces rough interface match between them.)\n */\nexport interface ParamsBuilder {\n  /**\n   * Expands each item in `this` into zero or more items.\n   * Each item has its parameters expanded with those returned by the `expander`.\n   *\n   * **Note:** When only a single key is being added, use the simpler `expand` for readability.\n   *\n   * ```text\n   *               this = [     a       ,      b     ,       c       ]\n   * this.map(expander) = [   f(a)           f(b)          f(c)      ]\n   *                    = [[a1, a2, a3] ,    [ b1 ]  ,       []      ]\n   *  merge and flatten = [ merge(a, a1), merge(a, a2), merge(a, a3), merge(b, b1) ]\n   * ```\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  expandWithParams(expander: (_: any) => any): any;\n\n  /**\n   * Expands each item in `this` into zero or more items. Each item has its parameters expanded\n   * with one new key, `key`, and the values returned by `expander`.\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  expand(key: string, expander: (_: any) => any): any;\n\n  /**\n   * Expands each item in `this` to multiple items, one for each item in `newParams`.\n   *\n   * In other words, takes the cartesian product of [ the items in `this` ] and `newParams`.\n   *\n   * **Note:** When only a single key is being added, use the simpler `combine` for readability.\n   *\n   * ```text\n   *                     this = [ {a:1}, {b:2} ]\n   *                newParams = [ {x:1}, {y:2} ]\n   * this.combineP(newParams) = [ {a:1,x:1}, {a:1,y:2}, {b:2,x:1}, {b:2,y:2} ]\n   * ```\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  combineWithParams(newParams: Iterable<any>): any;\n\n  /**\n   * Expands each item in `this` to multiple items with `{ [name]: value }` for each value.\n   *\n   * In other words, takes the cartesian product of [ the items in `this` ]\n   * and `[ {[name]: value} for each value in values ]`\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  combine(key: string, newParams: Iterable<any>): any;\n\n  /**\n   * Filters `this` to only items for which `pred` returns true.\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  filter(pred: (_: any) => boolean): any;\n\n  /**\n   * Filters `this` to only items for which `pred` returns false.\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  unless(pred: (_: any) => boolean): any;\n}\n\n/**\n * Determines the resulting parameter object type which would be generated by an object of\n * the given ParamsBuilder type.\n */\nexport type ParamTypeOf<\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  T extends ParamsBuilder\n> = T extends SubcaseParamsBuilder<infer CaseP, infer SubcaseP>\n  ? Merged<CaseP, SubcaseP>\n  : T extends CaseParamsBuilder<infer CaseP>\n  ? CaseP\n  : never;\n\n// ================================================================\n// Implementation\n// ================================================================\n\n/**\n * Iterable over pairs of either:\n * - `[case params, Iterable<subcase params>]` if there are subcases.\n * - `[case params, undefined]` if not.\n */\nexport type CaseSubcaseIterable<CaseP, SubcaseP> = Iterable<\n  readonly [CaseP, Iterable<SubcaseP> | undefined]\n>;\n\n/**\n * Base class for `CaseParamsBuilder` and `SubcaseParamsBuilder`.\n */\nexport abstract class ParamsBuilderBase<CaseP extends {}, SubcaseP extends {}> {\n  protected readonly cases: () => Generator<CaseP>;\n\n  constructor(cases: () => Generator<CaseP>) {\n    this.cases = cases;\n  }\n\n  /**\n   * Hidden from test files. Use `builderIterateCasesWithSubcases` to access this.\n   */\n  protected abstract iterateCasesWithSubcases(): CaseSubcaseIterable<CaseP, SubcaseP>;\n}\n\n/**\n * Calls the (normally hidden) `iterateCasesWithSubcases()` method.\n */\nexport function builderIterateCasesWithSubcases(builder: ParamsBuilderBase<{}, {}>) {\n  interface IterableParamsBuilder {\n    iterateCasesWithSubcases(): CaseSubcaseIterable<{}, {}>;\n  }\n\n  return ((builder as unknown) as IterableParamsBuilder).iterateCasesWithSubcases();\n}\n\n/**\n * Builder for combinatorial test **case** parameters.\n *\n * CaseParamsBuilder is immutable. Each method call returns a new, immutable object,\n * modifying the list of cases according to the method called.\n *\n * This means, for example, that the `unit` passed into `TestBuilder.params()` can be reused.\n */\nexport class CaseParamsBuilder<CaseP extends {}>\n  extends ParamsBuilderBase<CaseP, {}>\n  implements Iterable<CaseP>, ParamsBuilder {\n  *iterateCasesWithSubcases(): CaseSubcaseIterable<CaseP, {}> {\n    for (const a of this.cases()) {\n      yield [a, undefined];\n    }\n  }\n\n  [Symbol.iterator](): Iterator<CaseP> {\n    return this.cases();\n  }\n\n  /** @inheritDoc */\n  expandWithParams<NewP extends {}>(\n    expander: (_: Merged<{}, CaseP>) => Iterable<NewP>\n  ): CaseParamsBuilder<Merged<CaseP, NewP>> {\n    const newGenerator = expanderGenerator(this.cases, expander);\n    return new CaseParamsBuilder(() => newGenerator({}));\n  }\n\n  /** @inheritDoc */\n  expand<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    expander: (_: Merged<{}, CaseP>) => Iterable<NewPValue>\n  ): CaseParamsBuilder<Merged<CaseP, { [name in NewPKey]: NewPValue }>> {\n    return this.expandWithParams(function* (p) {\n      for (const value of expander(p)) {\n        yield { [key]: value } as { readonly [name in NewPKey]: NewPValue };\n      }\n    });\n  }\n\n  /** @inheritDoc */\n  combineWithParams<NewP extends {}>(\n    newParams: Iterable<NewP>\n  ): CaseParamsBuilder<Merged<CaseP, NewP>> {\n    assertNotGenerator(newParams);\n    const seenValues = new Set<string>();\n    for (const params of newParams) {\n      const paramsStr = stringifyPublicParams(params);\n      assert(!seenValues.has(paramsStr), `Duplicate entry in combine[WithParams]: ${paramsStr}`);\n      seenValues.add(paramsStr);\n    }\n\n    return this.expandWithParams(() => newParams);\n  }\n\n  /** @inheritDoc */\n  combine<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    values: Iterable<NewPValue>\n  ): CaseParamsBuilder<Merged<CaseP, { [name in NewPKey]: NewPValue }>> {\n    assertNotGenerator(values);\n    const mapped = mapLazy(values, v => ({ [key]: v } as { [name in NewPKey]: NewPValue }));\n    return this.combineWithParams(mapped);\n  }\n\n  /** @inheritDoc */\n  filter(pred: (_: Merged<{}, CaseP>) => boolean): CaseParamsBuilder<CaseP> {\n    const newGenerator = filterGenerator(this.cases, pred);\n    return new CaseParamsBuilder(() => newGenerator({}));\n  }\n\n  /** @inheritDoc */\n  unless(pred: (_: Merged<{}, CaseP>) => boolean): CaseParamsBuilder<CaseP> {\n    return this.filter(x => !pred(x));\n  }\n\n  /**\n   * \"Finalize\" the list of cases and begin defining subcases.\n   * Returns a new SubcaseParamsBuilder. Methods called on SubcaseParamsBuilder\n   * generate new subcases instead of new cases.\n   */\n  beginSubcases(): SubcaseParamsBuilder<CaseP, {}> {\n    return new SubcaseParamsBuilder(\n      () => this.cases(),\n      function* () {\n        yield {};\n      }\n    );\n  }\n}\n\n/**\n * The unit CaseParamsBuilder, representing a single case with no params: `[ {} ]`.\n *\n * `punit` is passed to every `.params()`/`.paramsSubcasesOnly()` call, so `kUnitCaseParamsBuilder`\n * is only explicitly needed if constructing a ParamsBuilder outside of a test builder.\n */\nexport const kUnitCaseParamsBuilder = new CaseParamsBuilder(function* () {\n  yield {};\n});\n\n/**\n * Builder for combinatorial test _subcase_ parameters.\n *\n * SubcaseParamsBuilder is immutable. Each method call returns a new, immutable object,\n * modifying the list of subcases according to the method called.\n */\nexport class SubcaseParamsBuilder<CaseP extends {}, SubcaseP extends {}>\n  extends ParamsBuilderBase<CaseP, SubcaseP>\n  implements ParamsBuilder {\n  protected readonly subcases: (_: CaseP) => Generator<SubcaseP>;\n\n  constructor(cases: () => Generator<CaseP>, generator: (_: CaseP) => Generator<SubcaseP>) {\n    super(cases);\n    this.subcases = generator;\n  }\n\n  *iterateCasesWithSubcases(): CaseSubcaseIterable<CaseP, SubcaseP> {\n    for (const caseP of this.cases()) {\n      const subcases = Array.from(this.subcases(caseP));\n      if (subcases.length) {\n        yield [caseP, subcases];\n      }\n    }\n  }\n\n  /** @inheritDoc */\n  expandWithParams<NewP extends {}>(\n    expander: (_: Merged<CaseP, SubcaseP>) => Iterable<NewP>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, NewP>> {\n    return new SubcaseParamsBuilder(this.cases, expanderGenerator(this.subcases, expander));\n  }\n\n  /** @inheritDoc */\n  expand<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    expander: (_: Merged<CaseP, SubcaseP>) => Iterable<NewPValue>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, { [name in NewPKey]: NewPValue }>> {\n    return this.expandWithParams(function* (p) {\n      for (const value of expander(p)) {\n        // TypeScript doesn't know here that NewPKey is always a single literal string type.\n        yield { [key]: value } as { [name in NewPKey]: NewPValue };\n      }\n    });\n  }\n\n  /** @inheritDoc */\n  combineWithParams<NewP extends {}>(\n    newParams: Iterable<NewP>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, NewP>> {\n    assertNotGenerator(newParams);\n    return this.expandWithParams(() => newParams);\n  }\n\n  /** @inheritDoc */\n  combine<NewPKey extends string, NewPValue>(\n    key: NewPKey,\n    values: Iterable<NewPValue>\n  ): SubcaseParamsBuilder<CaseP, Merged<SubcaseP, { [name in NewPKey]: NewPValue }>> {\n    assertNotGenerator(values);\n    return this.expand(key, () => values);\n  }\n\n  /** @inheritDoc */\n  filter(pred: (_: Merged<CaseP, SubcaseP>) => boolean): SubcaseParamsBuilder<CaseP, SubcaseP> {\n    return new SubcaseParamsBuilder(this.cases, filterGenerator(this.subcases, pred));\n  }\n\n  /** @inheritDoc */\n  unless(pred: (_: Merged<CaseP, SubcaseP>) => boolean): SubcaseParamsBuilder<CaseP, SubcaseP> {\n    return this.filter(x => !pred(x));\n  }\n}\n\nfunction expanderGenerator<Base, A, B>(\n  baseGenerator: (_: Base) => Generator<A>,\n  expander: (_: Merged<Base, A>) => Iterable<B>\n): (_: Base) => Generator<Merged<A, B>> {\n  return function* (base: Base) {\n    for (const a of baseGenerator(base)) {\n      for (const b of expander(mergeParams(base, a))) {\n        yield mergeParams(a, b);\n      }\n    }\n  };\n}\n\nfunction filterGenerator<Base, A>(\n  baseGenerator: (_: Base) => Generator<A>,\n  pred: (_: Merged<Base, A>) => boolean\n): (_: Base) => Generator<A> {\n  return function* (base: Base) {\n    for (const a of baseGenerator(base)) {\n      if (pred(mergeParams(base, a))) {\n        yield a;\n      }\n    }\n  };\n}\n\n/** Assert an object is not a Generator (a thing returned from a generator function). */\nfunction assertNotGenerator(x: object) {\n  if ('constructor' in x) {\n    assert(\n      x.constructor !== (function* () {})().constructor,\n      'Argument must not be a generator, as generators are not reusable'\n    );\n  }\n}\n"],"mappings":"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"}