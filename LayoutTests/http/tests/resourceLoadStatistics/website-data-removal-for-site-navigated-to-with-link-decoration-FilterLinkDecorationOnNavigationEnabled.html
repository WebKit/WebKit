<!DOCTYPE html><!-- webkit-test-runner [ FilterLinkDecorationOnNavigationEnabled=true ] -->
<html>
<head>
    <script src="/cookies/resources/cookie-utilities.js"></script>
    <script src="resources/util.js"></script>
</head>
<body onload="setTimeout('runTest()', 0)">
<div id="description">Check that script-writeable website data gets removed after a navigation with link decoration from a prevalent resource.</div>
<br>
<div id="output"></div>
<br>
<script>
    testRunner.waitUntilDone();
    testRunner.dumpAsText();

    const httpOnlyCookieName = "http-only-cookie";
    const serverSideCookieName = "server-side-cookie";
    const clientSideCookieName = "client-side-cookie";
    const clientSidePersistentCookieName = "client-side-persistent-cookie";
    const clientSidePersistentCookieMaxAge = 60 * 60 * 24;

    function sortStringArray(a, b) {
        a = a.toLowerCase();
        b = b.toLowerCase();

        return a > b ? 1 : b > a ? -1 : 0;
    }

    function addLinebreakToOutput() {
        let element = document.createElement("br");
        output.appendChild(element);
    }

    function addOutput(message) {
        let element = document.createElement("div");
        element.innerText = message;
        output.appendChild(element);
    }

    function checkCookies(isAfterDeletion) {
        let unsortedTestPassedMessages = [];
        let cookies = internals.getCookies();
        let potentialCookies = { "http-only-cookie": 1, "server-side-cookie": 1, "client-side-cookie": 1, "client-side-persistent-cookie": 1 };
        if (!cookies.length)
            testFailed((isAfterDeletion ? "After" : "Before") + " script-accessible deletion: No cookies found.");

        for (let cookie of cookies) {
            switch (cookie.name) {
                case httpOnlyCookieName:
                    delete potentialCookies[httpOnlyCookieName];
                    unsortedTestPassedMessages.push((isAfterDeletion ? "After" : "Before") + " deletion: HttpOnly cookie exists.");
                    break;
                case serverSideCookieName:
                    delete potentialCookies[serverSideCookieName];
                    unsortedTestPassedMessages.push((isAfterDeletion ? "After" : "Before") + " deletion: Regular server-side cookie exists.");
                    break;
                case clientSideCookieName:
                    delete potentialCookies[clientSideCookieName];
                    unsortedTestPassedMessages.push((isAfterDeletion ? "After" : "Before") + " deletion: Client-side cookie exists.");
                    break;
                case clientSidePersistentCookieName:
                    delete potentialCookies[clientSidePersistentCookieName];
                    let now = new Date();
                    let maxExpiryDateInMilliseconds = now.getTime() + (clientSidePersistentCookieMaxAge * 1000);
                    unsortedTestPassedMessages.push((isAfterDeletion ? "After" : "Before") + " deletion: Client-side persistent cookie exists with 24-hour capped max-age: " + (maxExpiryDateInMilliseconds > cookie.expires));
                    break;
            }
        }

        for (let missingCookie in potentialCookies) {
            switch (missingCookie) {
                case httpOnlyCookieName:
                    unsortedTestPassedMessages.push((isAfterDeletion ? "After" : "Before") + " deletion: HttpOnly cookie does not exist.");
                    break;
                case serverSideCookieName:
                    unsortedTestPassedMessages.push((isAfterDeletion ? "After" : "Before") + " deletion: Regular server-side cookie does not exist.");
                    break;
                case clientSideCookieName:
                    unsortedTestPassedMessages.push((isAfterDeletion ? "After" : "Before") + " deletion: Client-side cookie does not exist.");
                    break;
                case clientSidePersistentCookieName:
                    unsortedTestPassedMessages.push((isAfterDeletion ? "After" : "Before") + " deletion: Client-side persistent cookie does not exist.");
                    break;
            }
        }

        let sortedTestPassedMessages = unsortedTestPassedMessages.sort(sortStringArray);
        for (let testPassedMessage of sortedTestPassedMessages) {
            addOutput(testPassedMessage);
        }
    }

    const dbName = "TestDatabase";

    function createIDBDataStore(callback) {
        let request = indexedDB.open(dbName);
        request.onerror = function() {
            addOutput("Couldn't create indexedDB.");
            finishTest();
        };
        request.onupgradeneeded = function(event) {
            let db = event.target.result;
            let objStore = db.createObjectStore("test", {autoIncrement: true});
            objStore.add("value");
            callback();
        }
    }

    const maxIntervals = 20;

    let intervalCounterIDB;
    let checkIDBCallback;
    let checkIDBIntervalID;
    let semaphoreIDBCheck = false;
    function checkIDBDataStoreExists(isAfterDeletion, callback) {
        let request;
        intervalCounterIDB = 0;
        checkIDBCallback = callback;
        if (!isAfterDeletion) {
            // Check until there is a IDB.
            checkIDBIntervalID = setInterval(function() {
                if (semaphoreIDBCheck)
                    return;
                semaphoreIDBCheck = true;

                if (++intervalCounterIDB >= maxIntervals) {
                    clearInterval(checkIDBIntervalID);
                    addOutput("Before deletion: IDB entry does not exist.");
                    semaphoreIDBCheck = false;
                    checkIDBCallback();
                } else {
                    request = indexedDB.open(dbName);
                    request.onerror = function () {
                        clearInterval(checkIDBIntervalID);
                        addOutput("Couldn't open indexedDB.");
                        semaphoreIDBCheck = false;
                        finishTest();
                    };
                    request.onupgradeneeded = function () {
                        // Let the next interval check again.
                        semaphoreIDBCheck = false;
                    };
                    request.onsuccess = function () {
                        clearInterval(checkIDBIntervalID);
                        addOutput("Before deletion: IDB entry does exist.");
                        semaphoreIDBCheck = false;
                        checkIDBCallback();
                    };
                }
            }, 200);
        } else {
            // Check until there is no IDB.
            checkIDBIntervalID = setInterval(function () {
                if (semaphoreIDBCheck)
                    return;
                semaphoreIDBCheck = true;

                if (++intervalCounterIDB >= maxIntervals) {
                    clearInterval(checkIDBIntervalID);
                    addOutput("After deletion: IDB entry checks exhausted.");
                    semaphoreIDBCheck = false;
                    checkIDBCallback();
                } else {
                    request = indexedDB.open(dbName);
                    request.onerror = function () {
                        clearInterval(checkIDBIntervalID);
                        addOutput("Couldn't open indexedDB.");
                        semaphoreIDBCheck = false;
                        finishTest();
                    };
                    request.onupgradeneeded = function () {
                        clearInterval(checkIDBIntervalID);
                        addOutput("After deletion: IDB entry does not exist.");
                        semaphoreIDBCheck = false;
                        checkIDBCallback();
                    };
                    request.onsuccess = function () {
                        // Let the next interval check again.
                        semaphoreIDBCheck = false;
                    };
                }
            }, 200);
        }
    }

    let intervalCounterLocalStorage;
    let checkLocalStorageCallback;
    let checkLocalStorageIntervalID;
    const localStorageName = "test";
    const localStorageValue = "value";
    function checkLocalStorageExists(isAfterDeletion, callback) {
        intervalCounterLocalStorage = 0;
        checkLocalStorageCallback = callback;
        if (!isAfterDeletion) {
            // Check until there is LocalStorage.
            checkLocalStorageIntervalID = setInterval(function() {
                if (++intervalCounterLocalStorage >= maxIntervals) {
                    clearInterval(checkLocalStorageIntervalID);
                    let value = localStorage.getItem(localStorageName);
                    addOutput("Before deletion: LocalStorage entry " + (value === localStorageValue ? "does" : "does not") + " exist.");
                    checkLocalStorageCallback();
                } else if (testRunner.isStatisticsHasLocalStorage(destinationOrigin)) {
                    clearInterval(checkLocalStorageIntervalID);
                    let value = localStorage.getItem(localStorageName);
                    addOutput("Before deletion: LocalStorage entry " + (value === localStorageValue ? "does" : "does not") + " exist.");
                    checkLocalStorageCallback();
                }
            }, 100);
        } else {
            // Check until there is no LocalStorage.
            checkLocalStorageIntervalID = setInterval(function() {
                if (++intervalCounterLocalStorage >= maxIntervals) {
                    clearInterval(checkLocalStorageIntervalID);
                    let value = localStorage.getItem(localStorageName);
                    addOutput("After deletion: LocalStorage entry " + (value === localStorageValue ? "does" : "does not") + " exist.");
                    checkLocalStorageCallback();
                } else if (!testRunner.isStatisticsHasLocalStorage(destinationOrigin)) {
                    clearInterval(checkLocalStorageIntervalID);
                    let value = localStorage.getItem(localStorageName);
                    addOutput("After deletion: LocalStorage entry " + (value === localStorageValue ? "does" : "does not") + " exist.");
                    checkLocalStorageCallback();
                }
            }, 100);
        }
    }

    async function writeWebsiteDataAndContinue() {
        // Write cookies.
        await fetch("/cookies/resources/set-http-only-cookie.py?cookieName=" + httpOnlyCookieName, { credentials: "same-origin" });
        await fetch("/cookies/resources/setCookies.cgi", { headers: { "X-Set-Cookie": serverSideCookieName + "=1; path=/;" }, credentials: "same-origin" });
        document.cookie = clientSideCookieName + "=1";
        document.cookie = clientSidePersistentCookieName + "=1; max-age=1209602";

        checkCookies(false);

        // Write LocalStorage
        localStorage.setItem(localStorageName, localStorageValue);
        checkLocalStorageExists(false, function() {

            // Write IndexedDB.
            createIDBDataStore(function () {
                checkIDBDataStoreExists(false, function() {
                    addLinebreakToOutput();
                    processWebsiteDataAndContinue();
                });
            });
        });
    }

    function processWebsiteDataAndContinue() {
        testRunner.installStatisticsDidScanDataRecordsCallback(checkWebsiteDataAndContinue);
        testRunner.statisticsProcessStatisticsAndDataRecords();
    }

    const advanceTimeSecondsPerDay = 60 * 60 * 24;
    const expectDeletionAfterDays = advanceTimeSecondsPerDay*30;
    let currentAdvancedTime = 0;
    function checkWebsiteDataAndContinue() {
        let isAfterDeletion = currentAdvancedTime >= expectDeletionAfterDays;
        checkCookies(isAfterDeletion);
        checkLocalStorageExists(isAfterDeletion, function () {
            checkIDBDataStoreExists(isAfterDeletion, () => {
                if (!isAfterDeletion) {
                    currentAdvancedTime += expectDeletionAfterDays;
                    testRunner.setStatisticsTimeAdvanceForTesting(currentAdvancedTime);
                    processWebsiteDataAndContinue();
                } else
                    testRunner.setStatisticsShouldBlockThirdPartyCookies(false, finishTest);
            });
        });
    }

    async function finishTest() {
        await resetCookiesITP();
        testRunner.dumpResourceLoadStatistics();
        setEnableFeature(false, function() {
            testRunner.setStatisticsDebugMode(false, function() {
                testRunner.notifyDone();
            });
        });
    }

    const prevalentResourceOrigin = "http://localhost:8000";
    const destinationOrigin  = "http://127.0.0.1:8000";
    function runTest() {
        if (!location.search) {
            setEnableFeature(true, function () {
                testRunner.setStatisticsShouldBlockThirdPartyCookies(true, function () {
                    testRunner.setStatisticsHasHadUserInteraction(destinationOrigin, true, function() {
                        testRunner.setStatisticsPrevalentResourceForDebugMode(prevalentResourceOrigin, function() {
                            testRunner.setStatisticsDebugMode(true, function() {
                                let button = document.createElement("button");
                                button.onclick = () => { document.location = `${prevalentResourceOrigin}/resources/redirect.py?refresh=1&url=${location.href}?key%3Dvalue`; };
                                document.body.appendChild(button);
                                // Simulate clicking the button
                                let x = button.offsetLeft + button.offsetWidth / 2;
                                let y = button.offsetTop + button.offsetHeight / 2;
                                eventSender.mouseMoveTo(x, y);
                                eventSender.mouseDown();
                                eventSender.mouseUp();
                            });
                        });
                    });
                }, true /* onlyOnSitesWithoutUserInteraction */);
            });
            return;
        }

        writeWebsiteDataAndContinue();
    }
</script>
</body>
</html>
