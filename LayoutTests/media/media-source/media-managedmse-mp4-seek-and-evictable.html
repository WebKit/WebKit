<!DOCTYPE html>
<html>
<head>
    <title>media-source-mp4-eviction-calculation</title>
    <script src="media-source-loader.js"></script>
    <script src="../video-test.js"></script>
    <script>
    var loader;
    var source;
    var sourceBuffer;
    var evictable;

    function loaderPromise(loader) {
        return new Promise((resolve, reject) => {
            loader.onload = resolve;
            loader.onerror = reject;
        });
    }

    function bufferedRanges() {
        var bufferedRanges = '[ ';
        var timeRanges = sourceBuffer.buffered;
        for (var i = 0 ; i < timeRanges.length ; i++) {
            if (i)
                bufferedRanges += ', ';
            bufferedRanges += timeRanges.start(i) + '...' + timeRanges.end(i);
        }
        bufferedRanges += ' ]';
        return bufferedRanges;
    }

    async function loadData() {
        for (let i = 1; i < 10; i++) {
                consoleWrite('Append a media segment.')
                run('sourceBuffer.appendBuffer(loader.mediaSegment(0))');
                await waitFor(sourceBuffer, 'update');
                run('sourceBuffer.timestampOffset = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1)');
            }
        run('source.endOfStream()');
        return waitFor(source, 'sourceended');
    }

    window.addEventListener('load', async event => {
        findMediaElement();

        let manifests = [  'content/test-48khz-manifest.json', 'content/test-xhe-aac-manifest.json', 'content/test-opus-manifest.json', 'content/test-vorbis-manifest.json' ];
        for (const manifest of manifests) {
            loader = new MediaSourceLoader(manifest);
            await loaderPromise(loader);
            if (ManagedMediaSource.isTypeSupported(loader.type()))
                break;
        }

        video.disableRemotePlayback = true;
        source = new ManagedMediaSource();
        run('video.src = URL.createObjectURL(source)');
        await waitFor(source, 'sourceopen');
        waitFor(video, 'error').then(failTest);

        run('sourceBuffer = source.addSourceBuffer(loader.type())');

        run('sourceBuffer.appendBuffer(loader.initSegment())');
        await waitFor(sourceBuffer, 'update');

        await loadData();

        // No past data, and all contiguous, nothing evictable and nothing evicted.
        testExpected('internals.evictableSize(sourceBuffer)', 0, '==');

        run('video.currentTime = 5');        
        // Samples before currentTime are evictable.
        await waitFor(video, 'seeked');
        testExpected('internals.evictableSize(sourceBuffer)', 0, '>');

        run('video.currentTime = 0');
        await waitFor(video, 'seeked');
        testExpected('internals.evictableSize(sourceBuffer)', 0, '==');

        // Appending new data, will evict future data, not contiguous with the currently playing range.
        run('sourceBuffer.timestampOffset = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1) + 1');
        await loadData();

        run('evictable = internals.evictableSize(sourceBuffer)');
        testExpected('evictable', 0, '>');

        // Seeking 5s into the element, content before currentTime and after (non contiguous) are evictable.
        run('video.currentTime = 5');
        await waitFor(video, 'seeked');
        testExpected('internals.evictableSize(sourceBuffer) > evictable', true);

        endTest();
     });
    </script>
</head>
<body>
    <video></video>
</body>
</html>
