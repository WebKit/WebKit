<!DocType html>
<style>
body {
    margin: 4px;
}

body > p:first-of-type {
    margin-top: 0;
}

p {
    margin-bottom: 0.3em;
}

tr:not(.results-row) td {
    white-space: nowrap;
}

tr:not(.results-row) td:first-of-type {
    white-space: normal;
}

td:not(:first-of-type) {
    text-transform: lowercase;
}

td {
    padding: 0 4px;
}

th:empty, td:empty {
    padding: 0;
}

th {
    -webkit-user-select: none;
    -moz-user-select: none;
}

.results-row {
    background-color: white;
}

.results-row iframe, .results-row img {
    width: 800px;
    height: 600px;
}

.results-row[data-expanded="false"] {
    display: none;
}

#toolbar {
    position: fixed;
    padding: 4px;
    top: 0;
    right: 0;
    text-align: right;
}

.expand-button {
    background-color: white;
    color: blue;
    width: 11px;
    height: 11px;
    border: 1px solid blue;
    display: inline-block;
    margin: 0 3px 0 0;
    position: relative;
}

.expand-button-text {
    position: absolute;
    top: -0.3em;
    left: 1px;
}

.result-container {
    display: inline-block;
    border: 1px solid gray;
}

.result-container iframe, .result-container img {
    border: 0;
    border-top: 1px solid lightgray;
    vertical-align: top;
}

#options {
    background-color: white;
}

#options-menu {
    border: 1px solid;
    margin-top: 1px;
    padding: 2px 4px;
    box-shadow: 2px 2px 2px #888;
    -webkit-transition: opacity .2s;
    text-align: left;
}

#options-menu label {
    display: block;
}

.hidden-menu {
    pointer-events: none;
    opacity: 0;
}

.label {
    padding-left: 3px;
    font-weight: bold;
    font-size: small;
}

.pixel-zoom-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    display: -webkit-box;
    pointer-events: none;
}

.pixel-zoom-container > * {
    display: -webkit-box;
    -webkit-box-flex: 1;
    border: 1px inset lightgray;
    height: 100px;
    overflow: hidden;
    zoom: 300%;
    background-color: white;
}

.pixel-zoom-container img {
    width: 800px;
    height: 600px;
    vertical-align: top;
}
</style>
<style id="unexpected-style"></style>

<script>
var g_state;
function globalState()
{
    if (!g_state) {
        g_state = {
            crashTests: [],
            hasHttpTests: false,
            hasImageFailures: false,
            hasTextFailures: false,
            newTests: [],
            results: {},
            shouldToggleImages: true,
            testsWithStderr: [],
            timeoutTests: [],
            unexpectedPassTests: []
        }
    }
    return g_state;
}

function ADD_RESULTS(input)
{
    globalState().results = input;
}
</script>

<script src="full_results.json"></script>

<script>
function stripExtension(test)
{
    var index = test.lastIndexOf('.');
    return test.substring(0, index);
}

function parentOfType(node, selector)
{
    while (node = node.parentElement) {
        if (node.webkitMatchesSelector(selector))
            return node;
    }
    return null;
}

function remove(node)
{
    node.parentNode.removeChild(node);
}

function forEach(nodeList, handler)
{
    Array.prototype.forEach.call(nodeList, handler);
}

function resultIframe(src)
{
    // FIXME: use audio tags for AUDIO tests?
    var layoutTestsIndex = src.indexOf('LayoutTests');
    var name;
    if (layoutTestsIndex != -1) {
        var hasTrac = src.indexOf('trac.webkit.org') != -1;
        var prefix = hasTrac ? 'trac.webkit.org/.../' : '';
        name = prefix + src.substring(layoutTestsIndex + 'LayoutTests/'.length);
    } else {
        var lastDashIndex = src.lastIndexOf('-pretty');
        if (lastDashIndex == -1)
            lastDashIndex = src.lastIndexOf('-');
        name = src.substring(lastDashIndex + 1);
    }

    var tagName = (src.lastIndexOf('.png') == -1) ? 'iframe' : 'img';

    if (tagName != 'img')
        src += '?format=txt';
    return '<div class=result-container><div class=label>' + name + '</div><' + tagName + ' src="' + src + '"></' + tagName + '></div>';
}

function togglingImage(prefix)
{
    return '<div class=result-container><div class="label imageText"></div><img class=animatedImage data-prefix="' +
        prefix + '"></img></div>';
}

function toggleExpectations(e)
{
    var expandLink = e.target;
    if (expandLink.className != 'expand-button-text')
        expandLink = expandLink.querySelector('.expand-button-text');

    if (expandLink.textContent == '+')
        expandExpectations(expandLink);
    else
        collapseExpectations(expandLink);
}

function collapseExpectations(expandLink)
{
    expandLink.textContent = '+';
    var existingResultsRow = parentOfType(expandLink, 'tbody').querySelector('.results-row');
    if (existingResultsRow)
        updateExpandedState(existingResultsRow, false);
}

function updateExpandedState(row, isExpanded)
{
    row.setAttribute('data-expanded', isExpanded);
    updateImageTogglingTimer();
}

function expandExpectations(expandLink)
{
    var row = parentOfType(expandLink, 'tr');
    var parentTbody = row.parentNode;
    var existingResultsRow = parentTbody.querySelector('.results-row');
    
    var enDash = '\u2013';
    expandLink.textContent = enDash;
    if (existingResultsRow) {
        updateExpandedState(existingResultsRow, true);
        return;
    }
    
    var newRow = document.createElement('tr');
    newRow.className = 'results-row';
    var newCell = document.createElement('td');
    newCell.colSpan = row.querySelectorAll('td').length;

    var resultLinks = row.querySelectorAll('.result-link');
    var hasTogglingImages = false;
    for (var i = 0; i < resultLinks.length; i++) {
        var link = resultLinks[i];
        var result;
        if (link.textContent == 'images') {
            hasTogglingImages = true;
            result = togglingImage(link.getAttribute('data-prefix'));
        } else
            result = resultIframe(link.href);

        newCell.insertAdjacentHTML('beforeEnd', result);    
    }

    newRow.appendChild(newCell);
    parentTbody.appendChild(newRow);

    updateExpandedState(newRow, true);

    updateImageTogglingTimer();
}

function updateImageTogglingTimer()
{
    var hasVisibleAnimatedImage = document.querySelector('.results-row[data-expanded="true"] .animatedImage');
    if (!hasVisibleAnimatedImage) {
        clearInterval(globalState().togglingImageInterval);
        globalState().togglingImageInterval = null;
        return;
    }

    if (!globalState().togglingImageInterval) {
        toggleImages();
        globalState().togglingImageInterval = setInterval(toggleImages, 2000);
    }
}

function async(func, args)
{
    setTimeout(function() { func.apply(null, args); }, 100);
}

function visibleExpandLinks()
{
    if (onlyShowUnexpectedFailures())
        return document.querySelectorAll('tbody:not(.expected) .expand-button-text');
    else
        return document.querySelectorAll('.expand-button-text');
}

function expandAllExpectations()
{
    var expandLinks = visibleExpandLinks();
    for (var i = 0, len = expandLinks.length; i < len; i++)
        async(expandExpectations, [expandLinks[i]]);
}

function collapseAllExpectations()
{
    var expandLinks = visibleExpandLinks();
    for (var i = 0, len = expandLinks.length; i < len; i++)
        async(collapseExpectations, [expandLinks[i]]);
}

function shouldUseTracLinks()
{
    return !globalState().results.layout_tests_dir || !location.toString().indexOf('file://') == 0;
}

function testLink(test)
{
    var basePath;
    if (shouldUseTracLinks()) {
        var revision = globalState().results.revision;
        basePath = 'http://trac.webkit.org';
        basePath += revision ? ('/export/' + revision) : '/browser';
        basePath += '/trunk/LayoutTests/';
    } else
        basePath = globalState().results.layout_tests_dir + '/';
    return '<span class=expand-button onclick="toggleExpectations(event)"><span class=expand-button-text>+</span></span>' +
        '<a class=test-link href="' + basePath + test + '">' + test + '</a>';
}

function resultLink(testPrefix, suffix, contents)
{
    return '<a class=result-link href="' + testPrefix + suffix + '" data-prefix="' + testPrefix + '">' + contents + '</a> ';
}

function testObjectFor(test)
{
    var parts = test.split('/');
    var tree = globalState().results.tests;
    for (var i = 0; i < parts.length; i++) {
        if (parts[i] in tree)
            tree = tree[parts[i]];
        else {
            console.error('Test not in the results tree: ' + test);
            return null;
        }
    }
    return tree;
}

function processGlobalStateFor(testObject)
{
    var test = testObject.name;
    if (testObject.has_stderr)
        globalState().testsWithStderr.push(test);

    globalState().hasHttpTests = globalState().hasHttpTests || test.indexOf('http/') == 0;

    var actual = testObject.actual;
    if (actual == 'MISSING') {
        // FIXME: make sure that new-run-webkit-tests spits out an -actual.txt file for
        // tests with MISSING results.
        globalState().newTests.push(test);
        return;
    }

    var expected = testObject.expected || 'PASS';
    testObject.isExpected = true;
    if (actual != 'SKIP' && globalState().results.uses_expectations_file) {
        var expectedArray = expected.split(' ');
        var actualArray = actual.split(' ');
        for (var i = 0; i < actualArray.length; i++) {
            var actualValue = actualArray[i];
            if (expectedArray.indexOf(actualValue) == -1 &&
                (expectedArray.indexOf('FAIL') == -1 ||
                 (actualValue != 'IMAGE' && actualValue != 'TEXT' && actualValue != 'IMAGE+TEXT')))
                testObject.isExpected = false;
        }
    }

    if (actual == 'PASS' && expected != 'PASS')
        globalState().unexpectedPassTests.push(test);            

    if (globalState().results.uses_expectations_file && testObject.isExpected)
        return;

    // FIXME: Show some indication in the UI for a test that doesn't crash on the first run but crashes on the second run.
    if (actual.indexOf('CRASH') != -1) {
        globalState().crashTests.push(test);
        return;
    }

    // FIXME: Show some indication in the UI for a test only times out on one run?
    if (actual.indexOf('TIMEOUT') != -1)
        globalState().timeoutTests.push(test);
}

function toggleImages()
{
    var images = document.querySelectorAll('.animatedImage');
    var imageTexts = document.querySelectorAll('.imageText');
    for (var i = 0, len = images.length; i < len; i++) {
        var image = images[i];
        var text = imageTexts[i];
        if (text.textContent == 'Expected Image') {
            text.textContent = 'Actual Image';
            image.src = image.getAttribute('data-prefix') + '-actual.png';
        } else {
            text.textContent = 'Expected Image';
            image.src = image.getAttribute('data-prefix') + '-expected.png';
        }
    }
}

function textResultLinks(prefix)
{
    var html = resultLink(prefix, '-expected.txt', 'expected') +
        resultLink(prefix, '-actual.txt', 'actual') +
        resultLink(prefix, '-diff.txt', 'diff');

    if (globalState().results.has_pretty_patch)
        html += resultLink(prefix, '-pretty-diff.html', 'pretty diff');

    if (globalState().results.has_wdiff)
        html += resultLink(prefix, '-wdiff.html', 'wdiff');

    return html;
}

function tableRow(testObject)
{    
    var row = '<tbody'
    if (globalState().results.uses_expectations_file)
        row += ' class="' + (testObject.isExpected ? 'expected' : '') + '"';
    row += '><tr>';

    row += '<td>' + testLink(testObject.name) + '</td>';

    var test_prefix = stripExtension(testObject.name);
    row += '<td>';
    
    var actual = testObject.actual;
    if (actual.indexOf('TEXT') != -1) {
        globalState().hasTextFailures = true;
        row += textResultLinks(test_prefix);
    }
    
    if (actual.indexOf('AUDIO') != -1) {
        row += resultLink(test_prefix, '-expected.wav', 'expected audio');
        row += resultLink(test_prefix, '-actual.wav', 'actual audio');
    }

    row += '</td><td>';

    if (actual.indexOf('IMAGE') != -1) {
        globalState().hasImageFailures = true;

        if (testObject.is_mismatch_reftest) {
            row += resultLink(test_prefix, '-expected-mismatch.html', 'ref mismatch html') +
                resultLink(test_prefix, '-actual.png', 'actual');
        } else {
            if (testObject.is_reftest)
                row += resultLink(test_prefix, '-expected.html', 'ref html');
            
            if (globalState().shouldToggleImages) {
                row += resultLink(test_prefix, '-diffs.html', 'images');
            } else {
                row += resultLink(test_prefix, '-expected.png', 'expected');
                row += resultLink(test_prefix, '-actual.png', 'actual');
            }

            // FIXME: old-run-webkit-tests shows the diff percentage as the text contents of the "diff" link.
            row += resultLink(test_prefix, '-diff.png', 'diff');
        }
    }

    row += '</td>';
    row += '<td>' + actual + '</td>';

    if (globalState().results.uses_expectations_file)
      row += '<td>' + testObject.expected + '</td>';

    row += '</tr></tbody>';
    return row;
}

function forEachTest(handler, opt_tree, opt_prefix)
{
    var tree = opt_tree || globalState().results.tests;
    var prefix = opt_prefix || '';

    for (var key in tree) {
        var newPrefix = prefix ? (prefix + '/' + key) : key;
        if ('actual' in tree[key]) {
            var testObject = tree[key];
            testObject.name = newPrefix;
            handler(testObject);
        } else
            forEachTest(handler, tree[key], newPrefix);
    }
}

function tableRows()
{
    var html = '';
    forEachTest(function(testObject) {
        processGlobalStateFor(testObject)
        var test = testObject.name;
        if (globalState().unexpectedPassTests.indexOf(test) == -1 &&
            globalState().newTests.indexOf(test) == -1 &&
            globalState().crashTests.indexOf(test) == -1 &&
            globalState().timeoutTests.indexOf(test) == -1)
            html += tableRow(testObject);
    });
    return html;
}

function testList(tests, header, tableId)
{
    tests.sort();

    var html = '<p>' + header + '</p><table id="' + tableId + '">';

    if (tableId == 'passes-table')
        html += '<thead><th>test</th><th>expected failure type</th>';

    for (var i = 0; i < tests.length; i++) {
        var test = tests[i];
        html += '<tbody><tr><td>' + testLink(test) + '</td><td>';
        
        if (tableId == 'stderr-table')
            html += resultLink(stripExtension(test), '-stderr.txt', 'stderr');
        else if (tableId == 'passes-table')
            html += testObjectFor(test).expected;
        else if (tableId == 'crash-tests-table')
            html += resultLink(stripExtension(test), '-stack.txt', 'crash stack');
        else if (tableId == 'timeout-tests-table') {
            // FIXME: only include timeout actual/diff results here if we actually spit out results for timeout tests.
            html += textResultLinks(stripExtension(test));
        } else if (tableId == 'new-tests-table') {
            var testObject = testObjectFor(test);
            if (testObject.is_missing_audio)
                html += resultLink(stripExtension(test), '-actual.wav', 'audio result');
            if (testObject.is_missing_text)
                html += resultLink(stripExtension(test), '-actual.txt', 'result');
            if (testObject.is_missing_image)
                html += resultLink(stripExtension(test), '-actual.png', 'png result');
        } 
        
        html += '</td></tr></tbody>';
    }
    html += '</table>';
    return html;
}

function toArray(nodeList)
{
    return Array.prototype.slice.call(nodeList);
}

function trim(string)
{
    return string.replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
}

// Just a namespace for code management.
var TableSorter = {};

TableSorter._forwardArrow = '<svg style="width:10px;height:10px"><polygon points="0,0 10,0 5,10" style="fill:#ccc"></svg>';

TableSorter._backwardArrow = '<svg style="width:10px;height:10px"><polygon points="0,10 10,10 5,0" style="fill:#ccc"></svg>';

TableSorter._sortedContents = function(header, arrow)
{
    return arrow + ' ' + trim(header.textContent) + ' ' + arrow;
}

TableSorter._updateHeaderClassNames = function(newHeader)
{
    var sortHeader = document.querySelector('.sortHeader');
    if (sortHeader) {
        if (sortHeader == newHeader) {
            var isAlreadyReversed = sortHeader.classList.contains('reversed');
            if (isAlreadyReversed)
                sortHeader.classList.remove('reversed');
            else
                sortHeader.classList.add('reversed');
        } else {
            sortHeader.textContent = sortHeader.textContent;
            sortHeader.classList.remove('sortHeader');
            sortHeader.classList.remove('reversed');
        }
    }

    newHeader.classList.add('sortHeader');
}

TableSorter._textContent = function(tbodyRow, column)
{
    return tbodyRow.querySelectorAll('td')[column].textContent;
}

TableSorter._sortRows = function(newHeader, reversed)
{
    var testsTable = document.getElementById('results-table');
    var headers = toArray(testsTable.querySelectorAll('th'));
    var sortColumn = headers.indexOf(newHeader);

    var rows = toArray(testsTable.querySelectorAll('tbody'));

    rows.sort(function(a, b) {
        // Only need to support lexicographic sort for now.
        var aText = TableSorter._textContent(a, sortColumn);
        var bText = TableSorter._textContent(b, sortColumn);
        
        // Forward sort equal values by test name.
        if (sortColumn && aText == bText) {
            var aTestName = TableSorter._textContent(a, 0);
            var bTestName = TableSorter._textContent(b, 0);
            if (aTestName == bTestName)
                return 0;
            return aTestName < bTestName ? -1 : 1;
        }

        if (reversed)
            return aText < bText ? 1 : -1;
        else
            return aText < bText ? -1 : 1;
    });

    for (var i = 0; i < rows.length; i++)
        testsTable.appendChild(rows[i]);
}

TableSorter.sortColumn = function(columnNumber)
{
    var newHeader = document.getElementById('results-table').querySelectorAll('th')[columnNumber];
    TableSorter._sort(newHeader);
}

TableSorter.handleClick = function(e)
{
    var newHeader = e.target;
    if (newHeader.localName != 'th')
        return;
    TableSorter._sort(newHeader);
}

TableSorter._sort = function(newHeader)
{
    TableSorter._updateHeaderClassNames(newHeader);
    
    var reversed = newHeader.classList.contains('reversed');
    var sortArrow = reversed ? TableSorter._backwardArrow : TableSorter._forwardArrow;
    newHeader.innerHTML = TableSorter._sortedContents(newHeader, sortArrow);
    
    TableSorter._sortRows(newHeader, reversed);
}

var PixelZoomer = {};

PixelZoomer.showOnDelay = true;

PixelZoomer._zoomImageContainer = function(url)
{
    return '<div class=zoom-image-container><img src="' + url + '"></div>';
}

PixelZoomer._createContainer = function(e)
{
    var tbody = parentOfType(e.target, 'tbody');
    var row = tbody.querySelector('tr');
    var imageDiffLinks = row.querySelectorAll('a[href$=".png"]');
    
    var container = document.createElement('div');
    container.className = 'pixel-zoom-container';
    
    var html = '';
    
    var togglingImageLink = row.querySelector('a[href$="-diffs.html"]');
    if (togglingImageLink) {
        var prefix = togglingImageLink.getAttribute('data-prefix');
        html += PixelZoomer._zoomImageContainer(prefix + '-expected.png') +
            PixelZoomer._zoomImageContainer(prefix + '-actual.png');
    }
    
    for (var i = 0; i < imageDiffLinks.length; i++)
        html += PixelZoomer._zoomImageContainer(imageDiffLinks[i].href);

    container.innerHTML = html;
    document.body.appendChild(container);

    PixelZoomer._position(e);
}

PixelZoomer._position = function(e)
{
    var pageX = e.clientX;
    var pageY = e.clientY;
    var targetLocation = e.target.getBoundingClientRect();
    var x = pageX - targetLocation.left;
    var y = pageY - targetLocation.top;

    var zoomContainers = document.querySelectorAll('.pixel-zoom-container > .zoom-image-container');
    for (var i = 0; i < zoomContainers.length; i++) {
        var container = zoomContainers[i];
        container.scrollLeft = x - container.offsetWidth / 2;
        container.scrollTop = y - container.offsetHeight / 2;
    }
}

PixelZoomer.handleMouseOut = function(e)
{
    if (e.relatedTarget && e.relatedTarget.tagName != 'IFRAME')
        return;

    // If e.relatedTarget is null, we've moused out of the document.
    var container = document.querySelector('.pixel-zoom-container');
    if (container)
        remove(container);
}

PixelZoomer.handleMouseMove = function(e) {
    if (PixelZoomer._mouseMoveTimeout)
        clearTimeout(PixelZoomer._mouseMoveTimeout);

    if (parentOfType(e.target, '.pixel-zoom-container'))
        return;

    var container = document.querySelector('.pixel-zoom-container');
    
    var resultContainer = (e.target.className == 'result-container') ?
        e.target : parentOfType(e.target, '.result-container');
    if (!resultContainer || !resultContainer.querySelector('img')) {
        if (container)
            remove(container);
        return;
    }
    
    if (!container) {
        if (PixelZoomer.showOnDelay) {
            PixelZoomer._mouseMoveTimeout = setTimeout(function() {
                PixelZoomer._createContainer(e);
            }, 200);
            return;
        }

        PixelZoomer._createContainer(e);
        return;
    }
    
    PixelZoomer._position(e);
}

document.addEventListener('mousemove', PixelZoomer.handleMouseMove, false);
document.addEventListener('mouseout', PixelZoomer.handleMouseOut, false);

function onlyShowUnexpectedFailures()
{
    return document.getElementById('unexpected-results').checked;
}

function handleUnexpectedResultsChange()
{
    OptionWriter.save();
    updateExpectedFailures();
}

function updateExpectedFailures()
{
    document.getElementById('unexpected-style').innerText = onlyShowUnexpectedFailures() ?
        '.expected { display: none; }' : '';
}

var OptionWriter = {};

OptionWriter._key = 'run-webkit-tests-options';

OptionWriter.save = function()
{
    var options = document.querySelectorAll('label input');
    var data = {};
    for (var i = 0, len = options.length; i < len; i++) {
        var option = options[i];
        data[option.id] = option.checked;
    }
    localStorage.setItem(OptionWriter._key, JSON.stringify(data));
}

OptionWriter.apply = function()
{
    var json = localStorage.getItem(OptionWriter._key);
    if (!json)
        return;

    var data = JSON.parse(json);
    for (var id in data) {
        var input = document.getElementById(id);
        if (input) {
            input.checked = data[id];
            input.onchange();
        }
    }
}

function handleToggleImagesChange()
{
    OptionWriter.save();
    updateTogglingImages();
}

function updateTogglingImages()
{
    var shouldToggle = document.getElementById('toggle-images').checked;
    globalState().shouldToggleImages = shouldToggle;
    
    if (shouldToggle) {
        forEach(document.querySelectorAll('a[href$=".png"]'), convertToTogglingHandler(function(prefix) {
            return resultLink(prefix, '-diffs.html', 'images');
        }));
        forEach(document.querySelectorAll('img[src$=".png"]'), convertToTogglingHandler(togglingImage));
    } else {
        forEach(document.querySelectorAll('a[href$="-diffs.html"]'), convertToNonTogglingHandler(resultLink));
        forEach(document.querySelectorAll('.animatedImage'), convertToNonTogglingHandler(function (absolutePrefix, suffix) {
            return resultIframe(absolutePrefix + suffix);
        }));
    }

    updateImageTogglingTimer();
}

function getResultContainer(node)
{
    return (node.tagName == 'IMG') ? parentOfType(node, '.result-container') : node;
}

function convertToTogglingHandler(togglingImageFunction)
{
    return function(node) {
        var url = (node.tagName == 'IMG') ? node.src : node.href;
        if (url.match('-expected.png$'))
            remove(getResultContainer(node));
        else if (url.match('-actual.png$')) {
            var name = parentOfType(node, 'tbody').querySelector('.test-link').textContent;
            getResultContainer(node).outerHTML = togglingImageFunction(stripExtension(name));
        }   
    }
}

function convertToNonTogglingHandler(resultFunction)
{
    return function(node) {
        var prefix = node.getAttribute('data-prefix');
        getResultContainer(node).outerHTML = resultFunction(prefix, '-expected.png', 'expected') + resultFunction(prefix, '-actual.png', 'actual');
    }
}

function toggleOptionsMenu()
{
    var menu = document.getElementById('options-menu');
    menu.className = (menu.className == 'hidden-menu') ? '' : 'hidden-menu';
}

function handleMouseDown(e)
{
    if (!parentOfType(e.target, '#options-menu') && e.target.id != 'options-link')
        document.getElementById('options-menu').className = 'hidden-menu';
}

document.addEventListener('mousedown', handleMouseDown, false);

function generatePage()
{
    var html = '<div id=toolbar>' +
        '<a href="javascript:void()" onclick="expandAllExpectations()">expand all</a> ' +
        '<a href="javascript:void()" onclick="collapseAllExpectations()">collapse all</a> ' +
        '<a href="javascript:void()" id=options-link onclick="toggleOptionsMenu()">options</a>' +
        '<div id=options-menu class=hidden-menu>' +
            '<label><input id="unexpected-results" type=checkbox checked onchange="handleUnexpectedResultsChange()">Only show unexpected results</label>' +
            '<label><input id="toggle-images" type=checkbox checked onchange="handleToggleImagesChange()">Toggle images</label>' +
        '</div></div>';

    var tableRowsHtml = tableRows();

    if (tableRowsHtml) {
        html += '<p>Tests where results did not match expected results:</p>' +
            '<table id="results-table"><thead><tr>' +
            '<th>test</th>' +
            '<th id="text-results-header">results</th>' +
            '<th id="image-results-header">image results</th>' +
            '<th>failure type</th>';

        if (globalState().results.uses_expectations_file)
            html += '<th>expected failure type</th>';

        html += '</tr></thead>' + tableRowsHtml + '</table>';
    }

    if (globalState().crashTests.length)
        html += testList(globalState().crashTests, 'Tests that crashed:', 'crash-tests-table');

    if (globalState().timeoutTests.length)
        html += testList(globalState().timeoutTests, 'Tests that timed out:', 'timeout-tests-table');

    if (globalState().newTests.length)
        html += testList(globalState().newTests, 'Tests that had no expected results (probably new):', 'new-tests-table');

    if (globalState().testsWithStderr.length)
        html += testList(globalState().testsWithStderr, 'Tests that had stderr output:', 'stderr-table');

    if (globalState().results.uses_expectations_file && globalState().unexpectedPassTests.length)
        html += testList(globalState().unexpectedPassTests, 'Tests expected to fail but passed:', 'passes-table');

    if (globalState().hasHttpTests) {
        html += '<p>httpd access log: <a href="access_log.txt">access_log.txt</a></p>' +
            '<p>httpd error log: <a href="error_log.txt">error_log.txt</a></p>';
    }

    document.body.innerHTML = html;

    OptionWriter.apply();

    if (document.getElementById('results-table')) {
        document.getElementById('results-table').addEventListener('click', TableSorter.handleClick, false);
        TableSorter.sortColumn(0);
        if (!globalState().results.uses_expectations_file)
            parentOfType(document.getElementById('unexpected-results'), 'label').style.display = 'none';
        if (!globalState().hasTextFailures)
            document.getElementById('text-results-header').textContent = '';
        if (!globalState().hasImageFailures) {
            document.getElementById('image-results-header').textContent = '';
            parentOfType(document.getElementById('toggle-images'), 'label').style.display = 'none';
        }
    }
}
</script>
<!-- HACK: when json_results_test.js is included, loading this page runs the tests.
It is not copied to the layout-test-results output directory. -->
<script src="resources/results-test.js"></script>
<body onload="generatePage()"></body>
