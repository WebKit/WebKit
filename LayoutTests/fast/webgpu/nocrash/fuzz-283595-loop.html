<!-- webkit-test-runner [ enableMetalShaderValidation=true ] -->
<script>
  globalThis.testRunner?.waitUntilDone();
  const log = globalThis.$vm?.print ?? console.log;

  onload = async () => {
    let adapter = await navigator.gpu.requestAdapter({});
    let device = await adapter.requestDevice({});
    device.pushErrorScope('validation');
    let code = `
const moreThanArrayLength = 65;

@group(0) @binding(0) var<storage, read_write> buf: array<u32>;

@compute @workgroup_size(1)
fn c() {
  let maximumValidIndex = arrayLength(&buf) - 1;
  let sameAsBoundedIndex = select(moreThanArrayLength, maximumValidIndex, moreThanArrayLength == maximumValidIndex);
  loop {
    if sameAsBoundedIndex == arrayLength(&buf) {
      buf[5] = buf[moreThanArrayLength];
      buf[moreThanArrayLength] = 123456789;
      buf[2] = 100 + u32(sameAsBoundedIndex > arrayLength(&buf));
      buf[3] = 200 + u32(sameAsBoundedIndex == arrayLength(&buf));
      buf[4] = 300 + u32(sameAsBoundedIndex < arrayLength(&buf));
      buf[0] = sameAsBoundedIndex;
      buf[1] = arrayLength(&buf);
      break;
    }
  }
}
`;
    let module = device.createShaderModule({code});
    let bindGroupLayout0 = device.createBindGroupLayout({
      entries: [
        {binding: 0, buffer: {type: 'storage'}, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE},
      ],
    });
    let buffer0 = device.createBuffer({
      size: 256, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
    });
    let laterBuffer0 = device.createBuffer({
      size: 4, usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
    });
    device.queue.writeBuffer(laterBuffer0, 0, new Uint32Array(1), 0, 1);
    await device.queue.onSubmittedWorkDone();
    let bindGroup0 = device.createBindGroup({
      layout: bindGroupLayout0, entries: [
        {binding: 0, resource: {buffer: buffer0}},
      ],
    });
    let pipelineLayout = device.createPipelineLayout({bindGroupLayouts: [bindGroupLayout0]});
    let commandEncoder = device.createCommandEncoder();
    let computePassEncoder = commandEncoder.beginComputePass({});
    let computePipeline = device.createComputePipeline({layout: pipelineLayout, compute: {module}});
    computePassEncoder.setPipeline(computePipeline);
    computePassEncoder.setBindGroup(0, bindGroup0);
    computePassEncoder.dispatchWorkgroups(1);
    computePassEncoder.end();
    let outputBuffer = device.createBuffer({size: laterBuffer0.size, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ});
    commandEncoder.copyBufferToBuffer(laterBuffer0, 0, outputBuffer, 0, laterBuffer0.size);
    let outputBuffer2 = device.createBuffer({size: buffer0.size, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ});
    commandEncoder.copyBufferToBuffer(buffer0, 0, outputBuffer2, 0, buffer0.size);
    device.queue.submit([commandEncoder.finish()]);
    await device.queue.onSubmittedWorkDone();
    await outputBuffer.mapAsync(GPUMapMode.READ);
    log(new Uint32Array(outputBuffer.getMappedRange()));
    outputBuffer.unmap();
    await outputBuffer2.mapAsync(GPUMapMode.READ);
    let out = new Uint32Array(outputBuffer2.getMappedRange()).filter(x => x);
    log(out);
    outputBuffer2.unmap();
    let error = await device.popErrorScope();
    if (error) {
      log(error.message);
    } else {
      log('no validation error');
    }
    globalThis.testRunner?.notifyDone();
  };
</script>
