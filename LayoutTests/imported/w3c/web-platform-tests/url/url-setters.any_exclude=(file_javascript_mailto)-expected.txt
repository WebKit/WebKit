
PASS Loading data‚Ä¶
PASS URL: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.
PASS URL: Setting <a://example.net>.protocol = 'b'
PASS URL: Setting <a://example.net>.protocol = 'B' Upper-case ASCII is lower-cased
PASS URL: Setting <a://example.net>.protocol = '√©' Non-ASCII is rejected
PASS URL: Setting <a://example.net>.protocol = '0b' No leading digit
PASS URL: Setting <a://example.net>.protocol = '+b' No leading punctuation
PASS URL: Setting <a://example.net>.protocol = 'bC0+-.'
PASS URL: Setting <a://example.net>.protocol = 'b,c' Only some punctuation is acceptable
PASS URL: Setting <a://example.net>.protocol = 'b√©' Non-ASCII is rejected
PASS URL: Setting <http://test@example.net>.protocol = 'file' Can‚Äôt switch from URL containing username/password/port to file
PASS URL: Setting <https://example.net:1234>.protocol = 'file'
PASS URL: Setting <wss://x:x@example.net:1234>.protocol = 'file'
PASS URL: Setting <http://example.net>.protocol = 'b' Can‚Äôt switch from special scheme to non-special
PASS URL: Setting <https://example.net>.protocol = 's'
PASS URL: Setting <ftp://example.net>.protocol = 'test'
FAIL URL: Setting <ssh://me@example.net>.protocol = 'http' Can‚Äôt switch from non-special scheme to special assert_equals: expected "ssh://me@example.net" but got "http://me@example.net/"
FAIL URL: Setting <ssh://me@example.net>.protocol = 'https' assert_equals: expected "ssh://me@example.net" but got "https://me@example.net/"
PASS URL: Setting <ssh://me@example.net>.protocol = 'file'
FAIL URL: Setting <ssh://example.net>.protocol = 'file' assert_equals: expected "ssh://example.net" but got "file://example.net/"
FAIL URL: Setting <nonsense:///test>.protocol = 'https' assert_equals: expected "nonsense:///test" but got "https://test/"
PASS URL: Setting <http://example.net>.protocol = 'https:foo : bar' Stuff after the first ':' is ignored
PASS URL: Setting <data:text/html,<p>Test>.protocol = 'view-source+data:foo : bar' Stuff after the first ':' is ignored
PASS URL: Setting <http://foo.com:443/>.protocol = 'https' Port is set to null if it is the default for new scheme.
PASS URL: Setting <http://test/>.protocol = 'h\r
tt	ps' Tab and newline are stripped
PASS URL: Setting <http://test/>.protocol = 'https\r'
PASS URL: Setting <http://test/>.protocol = 'https\0' Non-tab/newline C0 controls result in no-op
PASS URL: Setting <http://test/>.protocol = 'https'
PASS URL: Setting <http://test/>.protocol = 'https'
PASS URL: Setting <http://test/>.protocol = 'https '
PASS URL: Setting <unix:/run/foo.socket>.username = 'me' No host means no username
PASS URL: Setting <http://example.net>.username = 'me'
PASS URL: Setting <http://:secret@example.net>.username = 'me'
PASS URL: Setting <http://me@example.net>.username = ''
PASS URL: Setting <http://me:secret@example.net>.username = ''
PASS URL: Setting <http://example.net>.username = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~¬Ä¬Å√â√©' UTF-8 percent encoding with the userinfo encode set.
PASS URL: Setting <http://example.net>.username = '%c3%89t√©' Bytes already percent-encoded are left as-is.
PASS URL: Setting <sc:///>.username = 'x'
PASS URL: Setting <unix:/run/foo.socket>.password = 'secret' No host means no password
PASS URL: Setting <http://example.net>.password = 'secret'
PASS URL: Setting <http://me@example.net>.password = 'secret'
PASS URL: Setting <http://:secret@example.net>.password = ''
PASS URL: Setting <http://me:secret@example.net>.password = ''
PASS URL: Setting <http://example.net>.password = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~¬Ä¬Å√â√©' UTF-8 percent encoding with the userinfo encode set.
PASS URL: Setting <http://example.net>.password = '%c3%89t√©' Bytes already percent-encoded are left as-is.
PASS URL: Setting <sc:///>.password = 'x'
PASS URL: Setting <sc://x/>.host = '\0' Non-special scheme
PASS URL: Setting <sc://x/>.host = '	'
PASS URL: Setting <sc://x/>.host = '
'
PASS URL: Setting <sc://x/>.host = '\r'
PASS URL: Setting <sc://x/>.host = ' '
PASS URL: Setting <sc://x/>.host = '#'
PASS URL: Setting <sc://x/>.host = '/'
PASS URL: Setting <sc://x/>.host = '?'
PASS URL: Setting <sc://x/>.host = '@'
PASS URL: Setting <sc://x/>.host = '√ü'
PASS URL: Setting <https://x/>.host = '√ü' IDNA Nontransitional_Processing
PASS URL: Setting <data:text/plain,Stuff>.host = 'example.net' Cannot-be-a-base means no host
PASS URL: Setting <http://example.net>.host = 'example.com:8080'
PASS URL: Setting <http://example.net:8080>.host = 'example.com' Port number is unchanged if not specified in the new value
PASS URL: Setting <http://example.net:8080>.host = 'example.com:' Port number is unchanged if not specified
PASS URL: Setting <http://example.net>.host = '' The empty host is not valid for special schemes
PASS URL: Setting <view-source+http://example.net/foo>.host = '' The empty host is OK for non-special schemes
PASS URL: Setting <a:/foo>.host = 'example.net' Path-only URLs can gain a host
PASS URL: Setting <http://example.net>.host = '0x7F000001:8080' IPv4 address syntax is normalized
PASS URL: Setting <http://example.net>.host = '[::0:01]:2' IPv6 address syntax is normalized
PASS URL: Setting <http://example.net>.host = '[2001:db8::2]:4002' IPv6 literal address with port, crbug.com/1012416
PASS URL: Setting <http://example.net>.host = 'example.com:80' Default port number is removed
PASS URL: Setting <https://example.net>.host = 'example.com:443' Default port number is removed
PASS URL: Setting <https://example.net>.host = 'example.com:80' Default port number is only removed for the relevant scheme
PASS URL: Setting <http://example.net:8080>.host = 'example.com:80' Port number is removed if new port is scheme default and existing URL has a non-default port
PASS URL: Setting <http://example.net/path>.host = 'example.com/stuff' Stuff after a / delimiter is ignored
PASS URL: Setting <http://example.net/path>.host = 'example.com:8080/stuff' Stuff after a / delimiter is ignored
PASS URL: Setting <http://example.net/path>.host = 'example.com?stuff' Stuff after a ? delimiter is ignored
PASS URL: Setting <http://example.net/path>.host = 'example.com:8080?stuff' Stuff after a ? delimiter is ignored
PASS URL: Setting <http://example.net/path>.host = 'example.com#stuff' Stuff after a # delimiter is ignored
PASS URL: Setting <http://example.net/path>.host = 'example.com:8080#stuff' Stuff after a # delimiter is ignored
PASS URL: Setting <http://example.net/path>.host = 'example.com\stuff' Stuff after a \ delimiter is ignored for special schemes
PASS URL: Setting <http://example.net/path>.host = 'example.com:8080\stuff' Stuff after a \ delimiter is ignored for special schemes
PASS URL: Setting <view-source+http://example.net/path>.host = 'example.com\stuff' \ is not a delimiter for non-special schemes, but still forbidden in hosts
PASS URL: Setting <view-source+http://example.net/path>.host = 'example.com:8080stuff2' Anything other than ASCII digit stops the port parser in a setter but is not an error
PASS URL: Setting <http://example.net/path>.host = 'example.com:8080stuff2' Anything other than ASCII digit stops the port parser in a setter but is not an error
PASS URL: Setting <http://example.net/path>.host = 'example.com:8080+2' Anything other than ASCII digit stops the port parser in a setter but is not an error
PASS URL: Setting <http://example.net/path>.host = 'example.com:65535' Port numbers are 16 bit integers
PASS URL: Setting <http://example.net/path>.host = 'example.com:65536' Port numbers are 16 bit integers, overflowing is an error. Hostname is still set, though.
PASS URL: Setting <http://example.net/>.host = '[google.com]' Broken IPv6
PASS URL: Setting <http://example.net/>.host = '[::1.2.3.4x]'
PASS URL: Setting <http://example.net/>.host = '[::1.2.3.]'
PASS URL: Setting <http://example.net/>.host = '[::1.2.]'
PASS URL: Setting <http://example.net/>.host = '[::1.]'
PASS URL: Setting <sc://test@test/>.host = ''
PASS URL: Setting <sc://test:12/>.host = ''
PASS URL: Setting <http://example.com/>.host = '///bad.com' Leading / is not stripped
PASS URL: Setting <sc://example.com/>.host = '///bad.com' Leading / is not stripped
PASS URL: Setting <https://example.com/>.host = 'a%C2%ADb'
PASS URL: Setting <https://example.com/>.host = '¬≠'
PASS URL: Setting <https://example.com/>.host = '%C2%AD'
PASS URL: Setting <https://example.com/>.host = 'xn--'
PASS URL: Setting <sc://x/>.hostname = '\0' Non-special scheme
PASS URL: Setting <sc://x/>.hostname = '	'
PASS URL: Setting <sc://x/>.hostname = '
'
PASS URL: Setting <sc://x/>.hostname = '\r'
PASS URL: Setting <sc://x/>.hostname = ' '
PASS URL: Setting <sc://x/>.hostname = '#'
PASS URL: Setting <sc://x/>.hostname = '/'
PASS URL: Setting <sc://x/>.hostname = '?'
PASS URL: Setting <sc://x/>.hostname = '@'
PASS URL: Setting <data:text/plain,Stuff>.hostname = 'example.net' Cannot-be-a-base means no host
PASS URL: Setting <http://example.net:8080>.hostname = 'example.com'
PASS URL: Setting <http://example.net>.hostname = '' The empty host is not valid for special schemes
PASS URL: Setting <view-source+http://example.net/foo>.hostname = '' The empty host is OK for non-special schemes
PASS URL: Setting <a:/foo>.hostname = 'example.net' Path-only URLs can gain a host
PASS URL: Setting <http://example.net:8080>.hostname = '0x7F000001' IPv4 address syntax is normalized
PASS URL: Setting <http://example.net>.hostname = '[::0:01]' IPv6 address syntax is normalized
PASS URL: Setting <http://example.net/path>.hostname = 'example.com:8080' : delimiter invalidates entire value
PASS URL: Setting <http://example.net:8080/path>.hostname = 'example.com:' : delimiter invalidates entire value
PASS URL: Setting <http://example.net/path>.hostname = 'example.com/stuff' Stuff after a / delimiter is ignored
PASS URL: Setting <http://example.net/path>.hostname = 'example.com?stuff' Stuff after a ? delimiter is ignored
PASS URL: Setting <http://example.net/path>.hostname = 'example.com#stuff' Stuff after a # delimiter is ignored
PASS URL: Setting <http://example.net/path>.hostname = 'example.com\stuff' Stuff after a \ delimiter is ignored for special schemes
PASS URL: Setting <view-source+http://example.net/path>.hostname = 'example.com\stuff' \ is not a delimiter for non-special schemes, but still forbidden in hosts
PASS URL: Setting <http://example.net/>.hostname = '[google.com]' Broken IPv6
PASS URL: Setting <http://example.net/>.hostname = '[::1.2.3.4x]'
PASS URL: Setting <http://example.net/>.hostname = '[::1.2.3.]'
PASS URL: Setting <http://example.net/>.hostname = '[::1.2.]'
PASS URL: Setting <http://example.net/>.hostname = '[::1.]'
PASS URL: Setting <sc://test@test/>.hostname = ''
PASS URL: Setting <sc://test:12/>.hostname = ''
PASS URL: Setting <non-spec:/.//p>.hostname = 'h' Drop /. from path
PASS URL: Setting <non-spec:/.//p>.hostname = ''
PASS URL: Setting <http://example.com/>.hostname = '///bad.com' Leading / is not stripped
PASS URL: Setting <sc://example.com/>.hostname = '///bad.com' Leading / is not stripped
PASS URL: Setting <https://example.com/>.hostname = 'a%C2%ADb'
PASS URL: Setting <https://example.com/>.hostname = '¬≠'
PASS URL: Setting <https://example.com/>.hostname = '%C2%AD'
PASS URL: Setting <https://example.com/>.hostname = 'xn--'
PASS URL: Setting <http://example.net>.port = '8080'
PASS URL: Setting <http://example.net:8080>.port = '' Port number is removed if empty is the new value
PASS URL: Setting <http://example.net:8080>.port = '80' Default port number is removed
PASS URL: Setting <https://example.net:4433>.port = '443' Default port number is removed
PASS URL: Setting <https://example.net>.port = '80' Default port number is only removed for the relevant scheme
PASS URL: Setting <http://example.net/path>.port = '8080/stuff' Stuff after a / delimiter is ignored
PASS URL: Setting <http://example.net/path>.port = '8080?stuff' Stuff after a ? delimiter is ignored
PASS URL: Setting <http://example.net/path>.port = '8080#stuff' Stuff after a # delimiter is ignored
PASS URL: Setting <http://example.net/path>.port = '8080\stuff' Stuff after a \ delimiter is ignored for special schemes
PASS URL: Setting <view-source+http://example.net/path>.port = '8080stuff2' Anything other than ASCII digit stops the port parser in a setter but is not an error
PASS URL: Setting <http://example.net/path>.port = '8080stuff2' Anything other than ASCII digit stops the port parser in a setter but is not an error
PASS URL: Setting <http://example.net/path>.port = '8080+2' Anything other than ASCII digit stops the port parser in a setter but is not an error
PASS URL: Setting <http://example.net/path>.port = '65535' Port numbers are 16 bit integers
PASS URL: Setting <http://example.net:8080/path>.port = '65536' Port numbers are 16 bit integers, overflowing is an error
PASS URL: Setting <http://example.net:8080/path>.port = 'randomstring' Setting port to a string that doesn't parse as a number
PASS URL: Setting <non-special://example.net:8080/path>.port = '65536' Port numbers are 16 bit integers, overflowing is an error
PASS URL: Setting <non-base:value>.port = '12'
PASS URL: Setting <sc:///>.port = '12'
PASS URL: Setting <sc://x/>.port = '12'
PASS URL: Setting <https://domain.com:443>.port = '	8080' Leading u0009 on special scheme
PASS URL: Setting <wpt++://domain.com:443>.port = '	8080' Leading u0009 on non-special scheme
PASS URL: Setting <https://www.google.com:4343>.port = '4wpt' Should use all ascii prefixed characters as port
PASS URL: Setting <data:original>.pathname = 'new value'
PASS URL: Setting <sc:original>.pathname = 'new value'
PASS URL: Setting <foo://somehost/some/path>.pathname = '' Non-special URLs can have their paths erased
PASS URL: Setting <foo:///some/path>.pathname = '' Non-special URLs with an empty host can have their paths erased
PASS URL: Setting <foo:/some/path>.pathname = '' Path-only URLs cannot have their paths erased
PASS URL: Setting <foo:/some/path>.pathname = 'test' Path-only URLs always have an initial slash
PASS URL: Setting <unix:/run/foo.socket?timeout=10>.pathname = '/var/log/../run/bar.socket'
PASS URL: Setting <https://example.net#nav>.pathname = 'home'
PASS URL: Setting <https://example.net#nav>.pathname = '../home'
PASS URL: Setting <http://example.net/home?lang=fr#nav>.pathname = '\a\%2E\b\%2e.\c' \ is a segment delimiter for 'special' URLs
PASS URL: Setting <view-source+http://example.net/home?lang=fr#nav>.pathname = '\a\%2E\b\%2e.\c' \ is *not* a segment delimiter for non-'special' URLs
PASS URL: Setting <a:/>.pathname = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~¬Ä¬Å√â√©' UTF-8 percent encoding with the default encode set. Tabs and newlines are removed.
PASS URL: Setting <http://example.net>.pathname = '%2e%2E%c3%89t√©' Bytes already percent-encoded are left as-is, including %2E outside dotted segments.
PASS URL: Setting <http://example.net>.pathname = '?' ? needs to be encoded
PASS URL: Setting <http://example.net>.pathname = '#' # needs to be encoded
PASS URL: Setting <sc://example.net>.pathname = '?' ? needs to be encoded, non-special scheme
PASS URL: Setting <sc://example.net>.pathname = '#' # needs to be encoded, non-special scheme
PASS URL: Setting <http://example.net>.pathname = '/?√©' ? doesn't mess up encoding
PASS URL: Setting <http://example.net>.pathname = '/#√©' # doesn't mess up encoding
PASS URL: Setting <non-spec:/>.pathname = '/.//p' Serialize /. in path
PASS URL: Setting <non-spec:/>.pathname = '/..//p'
PASS URL: Setting <non-spec:/>.pathname = '//p'
PASS URL: Setting <non-spec:/.//>.pathname = 'p' Drop /. from path
PASS URL: Setting <data:/nospace>.pathname = 'space ' Non-special URLs with non-opaque paths percent-encode U+0020
PASS URL: Setting <sc:/nospace>.pathname = 'space '
PASS URL: Setting <http://example.net>.pathname = ' ' Trailing space should be encoded
PASS URL: Setting <http://example.net>.pathname = '\0' Trailing C0 control should be encoded
PASS URL: Setting <https://example.net#nav>.search = 'lang=fr'
PASS URL: Setting <https://example.net?lang=en-US#nav>.search = 'lang=fr'
PASS URL: Setting <https://example.net?lang=en-US#nav>.search = '?lang=fr'
PASS URL: Setting <https://example.net?lang=en-US#nav>.search = '??lang=fr'
PASS URL: Setting <https://example.net?lang=en-US#nav>.search = '?'
PASS URL: Setting <https://example.net?lang=en-US#nav>.search = ''
PASS URL: Setting <https://example.net?lang=en-US>.search = ''
PASS URL: Setting <https://example.net>.search = ''
PASS URL: Setting <a:/>.search = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~¬Ä¬Å√â√©' UTF-8 percent encoding with the query encode set. Tabs and newlines are removed.
PASS URL: Setting <http://example.net>.search = '%c3%89t√©' Bytes already percent-encoded are left as-is
PASS URL: Setting <data:space ?query>.search = '' Drop trailing spaces from trailing opaque paths
PASS URL: Setting <sc:space ?query>.search = ''
PASS URL: Setting <data:space  ?query#fragment>.search = '' Do not drop trailing spaces from non-trailing opaque paths
PASS URL: Setting <sc:space  ?query#fragment>.search = ''
PASS URL: Setting <http://example.net>.search = ' ' Trailing space should be encoded
PASS URL: Setting <http://example.net>.search = '\0' Trailing C0 control should be encoded
PASS URL: Setting <https://example.net>.hash = 'main'
PASS URL: Setting <https://example.net#nav>.hash = 'main'
PASS URL: Setting <https://example.net?lang=en-US>.hash = '##nav'
PASS URL: Setting <https://example.net?lang=en-US#nav>.hash = '#main'
PASS URL: Setting <https://example.net?lang=en-US#nav>.hash = '#'
PASS URL: Setting <https://example.net?lang=en-US#nav>.hash = ''
PASS URL: Setting <http://example.net>.hash = '#foo bar'
PASS URL: Setting <http://example.net>.hash = '#foo"bar'
PASS URL: Setting <http://example.net>.hash = '#foo<bar'
PASS URL: Setting <http://example.net>.hash = '#foo>bar'
PASS URL: Setting <http://example.net>.hash = '#foo`bar'
PASS URL: Setting <a:/>.hash = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~¬Ä¬Å√â√©' Simple percent-encoding; tabs and newlines are removed
PASS URL: Setting <http://example.net>.hash = 'a\0b' Percent-encode NULLs in fragment
PASS URL: Setting <non-spec:/>.hash = 'a\0b' Percent-encode NULLs in fragment
PASS URL: Setting <http://example.net>.hash = '%c3%89t√©' Bytes already percent-encoded are left as-is
PASS URL: Setting <data:space                                                                                                                                  #fragment>.hash = '' Drop trailing spaces from trailing opaque paths
PASS URL: Setting <sc:space    #fragment>.hash = ''
PASS URL: Setting <data:space  ?query#fragment>.hash = '' Do not drop trailing spaces from non-trailing opaque paths
PASS URL: Setting <sc:space  ?query#fragment>.hash = ''
PASS URL: Setting <http://example.net>.hash = ' ' Trailing space should be encoded
PASS URL: Setting <http://example.net>.hash = '\0' Trailing C0 control should be encoded

