<!DOCTYPE html>
<html>
<head>
  <script src="/resources/testharness.js"></script>
  <script src="/resources/testharnessreport.js"></script>
  <meta http-equiv="Content-Security-Policy" content="require-trusted-types-for 'script'">
</head>
<body>
<script>
  const policy = trustedTypes.createPolicy("testpolicy", {
      createScript: x => x, createScriptURL: x => x});
  // Test that interactions between the script content, the .src attribute, and
  // exceptions still work correctly with TT and the "internal slot" thingy.
  promise_test(t => {
    const s = document.createElement("script");
    s.textContent = policy.createScript("window.postMessage('script body');");
    try {
      s.src = "support/HTMLScriptElement-internal-slot-support.js";
    } catch (e) {}
    document.body.appendChild(s);
    return new Promise((resolve, reject) => {
      window.addEventListener("message", e => {
        // .src was set with plain string => should not have been accepted.
        if (e.data == "script body") resolve();
        if (e.data == "script url") reject();
      });
    });
  }, "Setting .src to a plain string should throw an exception and not modify the script state, on an unconnected script element.");

  promise_test(t => {
    const s = document.createElement("script");
    s.textContent = policy.createScript("window.postMessage('script body');");
    s.src = policy.createScriptURL("support/HTMLScriptElement-internal-slot-support.js");
    document.body.appendChild(s);
    return new Promise((resolve, reject) => {
      window.addEventListener("message", e => {
        // .src was set with a TrustedScriptURL => the .src should get executed.
        if (e.data == "script body") reject();
        if (e.data == "script url") resolve();
      });
    });
  }, "Setting .src to a TrustedScriptURL should work and should execute the referenced script instead of the script body, on an unconnected script element.");

  promise_test(t => {
    const s = document.createElement("script");
    document.body.appendChild(s);
    s.textContent = policy.createScript("window.postMessage('script body');");
    try {
      s.src = "support/HTMLScriptElement-internal-slot-support.js";
    } catch (e) {}
    return new Promise((resolve, reject) => {
      window.addEventListener("message", e => {
        // .src was set with plain string => should not have been accepted.
        if (e.data == "script body") resolve();
        if (e.data == "script url") reject();
      });
    });
  }, "Setting .src to a plain string should throw an exception and not modify the script state, on a connected script element.");

  promise_test(t => {
    const s = document.createElement("script");
    s.textContent = policy.createScript("window.postMessage('script body');");
    s.src = policy.createScriptURL("support/HTMLScriptElement-internal-slot-support.js");
    document.body.appendChild(s);
    return new Promise((resolve, reject) => {
      window.addEventListener("message", e => {
        // .src was set with a TrustedScriptURL => the .src should get executed.
        if (e.data == "script body") reject();
        if (e.data == "script url") resolve();
      });
    });
  },  "Setting .src to a TrustedScriptURL should work and should execute the referenced script instead of the script body, on a onnected script element.");
</script>
</body>
</html>
