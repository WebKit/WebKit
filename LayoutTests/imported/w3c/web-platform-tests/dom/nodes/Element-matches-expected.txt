This test requires JavaScript.

PASS Selectors-API Level 2 Test Suite: HTML with Selectors Level 3
PASS Document should not support matches
PASS Detached Element supports matches
PASS Fragment should not support matches
PASS In-document Element supports matches
PASS DIV Element.matches(null)
PASS DIV Element.matches(undefined)
PASS DIV Element.matches no parameter
PASS NULL Element.matches(null)
PASS NULL Element.matches(undefined)
PASS NULL Element.matches no parameter
PASS UNDEFINED Element.matches(null)
PASS UNDEFINED Element.matches(undefined)
PASS UNDEFINED Element.matches no parameter
PASS Detached Element.matches: Empty String:
PASS Detached Element.matches: Invalid character: [
PASS Detached Element.matches: Invalid character: ]
PASS Detached Element.matches: Invalid character: (
PASS Detached Element.matches: Invalid character: )
PASS Detached Element.matches: Invalid character: {
PASS Detached Element.matches: Invalid character: }
PASS Detached Element.matches: Invalid character: <
PASS Detached Element.matches: Invalid character: >
PASS Detached Element.matches: Invalid ID: #
PASS Detached Element.matches: Invalid group of selectors: div,
PASS Detached Element.matches: Invalid class: .
PASS Detached Element.matches: Invalid class: .5cm
PASS Detached Element.matches: Invalid class: ..test
PASS Detached Element.matches: Invalid class: .foo..quux
PASS Detached Element.matches: Invalid class: .bar.
PASS Detached Element.matches: Invalid combinator: div & address, p
PASS Detached Element.matches: Invalid combinator: div ++ address, p
PASS Detached Element.matches: Invalid combinator: div ~~ address, p
PASS Detached Element.matches: Invalid [att=value] selector: [*=test]
PASS Detached Element.matches: Invalid [att=value] selector: [*|*=test]
PASS Detached Element.matches: Invalid [att=value] selector: [class= space unquoted ]
PASS Detached Element.matches: Unknown pseudo-class: div:example
PASS Detached Element.matches: Unknown pseudo-class: :example
PASS Detached Element.matches: Unknown pseudo-class: div:linkexample
PASS Detached Element.matches: Unknown pseudo-element: div::example
PASS Detached Element.matches: Unknown pseudo-element: ::example
PASS Detached Element.matches: Invalid pseudo-element: :::before
PASS Detached Element.matches: Invalid pseudo-element: :: before
PASS Detached Element.matches: Undeclared namespace: ns|div
PASS Detached Element.matches: Undeclared namespace: :not(ns|div)
PASS Detached Element.matches: Invalid namespace: ^|div
PASS Detached Element.matches: Invalid namespace: $|div
PASS Detached Element.matches: Relative selector: >*
PASS In-document Element.matches: Empty String:
PASS In-document Element.matches: Invalid character: [
PASS In-document Element.matches: Invalid character: ]
PASS In-document Element.matches: Invalid character: (
PASS In-document Element.matches: Invalid character: )
PASS In-document Element.matches: Invalid character: {
PASS In-document Element.matches: Invalid character: }
PASS In-document Element.matches: Invalid character: <
PASS In-document Element.matches: Invalid character: >
PASS In-document Element.matches: Invalid ID: #
PASS In-document Element.matches: Invalid group of selectors: div,
PASS In-document Element.matches: Invalid class: .
PASS In-document Element.matches: Invalid class: .5cm
PASS In-document Element.matches: Invalid class: ..test
PASS In-document Element.matches: Invalid class: .foo..quux
PASS In-document Element.matches: Invalid class: .bar.
PASS In-document Element.matches: Invalid combinator: div & address, p
PASS In-document Element.matches: Invalid combinator: div ++ address, p
PASS In-document Element.matches: Invalid combinator: div ~~ address, p
PASS In-document Element.matches: Invalid [att=value] selector: [*=test]
PASS In-document Element.matches: Invalid [att=value] selector: [*|*=test]
PASS In-document Element.matches: Invalid [att=value] selector: [class= space unquoted ]
PASS In-document Element.matches: Unknown pseudo-class: div:example
PASS In-document Element.matches: Unknown pseudo-class: :example
PASS In-document Element.matches: Unknown pseudo-class: div:linkexample
PASS In-document Element.matches: Unknown pseudo-element: div::example
PASS In-document Element.matches: Unknown pseudo-element: ::example
PASS In-document Element.matches: Invalid pseudo-element: :::before
PASS In-document Element.matches: Invalid pseudo-element: :: before
PASS In-document Element.matches: Undeclared namespace: ns|div
PASS In-document Element.matches: Undeclared namespace: :not(ns|div)
PASS In-document Element.matches: Invalid namespace: ^|div
PASS In-document Element.matches: Invalid namespace: $|div
PASS In-document Element.matches: Relative selector: >*
PASS In-document Element.matches: Type selector, matching html element (with no refNodes): html
PASS In-document Element.matches: Type selector, matching body element (with no refNodes): body
PASS In-document Element.matches: Universal selector, matching all elements (with no refNodes): *
PASS In-document Element.matches: Universal selector, matching all children of element with specified ID (with no refNodes): #universal>*
PASS In-document Element.matches: Universal selector, matching all grandchildren of element with specified ID (with no refNodes): #universal>*>*
PASS In-document Element.matches: Universal selector, matching all descendants of element with specified ID (with no refNodes): #universal *
PASS In-document Element.matches: Attribute presence selector, matching align attribute with value (with no refNodes): .attr-presence-div1[align]
PASS In-document Element.matches: Attribute presence selector, matching align attribute with empty value (with no refNodes): .attr-presence-div2[align]
PASS In-document Element.matches: Attribute presence selector, matching title attribute, case insensitivity (with no refNodes): #attr-presence [*|TiTlE]
PASS In-document Element.matches: Attribute presence selector, matching custom data-* attribute (with no refNodes): [data-attr-presence]
PASS In-document Element.matches: Attribute presence selector, matching attribute with non-ASCII characters (with no refNodes): ul[data-中文]
PASS In-document Element.matches: Attribute presence selector, matching option with selected attribute (with no refNodes): #attr-presence-select2 option[selected]
PASS In-document Element.matches: Attribute presence selector, matching multiple options with selected attributes (with no refNodes): #attr-presence-select3 option[selected]
PASS In-document Element.matches: Attribute value selector, matching align attribute with value (with no refNodes): #attr-value [align="center"]
PASS In-document Element.matches: Attribute value selector, matching align attribute with value, unclosed bracket (with no refNodes): #attr-value [align="center"
PASS In-document Element.matches: Attribute value selector, matching align attribute with empty value (with no refNodes): #attr-value [align=""]
PASS In-document Element.matches: Attribute value selector, matching custom data-* attribute with unicode escaped value (with no refNodes): [data-attr-value="\e9"]
PASS In-document Element.matches: Attribute value selector, matching custom data-* attribute with escaped character (with no refNodes): [data-attr-value_foo="\e9"]
PASS In-document Element.matches: Attribute value selector with single-quoted value, matching multiple inputs with type attributes (with no refNodes): #attr-value input[type='hidden'],#attr-value input[type='radio']
PASS In-document Element.matches: Attribute value selector with double-quoted value, matching multiple inputs with type attributes (with no refNodes): #attr-value input[type="hidden"],#attr-value input[type='radio']
PASS In-document Element.matches: Attribute value selector with unquoted value, matching multiple inputs with type attributes (with no refNodes): #attr-value input[type=hidden],#attr-value input[type=radio]
PASS In-document Element.matches: Attribute value selector, matching attribute with value using non-ASCII characters (with no refNodes): [data-attr-value=中文]
PASS In-document Element.matches: Attribute whitespace-separated list selector, matching class attribute with value (with no refNodes): #attr-whitespace [class~="div1"]
PASS In-document Element.matches: Attribute whitespace-separated list selector, matching custom data-* attribute with unicode escaped value (with no refNodes): [data-attr-whitespace~="\0000e9"]
PASS In-document Element.matches: Attribute whitespace-separated list selector, matching custom data-* attribute with escaped character (with no refNodes): [data-attr-whitespace_foo~="\e9"]
PASS In-document Element.matches: Attribute whitespace-separated list selector with single-quoted value, matching multiple links with rel attributes (with no refNodes): #attr-whitespace a[rel~='bookmark'],  #attr-whitespace a[rel~='nofollow']
PASS In-document Element.matches: Attribute whitespace-separated list selector with double-quoted value, matching multiple links with rel attributes (with no refNodes): #attr-whitespace a[rel~="bookmark"],#attr-whitespace a[rel~='nofollow']
PASS In-document Element.matches: Attribute whitespace-separated list selector with unquoted value, matching multiple links with rel attributes (with no refNodes): #attr-whitespace a[rel~=bookmark],    #attr-whitespace a[rel~=nofollow]
PASS In-document Element.matches: Attribute whitespace-separated list selector, matching title attribute with value using non-ASCII characters (with no refNodes): #attr-whitespace [title~=中文]
PASS In-document Element.matches: Attribute hyphen-separated list selector, matching lang attribute with exact value (with no refNodes): #attr-hyphen-div2[lang|="fr"]
PASS In-document Element.matches: Attribute hyphen-separated list selector, matching lang attribute with partial value (with no refNodes): #attr-hyphen-div3[lang|="en"]
PASS In-document Element.matches: Attribute begins with selector, matching href attributes beginning with specified substring (with no refNodes): #attr-begins a[href^="http://www"]
PASS In-document Element.matches: Attribute begins with selector, matching lang attributes beginning with specified substring,  (with no refNodes): #attr-begins [lang^="en-"]
PASS In-document Element.matches: Attribute begins with selector with single-quoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-begins [class^=' apple']
PASS In-document Element.matches: Attribute begins with selector with double-quoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-begins [class^=" apple"]
PASS In-document Element.matches: Attribute ends with selector, matching href attributes ending with specified substring (with no refNodes): #attr-ends a[href$=".org"]
PASS In-document Element.matches: Attribute ends with selector, matching lang attributes ending with specified substring,  (with no refNodes): #attr-ends [lang$="-CH"]
PASS In-document Element.matches: Attribute ends with selector with single-quoted value, matching class attribute ending with specified substring (with no refNodes): #attr-ends [class$='apple ']
PASS In-document Element.matches: Attribute ends with selector with double-quoted value, matching class attribute ending with specified substring (with no refNodes): #attr-ends [class$="apple "]
PASS In-document Element.matches: Attribute contains selector, matching href attributes beginning with specified substring (with no refNodes): #attr-contains a[href*="http://www"]
PASS In-document Element.matches: Attribute contains selector, matching href attributes ending with specified substring (with no refNodes): #attr-contains a[href*=".org"]
PASS In-document Element.matches: Attribute contains selector, matching href attributes containing specified substring (with no refNodes): #attr-contains a[href*=".example."]
PASS In-document Element.matches: Attribute contains selector, matching lang attributes beginning with specified substring,  (with no refNodes): #attr-contains [lang*="en-"]
PASS In-document Element.matches: Attribute contains selector, matching lang attributes ending with specified substring,  (with no refNodes): #attr-contains [lang*="-CH"]
PASS In-document Element.matches: Attribute contains selector with single-quoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-contains [class*=' apple']
PASS In-document Element.matches: Attribute contains selector with single-quoted value, matching class attribute ending with specified substring (with no refNodes): #attr-contains [class*='orange ']
PASS In-document Element.matches: Attribute contains selector with single-quoted value, matching class attribute containing specified substring (with no refNodes): #attr-contains [class*='ple banana ora']
PASS In-document Element.matches: Attribute contains selector with double-quoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-contains [class*=" apple"]
PASS In-document Element.matches: Attribute contains selector with double-quoted value, matching class attribute ending with specified substring (with no refNodes): #attr-contains [class*="orange "]
PASS In-document Element.matches: Attribute contains selector with double-quoted value, matching class attribute containing specified substring (with no refNodes): #attr-contains [class*="ple banana ora"]
PASS In-document Element.matches: Attribute contains selector with unquoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-contains [class*= apple]
PASS In-document Element.matches: Attribute contains selector with unquoted value, matching class attribute ending with specified substring (with no refNodes): #attr-contains [class*=orange ]
PASS In-document Element.matches: Attribute contains selector with unquoted value, matching class attribute containing specified substring (with no refNodes): #attr-contains [class*= banana ]
PASS In-document Element.matches: :root pseudo-class selector, matching document root element (with no refNodes): :root
PASS In-document Element.matches: :nth-child selector, matching the third child element (with no refNodes): #pseudo-nth-table1 :nth-child(3)
PASS In-document Element.matches: :nth-child selector, matching every third child element (with no refNodes): #pseudo-nth li:nth-child(3n)
PASS In-document Element.matches: :nth-child selector, matching every second child element, starting from the fourth (with no refNodes): #pseudo-nth li:nth-child(2n+4)
PASS In-document Element.matches: :nth-child selector, matching every fourth child element, starting from the third (with no refNodes): #pseudo-nth-p1 :nth-child(4n-1)
PASS In-document Element.matches: :nth-last-child selector, matching the third last child element (with no refNodes): #pseudo-nth-table1 :nth-last-child(3)
PASS In-document Element.matches: :nth-last-child selector, matching every third child element from the end (with no refNodes): #pseudo-nth li:nth-last-child(3n)
PASS In-document Element.matches: :nth-last-child selector, matching every second child element from the end, starting from the fourth last (with no refNodes): #pseudo-nth li:nth-last-child(2n+4)
PASS In-document Element.matches: :nth-last-child selector, matching every fourth element from the end, starting from the third last (with no refNodes): #pseudo-nth-p1 :nth-last-child(4n-1)
PASS In-document Element.matches: :nth-of-type selector, matching the third em element (with no refNodes): #pseudo-nth-p1 em:nth-of-type(3)
PASS In-document Element.matches: :nth-of-type selector, matching every second element of their type (with no refNodes): #pseudo-nth-p1 :nth-of-type(2n)
PASS In-document Element.matches: :nth-of-type selector, matching every second elemetn of their type, starting from the first (with no refNodes): #pseudo-nth-p1 span:nth-of-type(2n-1)
PASS In-document Element.matches: :nth-last-of-type selector, matching the third last em element (with no refNodes): #pseudo-nth-p1 em:nth-last-of-type(3)
PASS In-document Element.matches: :nth-last-of-type selector, matching every second last element of their type (with no refNodes): #pseudo-nth-p1 :nth-last-of-type(2n)
PASS In-document Element.matches: :nth-last-of-type selector, matching every second last element of their type, starting from the last (with no refNodes): #pseudo-nth-p1 span:nth-last-of-type(2n-1)
PASS In-document Element.matches: :first-of-type selector, matching the first em element (with no refNodes): #pseudo-nth-p1 em:first-of-type
PASS In-document Element.matches: :first-of-type selector, matching the first of every type of element (with no refNodes): #pseudo-nth-p1 :first-of-type
PASS In-document Element.matches: :first-of-type selector, matching the first td element in each table row (with no refNodes): #pseudo-nth-table1 tr :first-of-type
PASS In-document Element.matches: :last-of-type selector, matching the last em elemnet (with no refNodes): #pseudo-nth-p1 em:last-of-type
PASS In-document Element.matches: :last-of-type selector, matching the last of every type of element (with no refNodes): #pseudo-nth-p1 :last-of-type
PASS In-document Element.matches: :last-of-type selector, matching the last td element in each table row (with no refNodes): #pseudo-nth-table1 tr :last-of-type
PASS In-document Element.matches: :first-child pseudo-class selector, matching first child div element (with no refNodes): #pseudo-first-child div:first-child
PASS In-document Element.matches: :first-child pseudo-class selector, matching first-child of multiple elements (with no refNodes): #pseudo-first-child span:first-child
PASS In-document Element.matches: :last-child pseudo-class selector, matching last child div element (with no refNodes): #pseudo-last-child div:last-child
PASS In-document Element.matches: :last-child pseudo-class selector, matching first-child of multiple elements (with no refNodes): #pseudo-last-child span:last-child
PASS In-document Element.matches: :pseudo-only-child pseudo-class selector, matching all only-child elements (with no refNodes): #pseudo-only :only-child
PASS In-document Element.matches: :pseudo-only-of-type pseudo-class selector, matching all elements with no siblings of the same type (with no refNodes): #pseudo-only :only-of-type
PASS In-document Element.matches: :pseudo-only-of-type pseudo-class selector, matching em elements with no siblings of the same type (with no refNodes): #pseudo-only em:only-of-type
PASS In-document Element.matches: :empty pseudo-class selector, matching empty p elements (with no refNodes): #pseudo-empty p:empty
PASS In-document Element.matches: :empty pseudo-class selector, matching all empty elements (with no refNodes): #pseudo-empty :empty
PASS In-document Element.matches: :link and :visited pseudo-class selectors, matching a and area elements with href attributes (with no refNodes): #pseudo-link :link, #pseudo-link :visited
PASS In-document Element.matches: :link and :visited pseudo-class selectors, matching link elements with href attributes (with no refNodes): #head :link, #head :visited
PASS In-document Element.matches: :target pseudo-class selector, matching the element referenced by the URL fragment identifier (with no refNodes): :target
PASS In-document Element.matches: :lang pseudo-class selector, matching inherited language (with no refNodes): #pseudo-lang-div1:lang(en)
PASS In-document Element.matches: :lang pseudo-class selector, matching specified language with exact value (with no refNodes): #pseudo-lang-div2:lang(fr)
PASS In-document Element.matches: :lang pseudo-class selector, matching specified language with partial value (with no refNodes): #pseudo-lang-div3:lang(en)
PASS In-document Element.matches: :enabled pseudo-class selector, matching all enabled form controls (with no refNodes): #pseudo-ui :enabled
PASS In-document Element.matches: :enabled pseudo-class selector, not matching link elements (with no refNodes): #pseudo-link :enabled
PASS In-document Element.matches: :disabled pseudo-class selector, matching all disabled form controls (with no refNodes): #pseudo-ui :disabled
PASS In-document Element.matches: :disabled pseudo-class selector, not matching link elements (with no refNodes): #pseudo-link :disabled
PASS In-document Element.matches: :checked pseudo-class selector, matching checked radio buttons and checkboxes (with no refNodes): #pseudo-ui :checked
PASS In-document Element.matches: :not pseudo-class selector, matching  (with no refNodes): #not>:not(div)
PASS In-document Element.matches: :not pseudo-class selector, matching  (with no refNodes): #not * :not(:first-child)
PASS In-document Element.matches: :not pseudo-class selector argument surrounded by spaces, matching  (with no refNodes): #not>:not( div )
PASS In-document Element.matches: Class selector, matching element with specified class (with no refNodes): .class-p
PASS In-document Element.matches: Class selector, chained, matching only elements with all specified classes (with no refNodes): #class .apple.orange.banana
PASS In-document Element.matches: Class Selector, chained, with type selector (with no refNodes): div.apple.banana.orange
PASS In-document Element.matches: Class selector, matching element with class value using non-ASCII characters (1) (with no refNodes): .台北Táiběi
PASS In-document Element.matches: Class selector, matching multiple elements with class value using non-ASCII characters (with no refNodes): .台北
PASS In-document Element.matches: Class selector, chained, matching element with multiple class values using non-ASCII characters (1) (with no refNodes): .台北Táiběi.台北
PASS In-document Element.matches: Class selector, matching element with class with escaped character (with no refNodes): .foo\:bar
PASS In-document Element.matches: Class selector, matching element with class with escaped character (with no refNodes): .test\.foo\[5\]bar
PASS In-document Element.matches: ID selector, matching element with specified id (with no refNodes): #id #id-div1
PASS In-document Element.matches: ID selector, chained, matching element with specified id (with no refNodes): #id-div1, #id-div1
PASS In-document Element.matches: ID selector, chained, matching element with specified id (with no refNodes): #id-div1, #id-div2
PASS In-document Element.matches: ID Selector, chained, with type selector (with no refNodes): div#id-div1, div#id-div2
PASS In-document Element.matches: ID selector, matching multiple elements with duplicate id (with no refNodes): #id-li-duplicate
PASS In-document Element.matches: ID selector, matching id value using non-ASCII characters (1) (with no refNodes): #台北Táiběi
PASS In-document Element.matches: ID selector, matching id value using non-ASCII characters (2) (with no refNodes): #台北
PASS In-document Element.matches: ID selector, matching id values using non-ASCII characters (1) (with no refNodes): #台北Táiběi, #台北
PASS In-document Element.matches: Descendant combinator, matching element that is a descendant of an element with id (with no refNodes): #descendant div
PASS In-document Element.matches: Descendant combinator, matching element with id that is a descendant of an element (with no refNodes): body #descendant-div1
PASS In-document Element.matches: Descendant combinator, matching element with id that is a descendant of an element (with no refNodes): div #descendant-div1
PASS In-document Element.matches: Descendant combinator, matching element with id that is a descendant of an element with id (with no refNodes): #descendant #descendant-div2
PASS In-document Element.matches: Descendant combinator, matching element with class that is a descendant of an element with id (with no refNodes): #descendant .descendant-div2
PASS In-document Element.matches: Descendant combinator, matching element with class that is a descendant of an element with class (with no refNodes): .descendant-div1 .descendant-div3
PASS In-document Element.matches: Descendant combinator, whitespace characters (with no refNodes): #descendant	\r
#descendant-div2
PASS In-document Element.matches: Child combinator, matching element that is a child of an element with id (with no refNodes): #child>div
PASS In-document Element.matches: Child combinator, matching element with id that is a child of an element (with no refNodes): div>#child-div1
PASS In-document Element.matches: Child combinator, matching element with id that is a child of an element with id (with no refNodes): #child>#child-div1
PASS In-document Element.matches: Child combinator, matching element with id that is a child of an element with class (with no refNodes): #child-div1>.child-div2
PASS In-document Element.matches: Child combinator, matching element with class that is a child of an element with class (with no refNodes): .child-div1>.child-div2
PASS In-document Element.matches: Child combinator, surrounded by whitespace (with no refNodes): #child-div1	\r
>	\r
#child-div2
PASS In-document Element.matches: Child combinator, whitespace after (with no refNodes): #child-div1>	\r
#child-div2
PASS In-document Element.matches: Child combinator, whitespace before (with no refNodes): #child-div1	\r
>#child-div2
PASS In-document Element.matches: Child combinator, no whitespace (with no refNodes): #child-div1>#child-div2
PASS In-document Element.matches: Adjacent sibling combinator, matching element that is an adjacent sibling of an element with id (with no refNodes): #adjacent-div2+div
PASS In-document Element.matches: Adjacent sibling combinator, matching element with id that is an adjacent sibling of an element (with no refNodes): div+#adjacent-div4
PASS In-document Element.matches: Adjacent sibling combinator, matching element with id that is an adjacent sibling of an element with id (with no refNodes): #adjacent-div2+#adjacent-div4
PASS In-document Element.matches: Adjacent sibling combinator, matching element with class that is an adjacent sibling of an element with id (with no refNodes): #adjacent-div2+.adjacent-div4
PASS In-document Element.matches: Adjacent sibling combinator, matching element with class that is an adjacent sibling of an element with class (with no refNodes): .adjacent-div2+.adjacent-div4
PASS In-document Element.matches: Adjacent sibling combinator, matching p element that is an adjacent sibling of a div element (with no refNodes): #adjacent div+p
PASS In-document Element.matches: Adjacent sibling combinator, surrounded by whitespace (with no refNodes): #adjacent-p2	\r
+	\r
#adjacent-p3
PASS In-document Element.matches: Adjacent sibling combinator, whitespace after (with no refNodes): #adjacent-p2+	\r
#adjacent-p3
PASS In-document Element.matches: Adjacent sibling combinator, whitespace before (with no refNodes): #adjacent-p2	\r
+#adjacent-p3
PASS In-document Element.matches: Adjacent sibling combinator, no whitespace (with no refNodes): #adjacent-p2+#adjacent-p3
PASS In-document Element.matches: General sibling combinator, matching element that is a sibling of an element with id (with no refNodes): #sibling-div2~div
PASS In-document Element.matches: General sibling combinator, matching element with id that is a sibling of an element (with no refNodes): div~#sibling-div4
PASS In-document Element.matches: General sibling combinator, matching element with id that is a sibling of an element with id (with no refNodes): #sibling-div2~#sibling-div4
PASS In-document Element.matches: General sibling combinator, matching element with class that is a sibling of an element with id (with no refNodes): #sibling-div2~.sibling-div
PASS In-document Element.matches: General sibling combinator, matching p element that is a sibling of a div element (with no refNodes): #sibling div~p
PASS In-document Element.matches: General sibling combinator, surrounded by whitespace (with no refNodes): #sibling-p2	\r
~	\r
#sibling-p3
PASS In-document Element.matches: General sibling combinator, whitespace after (with no refNodes): #sibling-p2~	\r
#sibling-p3
PASS In-document Element.matches: General sibling combinator, whitespace before (with no refNodes): #sibling-p2	\r
~#sibling-p3
PASS In-document Element.matches: General sibling combinator, no whitespace (with no refNodes): #sibling-p2~#sibling-p3
PASS In-document Element.matches: Syntax, group of selectors separator, surrounded by whitespace (with no refNodes): #group em	\r
,	\r
#group strong
PASS In-document Element.matches: Syntax, group of selectors separator, whitespace after (with no refNodes): #group em,	\r
#group strong
PASS In-document Element.matches: Syntax, group of selectors separator, whitespace before (with no refNodes): #group em	\r
,#group strong
PASS In-document Element.matches: Syntax, group of selectors separator, no whitespace (with no refNodes): #group em,#group strong
PASS Detached Element.matches: Universal selector, matching all elements (with no refNodes): *
PASS Detached Element.matches: Universal selector, matching all children of element with specified ID (with no refNodes): #universal>*
PASS Detached Element.matches: Universal selector, matching all grandchildren of element with specified ID (with no refNodes): #universal>*>*
PASS Detached Element.matches: Universal selector, matching all descendants of element with specified ID (with no refNodes): #universal *
PASS Detached Element.matches: Attribute presence selector, matching align attribute with value (with no refNodes): .attr-presence-div1[align]
PASS Detached Element.matches: Attribute presence selector, matching align attribute with empty value (with no refNodes): .attr-presence-div2[align]
PASS Detached Element.matches: Attribute presence selector, matching title attribute, case insensitivity (with no refNodes): #attr-presence [*|TiTlE]
PASS Detached Element.matches: Attribute presence selector, matching custom data-* attribute (with no refNodes): [data-attr-presence]
PASS Detached Element.matches: Attribute presence selector, matching attribute with non-ASCII characters (with no refNodes): ul[data-中文]
PASS Detached Element.matches: Attribute presence selector, matching option with selected attribute (with no refNodes): #attr-presence-select2 option[selected]
PASS Detached Element.matches: Attribute presence selector, matching multiple options with selected attributes (with no refNodes): #attr-presence-select3 option[selected]
PASS Detached Element.matches: Attribute value selector, matching align attribute with value (with no refNodes): #attr-value [align="center"]
PASS Detached Element.matches: Attribute value selector, matching align attribute with value, unclosed bracket (with no refNodes): #attr-value [align="center"
PASS Detached Element.matches: Attribute value selector, matching align attribute with empty value (with no refNodes): #attr-value [align=""]
PASS Detached Element.matches: Attribute value selector, matching custom data-* attribute with unicode escaped value (with no refNodes): [data-attr-value="\e9"]
PASS Detached Element.matches: Attribute value selector, matching custom data-* attribute with escaped character (with no refNodes): [data-attr-value_foo="\e9"]
PASS Detached Element.matches: Attribute value selector with single-quoted value, matching multiple inputs with type attributes (with no refNodes): #attr-value input[type='hidden'],#attr-value input[type='radio']
PASS Detached Element.matches: Attribute value selector with double-quoted value, matching multiple inputs with type attributes (with no refNodes): #attr-value input[type="hidden"],#attr-value input[type='radio']
PASS Detached Element.matches: Attribute value selector with unquoted value, matching multiple inputs with type attributes (with no refNodes): #attr-value input[type=hidden],#attr-value input[type=radio]
PASS Detached Element.matches: Attribute value selector, matching attribute with value using non-ASCII characters (with no refNodes): [data-attr-value=中文]
PASS Detached Element.matches: Attribute whitespace-separated list selector, matching class attribute with value (with no refNodes): #attr-whitespace [class~="div1"]
PASS Detached Element.matches: Attribute whitespace-separated list selector, matching custom data-* attribute with unicode escaped value (with no refNodes): [data-attr-whitespace~="\0000e9"]
PASS Detached Element.matches: Attribute whitespace-separated list selector, matching custom data-* attribute with escaped character (with no refNodes): [data-attr-whitespace_foo~="\e9"]
PASS Detached Element.matches: Attribute whitespace-separated list selector with single-quoted value, matching multiple links with rel attributes (with no refNodes): #attr-whitespace a[rel~='bookmark'],  #attr-whitespace a[rel~='nofollow']
PASS Detached Element.matches: Attribute whitespace-separated list selector with double-quoted value, matching multiple links with rel attributes (with no refNodes): #attr-whitespace a[rel~="bookmark"],#attr-whitespace a[rel~='nofollow']
PASS Detached Element.matches: Attribute whitespace-separated list selector with unquoted value, matching multiple links with rel attributes (with no refNodes): #attr-whitespace a[rel~=bookmark],    #attr-whitespace a[rel~=nofollow]
PASS Detached Element.matches: Attribute whitespace-separated list selector, matching title attribute with value using non-ASCII characters (with no refNodes): #attr-whitespace [title~=中文]
PASS Detached Element.matches: Attribute hyphen-separated list selector, matching lang attribute with exact value (with no refNodes): #attr-hyphen-div2[lang|="fr"]
PASS Detached Element.matches: Attribute hyphen-separated list selector, matching lang attribute with partial value (with no refNodes): #attr-hyphen-div3[lang|="en"]
PASS Detached Element.matches: Attribute begins with selector, matching href attributes beginning with specified substring (with no refNodes): #attr-begins a[href^="http://www"]
PASS Detached Element.matches: Attribute begins with selector, matching lang attributes beginning with specified substring,  (with no refNodes): #attr-begins [lang^="en-"]
PASS Detached Element.matches: Attribute begins with selector with single-quoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-begins [class^=' apple']
PASS Detached Element.matches: Attribute begins with selector with double-quoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-begins [class^=" apple"]
PASS Detached Element.matches: Attribute ends with selector, matching href attributes ending with specified substring (with no refNodes): #attr-ends a[href$=".org"]
PASS Detached Element.matches: Attribute ends with selector, matching lang attributes ending with specified substring,  (with no refNodes): #attr-ends [lang$="-CH"]
PASS Detached Element.matches: Attribute ends with selector with single-quoted value, matching class attribute ending with specified substring (with no refNodes): #attr-ends [class$='apple ']
PASS Detached Element.matches: Attribute ends with selector with double-quoted value, matching class attribute ending with specified substring (with no refNodes): #attr-ends [class$="apple "]
PASS Detached Element.matches: Attribute contains selector, matching href attributes beginning with specified substring (with no refNodes): #attr-contains a[href*="http://www"]
PASS Detached Element.matches: Attribute contains selector, matching href attributes ending with specified substring (with no refNodes): #attr-contains a[href*=".org"]
PASS Detached Element.matches: Attribute contains selector, matching href attributes containing specified substring (with no refNodes): #attr-contains a[href*=".example."]
PASS Detached Element.matches: Attribute contains selector, matching lang attributes beginning with specified substring,  (with no refNodes): #attr-contains [lang*="en-"]
PASS Detached Element.matches: Attribute contains selector, matching lang attributes ending with specified substring,  (with no refNodes): #attr-contains [lang*="-CH"]
PASS Detached Element.matches: Attribute contains selector with single-quoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-contains [class*=' apple']
PASS Detached Element.matches: Attribute contains selector with single-quoted value, matching class attribute ending with specified substring (with no refNodes): #attr-contains [class*='orange ']
PASS Detached Element.matches: Attribute contains selector with single-quoted value, matching class attribute containing specified substring (with no refNodes): #attr-contains [class*='ple banana ora']
PASS Detached Element.matches: Attribute contains selector with double-quoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-contains [class*=" apple"]
PASS Detached Element.matches: Attribute contains selector with double-quoted value, matching class attribute ending with specified substring (with no refNodes): #attr-contains [class*="orange "]
PASS Detached Element.matches: Attribute contains selector with double-quoted value, matching class attribute containing specified substring (with no refNodes): #attr-contains [class*="ple banana ora"]
PASS Detached Element.matches: Attribute contains selector with unquoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-contains [class*= apple]
PASS Detached Element.matches: Attribute contains selector with unquoted value, matching class attribute ending with specified substring (with no refNodes): #attr-contains [class*=orange ]
PASS Detached Element.matches: Attribute contains selector with unquoted value, matching class attribute containing specified substring (with no refNodes): #attr-contains [class*= banana ]
PASS Detached Element.matches: :nth-child selector, matching the third child element (with no refNodes): #pseudo-nth-table1 :nth-child(3)
PASS Detached Element.matches: :nth-child selector, matching every third child element (with no refNodes): #pseudo-nth li:nth-child(3n)
PASS Detached Element.matches: :nth-child selector, matching every second child element, starting from the fourth (with no refNodes): #pseudo-nth li:nth-child(2n+4)
PASS Detached Element.matches: :nth-child selector, matching every fourth child element, starting from the third (with no refNodes): #pseudo-nth-p1 :nth-child(4n-1)
PASS Detached Element.matches: :nth-last-child selector, matching the third last child element (with no refNodes): #pseudo-nth-table1 :nth-last-child(3)
PASS Detached Element.matches: :nth-last-child selector, matching every third child element from the end (with no refNodes): #pseudo-nth li:nth-last-child(3n)
PASS Detached Element.matches: :nth-last-child selector, matching every second child element from the end, starting from the fourth last (with no refNodes): #pseudo-nth li:nth-last-child(2n+4)
PASS Detached Element.matches: :nth-last-child selector, matching every fourth element from the end, starting from the third last (with no refNodes): #pseudo-nth-p1 :nth-last-child(4n-1)
PASS Detached Element.matches: :nth-of-type selector, matching the third em element (with no refNodes): #pseudo-nth-p1 em:nth-of-type(3)
PASS Detached Element.matches: :nth-of-type selector, matching every second element of their type (with no refNodes): #pseudo-nth-p1 :nth-of-type(2n)
PASS Detached Element.matches: :nth-of-type selector, matching every second elemetn of their type, starting from the first (with no refNodes): #pseudo-nth-p1 span:nth-of-type(2n-1)
PASS Detached Element.matches: :nth-last-of-type selector, matching the third last em element (with no refNodes): #pseudo-nth-p1 em:nth-last-of-type(3)
PASS Detached Element.matches: :nth-last-of-type selector, matching every second last element of their type (with no refNodes): #pseudo-nth-p1 :nth-last-of-type(2n)
PASS Detached Element.matches: :nth-last-of-type selector, matching every second last element of their type, starting from the last (with no refNodes): #pseudo-nth-p1 span:nth-last-of-type(2n-1)
PASS Detached Element.matches: :first-of-type selector, matching the first em element (with no refNodes): #pseudo-nth-p1 em:first-of-type
PASS Detached Element.matches: :first-of-type selector, matching the first of every type of element (with no refNodes): #pseudo-nth-p1 :first-of-type
PASS Detached Element.matches: :first-of-type selector, matching the first td element in each table row (with no refNodes): #pseudo-nth-table1 tr :first-of-type
PASS Detached Element.matches: :last-of-type selector, matching the last em elemnet (with no refNodes): #pseudo-nth-p1 em:last-of-type
PASS Detached Element.matches: :last-of-type selector, matching the last of every type of element (with no refNodes): #pseudo-nth-p1 :last-of-type
PASS Detached Element.matches: :last-of-type selector, matching the last td element in each table row (with no refNodes): #pseudo-nth-table1 tr :last-of-type
PASS Detached Element.matches: :first-child pseudo-class selector, matching first child div element (with no refNodes): #pseudo-first-child div:first-child
PASS Detached Element.matches: :first-child pseudo-class selector, matching first-child of multiple elements (with no refNodes): #pseudo-first-child span:first-child
PASS Detached Element.matches: :last-child pseudo-class selector, matching last child div element (with no refNodes): #pseudo-last-child div:last-child
PASS Detached Element.matches: :last-child pseudo-class selector, matching first-child of multiple elements (with no refNodes): #pseudo-last-child span:last-child
PASS Detached Element.matches: :pseudo-only-child pseudo-class selector, matching all only-child elements (with no refNodes): #pseudo-only :only-child
PASS Detached Element.matches: :pseudo-only-of-type pseudo-class selector, matching all elements with no siblings of the same type (with no refNodes): #pseudo-only :only-of-type
PASS Detached Element.matches: :pseudo-only-of-type pseudo-class selector, matching em elements with no siblings of the same type (with no refNodes): #pseudo-only em:only-of-type
PASS Detached Element.matches: :empty pseudo-class selector, matching empty p elements (with no refNodes): #pseudo-empty p:empty
PASS Detached Element.matches: :empty pseudo-class selector, matching all empty elements (with no refNodes): #pseudo-empty :empty
PASS Detached Element.matches: :link and :visited pseudo-class selectors, matching a and area elements with href attributes (with no refNodes): #pseudo-link :link, #pseudo-link :visited
PASS Detached Element.matches: :lang pseudo-class selector, matching specified language with exact value (with no refNodes): #pseudo-lang-div2:lang(fr)
PASS Detached Element.matches: :lang pseudo-class selector, matching specified language with partial value (with no refNodes): #pseudo-lang-div3:lang(en)
PASS Detached Element.matches: :enabled pseudo-class selector, matching all enabled form controls (with no refNodes): #pseudo-ui :enabled
PASS Detached Element.matches: :enabled pseudo-class selector, not matching link elements (with no refNodes): #pseudo-link :enabled
PASS Detached Element.matches: :disabled pseudo-class selector, matching all disabled form controls (with no refNodes): #pseudo-ui :disabled
PASS Detached Element.matches: :disabled pseudo-class selector, not matching link elements (with no refNodes): #pseudo-link :disabled
PASS Detached Element.matches: :checked pseudo-class selector, matching checked radio buttons and checkboxes (with no refNodes): #pseudo-ui :checked
PASS Detached Element.matches: :not pseudo-class selector, matching  (with no refNodes): #not>:not(div)
PASS Detached Element.matches: :not pseudo-class selector, matching  (with no refNodes): #not * :not(:first-child)
PASS Detached Element.matches: :not pseudo-class selector argument surrounded by spaces, matching  (with no refNodes): #not>:not( div )
PASS Detached Element.matches: Class selector, matching element with specified class (with no refNodes): .class-p
PASS Detached Element.matches: Class selector, chained, matching only elements with all specified classes (with no refNodes): #class .apple.orange.banana
PASS Detached Element.matches: Class Selector, chained, with type selector (with no refNodes): div.apple.banana.orange
PASS Detached Element.matches: Class selector, matching element with class value using non-ASCII characters (1) (with no refNodes): .台北Táiběi
PASS Detached Element.matches: Class selector, matching multiple elements with class value using non-ASCII characters (with no refNodes): .台北
PASS Detached Element.matches: Class selector, chained, matching element with multiple class values using non-ASCII characters (1) (with no refNodes): .台北Táiběi.台北
PASS Detached Element.matches: Class selector, matching element with class with escaped character (with no refNodes): .foo\:bar
PASS Detached Element.matches: Class selector, matching element with class with escaped character (with no refNodes): .test\.foo\[5\]bar
PASS Detached Element.matches: ID selector, matching element with specified id (with no refNodes): #id #id-div1
PASS Detached Element.matches: ID selector, chained, matching element with specified id (with no refNodes): #id-div1, #id-div1
PASS Detached Element.matches: ID selector, chained, matching element with specified id (with no refNodes): #id-div1, #id-div2
PASS Detached Element.matches: ID Selector, chained, with type selector (with no refNodes): div#id-div1, div#id-div2
PASS Detached Element.matches: ID selector, matching multiple elements with duplicate id (with no refNodes): #id-li-duplicate
PASS Detached Element.matches: ID selector, matching id value using non-ASCII characters (1) (with no refNodes): #台北Táiběi
PASS Detached Element.matches: ID selector, matching id value using non-ASCII characters (2) (with no refNodes): #台北
PASS Detached Element.matches: ID selector, matching id values using non-ASCII characters (1) (with no refNodes): #台北Táiběi, #台北
PASS Detached Element.matches: Descendant combinator, matching element that is a descendant of an element with id (with no refNodes): #descendant div
PASS Detached Element.matches: Descendant combinator, matching element with id that is a descendant of an element (with no refNodes): div #descendant-div1
PASS Detached Element.matches: Descendant combinator, matching element with id that is a descendant of an element with id (with no refNodes): #descendant #descendant-div2
PASS Detached Element.matches: Descendant combinator, matching element with class that is a descendant of an element with id (with no refNodes): #descendant .descendant-div2
PASS Detached Element.matches: Descendant combinator, matching element with class that is a descendant of an element with class (with no refNodes): .descendant-div1 .descendant-div3
PASS Detached Element.matches: Descendant combinator, whitespace characters (with no refNodes): #descendant	\r
#descendant-div2
PASS Detached Element.matches: Child combinator, matching element that is a child of an element with id (with no refNodes): #child>div
PASS Detached Element.matches: Child combinator, matching element with id that is a child of an element (with no refNodes): div>#child-div1
PASS Detached Element.matches: Child combinator, matching element with id that is a child of an element with id (with no refNodes): #child>#child-div1
PASS Detached Element.matches: Child combinator, matching element with id that is a child of an element with class (with no refNodes): #child-div1>.child-div2
PASS Detached Element.matches: Child combinator, matching element with class that is a child of an element with class (with no refNodes): .child-div1>.child-div2
PASS Detached Element.matches: Child combinator, surrounded by whitespace (with no refNodes): #child-div1	\r
>	\r
#child-div2
PASS Detached Element.matches: Child combinator, whitespace after (with no refNodes): #child-div1>	\r
#child-div2
PASS Detached Element.matches: Child combinator, whitespace before (with no refNodes): #child-div1	\r
>#child-div2
PASS Detached Element.matches: Child combinator, no whitespace (with no refNodes): #child-div1>#child-div2
PASS Detached Element.matches: Adjacent sibling combinator, matching element that is an adjacent sibling of an element with id (with no refNodes): #adjacent-div2+div
PASS Detached Element.matches: Adjacent sibling combinator, matching element with id that is an adjacent sibling of an element (with no refNodes): div+#adjacent-div4
PASS Detached Element.matches: Adjacent sibling combinator, matching element with id that is an adjacent sibling of an element with id (with no refNodes): #adjacent-div2+#adjacent-div4
PASS Detached Element.matches: Adjacent sibling combinator, matching element with class that is an adjacent sibling of an element with id (with no refNodes): #adjacent-div2+.adjacent-div4
PASS Detached Element.matches: Adjacent sibling combinator, matching element with class that is an adjacent sibling of an element with class (with no refNodes): .adjacent-div2+.adjacent-div4
PASS Detached Element.matches: Adjacent sibling combinator, matching p element that is an adjacent sibling of a div element (with no refNodes): #adjacent div+p
PASS Detached Element.matches: Adjacent sibling combinator, surrounded by whitespace (with no refNodes): #adjacent-p2	\r
+	\r
#adjacent-p3
PASS Detached Element.matches: Adjacent sibling combinator, whitespace after (with no refNodes): #adjacent-p2+	\r
#adjacent-p3
PASS Detached Element.matches: Adjacent sibling combinator, whitespace before (with no refNodes): #adjacent-p2	\r
+#adjacent-p3
PASS Detached Element.matches: Adjacent sibling combinator, no whitespace (with no refNodes): #adjacent-p2+#adjacent-p3
PASS Detached Element.matches: General sibling combinator, matching element that is a sibling of an element with id (with no refNodes): #sibling-div2~div
PASS Detached Element.matches: General sibling combinator, matching element with id that is a sibling of an element (with no refNodes): div~#sibling-div4
PASS Detached Element.matches: General sibling combinator, matching element with id that is a sibling of an element with id (with no refNodes): #sibling-div2~#sibling-div4
PASS Detached Element.matches: General sibling combinator, matching element with class that is a sibling of an element with id (with no refNodes): #sibling-div2~.sibling-div
PASS Detached Element.matches: General sibling combinator, matching p element that is a sibling of a div element (with no refNodes): #sibling div~p
PASS Detached Element.matches: General sibling combinator, surrounded by whitespace (with no refNodes): #sibling-p2	\r
~	\r
#sibling-p3
PASS Detached Element.matches: General sibling combinator, whitespace after (with no refNodes): #sibling-p2~	\r
#sibling-p3
PASS Detached Element.matches: General sibling combinator, whitespace before (with no refNodes): #sibling-p2	\r
~#sibling-p3
PASS Detached Element.matches: General sibling combinator, no whitespace (with no refNodes): #sibling-p2~#sibling-p3
PASS Detached Element.matches: Syntax, group of selectors separator, surrounded by whitespace (with no refNodes): #group em	\r
,	\r
#group strong
PASS Detached Element.matches: Syntax, group of selectors separator, whitespace after (with no refNodes): #group em,	\r
#group strong
PASS Detached Element.matches: Syntax, group of selectors separator, whitespace before (with no refNodes): #group em	\r
,#group strong
PASS Detached Element.matches: Syntax, group of selectors separator, no whitespace (with no refNodes): #group em,#group strong
PASS Fragment Element.matches: Universal selector, matching all elements (with no refNodes): *
PASS Fragment Element.matches: Universal selector, matching all children of element with specified ID (with no refNodes): #universal>*
PASS Fragment Element.matches: Universal selector, matching all grandchildren of element with specified ID (with no refNodes): #universal>*>*
PASS Fragment Element.matches: Universal selector, matching all descendants of element with specified ID (with no refNodes): #universal *
PASS Fragment Element.matches: Attribute presence selector, matching align attribute with value (with no refNodes): .attr-presence-div1[align]
PASS Fragment Element.matches: Attribute presence selector, matching align attribute with empty value (with no refNodes): .attr-presence-div2[align]
PASS Fragment Element.matches: Attribute presence selector, matching title attribute, case insensitivity (with no refNodes): #attr-presence [*|TiTlE]
PASS Fragment Element.matches: Attribute presence selector, matching custom data-* attribute (with no refNodes): [data-attr-presence]
PASS Fragment Element.matches: Attribute presence selector, matching attribute with non-ASCII characters (with no refNodes): ul[data-中文]
PASS Fragment Element.matches: Attribute presence selector, matching option with selected attribute (with no refNodes): #attr-presence-select2 option[selected]
PASS Fragment Element.matches: Attribute presence selector, matching multiple options with selected attributes (with no refNodes): #attr-presence-select3 option[selected]
PASS Fragment Element.matches: Attribute value selector, matching align attribute with value (with no refNodes): #attr-value [align="center"]
PASS Fragment Element.matches: Attribute value selector, matching align attribute with value, unclosed bracket (with no refNodes): #attr-value [align="center"
PASS Fragment Element.matches: Attribute value selector, matching align attribute with empty value (with no refNodes): #attr-value [align=""]
PASS Fragment Element.matches: Attribute value selector, matching custom data-* attribute with unicode escaped value (with no refNodes): [data-attr-value="\e9"]
PASS Fragment Element.matches: Attribute value selector, matching custom data-* attribute with escaped character (with no refNodes): [data-attr-value_foo="\e9"]
PASS Fragment Element.matches: Attribute value selector with single-quoted value, matching multiple inputs with type attributes (with no refNodes): #attr-value input[type='hidden'],#attr-value input[type='radio']
PASS Fragment Element.matches: Attribute value selector with double-quoted value, matching multiple inputs with type attributes (with no refNodes): #attr-value input[type="hidden"],#attr-value input[type='radio']
PASS Fragment Element.matches: Attribute value selector with unquoted value, matching multiple inputs with type attributes (with no refNodes): #attr-value input[type=hidden],#attr-value input[type=radio]
PASS Fragment Element.matches: Attribute value selector, matching attribute with value using non-ASCII characters (with no refNodes): [data-attr-value=中文]
PASS Fragment Element.matches: Attribute whitespace-separated list selector, matching class attribute with value (with no refNodes): #attr-whitespace [class~="div1"]
PASS Fragment Element.matches: Attribute whitespace-separated list selector, matching custom data-* attribute with unicode escaped value (with no refNodes): [data-attr-whitespace~="\0000e9"]
PASS Fragment Element.matches: Attribute whitespace-separated list selector, matching custom data-* attribute with escaped character (with no refNodes): [data-attr-whitespace_foo~="\e9"]
PASS Fragment Element.matches: Attribute whitespace-separated list selector with single-quoted value, matching multiple links with rel attributes (with no refNodes): #attr-whitespace a[rel~='bookmark'],  #attr-whitespace a[rel~='nofollow']
PASS Fragment Element.matches: Attribute whitespace-separated list selector with double-quoted value, matching multiple links with rel attributes (with no refNodes): #attr-whitespace a[rel~="bookmark"],#attr-whitespace a[rel~='nofollow']
PASS Fragment Element.matches: Attribute whitespace-separated list selector with unquoted value, matching multiple links with rel attributes (with no refNodes): #attr-whitespace a[rel~=bookmark],    #attr-whitespace a[rel~=nofollow]
PASS Fragment Element.matches: Attribute whitespace-separated list selector, matching title attribute with value using non-ASCII characters (with no refNodes): #attr-whitespace [title~=中文]
PASS Fragment Element.matches: Attribute hyphen-separated list selector, matching lang attribute with exact value (with no refNodes): #attr-hyphen-div2[lang|="fr"]
PASS Fragment Element.matches: Attribute hyphen-separated list selector, matching lang attribute with partial value (with no refNodes): #attr-hyphen-div3[lang|="en"]
PASS Fragment Element.matches: Attribute begins with selector, matching href attributes beginning with specified substring (with no refNodes): #attr-begins a[href^="http://www"]
PASS Fragment Element.matches: Attribute begins with selector, matching lang attributes beginning with specified substring,  (with no refNodes): #attr-begins [lang^="en-"]
PASS Fragment Element.matches: Attribute begins with selector with single-quoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-begins [class^=' apple']
PASS Fragment Element.matches: Attribute begins with selector with double-quoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-begins [class^=" apple"]
PASS Fragment Element.matches: Attribute ends with selector, matching href attributes ending with specified substring (with no refNodes): #attr-ends a[href$=".org"]
PASS Fragment Element.matches: Attribute ends with selector, matching lang attributes ending with specified substring,  (with no refNodes): #attr-ends [lang$="-CH"]
PASS Fragment Element.matches: Attribute ends with selector with single-quoted value, matching class attribute ending with specified substring (with no refNodes): #attr-ends [class$='apple ']
PASS Fragment Element.matches: Attribute ends with selector with double-quoted value, matching class attribute ending with specified substring (with no refNodes): #attr-ends [class$="apple "]
PASS Fragment Element.matches: Attribute contains selector, matching href attributes beginning with specified substring (with no refNodes): #attr-contains a[href*="http://www"]
PASS Fragment Element.matches: Attribute contains selector, matching href attributes ending with specified substring (with no refNodes): #attr-contains a[href*=".org"]
PASS Fragment Element.matches: Attribute contains selector, matching href attributes containing specified substring (with no refNodes): #attr-contains a[href*=".example."]
PASS Fragment Element.matches: Attribute contains selector, matching lang attributes beginning with specified substring,  (with no refNodes): #attr-contains [lang*="en-"]
PASS Fragment Element.matches: Attribute contains selector, matching lang attributes ending with specified substring,  (with no refNodes): #attr-contains [lang*="-CH"]
PASS Fragment Element.matches: Attribute contains selector with single-quoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-contains [class*=' apple']
PASS Fragment Element.matches: Attribute contains selector with single-quoted value, matching class attribute ending with specified substring (with no refNodes): #attr-contains [class*='orange ']
PASS Fragment Element.matches: Attribute contains selector with single-quoted value, matching class attribute containing specified substring (with no refNodes): #attr-contains [class*='ple banana ora']
PASS Fragment Element.matches: Attribute contains selector with double-quoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-contains [class*=" apple"]
PASS Fragment Element.matches: Attribute contains selector with double-quoted value, matching class attribute ending with specified substring (with no refNodes): #attr-contains [class*="orange "]
PASS Fragment Element.matches: Attribute contains selector with double-quoted value, matching class attribute containing specified substring (with no refNodes): #attr-contains [class*="ple banana ora"]
PASS Fragment Element.matches: Attribute contains selector with unquoted value, matching class attribute beginning with specified substring (with no refNodes): #attr-contains [class*= apple]
PASS Fragment Element.matches: Attribute contains selector with unquoted value, matching class attribute ending with specified substring (with no refNodes): #attr-contains [class*=orange ]
PASS Fragment Element.matches: Attribute contains selector with unquoted value, matching class attribute containing specified substring (with no refNodes): #attr-contains [class*= banana ]
PASS Fragment Element.matches: :nth-child selector, matching the third child element (with no refNodes): #pseudo-nth-table1 :nth-child(3)
PASS Fragment Element.matches: :nth-child selector, matching every third child element (with no refNodes): #pseudo-nth li:nth-child(3n)
PASS Fragment Element.matches: :nth-child selector, matching every second child element, starting from the fourth (with no refNodes): #pseudo-nth li:nth-child(2n+4)
PASS Fragment Element.matches: :nth-child selector, matching every fourth child element, starting from the third (with no refNodes): #pseudo-nth-p1 :nth-child(4n-1)
PASS Fragment Element.matches: :nth-last-child selector, matching the third last child element (with no refNodes): #pseudo-nth-table1 :nth-last-child(3)
PASS Fragment Element.matches: :nth-last-child selector, matching every third child element from the end (with no refNodes): #pseudo-nth li:nth-last-child(3n)
PASS Fragment Element.matches: :nth-last-child selector, matching every second child element from the end, starting from the fourth last (with no refNodes): #pseudo-nth li:nth-last-child(2n+4)
PASS Fragment Element.matches: :nth-last-child selector, matching every fourth element from the end, starting from the third last (with no refNodes): #pseudo-nth-p1 :nth-last-child(4n-1)
PASS Fragment Element.matches: :nth-of-type selector, matching the third em element (with no refNodes): #pseudo-nth-p1 em:nth-of-type(3)
PASS Fragment Element.matches: :nth-of-type selector, matching every second element of their type (with no refNodes): #pseudo-nth-p1 :nth-of-type(2n)
PASS Fragment Element.matches: :nth-of-type selector, matching every second elemetn of their type, starting from the first (with no refNodes): #pseudo-nth-p1 span:nth-of-type(2n-1)
PASS Fragment Element.matches: :nth-last-of-type selector, matching the third last em element (with no refNodes): #pseudo-nth-p1 em:nth-last-of-type(3)
PASS Fragment Element.matches: :nth-last-of-type selector, matching every second last element of their type (with no refNodes): #pseudo-nth-p1 :nth-last-of-type(2n)
PASS Fragment Element.matches: :nth-last-of-type selector, matching every second last element of their type, starting from the last (with no refNodes): #pseudo-nth-p1 span:nth-last-of-type(2n-1)
PASS Fragment Element.matches: :first-of-type selector, matching the first em element (with no refNodes): #pseudo-nth-p1 em:first-of-type
PASS Fragment Element.matches: :first-of-type selector, matching the first of every type of element (with no refNodes): #pseudo-nth-p1 :first-of-type
PASS Fragment Element.matches: :first-of-type selector, matching the first td element in each table row (with no refNodes): #pseudo-nth-table1 tr :first-of-type
PASS Fragment Element.matches: :last-of-type selector, matching the last em elemnet (with no refNodes): #pseudo-nth-p1 em:last-of-type
PASS Fragment Element.matches: :last-of-type selector, matching the last of every type of element (with no refNodes): #pseudo-nth-p1 :last-of-type
PASS Fragment Element.matches: :last-of-type selector, matching the last td element in each table row (with no refNodes): #pseudo-nth-table1 tr :last-of-type
PASS Fragment Element.matches: :first-child pseudo-class selector, matching first child div element (with no refNodes): #pseudo-first-child div:first-child
PASS Fragment Element.matches: :first-child pseudo-class selector, matching first-child of multiple elements (with no refNodes): #pseudo-first-child span:first-child
PASS Fragment Element.matches: :last-child pseudo-class selector, matching last child div element (with no refNodes): #pseudo-last-child div:last-child
PASS Fragment Element.matches: :last-child pseudo-class selector, matching first-child of multiple elements (with no refNodes): #pseudo-last-child span:last-child
PASS Fragment Element.matches: :pseudo-only-child pseudo-class selector, matching all only-child elements (with no refNodes): #pseudo-only :only-child
PASS Fragment Element.matches: :pseudo-only-of-type pseudo-class selector, matching all elements with no siblings of the same type (with no refNodes): #pseudo-only :only-of-type
PASS Fragment Element.matches: :pseudo-only-of-type pseudo-class selector, matching em elements with no siblings of the same type (with no refNodes): #pseudo-only em:only-of-type
PASS Fragment Element.matches: :empty pseudo-class selector, matching empty p elements (with no refNodes): #pseudo-empty p:empty
PASS Fragment Element.matches: :empty pseudo-class selector, matching all empty elements (with no refNodes): #pseudo-empty :empty
PASS Fragment Element.matches: :link and :visited pseudo-class selectors, matching a and area elements with href attributes (with no refNodes): #pseudo-link :link, #pseudo-link :visited
PASS Fragment Element.matches: :lang pseudo-class selector, matching specified language with exact value (with no refNodes): #pseudo-lang-div2:lang(fr)
PASS Fragment Element.matches: :lang pseudo-class selector, matching specified language with partial value (with no refNodes): #pseudo-lang-div3:lang(en)
PASS Fragment Element.matches: :enabled pseudo-class selector, matching all enabled form controls (with no refNodes): #pseudo-ui :enabled
PASS Fragment Element.matches: :enabled pseudo-class selector, not matching link elements (with no refNodes): #pseudo-link :enabled
PASS Fragment Element.matches: :disabled pseudo-class selector, matching all disabled form controls (with no refNodes): #pseudo-ui :disabled
PASS Fragment Element.matches: :disabled pseudo-class selector, not matching link elements (with no refNodes): #pseudo-link :disabled
PASS Fragment Element.matches: :checked pseudo-class selector, matching checked radio buttons and checkboxes (with no refNodes): #pseudo-ui :checked
PASS Fragment Element.matches: :not pseudo-class selector, matching  (with no refNodes): #not>:not(div)
PASS Fragment Element.matches: :not pseudo-class selector, matching  (with no refNodes): #not * :not(:first-child)
PASS Fragment Element.matches: :not pseudo-class selector argument surrounded by spaces, matching  (with no refNodes): #not>:not( div )
PASS Fragment Element.matches: Class selector, matching element with specified class (with no refNodes): .class-p
PASS Fragment Element.matches: Class selector, chained, matching only elements with all specified classes (with no refNodes): #class .apple.orange.banana
PASS Fragment Element.matches: Class Selector, chained, with type selector (with no refNodes): div.apple.banana.orange
PASS Fragment Element.matches: Class selector, matching element with class value using non-ASCII characters (1) (with no refNodes): .台北Táiběi
PASS Fragment Element.matches: Class selector, matching multiple elements with class value using non-ASCII characters (with no refNodes): .台北
PASS Fragment Element.matches: Class selector, chained, matching element with multiple class values using non-ASCII characters (1) (with no refNodes): .台北Táiběi.台北
PASS Fragment Element.matches: Class selector, matching element with class with escaped character (with no refNodes): .foo\:bar
PASS Fragment Element.matches: Class selector, matching element with class with escaped character (with no refNodes): .test\.foo\[5\]bar
PASS Fragment Element.matches: ID selector, matching element with specified id (with no refNodes): #id #id-div1
PASS Fragment Element.matches: ID selector, chained, matching element with specified id (with no refNodes): #id-div1, #id-div1
PASS Fragment Element.matches: ID selector, chained, matching element with specified id (with no refNodes): #id-div1, #id-div2
PASS Fragment Element.matches: ID Selector, chained, with type selector (with no refNodes): div#id-div1, div#id-div2
PASS Fragment Element.matches: ID selector, matching multiple elements with duplicate id (with no refNodes): #id-li-duplicate
PASS Fragment Element.matches: ID selector, matching id value using non-ASCII characters (1) (with no refNodes): #台北Táiběi
PASS Fragment Element.matches: ID selector, matching id value using non-ASCII characters (2) (with no refNodes): #台北
PASS Fragment Element.matches: ID selector, matching id values using non-ASCII characters (1) (with no refNodes): #台北Táiběi, #台北
PASS Fragment Element.matches: Descendant combinator, matching element that is a descendant of an element with id (with no refNodes): #descendant div
PASS Fragment Element.matches: Descendant combinator, matching element with id that is a descendant of an element (with no refNodes): div #descendant-div1
PASS Fragment Element.matches: Descendant combinator, matching element with id that is a descendant of an element with id (with no refNodes): #descendant #descendant-div2
PASS Fragment Element.matches: Descendant combinator, matching element with class that is a descendant of an element with id (with no refNodes): #descendant .descendant-div2
PASS Fragment Element.matches: Descendant combinator, matching element with class that is a descendant of an element with class (with no refNodes): .descendant-div1 .descendant-div3
PASS Fragment Element.matches: Descendant combinator, whitespace characters (with no refNodes): #descendant	\r
#descendant-div2
PASS Fragment Element.matches: Child combinator, matching element that is a child of an element with id (with no refNodes): #child>div
PASS Fragment Element.matches: Child combinator, matching element with id that is a child of an element (with no refNodes): div>#child-div1
PASS Fragment Element.matches: Child combinator, matching element with id that is a child of an element with id (with no refNodes): #child>#child-div1
PASS Fragment Element.matches: Child combinator, matching element with id that is a child of an element with class (with no refNodes): #child-div1>.child-div2
PASS Fragment Element.matches: Child combinator, matching element with class that is a child of an element with class (with no refNodes): .child-div1>.child-div2
PASS Fragment Element.matches: Child combinator, surrounded by whitespace (with no refNodes): #child-div1	\r
>	\r
#child-div2
PASS Fragment Element.matches: Child combinator, whitespace after (with no refNodes): #child-div1>	\r
#child-div2
PASS Fragment Element.matches: Child combinator, whitespace before (with no refNodes): #child-div1	\r
>#child-div2
PASS Fragment Element.matches: Child combinator, no whitespace (with no refNodes): #child-div1>#child-div2
PASS Fragment Element.matches: Adjacent sibling combinator, matching element that is an adjacent sibling of an element with id (with no refNodes): #adjacent-div2+div
PASS Fragment Element.matches: Adjacent sibling combinator, matching element with id that is an adjacent sibling of an element (with no refNodes): div+#adjacent-div4
PASS Fragment Element.matches: Adjacent sibling combinator, matching element with id that is an adjacent sibling of an element with id (with no refNodes): #adjacent-div2+#adjacent-div4
PASS Fragment Element.matches: Adjacent sibling combinator, matching element with class that is an adjacent sibling of an element with id (with no refNodes): #adjacent-div2+.adjacent-div4
PASS Fragment Element.matches: Adjacent sibling combinator, matching element with class that is an adjacent sibling of an element with class (with no refNodes): .adjacent-div2+.adjacent-div4
PASS Fragment Element.matches: Adjacent sibling combinator, matching p element that is an adjacent sibling of a div element (with no refNodes): #adjacent div+p
PASS Fragment Element.matches: Adjacent sibling combinator, surrounded by whitespace (with no refNodes): #adjacent-p2	\r
+	\r
#adjacent-p3
PASS Fragment Element.matches: Adjacent sibling combinator, whitespace after (with no refNodes): #adjacent-p2+	\r
#adjacent-p3
PASS Fragment Element.matches: Adjacent sibling combinator, whitespace before (with no refNodes): #adjacent-p2	\r
+#adjacent-p3
PASS Fragment Element.matches: Adjacent sibling combinator, no whitespace (with no refNodes): #adjacent-p2+#adjacent-p3
PASS Fragment Element.matches: General sibling combinator, matching element that is a sibling of an element with id (with no refNodes): #sibling-div2~div
PASS Fragment Element.matches: General sibling combinator, matching element with id that is a sibling of an element (with no refNodes): div~#sibling-div4
PASS Fragment Element.matches: General sibling combinator, matching element with id that is a sibling of an element with id (with no refNodes): #sibling-div2~#sibling-div4
PASS Fragment Element.matches: General sibling combinator, matching element with class that is a sibling of an element with id (with no refNodes): #sibling-div2~.sibling-div
PASS Fragment Element.matches: General sibling combinator, matching p element that is a sibling of a div element (with no refNodes): #sibling div~p
PASS Fragment Element.matches: General sibling combinator, surrounded by whitespace (with no refNodes): #sibling-p2	\r
~	\r
#sibling-p3
PASS Fragment Element.matches: General sibling combinator, whitespace after (with no refNodes): #sibling-p2~	\r
#sibling-p3
PASS Fragment Element.matches: General sibling combinator, whitespace before (with no refNodes): #sibling-p2	\r
~#sibling-p3
PASS Fragment Element.matches: General sibling combinator, no whitespace (with no refNodes): #sibling-p2~#sibling-p3
PASS Fragment Element.matches: Syntax, group of selectors separator, surrounded by whitespace (with no refNodes): #group em	\r
,	\r
#group strong
PASS Fragment Element.matches: Syntax, group of selectors separator, whitespace after (with no refNodes): #group em,	\r
#group strong
PASS Fragment Element.matches: Syntax, group of selectors separator, whitespace before (with no refNodes): #group em	\r
,#group strong
PASS Fragment Element.matches: Syntax, group of selectors separator, no whitespace (with no refNodes): #group em,#group strong
PASS In-document Element.matches: Attribute presence selector, matching align attribute with value (with refNode Element): .attr-presence-div1[align]
PASS In-document Element.matches: Attribute presence selector, matching align attribute with empty value (with refNode Element): .attr-presence-div2[align]
PASS In-document Element.matches: Attribute presence selector, matching title attribute, case insensitivity (with refNode Element): [TiTlE]
PASS In-document Element.matches: Attribute presence selector, matching custom data-* attribute (with refNode Element): [data-attr-presence]
PASS In-document Element.matches: Attribute presence selector, matching attribute with non-ASCII characters (with refNode Element): ul[data-中文]
PASS In-document Element.matches: Attribute presence selector, matching option with selected attribute (with refNode Element): #attr-presence-select2 option[selected]
PASS In-document Element.matches: Attribute presence selector, matching multiple options with selected attributes (with refNode Element): #attr-presence-select3 option[selected]
PASS In-document Element.matches: Attribute value selector, matching align attribute with value (with refNode Element): [align="center"]
PASS In-document Element.matches: Attribute value selector, matching align attribute with empty value (with refNode Element): [align=""]
PASS In-document Element.matches: Attribute value selector, matching custom data-* attribute with unicode escaped value (with refNode Element): [data-attr-value="\e9"]
PASS In-document Element.matches: Attribute value selector, matching custom data-* attribute with escaped character (with refNode Element): [data-attr-value_foo="\e9"]
PASS In-document Element.matches: Attribute value selector with single-quoted value, matching multiple inputs with type attributes (with refNode Element): input[type='hidden'],#attr-value input[type='radio']
PASS In-document Element.matches: Attribute value selector with double-quoted value, matching multiple inputs with type attributes (with refNode Element): input[type="hidden"],#attr-value input[type='radio']
PASS In-document Element.matches: Attribute value selector with unquoted value, matching multiple inputs with type attributes (with refNode Element): input[type=hidden],#attr-value input[type=radio]
PASS In-document Element.matches: Attribute value selector, matching attribute with value using non-ASCII characters (with refNode Element): [data-attr-value=中文]
PASS In-document Element.matches: Attribute whitespace-separated list selector, matching class attribute with value (with refNode Element): [class~="div1"]
PASS In-document Element.matches: Attribute whitespace-separated list selector, matching custom data-* attribute with unicode escaped value (with refNode Element): [data-attr-whitespace~="\0000e9"]
PASS In-document Element.matches: Attribute whitespace-separated list selector, matching custom data-* attribute with escaped character (with refNode Element): [data-attr-whitespace_foo~="\e9"]
PASS In-document Element.matches: Attribute whitespace-separated list selector with single-quoted value, matching multiple links with rel attributes (with refNode Element): a[rel~='bookmark'],  #attr-whitespace a[rel~='nofollow']
PASS In-document Element.matches: Attribute whitespace-separated list selector with double-quoted value, matching multiple links with rel attributes (with refNode Element): a[rel~="bookmark"],#attr-whitespace a[rel~='nofollow']
PASS In-document Element.matches: Attribute whitespace-separated list selector with unquoted value, matching multiple links with rel attributes (with refNode Element): a[rel~=bookmark],    #attr-whitespace a[rel~=nofollow]
PASS In-document Element.matches: Attribute whitespace-separated list selector, matching title attribute with value using non-ASCII characters (with refNode Element): [title~=中文]
PASS In-document Element.matches: Attribute hyphen-separated list selector, matching lang attribute with exact value (with refNode Element): #attr-hyphen-div2[lang|="fr"]
PASS In-document Element.matches: Attribute hyphen-separated list selector, matching lang attribute with partial value (with refNode Element): #attr-hyphen-div3[lang|="en"]
PASS In-document Element.matches: Attribute begins with selector, matching href attributes beginning with specified substring (with refNode Element): a[href^="http://www"]
PASS In-document Element.matches: Attribute begins with selector, matching lang attributes beginning with specified substring,  (with refNode Element): [lang^="en-"]
PASS In-document Element.matches: Attribute begins with selector with single-quoted value, matching class attribute beginning with specified substring (with refNode Element): [class^=' apple']
PASS In-document Element.matches: Attribute begins with selector with double-quoted value, matching class attribute beginning with specified substring (with refNode Element): [class^=" apple"]
PASS In-document Element.matches: Attribute ends with selector, matching href attributes ending with specified substring (with refNode Element): a[href$=".org"]
PASS In-document Element.matches: Attribute ends with selector, matching lang attributes ending with specified substring,  (with refNode Element): [lang$="-CH"]
PASS In-document Element.matches: Attribute ends with selector with single-quoted value, matching class attribute ending with specified substring (with refNode Element): [class$='apple ']
PASS In-document Element.matches: Attribute ends with selector with double-quoted value, matching class attribute ending with specified substring (with refNode Element): [class$="apple "]
PASS In-document Element.matches: Attribute contains selector, matching href attributes beginning with specified substring (with refNode Element): a[href*="http://www"]
PASS In-document Element.matches: Attribute contains selector, matching href attributes ending with specified substring (with refNode Element): a[href*=".org"]
PASS In-document Element.matches: Attribute contains selector, matching href attributes containing specified substring (with refNode Element): a[href*=".example."]
PASS In-document Element.matches: Attribute contains selector, matching lang attributes beginning with specified substring,  (with refNode Element): [lang*="en-"]
PASS In-document Element.matches: Attribute contains selector, matching lang attributes ending with specified substring,  (with refNode Element): [lang*="-CH"]
PASS In-document Element.matches: Attribute contains selector with single-quoted value, matching class attribute beginning with specified substring (with refNode Element): [class*=' apple']
PASS In-document Element.matches: Attribute contains selector with single-quoted value, matching class attribute ending with specified substring (with refNode Element): [class*='orange ']
PASS In-document Element.matches: Attribute contains selector with single-quoted value, matching class attribute containing specified substring (with refNode Element): [class*='ple banana ora']
PASS In-document Element.matches: Attribute contains selector with double-quoted value, matching class attribute beginning with specified substring (with refNode Element): [class*=" apple"]
PASS In-document Element.matches: Attribute contains selector with double-quoted value, matching class attribute ending with specified substring (with refNode Element): [class*="orange "]
PASS In-document Element.matches: Attribute contains selector with double-quoted value, matching class attribute containing specified substring (with refNode Element): [class*="ple banana ora"]
PASS In-document Element.matches: Attribute contains selector with unquoted value, matching class attribute beginning with specified substring (with refNode Element): [class*= apple]
PASS In-document Element.matches: Attribute contains selector with unquoted value, matching class attribute ending with specified substring (with refNode Element): [class*=orange ]
PASS In-document Element.matches: Attribute contains selector with unquoted value, matching class attribute containing specified substring (with refNode Element): [class*= banana ]
PASS In-document Element.matches: :nth-child selector, matching the third child element (with refNode Element): :nth-child(3)
PASS In-document Element.matches: :nth-child selector, matching every third child element (with refNode Element): li:nth-child(3n)
PASS In-document Element.matches: :nth-child selector, matching every second child element, starting from the fourth (with refNode Element): li:nth-child(2n+4)
PASS In-document Element.matches: :nth-child selector, matching every second child element, starting from the fourth, with whitespace (with refNode Element): li:nth-child(2n 	\r
+ 	\r
4)
PASS In-document Element.matches: :nth-child selector, matching every fourth child element, starting from the third (with refNode Element): :nth-child(4n-1)
PASS In-document Element.matches: :nth-child selector, matching every fourth child element, starting from the third, with whitespace (with refNode Element): :nth-child(4n 	\r
- 	\r
1)
PASS In-document Element.matches: :nth-child selector used twice, matching  (with refNode Element): :nth-child(1) :nth-child(1)
PASS In-document Element.matches: :nth-last-child selector, matching the third last child element (with refNode Element): :nth-last-child(3)
PASS In-document Element.matches: :nth-last-child selector, matching every third child element from the end (with refNode Element): li:nth-last-child(3n)
PASS In-document Element.matches: :nth-last-child selector, matching every second child element from the end, starting from the fourth last (with refNode Element): li:nth-last-child(2n+4)
PASS In-document Element.matches: :nth-last-child selector, matching every fourth element from the end, starting from the third last (with refNode Element): :nth-last-child(4n-1)
PASS In-document Element.matches: :nth-of-type selector, matching the third em element (with refNode Element): em:nth-of-type(3)
PASS In-document Element.matches: :nth-of-type selector, matching every second element of their type (with refNode Element): :nth-of-type(2n)
PASS In-document Element.matches: :nth-of-type selector, matching every second elemetn of their type, starting from the first (with refNode Element): span:nth-of-type(2n-1)
PASS In-document Element.matches: :nth-last-of-type selector, matching the third last em element (with refNode Element): em:nth-last-of-type(3)
PASS In-document Element.matches: :nth-last-of-type selector, matching every second last element of their type (with refNode Element): :nth-last-of-type(2n)
PASS In-document Element.matches: :nth-last-of-type selector, matching every second last element of their type, starting from the last (with refNode Element): span:nth-last-of-type(2n-1)
PASS In-document Element.matches: :first-of-type selector, matching the first em element (with refNode Element): em:first-of-type
PASS In-document Element.matches: :first-of-type selector, matching the first of every type of element (with refNode Element): :first-of-type
PASS In-document Element.matches: :first-of-type selector, matching the first td element in each table row (with refNode Element): tr :first-of-type
PASS In-document Element.matches: :last-of-type selector, matching the last em elemnet (with refNode Element): em:last-of-type
PASS In-document Element.matches: :last-of-type selector, matching the last of every type of element (with refNode Element): :last-of-type
PASS In-document Element.matches: :last-of-type selector, matching the last td element in each table row (with refNode Element): tr :last-of-type
PASS In-document Element.matches: :first-child pseudo-class selector, matching first child div element (with refNode Element): div:first-child
PASS In-document Element.matches: :first-child pseudo-class selector, matching first-child of multiple elements (with refNode Element): span:first-child
PASS In-document Element.matches: :last-child pseudo-class selector, matching last child div element (with refNode Element): div:last-child
PASS In-document Element.matches: :last-child pseudo-class selector, matching first-child of multiple elements (with refNode Element): span:last-child
PASS In-document Element.matches: :pseudo-only-child pseudo-class selector, matching all only-child elements (with refNode Element): :only-child
PASS In-document Element.matches: :pseudo-only-of-type pseudo-class selector, matching all elements with no siblings of the same type (with refNode Element):  :only-of-type
PASS In-document Element.matches: :pseudo-only-of-type pseudo-class selector, matching em elements with no siblings of the same type (with refNode Element):  em:only-of-type
PASS In-document Element.matches: :empty pseudo-class selector, matching empty p elements (with refNode Element): p:empty
PASS In-document Element.matches: :empty pseudo-class selector, matching all empty elements (with refNode Element): :empty
PASS In-document Element.matches: :link and :visited pseudo-class selectors, matching a and area elements with href attributes (with refNode Element):  :link, #pseudo-link :visited
PASS In-document Element.matches: :link and :visited pseudo-class selectors, matching link elements with href attributes (with refNode Element):  :link, #head :visited
PASS In-document Element.matches: :lang pseudo-class selector, matching inherited language (1) (with no refNodes): #pseudo-lang-div1:lang(en)
PASS In-document Element.matches: :lang pseudo-class selector, matching specified language with exact value (1) (with no refNodes): #pseudo-lang-div2:lang(fr)
PASS In-document Element.matches: :lang pseudo-class selector, matching specified language with partial value (1) (with no refNodes): #pseudo-lang-div3:lang(en)
PASS In-document Element.matches: :enabled pseudo-class selector, matching all enabled form controls (1) (with no refNodes): #pseudo-ui :enabled
PASS In-document Element.matches: :enabled pseudo-class selector, not matching link elements (1) (with no refNodes): #pseudo-link :enabled
PASS In-document Element.matches: :disabled pseudo-class selector, matching all disabled form controls (1) (with no refNodes): #pseudo-ui :disabled
PASS In-document Element.matches: :disabled pseudo-class selector, not matching link elements (1) (with no refNodes): #pseudo-link :disabled
PASS In-document Element.matches: :checked pseudo-class selector, matching checked radio buttons and checkboxes (1) (with no refNodes): #pseudo-ui :checked
PASS In-document Element.matches: :not pseudo-class selector, matching (1) (with no refNodes): #not>:not(div)
PASS In-document Element.matches: :not pseudo-class selector, matching (1) (with no refNodes): #not * :not(:first-child)
PASS In-document Element.matches: Class selector, matching element with specified class (1) (with no refNodes): .class-p
PASS In-document Element.matches: Class selector, chained, matching only elements with all specified classes (1) (with no refNodes): #class .apple.orange.banana
PASS In-document Element.matches: Class Selector, chained, with type selector (1) (with no refNodes): div.apple.banana.orange
PASS In-document Element.matches: Class selector, matching element with class value using non-ASCII characters (2) (with no refNodes): .台北Táiběi
PASS In-document Element.matches: Class selector, matching multiple elements with class value using non-ASCII characters (1) (with no refNodes): .台北
PASS In-document Element.matches: Class selector, chained, matching element with multiple class values using non-ASCII characters (2) (with no refNodes): .台北Táiběi.台北
PASS In-document Element.matches: Class selector, matching element with class with escaped character (1) (with no refNodes): .foo\:bar
PASS In-document Element.matches: Class selector, matching element with class with escaped character (1) (with no refNodes): .test\.foo\[5\]bar
PASS In-document Element.matches: ID selector, matching element with specified id (1) (with no refNodes): #id #id-div1
PASS In-document Element.matches: ID selector, chained, matching element with specified id (1) (with no refNodes): #id-div1, #id-div1
PASS In-document Element.matches: ID selector, chained, matching element with specified id (1) (with no refNodes): #id-div1, #id-div2
PASS In-document Element.matches: ID Selector, chained, with type selector (1) (with no refNodes): div#id-div1, div#id-div2
PASS In-document Element.matches: ID selector, matching multiple elements with duplicate id (1) (with no refNodes): #id-li-duplicate
PASS In-document Element.matches: ID selector, matching id value using non-ASCII characters (3) (with no refNodes): #台北Táiběi
PASS In-document Element.matches: ID selector, matching id value using non-ASCII characters (4) (with no refNodes): #台北
PASS In-document Element.matches: ID selector, matching id values using non-ASCII characters (2) (with no refNodes): #台北Táiběi, #台北
PASS In-document Element.matches: Descendant combinator, matching element that is a descendant of an element with id (1) (with no refNodes): #descendant div
PASS In-document Element.matches: Descendant combinator, matching element with id that is a descendant of an element (1) (with no refNodes): body #descendant-div1
PASS In-document Element.matches: Descendant combinator, matching element with id that is a descendant of an element (1) (with no refNodes): div #descendant-div1
PASS In-document Element.matches: Descendant combinator, matching element with id that is a descendant of an element with id (1) (with no refNodes): #descendant #descendant-div2
PASS In-document Element.matches: Descendant combinator, matching element with class that is a descendant of an element with id (1) (with no refNodes): #descendant .descendant-div2
PASS In-document Element.matches: Descendant combinator, matching element with class that is a descendant of an element with class (1) (with no refNodes): .descendant-div1 .descendant-div3
PASS In-document Element.matches: Descendant combinator, whitespace characters (1) (with no refNodes): #descendant	\r
#descendant-div2
PASS In-document Element.matches: Child combinator, matching element that is a child of an element with id (1) (with no refNodes): #child>div
PASS In-document Element.matches: Child combinator, matching element with id that is a child of an element (1) (with no refNodes): div>#child-div1
PASS In-document Element.matches: Child combinator, matching element with id that is a child of an element with id (1) (with no refNodes): #child>#child-div1
PASS In-document Element.matches: Child combinator, matching element with id that is a child of an element with class (1) (with no refNodes): #child-div1>.child-div2
PASS In-document Element.matches: Child combinator, matching element with class that is a child of an element with class (1) (with no refNodes): .child-div1>.child-div2
PASS In-document Element.matches: Child combinator, surrounded by whitespace (1) (with no refNodes): #child-div1	\r
>	\r
#child-div2
PASS In-document Element.matches: Child combinator, whitespace after (1) (with no refNodes): #child-div1>	\r
#child-div2
PASS In-document Element.matches: Child combinator, whitespace before (1) (with no refNodes): #child-div1	\r
>#child-div2
PASS In-document Element.matches: Child combinator, no whitespace (1) (with no refNodes): #child-div1>#child-div2
PASS In-document Element.matches: Adjacent sibling combinator, matching element that is an adjacent sibling of an element with id (1) (with no refNodes): #adjacent-div2+div
PASS In-document Element.matches: Adjacent sibling combinator, matching element with id that is an adjacent sibling of an element (1) (with no refNodes): div+#adjacent-div4
PASS In-document Element.matches: Adjacent sibling combinator, matching element with id that is an adjacent sibling of an element with id (1) (with no refNodes): #adjacent-div2+#adjacent-div4
PASS In-document Element.matches: Adjacent sibling combinator, matching element with class that is an adjacent sibling of an element with id (1) (with no refNodes): #adjacent-div2+.adjacent-div4
PASS In-document Element.matches: Adjacent sibling combinator, matching element with class that is an adjacent sibling of an element with class (1) (with no refNodes): .adjacent-div2+.adjacent-div4
PASS In-document Element.matches: Adjacent sibling combinator, matching p element that is an adjacent sibling of a div element (1) (with no refNodes): #adjacent div+p
PASS In-document Element.matches: Adjacent sibling combinator, surrounded by whitespace (1) (with no refNodes): #adjacent-p2	\r
+	\r
#adjacent-p3
PASS In-document Element.matches: Adjacent sibling combinator, whitespace after (1) (with no refNodes): #adjacent-p2+	\r
#adjacent-p3
PASS In-document Element.matches: Adjacent sibling combinator, whitespace before (1) (with no refNodes): #adjacent-p2	\r
+#adjacent-p3
PASS In-document Element.matches: Adjacent sibling combinator, no whitespace (1) (with no refNodes): #adjacent-p2+#adjacent-p3
PASS In-document Element.matches: General sibling combinator, matching element that is a sibling of an element with id (1) (with no refNodes): #sibling-div2~div
PASS In-document Element.matches: General sibling combinator, matching element with id that is a sibling of an element (1) (with no refNodes): div~#sibling-div4
PASS In-document Element.matches: General sibling combinator, matching element with id that is a sibling of an element with id (1) (with no refNodes): #sibling-div2~#sibling-div4
PASS In-document Element.matches: General sibling combinator, matching element with class that is a sibling of an element with id (1) (with no refNodes): #sibling-div2~.sibling-div
PASS In-document Element.matches: General sibling combinator, matching p element that is a sibling of a div element (1) (with no refNodes): #sibling div~p
PASS In-document Element.matches: General sibling combinator, surrounded by whitespace (1) (with no refNodes): #sibling-p2	\r
~	\r
#sibling-p3
PASS In-document Element.matches: General sibling combinator, whitespace after (1) (with no refNodes): #sibling-p2~	\r
#sibling-p3
PASS In-document Element.matches: General sibling combinator, whitespace before (1) (with no refNodes): #sibling-p2	\r
~#sibling-p3
PASS In-document Element.matches: General sibling combinator, no whitespace (1) (with no refNodes): #sibling-p2~#sibling-p3
PASS In-document Element.matches: Syntax, group of selectors separator, surrounded by whitespace (1) (with no refNodes): #group em	\r
,	\r
#group strong
PASS In-document Element.matches: Syntax, group of selectors separator, whitespace after (1) (with no refNodes): #group em,	\r
#group strong
PASS In-document Element.matches: Syntax, group of selectors separator, whitespace before (1) (with no refNodes): #group em	\r
,#group strong
PASS In-document Element.matches: Syntax, group of selectors separator, no whitespace (1) (with no refNodes): #group em,#group strong

