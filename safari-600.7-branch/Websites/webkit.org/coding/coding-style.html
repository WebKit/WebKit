<?php 
    $title="WebKit Coding Style Guidelines";
    
    $extra_head_content = <<<END
<style type="text/css">
pre .code {
   background-color: #F2F2F2;
}

.right {
  color: #080 !important;
}

.wrong {
  color: #f00 !important;
}

.idbutton {
  color: #888;
  font-size: smaller;
  cursor: pointer;
}
</style>


END;

    include("../header.inc"); 
?>

<h2>WebKit Coding Style Guidelines</h2>
<h3 id="indentation">Indentation</h3>

<ol>
<li id="indentation-no-tabs"> Use spaces, not tabs. Tabs should only appear in files that require them for semantic meaning, like Makefiles.
</li>
<li id="indentation-4-spaces"> The indent size is 4 spaces.
<h4 class="right">Right:</h4>
<pre class="code">
int main()
{
    return 0;
}
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
int main() 
{
        return 0;
}
</pre>
</li>
<li id="indentation-namespace">The contents of an outermost <code>namespace</code> block (and any nested namespaces with the same scope)
should not be indented. The contents of other nested namespaces should be indented.
<h4 class="right">Right:</h4>
<pre class="code">
// Document.h
namespace WebCore {

class Document {
    Document();
    ...
};

namespace NestedNamespace {
    ...
}

} // namespace WebCore

// Document.cpp
namespace WebCore {

Document::Document()
{
    ...
}

} // namespace WebCore
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
// Document.h
namespace WebCore {

    class Document {
        Document();
        ...
    };

    namespace NestedNamespace {
    ...
    }

} // namespace WebCore

// Document.cpp
namespace WebCore {

    Document::Document()
    {
        ...
    }

} // namespace WebCore
</pre>
</li>

<li id="indentation-case-label">A case label should line up with its switch statement.  The case statement is indented.
<h4 class="right">Right:</h4>
<pre class="code">
switch (condition) {
case fooCondition:
case barCondition:
    i++;
    break;
default:
    i--;
}
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
switch (condition) {
    case fooCondition:
    case barCondition:
        i++;
        break;
    default:
        i--;
}
</pre>
</li>

<li id="indentation-wrap-bool-op">Boolean expressions at the same nesting level that span multiple lines should
have their operators on the left side of the line instead of the right side.

<h4 class="right">Right:</h4>
<pre class="code">
return attribute.name() == srcAttr
    || attribute.name() == lowsrcAttr
    || (attribute.name() == usemapAttr &amp;&amp; attribute.value().string()[0] != '#');
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
return attribute.name() == srcAttr ||
    attribute.name() == lowsrcAttr ||
    (attribute.name() == usemapAttr &amp;&amp; attr->value().string()[0] != '#');
</pre>
</li>

</ol>

<h3 id="spacing">Spacing</h3>
<ol>
<li id="spacing-unary-op">Do not place spaces around unary operators.
<h4 class="right">Right:</h4>
<pre class="code">
i++;
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
i ++;
</pre>
</li>

<li id="spacing-binary-ternary-op"><em>Do</em> place spaces around binary and ternary operators.
<h4 class="right">Right:</h4>
<pre class="code">
y = m * x + b;
f(a, b);
c = a | b;
return condition ? 1 : 0;
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
y=m*x+b;
f(a,b);
c = a|b;
return condition ? 1:0;
</pre>
</li>

<li id="spacing-for-colon">Place spaces around the colon in a range-based for loop.
<h4 class="right">Right:</h4>
<pre class="code">
Vector&lt;PluginModuleInfo> plugins;
for (auto&amp; plugin : plugins)
    registerPlugin(plugin);
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
Vector&lt;PluginModuleInfo> plugins;
for (auto&amp; plugin: plugins)
    registerPlugin(plugin);
</pre>
</li>

<li id="spacing-comma-semicolon">Do not place spaces before comma and semicolon.
<h4 class="right">Right:</h4>
<pre class="code">
for (int i = 0; i &lt; 10; ++i)
    doSomething();

f(a, b);
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
for (int i = 0 ; i &lt; 10 ; ++i)
    doSomething();

f(a , b) ;
</pre>
</li>

<li id="spacing-control-paren">Place spaces between control statements and their parentheses.
<h4 class="right">Right:</h4>
<pre class="code">
if (condition)
    doIt();
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
if(condition)
    doIt();
</pre>
</li>

<li id="spacing-function-paren">Do not place spaces between a function and its parentheses, or between a parenthesis and its content.
<h4 class="right">Right:</h4>
<pre class="code">
f(a, b);
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
f (a, b);
f( a, b );
</pre>
</li>
</ol>

<h3 id="linebreaking">Line breaking</h3>
<ol>
<li id="linebreaking-multiple-statements">Each statement should get its own line.
<h4 class="right">Right:</h4>
<pre class="code">
x++;
y++;
if (condition)
    doIt();
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
x++; y++;
if (condition) doIt();
</pre>
</li>

<li id="linebreaking-else-braces">An <code>else</code> statement should go on the same line as a preceding close brace if one is present,
else it should line up with the <code>if</code> statement.
<h4 class="right">Right:</h4>
<pre class="code">
if (condition) {
    ...
} else {
    ...
}

if (condition)
    doSomething();
else
    doSomethingElse();

if (condition)
    doSomething();
else {
    ...
}
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
if (condition) {
    ...
}
else {
    ...
}

if (condition) doSomething(); else doSomethingElse();

if (condition) doSomething(); else {
    ...
}
</pre>
</li>

<li id="linebreaking-else-if">An <code>else if</code> statement should be written as an <code>if</code> statement when the prior <code>if</code> concludes with a <code>return</code> statement.
<h4 class="right">Right:</h4>
<pre class="code">
if (condition) {
    ...
    return someValue;
}
if (condition) {
    ...
}
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
if (condition) {
    ...
    return someValue;
} else if (condition) {
    ...
}
</pre>
</li>
</ol>

<h3 id="braces">Braces</h3>
<ol>
<li id="braces-function"> Function definitions: place each brace on its own line.

<h4 class="right">Right:</h4>
<pre class="code">
int main()
{
    ...
}
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
int main() {
    ...
}
</pre>
</li>
<li id="braces-blocks"> Other braces: place the open brace on the line preceding the code block; place the close brace on its own line.

<h4 class="right">Right:</h4>
<pre class="code">
class MyClass {
    ...
};

namespace WebCore {
    ...
}

for (int i = 0; i &lt; 10; ++i) {
    ...
}
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
class MyClass 
{
    ...
};
</pre>
<li id="braces-one-line">One-line control clauses should not use braces unless comments are included
or a single statement spans multiple lines.
<h4 class="right">Right:</h4>
<pre class="code">
if (condition)
    doIt();

if (condition) {
    // Some comment
    doIt();
}

if (condition) {
    myFunction(reallyLongParam1, reallyLongParam2, ...
        reallyLongParam5);
}
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
if (condition) {
    doIt();
}

if (condition)
    // Some comment
    doIt();

if (condition)
    myFunction(reallyLongParam1, reallyLongParam2, ...
        reallyLongParam5);
</pre>
</li>

<li id="braces-empty-block">Control clauses without a body should use empty braces:
<h4 class="right">Right:</h4>
<pre class="code">
for ( ; current; current = current->next) { }
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
for ( ; current; current = current->next);
</pre>
</li>
</ol>

<h3 id="zero">Null, false and zero</h3>
<ol>
<li id="zero-null">In C++, the null pointer value should be written as <code>nullptr</code>. In C, it should be written as <code>NULL</code>. In Objective-C and Objective-C++, follow the guideline for C or C++, respectively, but use <code>nil</code> to represent a null Objective-C object.</li>

<li id="zero-bool">C++ and C <code>bool</code> values should be written as <code>true</code> and <code>false</code>. Objective-C <code>BOOL</code> values should be written as <code>YES</code> and <code>NO</code>.</li>

<li id="zero-comparison">Tests for true/false, null/non-null, and zero/non-zero should all be done without equality comparisons.<br>

<h4 class="right">Right:</h4>
<pre class="code">
if (condition)
    doIt();
    
if (!ptr)
    return;

if (!count)
    return;
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
if (condition == true)
    doIt();
    
if (ptr == NULL)
    return;
    
if (count == 0)
    return;
</pre>
</li>

<li id="zero-objc-variables">In Objective-C, instance variables are initialized to zero automatically. Don't add explicit initializations to nil or NO in an init method.</li>
</ol>

<h3 id="float">Floating point literals</h3>
<ol>
<li id="float-suffixes">Unless required in order to force floating point math, do not append
<code>.0</code>, <code>.f</code> and <code>.0f</code> to floating point
literals.

<h4 class="right">Right:</h4>
<pre class="code">
const double duration = 60;

void setDiameter(float diameter)
{
    radius = diameter / 2;
}

setDiameter(10);

const int framesPerSecond = 12;
double frameDuration = 1.0 / framesPerSecond;
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
const double duration = 60.0;

void setDiameter(float diameter)
{
    radius = diameter / 2.f;
}

setDiameter(10.f);

const int framesPerSecond = 12;
double frameDuration = 1 / framesPerSecond; // integer division
</pre>
</li>
</ol>

<h3 id="names">Names</h3>
<ol>
<li id="names-basic">Use CamelCase. Capitalize the first letter, including all letters in an acronym, in a class, struct, protocol, or namespace name. Lower-case the first letter, including all letters in an acronym, in a variable or function name.
<h4 class="right">Right:</h4>
<pre class="code">
struct Data;
size_t bufferSize;
class HTMLDocument;
String mimeType();
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
struct data;
size_t buffer_size;
class HtmlDocument;
String MIMEType();
</pre>
</li>

<li id="names-full-words">Use full words, except in the rare case where an abbreviation would be more canonical and easier to understand.
<h4 class="right">Right:</h4>
<pre class="code">
size_t characterSize;
size_t length;
short tabIndex; // more canonical
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
size_t charSize;
size_t len;
short tabulationIndex; // bizarre
</pre>
</li>

<li id="names-data-members">Data members in C++ classes should be private.  Static data members should be prefixed by "s_".  Other data members should be prefixed by "m_".
<h4 class="right">Right:</h4>
<pre class="code">
class String {
public:
    ...

private:
    short m_length;
};
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
class String {
public:
    ...

    short length;
};
</pre>
</li>

<li id="names-objc-instance-variables">Prefix Objective-C instance variables with "_".
<h4 class="right">Right:</h4>
<pre class="code">
@class String
    ...
    short _length;
@end
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
@class String
    ...
    short length;
@end
</pre>
</li>

<li id="names-bool">Precede boolean values with words like "is" and "did".
<h4 class="right">Right:</h4>
<pre class="code">
bool isValid;
bool didSendData;
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
bool valid;
bool sentData;
</pre>
</li>

<li id="names-setter-getter">Precede setters with the word "set". Use bare words for getters. Setter and getter names should match the names of the variables being set/gotten.
<h4 class="right">Right:</h4>
<pre class="code">
void setCount(size_t); // sets m_count
size_t count(); // returns m_count
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
void setCount(size_t); // sets m_theCount
size_t getCount();
</pre>
</li>

<li id="names-out-argument">Precede getters that return values through out arguments with the word "get".
<h4 class="right">Right:</h4>
<pre class="code">
void getInlineBoxAndOffset(InlineBox*&amp;, int&amp; caretOffset) const;
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
void inlineBoxAndOffset(InlineBox*&amp;, int&amp; caretOffset) const;
</pre>
</li>

<li id="names-verb">Use descriptive verbs in function names.
<h4 class="right">Right:</h4>
<pre class="code">
bool convertToASCII(short*, size_t);
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
bool toASCII(short*, size_t);
</pre>
</li>

<li id="names-variable-name-in-function-decl">Leave meaningless variable names out of function declarations. A good rule of thumb is if the parameter type name contains the parameter name (without trailing numbers or pluralization), then the parameter name isn't needed.  Usually, there should be a parameter name for bools, strings, and numerical types.
<h4 class="right">Right:</h4>
<pre class="code">
void setCount(size_t);

void doSomething(ScriptExecutionContext*);
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
void setCount(size_t count);

void doSomething(ScriptExecutionContext* context);
</pre>
</li>

<li id="names-enum-to-bool">Prefer enums to bools on function parameters if callers are likely to be
passing constants, since named constants are easier to read at the call
site.  An exception to this rule is a setter function, where the name of the
function already makes clear what the boolean is.
<h4 class="right">Right:</h4>
<pre class="code">
doSomething(something, AllowFooBar);
paintTextWithShadows(context, ..., textStrokeWidth > 0, isHorizontal());
setResizable(false);
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
doSomething(something, false);
setResizable(NotResizable);
</pre>
</li>

<li id="names-objc-methods">Objective-C method names should follow the Cocoa naming guidelines &mdash;
they should read like a phrase and each piece of the selector should 
start with a lowercase letter and use intercaps.</li>

<li id="names-enum-members">Enum members should use InterCaps with an initial capital letter.</li>

<li id="names-const-to-define">Prefer const to #define. Prefer inline functions to macros.</li>

<li id="names-define-constants">#defined constants should use all uppercase names with words separated by underscores.</li>

<li id="names-define-non-const"> Macros that expand to function calls or other non-constant computation: these
should be named like functions, and should have parentheses at the end, even if 
they take no arguments (with the exception of some special macros like ASSERT). 
Note that usually it is preferable to use an inline function in such cases instead of a macro.<br>

<h4 class="right">Right:</h4>
<pre class="code">
#define WBStopButtonTitle() \
        NSLocalizedString(@"Stop", @"Stop button title")
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
#define WB_STOP_BUTTON_TITLE \
        NSLocalizedString(@"Stop", @"Stop button title")

#define WBStopButtontitle \
        NSLocalizedString(@"Stop", @"Stop button title")
</pre>
</li>

<li id="names-header-guards">#define, #ifdef "header guards" should be named exactly the same as the file (including case), replacing the '.' with a '_'.
<h4 class="right">Right:</h4>
<pre class="code">
// HTMLDocument.h
#ifndef HTMLDocument_h
#define HTMLDocument_h
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
// HTMLDocument.h
#ifndef _HTML_DOCUMENT_H_
#define _HTML_DOCUMENT_H_
</pre>
</li>
</ol>

<h3 id="punctuation">Other Punctuation</h3>

<ol>

<li id="punctuation-member-init">Constructors for C++ classes should initialize all of their members using C++ 
initializer syntax.  Each member (and superclass) should be indented on a separate 
line, with the colon or comma preceding the member on that line.

<h4 class="right">Right:</h4>
<pre class="code">
MyClass::MyClass(Document* document)
    : MySuperClass()
    , m_myMember(0)
    , m_document(document)
{
}

MyOtherClass::MyOtherClass()
    : MySuperClass()
{
}
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
MyClass::MyClass(Document* document) : MySuperClass()
{
    m_myMember = 0;
    m_document = document;
}

MyOtherClass::MyOtherClass() : MySuperClass() {}
</pre>

<li id="punctuation-vector-index">Prefer index over iterator in Vector iterations for terse, easier-to-read code.

<h4 class="right">Right:</h4>
<pre class="code">
for (auto&amp; frameView : frameViews)
    frameView->updateLayoutAndStyleIfNeededRecursive();
</pre>

<h4 class="right">OK:</h4>
<pre class="code">
unsigned frameViewsCount = frameViews.size();
for (unsigned i = 0; i &lt; frameViewsCount; ++i)
    frameViews[i]->updateLayoutAndStyleIfNeededRecursive();
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
const Vector&lt;RefPtr&lt;FrameView&gt; &gt;::iterator end = frameViews.end();
for (Vector&lt;RefPtr&lt;FrameView&gt; &gt;::iterator it = frameViews.begin(); it != end; ++it)
    (*it)-&gt;updateLayoutAndStyleIfNeededRecursive();
</pre>
</ol>

<h3 id="pointers">Pointers and References</h3>

<ol>

<li id="pointers-non-cpp">Pointer types in non-C++ code &mdash; Pointer types should be written with a space between the
type and the * (so the * is adjacent to the following identifier if any).

<li id="pointers-cpp">Pointer and reference types in C++ code &mdash; Both pointer types and reference types
should be written with no space between the type name and the * or &amp;.

<h4 class="right">Right:</h4>
<pre class="code">
Image* SVGStyledElement::doSomething(PaintInfo&amp; paintInfo)
{
    SVGStyledElement* element = static_cast&lt;SVGStyledElement*>(node());
    const KCDashArray&amp; dashes = dashArray();
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
Image *SVGStyledElement::doSomething(PaintInfo &amp;paintInfo)
{
    SVGStyledElement *element = static_cast&lt;SVGStyledElement *>(node());
    const KCDashArray &amp;dashes = dashArray();
</pre>

<li id="pointers-out-argument">An out argument of a function should be passed by reference except rare cases where
it is optional in which case it should be passed by pointer.

<h4 class="right">Right:</h4>
<pre class="code">
void MyClass::getSomeValue(OutArgumentType&amp; outArgument) const
{
    outArgument = m_value;
}

void MyClass::doSomething(OutArgumentType* outArgument) const
{
    doSomething();
    if (outArgument)
        *outArgument = m_value;
}
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
void MyClass::getSomeValue(OutArgumentType* outArgument) const
{
    *outArgument = m_value;
}
</pre>

</ol>

<h3 id="include">#include Statements</h3>

<ol>

<li id="include-config-h">All implementation files must #include "config.h" first. Header
files should never include "config.h".

<h4 class="right">Right:</h4>
<pre class="code">
// RenderLayer.h
#include "Node.h"
#include "RenderObject.h"
#include "RenderView.h"
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
// RenderLayer.h
#include "config.h"

#include "RenderObject.h"
#include "RenderView.h"
#include "Node.h"
</pre>

<li id="include-primary">All implementation files must #include the primary header second,
just after "config.h". So for example, Node.cpp should include Node.h first,
before other files. This guarantees that each header's completeness is tested.
This also assures that each header can be compiled without requiring any other
header files be included first.

<li id="include-others">Other #include statements should be in sorted order (case sensitive, as
done by the command-line sort tool or the Xcode sort selection command).
Don't bother to organize them in a logical order.

<h4 class="right">Right:</h4>
<pre class="code">
// HTMLDivElement.cpp
#include "config.h"
#include "HTMLDivElement.h"

#include "Attribute.h"
#include "HTMLElement.h"
#include "QualifiedName.h"
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
// HTMLDivElement.cpp
#include "HTMLElement.h"
#include "HTMLDivElement.h"
#include "QualifiedName.h"
#include "Attribute.h"
</pre>

<li id="include-system">Includes of system headers must come after includes of other headers.

<h4 class="right">Right:</h4>
<pre class="code">
// ConnectionQt.cpp
#include "ArgumentEncoder.h"
#include "ProcessLauncher.h"
#include "WebPageProxyMessageKinds.h"
#include "WorkItem.h"
#include &lt;QApplication&gt;
#include &lt;QLocalServer&gt;
#include &lt;QLocalSocket&gt;
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
// ConnectionQt.cpp
#include "ArgumentEncoder.h"
#include "ProcessLauncher.h"
#include &lt;QApplication&gt;
#include &lt;QLocalServer&gt;
#include &lt;QLocalSocket&gt;
#include "WebPageProxyMessageKinds.h"
#include "WorkItem.h"
</pre>
</li>
</ol>

<h3 id="using">"using" Statements</h3>

<ol>

<li id="using-in-headers">In header files, do not use "using" statements in namespace
(or global) scope.

<h4 class="right">Right:</h4>
<pre class="code">
// wtf/Vector.h

namespace WTF {

class VectorBuffer {
    using std::min;
    ...
};

} // namespace WTF
</pre>
<h4 class="wrong">Wrong:</h4>
<pre class="code">
// wtf/Vector.h

namespace WTF {

using std::min;
    
class VectorBuffer {
    ...
};

} // namespace WTF
</pre>
</li>

<li id="using-wtf">In header files in the WTF sub-library, however, it is acceptable
to use "using" declarations at the end of the file to import one
or more names in the WTF namespace into the global scope.

<h4 class="right">Right:</h4>
<pre class="code">
// wtf/Vector.h

namespace WTF {

} // namespace WTF

using WTF::Vector;
</pre>
<h4 class="wrong">Wrong:</h4>
<pre class="code">
// wtf/Vector.h

namespace WTF {

} // namespace WTF

using namespace WTF;
</pre>
<h4 class="wrong">Wrong:</h4>
<pre class="code">
// runtime/JSObject.h

namespace WTF {

} // namespace WTF

using WTF::PlacementNewAdopt;
</pre>
</li>

<li id="using-in-cpp">In C++ implementation files, do not use "using" declarations
of any kind to import names in the standard template library.  Directly qualify
the names at the point they're used instead.

<h4 class="right">Right:</h4>
<pre class="code">
// HTMLBaseElement.cpp

namespace WebCore {

  std::swap(a, b);
  c = std::numeric_limits&lt;int&gt;::max()

} // namespace WebCore
</pre>
<h4 class="wrong">Wrong:</h4>
<pre class="code">
// HTMLBaseElement.cpp

using std::swap;

namespace WebCore {

  swap(a, b);

} // namespace WebCore
</pre>
<h4 class="wrong">Wrong:</h4>
<pre class="code">
// HTMLBaseElement.cpp

using namespace std;

namespace WebCore {

  swap(a, b);

} // namespace WebCore
</pre>
</li>

<li id="using-nested-namespaces">In implementation files, if a "using namespace" statement is
for a nested namespace whose parent namespace is defined in the file,
put the statement inside that namespace definition.

<h4 class="right">Right:</h4>
<pre class="code">
// HTMLBaseElement.cpp

namespace WebCore {

using namespace HTMLNames;

} // namespace WebCore
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
// HTMLBaseElement.cpp

using namespace WebCore::HTMLNames;

namespace WebCore {

} // namespace WebCore
</pre>
</li>

<li id="using-position">In implementation files, put all other "using" statements
at the beginning of the file, before any namespace definitions and
after any "include" statements.

<h4 class="right">Right:</h4>
<pre class="code">
// HTMLSelectElement.cpp

using namespace other;

namespace WebCore {

} // namespace WebCore
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
// HTMLSelectElement.cpp

namespace WebCore {

using namespace other;

} // namespace WebCore
</pre>
</li>

</ol>

<h3 id="types">Types</h3>

<ol>
<li id="types-unsigned">
Omit "int" when using "unsigned" modifier. Do not use "signed" modifier. Use "int" by itself instead.
<h4 class="right">Right:</h4>
<pre class="code">
unsigned a;
int b;
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
unsigned int a; // Doesn't omit "int".
signed b; // Uses "signed" instead of "int".
signed int c; // Doesn't omit "signed".
</pre>
</li>
</ol>

<h3 id="classes">Classes</h3>

<ol>
<li id="classes-explicit">
Use a constructor to do an implicit conversion when the argument is reasonably thought of as a type conversion and the type conversion is fast. Otherwise, use the explicit keyword or a function returning the type. This only applies to single argument constructors.
<h4 class="right">Right:</h4>
<pre class="code">
class LargeInt {
public:
    LargeInt(int);
...

class Vector {
public:
    explicit Vector(int size); // Not a type conversion.
    Vector create(Array); // Costly conversion.
...

</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
class Task {
public:
    Task(ScriptExecutionContext&amp;); // Not a type conversion.
    explicit Task(); // No arguments.
    explicit Task(ScriptExecutionContext&amp;, Other); // More than one argument.
...
</pre>
</li>
</ol>

<h3 id="comments">Comments</h3>
<ol>
<li id="comments-eol">Use only <i>one</i> space before end of line comments and in between sentences in comments.
<h4 class="right">Right:</h4>
<pre class="code">
f(a, b); // This explains why the function call was done. This is another sentence.
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
int i;    // This is a comment with several spaces before it, which is a non-conforming style.
double f; // This is another comment.  There are two spaces before this sentence which is a non-conforming style.
</pre>
</li>

<li id="comments-sentences">
Make comments look like sentences by starting with a capital letter and ending with a period (punctation). One exception may be end of line comments like this "if (x == y) // false for NaN".
</li>

<li id="comments-fixme">
Use FIXME: (without attribution) to denote items that need to be addressed in the future.
<h4 class="right">Right:</h4>
<pre class="code">
drawJpg(); // FIXME: Make this code handle jpg in addition to the png support.
</pre>

<h4 class="wrong">Wrong:</h4>
<pre class="code">
drawJpg(); // FIXME(joe): Make this code handle jpg in addition to the png support.
</pre>
<pre class="code">
drawJpg(); // TODO: Make this code handle jpg in addition to the png support.
</pre>
</ol>
</li>

<script>
(function() {
    var listItems = document.getElementsByTagName('li');
    var idsUsed = {};
    for (var i = 0; i < listItems.length; ++i) {
        var item = listItems[i];
        if (!item.id)
            continue;
        var button = document.createElement('span');
        button.className = 'idbutton';
        button.setAttribute('data-target-id', listItems[i].id);
        button.appendChild(document.createTextNode(' [' + listItems[i].id + ']'));
        button.addEventListener('click', function(event) {
            window.location.hash = '#' + event.currentTarget.getAttribute('data-target-id');
        });
        listItems[i].appendChild(button);
        if (idsUsed[item.id])
            alert('The id ' + item.id + ' is used more than once in this document.');
        idsUsed[item.id] = 1;
    }
})();
</script>

<?php
    include("../footer.inc");
?>
